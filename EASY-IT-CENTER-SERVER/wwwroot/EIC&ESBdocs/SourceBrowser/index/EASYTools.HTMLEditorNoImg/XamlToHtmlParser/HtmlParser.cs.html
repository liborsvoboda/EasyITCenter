<!DOCTYPE html>
<html><head><title>HtmlParser.cs</title><link rel="stylesheet" href="../../styles.css"><script src="../../scripts.js"></script></head>
<body class="cB" onload="i(587);"><div class="dH">
<table style="width: 100%">
<tr><td>File: <a id="filePath" class="blueLink" href="/#EASYTools.HTMLEditorNoImg/XamlToHtmlParser/HtmlParser.cs" target="_top">XamlToHtmlParser\HtmlParser.cs</a><br/></td><td></td></tr>
<tr><td>Project: <a id="projectPath" class="blueLink" href="/#EASYTools.HTMLEditorNoImg" target="_top">..\..\..\EASY-TOOLS\EASYTools.HTMLEditorNoImg\EASYTools.HTMLEditorNoImg.csproj</a> (EASYTools.HTMLEditorNoImg)</td></tr>
</table>
</div>
<div class="cz"><table class="tb" cellpadding="0" cellspacing="0"><tr><td valign="top" align="right"><pre id="ln"></pre></td><td valign="top" align="left"><pre id="code">
<span class="c">//---------------------------------------------------------------------------</span>
<span class="c">// </span>
<span class="c">// File: HtmlParser.cs</span>
<span class="c">//</span>
<span class="c">// Copyright (C) Microsoft Corporation.  All rights reserved.</span>
<span class="c">//</span>
<span class="c">// Description: Parser for Html-to-Xaml converter</span>
<span class="c">//</span>
<span class="c">//---------------------------------------------------------------------------</span>
 
<b>using</b> <span class="i n">System</span>;
<b>using</b> <span class="i n">System</span>.<span class="i n">Collections</span>.<span class="i n">Generic</span>;
<b>using</b> <span class="i n">System</span>.<span class="i n">Globalization</span>; <span class="c">// StringBuilder</span>
<b>using</b> <span class="i n">System</span>.<span class="i n">Text</span>;
<b>using</b> <span class="i n">System</span>.<span class="i n">Xml</span>;
 
<span class="c">// important TODOS: </span>
<span class="c">// TODO 1. Start tags: The ParseXmlElement function has been modified to be called after both the </span>
<span class="c">// angle bracket &lt; and element name have been read, instead of just the &lt; bracket and some valid name character, </span>
<span class="c">// previously the case. This change was made so that elements with optional closing tags could read a new</span>
<span class="c">// element&#39;s start tag and decide whether they were required to close. However, there is a question of whether to</span>
<span class="c">// handle this in the parser or lexical analyzer. It is currently handled in the parser - the lexical analyzer still</span>
<span class="c">// recognizes a start tag opener as a &#39;&lt;&#39; + valid name start char; it is the parser that reads the actual name. </span>
<span class="c">// this is correct behavior assuming that the name is a valid html name, because the lexical analyzer should not know anything</span>
<span class="c">// about optional closing tags, etc. UPDATED: 10/13/2004: I am updating this to read the whole start tag of something </span>
<span class="c">// that is not an HTML, treat it as empty, and add it to the tree. That way the converter will know it&#39;s there, but</span>
<span class="c">// it will hvae no content. We could also partially recover by trying to look up and match names if they are similar</span>
<span class="c">// TODO 2. Invalid element names: However, it might make sense to give the lexical analyzer the ability to identify</span>
<span class="c">// a valid html element name and not return something as a start tag otherwise. For example, if we type &lt;good&gt;, should</span>
<span class="c">// the lexical analyzer return that it has found the start of an element when this is not the case in HTML? But this will</span>
<span class="c">// require implementing a lookahead token in the lexical analyzer so that it can treat an invalid element name as text. One </span>
<span class="c">// character of lookahead will not be enough.</span>
<span class="c">// TODO 3. Attributes: The attribute recovery is poor when reading attribute values in quotes - if no closing quotes are found,</span>
<span class="c">// the lexical analyzer just keeps reading and if it eventually reaches the end of file, it would have just skipped everything.</span>
<span class="c">// There are a couple of ways to deal with this: 1) stop reading attributes when we encounter a &#39;&gt;&#39; character - this doesn&#39;t allow</span>
<span class="c">// the &#39;&gt;&#39; character to be used in attribute values, but it can still be used as an entity. 2) Maintain a HTML-specific list</span>
<span class="c">// of attributes and their values that each html element can take, and if we find correct attribute namesand values for an</span>
<span class="c">// element we use them regardless of the quotes, this way we could just ignore something invalid. One more option: 3) Read ahead</span>
<span class="c">// in the quoted value and if we find an end of file, we can return to where we were and process as text. However this requires</span>
<span class="c">// a lot of lookahead and a resettable reader.</span>
<span class="c">// TODO 4: elements with optional closing tags: For elements with optional closing tags, we always close the element if we find</span>
<span class="c">// that one of it&#39;s ancestors has closed. This condition may be too broad and we should develop a better heuristic. We should also</span>
<span class="c">// improve the heuristics for closing certain elements when the next element starts</span>
<span class="c">// TODO 5. Nesting: Support for unbalanced nesting, e.g. &lt;b&gt; &lt;i&gt; &lt;/b&gt; &lt;/i&gt;: this is not presently supported. To support it we may need</span>
<span class="c">// to maintain two xml elements, one the element that represents what has already been read and another represents what we are presently reading.</span>
<span class="c">// Then if we encounter an unbalanced nesting tag we could close the element that was supposed to close, save the current element</span>
<span class="c">// and store it in the list of already-read content, and then open a new element to which all tags that are currently open</span>
<span class="c">// can be applied. Is there a better way to do this? Should we do it at all?</span>
<span class="c">// TODO 6. Elements with optional starting tags: there are 4 such elements in the HTML 4 specification - html, tbody, body and head.</span>
<span class="c">// The current recovery doesn;t do anything for any of these elements except the html element, because it&#39;s not critical - head</span>
<span class="c">// and body elementscan be contained within html element, and tbody is contained within table. To extend this for XHTML </span>
<span class="c">// extensions, and to recover in case other elements are missing start tags, we would need to insert an extra recursive call</span>
<span class="c">// to ParseXmlElement for the missing start tag. It is suggested to do this by giving ParseXmlElement an argument that specifies</span>
<span class="c">// a name to use. If this argument is null, it  assumes its name is the next token from the lexical analyzer and continues</span>
<span class="c">// exactly as it does now. However, if the argument contains a valid html element name then it takes that value as its name</span>
<span class="c">// and continues as before. This way, if the next token is the element that should actually be its child, it will see</span>
<span class="c">// the name in the next step and initiate a recursive call. We would also need to add some logic in the loop for when a start tag</span>
<span class="c">// is found - if the start tag is not compatible with current context and indicates that a start tag has been missed, then we</span>
<span class="c">// can initiate the extra recursive call and give it the name of the missed start tag. The issues are when to insert this logic,</span>
<span class="c">// and if we want to support it over multiple missing start tags. If we insert it at the time a start tag is read in element</span>
<span class="c">// text,  then we can support only one missing start tag, since the extra call will read the next start tag and make a recursive</span>
<span class="c">// call without checking the context. This is a conceptual problem, and the check should be made just before a recursive call,</span>
<span class="c">// with the choice being whether we should supply an element name as argument, or leave it as NULL and read from the input</span>
<span class="c">// TODO 7: Context: Is it appropriate to keep track of context here? For example, should we only expect td, tr elements when</span>
<span class="c">// reading a table and ignore them otherwise? This may be too much of a load on the parser, I think it&#39;s better if the converter</span>
<span class="c">// deals with it</span>
 
 
<b>namespace</b> <span class="i n">EASYTools</span>.<span class="i n">HTMLEditorNoImg</span>
{
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span>
    <span class="c">///</span><span class="c"> HtmlParser class accepts a string of possibly badly formed Html, parses it and returns a string</span>
    <span class="c">///</span><span class="c"> of well-formed Html that is as close to the original string in content as possible</span>
    <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
 
    <b>internal class</b> <a id="047776b6c421dcb9" href="../R/047776b6c421dcb9.html" target="n" data-glyph="2,0" class="t t">HtmlParser</a> : <a href="@0@mscorlib/A.html#1f55292c3174123d" class="t t">IDisposable</a>
    {
        <span class="c">// ---------------------------------------------------------------------</span>
        <span class="c">//</span>
        <span class="c">// Constructors</span>
        <span class="c">//</span>
        <span class="c">// ---------------------------------------------------------------------</span>
 
        <span class="k preprocess">#</span><span class="k preprocess">region</span> Constructors
 
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> Constructor. Initializes the _htmlLexicalAnalayzer element with the given input string</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span> <span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r0 r">inputString</span><span class="c">&quot;</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> string to parsed into well-formed Html</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
        <b>private</b> <a id="25a682d4d5ca405e" href="../R/25a682d4d5ca405e.html" target="n" data-glyph="76,1" class="t constructor">HtmlParser</a>(<a href="@0@mscorlib/A.html#8281103e6f23cb5c" class="k">string</a> <span id="r0 rd" class="r0 r">inputString</span>)
        {
            <span class="c">// Create an output xml document</span>
            <a href="#ff9e7776b773ed10" class="i field">_document</a> = <b>new</b> <a href="@0@System.Xml/A.html#2d559a81f89e826f" class="t constructor">XmlDocument</a>();
 
            <span class="c">// initialize open tag stack</span>
            <a href="#823e7b8b3d3502d3" class="i field">_openedElements</a> = <b>new</b> <a href="@0@System/A.html#692a18e31afb7ef9" class="t constructor">Stack</a>&lt;<a href="@0@System.Xml/A.html#184875ff599860f7" class="t t">XmlElement</a>&gt;();
 
            <a href="#d7b634f6e84469c5" class="i field">_pendingInlineElements</a> = <b>new</b> <a href="@0@System/A.html#692a18e31afb7ef9" class="t constructor">Stack</a>&lt;<a href="@0@System.Xml/A.html#184875ff599860f7" class="t t">XmlElement</a>&gt;();
 
            <span class="c">// initialize lexical analyzer</span>
            <a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a> = <b>new</b> <a href="HtmlLexicalAnalyzer.cs.html#d7e9e8b04534b42c" class="t constructor">HtmlLexicalAnalyzer</a>(<span class="r0 r">inputString</span>);
 
            <span class="c">// get first token from input, expecting text</span>
            <a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a>.<a href="HtmlLexicalAnalyzer.cs.html#41057b16ec4d8b80" class="i method">GetNextContentToken</a>();
        }
 
        <span class="k preprocess">#</span><span class="k preprocess">endregion</span> Constructors
 
        <span class="c">// ---------------------------------------------------------------------</span>
        <span class="c">//</span>
        <span class="c">// Internal Methods</span>
        <span class="c">//</span>
        <span class="c">// ---------------------------------------------------------------------</span>
 
        <span class="k preprocess">#</span><span class="k preprocess">region</span> Internal Methods
 
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> Instantiates an HtmlParser element and calls the parsing function on the given input string</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span> <span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r1 r">htmlString</span><span class="c">&quot;</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> Input string of pssibly badly-formed Html to be parsed into well-formed Html</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> XmlElement rep</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
        <b>internal static</b> <a href="@0@System.Xml/A.html#184875ff599860f7" class="t t">XmlElement</a> <a id="5556078f35e1565a" href="../R/5556078f35e1565a.html" target="n" data-glyph="74,1" class="i method">ParseHtml</a>(<a href="@0@mscorlib/A.html#8281103e6f23cb5c" class="k">string</a> <span id="r1 rd" class="r1 r">htmlString</span>)
        {
			<b>using</b> (<a href="#047776b6c421dcb9" class="t t">HtmlParser</a> <span id="r2 rd" class="r2 r">htmlParser</span> = <b>new</b> <a href="#25a682d4d5ca405e" class="t constructor">HtmlParser</a>(<span class="r1 r">htmlString</span>))
			{
 
				<a href="@0@System.Xml/A.html#184875ff599860f7" class="t t">XmlElement</a> <span id="r3 rd" class="r3 r">htmlRootElement</span> = <span class="r2 r">htmlParser</span>.<a href="#05139340ed6e4a55" class="i method">ParseHtmlContent</a>();
 
				<b>return</b> <span class="r3 r">htmlRootElement</span>;
			}
        }
 
        <span class="c">// .....................................................................</span>
        <span class="c">//</span>
        <span class="c">// Html Header on Clipboard</span>
        <span class="c">//</span>
        <span class="c">// .....................................................................</span>
 
        <span class="c">// Html header structure.</span>
        <span class="c">//      Version:1.0</span>
        <span class="c">//      StartHTML:000000000</span>
        <span class="c">//      EndHTML:000000000</span>
        <span class="c">//      StartFragment:000000000</span>
        <span class="c">//      EndFragment:000000000</span>
        <span class="c">//      StartSelection:000000000</span>
        <span class="c">//      EndSelection:000000000</span>
        <b>internal const string</b> <a id="bd33a96c171acb48" href="../R/bd33a96c171acb48.html" target="n" data-glyph="8,1" class="i field">HtmlHeader</a> = <span class="s">&quot;Version:1.0\r\nStartHTML:{0:D10}\r\nEndHTML:{1:D10}\r\nStartFragment:{2:D10}\r\nEndFragment:{3:D10}\r\nStartSelection:{4:D10}\r\nEndSelection:{5:D10}\r\n&quot;</span>;
        <b>internal const string</b> <a id="df033b238c493623" href="../R/df033b238c493623.html" target="n" data-glyph="8,1" class="i field">HtmlStartFragmentComment</a> = <span class="s">&quot;&lt;!--StartFragment--&gt;&quot;</span>;
        <b>internal const string</b> <a id="f40ef480fbd63567" href="../R/f40ef480fbd63567.html" target="n" data-glyph="8,1" class="i field">HtmlEndFragmentComment</a> = <span class="s">&quot;&lt;!--EndFragment--&gt;&quot;</span>;
 
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> Extracts Html string from clipboard data by parsing header information in htmlDataString</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span> <span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r4 r">htmlDataString</span><span class="c">&quot;</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> String representing Html clipboard data. This includes Html header</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> String containing only the Html data part of htmlDataString, without header</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
        <b>internal static string</b> <a id="9feb189006a8249b" href="../R/../../0000000000.html" target="n" data-glyph="74,1" class="i method">ExtractHtmlFromClipboardData</a>(<a href="@0@mscorlib/A.html#8281103e6f23cb5c" class="k">string</a> <span id="r4 rd" class="r4 r">htmlDataString</span>)
        {
            <b>int</b> <span id="r5 rd" class="r5 r">startHtmlIndex</span> = <span class="r4 r">htmlDataString</span>.<a href="@0@mscorlib/A.html#7d6aed52d875ec59" class="i method">IndexOf</a>(<span class="s">&quot;StartHTML:&quot;</span>, <a href="@0@mscorlib/A.html#702797def97ecb7c" class="t t">StringComparison</a>.<a href="@0@mscorlib/A.html#6c3139b940557bf9" class="i field">OrdinalIgnoreCase</a>);
            <b>if</b> (<span class="r5 r">startHtmlIndex</span> &lt; 0)
            {
                <b>return</b> <span class="s">&quot;ERROR: Urecognized html header&quot;</span>;
            }
            <span class="c">// TODO: We assume that indices represented by strictly 10 zeros (&quot;0123456789&quot;.Length),</span>
            <span class="c">// which could be wrong assumption. We need to implement more flrxible parsing here</span>
            <span class="r5 r">startHtmlIndex</span> = <a href="@0@mscorlib/A.html#225942ed7b7a3252" class="t t">Int32</a>.<a href="@0@mscorlib/A.html#78ffbe1e274ca0bb" class="i method">Parse</a>(<span class="r4 r">htmlDataString</span>.<a href="@0@mscorlib/A.html#8124961f027d9ac9" class="i method">Substring</a>(<span class="r5 r">startHtmlIndex</span> + <span class="s">&quot;StartHTML:&quot;</span>.<a href="@0@mscorlib/A.html#e13f5829ef28aa07" class="i property">Length</a>, <span class="s">&quot;0123456789&quot;</span>.<a href="@0@mscorlib/A.html#e13f5829ef28aa07" class="i property">Length</a>), <a href="@0@mscorlib/A.html#e319c6636909012f" class="t t">CultureInfo</a>.<a href="@0@mscorlib/A.html#26ef1c020f0dbb7a" class="i property">InvariantCulture</a>);
            <b>if</b> (<span class="r5 r">startHtmlIndex</span> &lt; 0 || <span class="r5 r">startHtmlIndex</span> &gt; <span class="r4 r">htmlDataString</span>.<a href="@0@mscorlib/A.html#e13f5829ef28aa07" class="i property">Length</a>)
            {
                <b>return</b> <span class="s">&quot;ERROR: Urecognized html header&quot;</span>;
            }
 
            <b>int</b> <span id="r6 rd" class="r6 r">endHtmlIndex</span> = <span class="r4 r">htmlDataString</span>.<a href="@0@mscorlib/A.html#7d6aed52d875ec59" class="i method">IndexOf</a>(<span class="s">&quot;EndHTML:&quot;</span>, <a href="@0@mscorlib/A.html#702797def97ecb7c" class="t t">StringComparison</a>.<a href="@0@mscorlib/A.html#6c3139b940557bf9" class="i field">OrdinalIgnoreCase</a>);
            <b>if</b> (<span class="r6 r">endHtmlIndex</span> &lt; 0)
            {
                <b>return</b> <span class="s">&quot;ERROR: Urecognized html header&quot;</span>;
            }
            <span class="c">// TODO: We assume that indices represented by strictly 10 zeros (&quot;0123456789&quot;.Length),</span>
            <span class="c">// which could be wrong assumption. We need to implement more flrxible parsing here</span>
			<span class="r6 r">endHtmlIndex</span> = <a href="@0@mscorlib/A.html#225942ed7b7a3252" class="t t">Int32</a>.<a href="@0@mscorlib/A.html#78ffbe1e274ca0bb" class="i method">Parse</a>(<span class="r4 r">htmlDataString</span>.<a href="@0@mscorlib/A.html#8124961f027d9ac9" class="i method">Substring</a>(<span class="r6 r">endHtmlIndex</span> + <span class="s">&quot;EndHTML:&quot;</span>.<a href="@0@mscorlib/A.html#e13f5829ef28aa07" class="i property">Length</a>, <span class="s">&quot;0123456789&quot;</span>.<a href="@0@mscorlib/A.html#e13f5829ef28aa07" class="i property">Length</a>), <a href="@0@mscorlib/A.html#e319c6636909012f" class="t t">CultureInfo</a>.<a href="@0@mscorlib/A.html#26ef1c020f0dbb7a" class="i property">InvariantCulture</a>);
            <b>if</b> (<span class="r6 r">endHtmlIndex</span> &gt; <span class="r4 r">htmlDataString</span>.<a href="@0@mscorlib/A.html#e13f5829ef28aa07" class="i property">Length</a>)
            {
                <span class="r6 r">endHtmlIndex</span> = <span class="r4 r">htmlDataString</span>.<a href="@0@mscorlib/A.html#e13f5829ef28aa07" class="i property">Length</a>;
            }
 
            <b>return</b> <span class="r4 r">htmlDataString</span>.<a href="@0@mscorlib/A.html#8124961f027d9ac9" class="i method">Substring</a>(<span class="r5 r">startHtmlIndex</span>, <span class="r6 r">endHtmlIndex</span> - <span class="r5 r">startHtmlIndex</span>);
        }
 
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> Adds Xhtml header information to Html data string so that it can be placed on clipboard</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">param</span> <span class="c">name</span><span class="c">=</span><span class="c">&quot;</span><span class="r7 r">htmlString</span><span class="c">&quot;</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> Html string to be placed on clipboard with appropriate header</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">param</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">returns</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> String wrapping htmlString with appropriate Html header</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">returns</span><span class="c">&gt;</span>
        <b>internal static string</b> <a id="d155a608a8ab0c6c" href="../R/../../0000000000.html" target="n" data-glyph="74,1" class="i method">AddHtmlClipboardHeader</a>(<a href="@0@mscorlib/A.html#8281103e6f23cb5c" class="k">string</a> <span id="r7 rd" class="r7 r">htmlString</span>)
        {
            <a href="@0@mscorlib/A.html#adf60ee46ebd299f" class="t t">StringBuilder</a> <span id="r8 rd" class="r8 r">stringBuilder</span> = <b>new</b> <a href="@0@mscorlib/A.html#6e631639c1e2746b" class="t constructor">StringBuilder</a>();
 
            <span class="c">// each of 6 numbers is represented by &quot;{0:D10}&quot; in the format string</span>
            <span class="c">// must actually occupy 10 digit positions (&quot;0123456789&quot;)</span>
            <b>int</b> <span id="r9 rd" class="r9 r">startHTML</span> = <a href="#bd33a96c171acb48" class="i field">HtmlHeader</a>.<a href="@0@mscorlib/A.html#e13f5829ef28aa07" class="i property">Length</a> + 6 * (<span class="s">&quot;0123456789&quot;</span>.<a href="@0@mscorlib/A.html#e13f5829ef28aa07" class="i property">Length</a> - <span class="s">&quot;{0:D10}&quot;</span>.<a href="@0@mscorlib/A.html#e13f5829ef28aa07" class="i property">Length</a>);
            <b>int</b> <span id="r10 rd" class="r10 r">endHTML</span> = <span class="r9 r">startHTML</span> + <span class="r7 r">htmlString</span>.<a href="@0@mscorlib/A.html#e13f5829ef28aa07" class="i property">Length</a>;
			<b>int</b> <span id="r11 rd" class="r11 r">startFragment</span> = <span class="r7 r">htmlString</span>.<a href="@0@mscorlib/A.html#3b7fbc076e08ccb8" class="i method">IndexOf</a>(<a href="#df033b238c493623" class="i field">HtmlStartFragmentComment</a>, 0, <a href="@0@mscorlib/A.html#702797def97ecb7c" class="t t">StringComparison</a>.<a href="@0@mscorlib/A.html#6c3139b940557bf9" class="i field">OrdinalIgnoreCase</a>);
            <b>if</b> (<span class="r11 r">startFragment</span> &gt;= 0)
            {
                <span class="r11 r">startFragment</span> = <span class="r9 r">startHTML</span> + <span class="r11 r">startFragment</span> + <a href="#df033b238c493623" class="i field">HtmlStartFragmentComment</a>.<a href="@0@mscorlib/A.html#e13f5829ef28aa07" class="i property">Length</a>;
            }
            <b>else</b>
            {
                <span class="r11 r">startFragment</span> = <span class="r9 r">startHTML</span>;
            }
            <b>int</b> <span id="r12 rd" class="r12 r">endFragment</span> = <span class="r7 r">htmlString</span>.<a href="@0@mscorlib/A.html#3b7fbc076e08ccb8" class="i method">IndexOf</a>(<a href="#f40ef480fbd63567" class="i field">HtmlEndFragmentComment</a>, 0, <a href="@0@mscorlib/A.html#702797def97ecb7c" class="t t">StringComparison</a>.<a href="@0@mscorlib/A.html#6c3139b940557bf9" class="i field">OrdinalIgnoreCase</a>);
            <b>if</b> (<span class="r12 r">endFragment</span> &gt;= 0)
            {
                <span class="r12 r">endFragment</span> = <span class="r9 r">startHTML</span> + <span class="r12 r">endFragment</span>;
            }
            <b>else</b>
            {
                <span class="r12 r">endFragment</span> = <span class="r10 r">endHTML</span>;
            }
 
            <span class="c">// Create HTML clipboard header string</span>
			<span class="r8 r">stringBuilder</span>.<a href="@0@mscorlib/A.html#b2e417523e4a69a5" class="i method">AppendFormat</a>(<a href="@0@mscorlib/A.html#e319c6636909012f" class="t t">CultureInfo</a>.<a href="@0@mscorlib/A.html#26ef1c020f0dbb7a" class="i property">InvariantCulture</a>,<a href="#bd33a96c171acb48" class="i field">HtmlHeader</a>, <span class="r9 r">startHTML</span>, <span class="r10 r">endHTML</span>, <span class="r11 r">startFragment</span>, <span class="r12 r">endFragment</span>, <span class="r11 r">startFragment</span>, <span class="r12 r">endFragment</span>);
 
            <span class="c">// Append HTML body.</span>
            <span class="r8 r">stringBuilder</span>.<a href="@0@mscorlib/A.html#e8eaef3c361184bc" class="i method">Append</a>(<span class="r7 r">htmlString</span>);
 
            <b>return</b> <span class="r8 r">stringBuilder</span>.<a href="@0@mscorlib/A.html#5a97da49a158a3c9" class="i method">ToString</a>();
        }
 
        <span class="k preprocess">#</span><span class="k preprocess">endregion</span> Internal Methods
 
        <span class="c">// ---------------------------------------------------------------------</span>
        <span class="c">//</span>
        <span class="c">// Private methods</span>
        <span class="c">//</span>
        <span class="c">// ---------------------------------------------------------------------</span>
 
        <span class="k preprocess">#</span><span class="k preprocess">region</span> Private Methods
 
        <b>private static void</b> <a id="a9111baad8a757cb" href="../R/a9111baad8a757cb.html" target="n" data-glyph="76,1" class="i method">InvariantAssert</a>(<b>bool</b> <span id="r13 rd" class="r13 r">condition</span>, <a href="@0@mscorlib/A.html#8281103e6f23cb5c" class="k">string</a> <span id="r14 rd" class="r14 r">message</span>)
        {
            <b>if</b> (!<span class="r13 r">condition</span>)
            {
                <b>throw</b> <b>new</b> <a href="@0@mscorlib/A.html#5fec5e06371b1f6c" class="t constructor">ArgumentOutOfRangeException</a>(<span class="s">&quot;Assertion error: &quot;</span> + <span class="r14 r">message</span>);
            }
        }
 
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;</span><span class="c">summary</span><span class="c">&gt;</span>
        <span class="c">///</span><span class="c"> Parses the stream of html tokens starting</span>
        <span class="c">///</span><span class="c"> from the name of top-level element.</span>
        <span class="c">///</span><span class="c"> Returns XmlElement representing the top-level</span>
        <span class="c">///</span><span class="c"> html element</span>
        <span class="c">///</span><span class="c"> </span><span class="c">&lt;/</span><span class="c">summary</span><span class="c">&gt;</span>
        <b>private</b> <a href="@0@System.Xml/A.html#184875ff599860f7" class="t t">XmlElement</a> <a id="05139340ed6e4a55" href="../R/05139340ed6e4a55.html" target="n" data-glyph="76,1" class="i method">ParseHtmlContent</a>()
        {
            <span class="c">// Create artificial root elelemt to be able to group multiple top-level elements</span>
            <span class="c">// We create &quot;html&quot; element which may be a duplicate of real HTML element, which is ok, as HtmlConverter will swallow it painlessly..</span>
            <a href="@0@System.Xml/A.html#184875ff599860f7" class="t t">XmlElement</a> <span id="r15 rd" class="r15 r">htmlRootElement</span> = <a href="#ff9e7776b773ed10" class="i field">_document</a>.<a href="@0@System.Xml/A.html#5bdcd294e2bb6b38" class="i method">CreateElement</a>(<span class="s">&quot;html&quot;</span>, <a href="#dd5a2f8ccbee6dff" class="i field">XhtmlNamespace</a>);
            <a href="#d16a02cd3c39660c" class="i method">OpenStructuringElement</a>(<span class="r15 r">htmlRootElement</span>);
 
            <b>while</b> (<a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a>.<a href="HtmlLexicalAnalyzer.cs.html#137ae3c4e8304455" class="i property">NextTokenType</a> != <a href="HtmlTokenType.cs.html#98651734a4a839e4" class="t t">HtmlTokenType</a>.<a href="HtmlTokenType.cs.html#04f6622f4035d47a" class="i field">EOF</a>)
            {
                <b>if</b> (<a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a>.<a href="HtmlLexicalAnalyzer.cs.html#137ae3c4e8304455" class="i property">NextTokenType</a> == <a href="HtmlTokenType.cs.html#98651734a4a839e4" class="t t">HtmlTokenType</a>.<a href="HtmlTokenType.cs.html#e0fadcc0808e9b3c" class="i field">OpeningTagStart</a>)
                {
                    <a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a>.<a href="HtmlLexicalAnalyzer.cs.html#6b0f88c646c98292" class="i method">GetNextTagToken</a>();
                    <b>if</b> (<a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a>.<a href="HtmlLexicalAnalyzer.cs.html#137ae3c4e8304455" class="i property">NextTokenType</a> == <a href="HtmlTokenType.cs.html#98651734a4a839e4" class="t t">HtmlTokenType</a>.<a href="HtmlTokenType.cs.html#feb69dd54c3adb98" class="i field">Name</a>)
                    {
						<a href="@0@mscorlib/A.html#8281103e6f23cb5c" class="k">string</a> <span id="r16 rd" class="r16 r">htmlElementName</span> = <a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a>.<a href="HtmlLexicalAnalyzer.cs.html#249660fc94e9bedf" class="i property">NextToken</a>.<a href="@0@mscorlib/A.html#e1eaac9b427f9c78" class="i method">ToLower</a>(<a href="@0@mscorlib/A.html#e319c6636909012f" class="t t">CultureInfo</a>.<a href="@0@mscorlib/A.html#26ef1c020f0dbb7a" class="i property">InvariantCulture</a>);
                        <a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a>.<a href="HtmlLexicalAnalyzer.cs.html#6b0f88c646c98292" class="i method">GetNextTagToken</a>();
 
                        <span class="c">// Create an element</span>
                        <a href="@0@System.Xml/A.html#184875ff599860f7" class="t t">XmlElement</a> <span id="r17 rd" class="r17 r">htmlElement</span> = <a href="#ff9e7776b773ed10" class="i field">_document</a>.<a href="@0@System.Xml/A.html#5bdcd294e2bb6b38" class="i method">CreateElement</a>(<span class="r16 r">htmlElementName</span>, <a href="#dd5a2f8ccbee6dff" class="i field">XhtmlNamespace</a>);
 
                        <span class="c">// Parse element attributes</span>
                        <a href="#8be82beab2926b74" class="i method">ParseAttributes</a>(<span class="r17 r">htmlElement</span>);
 
                        <b>if</b> (<a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a>.<a href="HtmlLexicalAnalyzer.cs.html#137ae3c4e8304455" class="i property">NextTokenType</a> == <a href="HtmlTokenType.cs.html#98651734a4a839e4" class="t t">HtmlTokenType</a>.<a href="HtmlTokenType.cs.html#0c16c6d8e7fef003" class="i field">EmptyTagEnd</a> || <a href="HtmlSchema.cs.html#55602139b10af512" class="t t">HtmlSchema</a>.<a href="HtmlSchema.cs.html#049a983e9508c6f2" class="i method">IsEmptyElement</a>(<span class="r16 r">htmlElementName</span>))
                        {
                            <span class="c">// It is an element without content (because of explicit slash or based on implicit knowledge aboout html)</span>
                            <a href="#e6a624716b1404b5" class="i method">AddEmptyElement</a>(<span class="r17 r">htmlElement</span>);
                        }
                        <b>else</b> <b>if</b> (<a href="HtmlSchema.cs.html#55602139b10af512" class="t t">HtmlSchema</a>.<a href="HtmlSchema.cs.html#730dd3b26fb25581" class="i method">IsInlineElement</a>(<span class="r16 r">htmlElementName</span>))
                        {
                            <span class="c">// Elements known as formatting are pushed to some special</span>
                            <span class="c">// pending stack, which allows them to be transferred</span>
                            <span class="c">// over block tags - by doing this we convert</span>
                            <span class="c">// overlapping tags into normal heirarchical element structure.</span>
                            <a href="#a04bb73815e0b222" class="i method">OpenInlineElement</a>(<span class="r17 r">htmlElement</span>);
                        }
                        <b>else</b> <b>if</b> (<a href="HtmlSchema.cs.html#55602139b10af512" class="t t">HtmlSchema</a>.<a href="HtmlSchema.cs.html#e98a79a7f75db1f0" class="i method">IsBlockElement</a>(<span class="r16 r">htmlElementName</span>) || <a href="HtmlSchema.cs.html#55602139b10af512" class="t t">HtmlSchema</a>.<a href="HtmlSchema.cs.html#ddf58cab3b579738" class="i method">IsKnownOpenableElement</a>(<span class="r16 r">htmlElementName</span>))
                        {
                            <span class="c">// This includes no-scope elements</span>
                            <a href="#d16a02cd3c39660c" class="i method">OpenStructuringElement</a>(<span class="r17 r">htmlElement</span>);
                        }
                        <b>else</b>
                        {
                            <span class="c">// Do nothing. Skip the whole opening tag.</span>
                            <span class="c">// Ignoring all unknown elements on their start tags.</span>
                            <span class="c">// Thus we will ignore them on closinng tag as well.</span>
                            <span class="c">// Anyway we don&#39;t know what to do withthem on conversion to Xaml.</span>
                        }
                    }
                    <b>else</b>
                    {
                        <span class="c">// Note that the token following opening angle bracket must be a name - lexical analyzer must guarantee that.</span>
                        <span class="c">// Otherwise - we skip the angle bracket and continue parsing the content as if it is just text.</span>
                        <span class="c">//  Add the following asserion here, right? or output &quot;&lt;&quot; as a text run instead?:</span>
                        <span class="c">// InvariantAssert(false, &quot;Angle bracket without a following name is not expected&quot;);</span>
                    }
                }
                <b>else</b> <b>if</b> (<a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a>.<a href="HtmlLexicalAnalyzer.cs.html#137ae3c4e8304455" class="i property">NextTokenType</a> == <a href="HtmlTokenType.cs.html#98651734a4a839e4" class="t t">HtmlTokenType</a>.<a href="HtmlTokenType.cs.html#77a586ef3a08f2a4" class="i field">ClosingTagStart</a>)
                {
                    <a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a>.<a href="HtmlLexicalAnalyzer.cs.html#6b0f88c646c98292" class="i method">GetNextTagToken</a>();
                    <b>if</b> (<a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a>.<a href="HtmlLexicalAnalyzer.cs.html#137ae3c4e8304455" class="i property">NextTokenType</a> == <a href="HtmlTokenType.cs.html#98651734a4a839e4" class="t t">HtmlTokenType</a>.<a href="HtmlTokenType.cs.html#feb69dd54c3adb98" class="i field">Name</a>)
                    {
						<a href="@0@mscorlib/A.html#8281103e6f23cb5c" class="k">string</a> <span id="r18 rd" class="r18 r">htmlElementName</span> = <a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a>.<a href="HtmlLexicalAnalyzer.cs.html#249660fc94e9bedf" class="i property">NextToken</a>.<a href="@0@mscorlib/A.html#e1eaac9b427f9c78" class="i method">ToLower</a>(<a href="@0@mscorlib/A.html#e319c6636909012f" class="t t">CultureInfo</a>.<a href="@0@mscorlib/A.html#26ef1c020f0dbb7a" class="i property">InvariantCulture</a>);
 
                        <span class="c">// Skip the name token. Assume that the following token is end of tag,</span>
                        <span class="c">// but do not check this. If it is not true, we simply ignore one token</span>
                        <span class="c">// - this is our recovery from bad xml in this case.</span>
                        <a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a>.<a href="HtmlLexicalAnalyzer.cs.html#6b0f88c646c98292" class="i method">GetNextTagToken</a>();
 
                        <a href="#62f0faa7b2d2cb5f" class="i method">CloseElement</a>(<span class="r18 r">htmlElementName</span>);
                    }
                }
                <b>else</b> <b>if</b> (<a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a>.<a href="HtmlLexicalAnalyzer.cs.html#137ae3c4e8304455" class="i property">NextTokenType</a> == <a href="HtmlTokenType.cs.html#98651734a4a839e4" class="t t">HtmlTokenType</a>.<a href="HtmlTokenType.cs.html#d5ec735ebf6aff09" class="i field">Text</a>)
                {
                    <a href="#063e308936158f6e" class="i method">AddTextContent</a>(<a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a>.<a href="HtmlLexicalAnalyzer.cs.html#249660fc94e9bedf" class="i property">NextToken</a>);
                }
                <b>else</b> <b>if</b> (<a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a>.<a href="HtmlLexicalAnalyzer.cs.html#137ae3c4e8304455" class="i property">NextTokenType</a> == <a href="HtmlTokenType.cs.html#98651734a4a839e4" class="t t">HtmlTokenType</a>.<a href="HtmlTokenType.cs.html#c2d1cdb94c5b2658" class="i field">Comment</a>)
                {
                    <a href="#3ce237e6b36aeff1" class="i method">AddComment</a>(<a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a>.<a href="HtmlLexicalAnalyzer.cs.html#249660fc94e9bedf" class="i property">NextToken</a>);
                }
 
                <a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a>.<a href="HtmlLexicalAnalyzer.cs.html#41057b16ec4d8b80" class="i method">GetNextContentToken</a>();
            }
 
            <span class="c">// Get rid of the artificial root element</span>
            <b>if</b> (<span class="r15 r">htmlRootElement</span>.<a href="@0@System.Xml/A.html#a94b83e085390fb4" class="i property">FirstChild</a> <b>is</b> <a href="@0@System.Xml/A.html#184875ff599860f7" class="t t">XmlElement</a> &amp;&amp;
                <span class="r15 r">htmlRootElement</span>.<a href="@0@System.Xml/A.html#a94b83e085390fb4" class="i property">FirstChild</a> == <span class="r15 r">htmlRootElement</span>.<a href="@0@System.Xml/A.html#373f7a0306be1c3c" class="i property">LastChild</a> &amp;&amp;
				<span class="r15 r">htmlRootElement</span>.<a href="@0@System.Xml/A.html#a94b83e085390fb4" class="i property">FirstChild</a>.<a href="@0@System.Xml/A.html#a52f290496276b21" class="i property">LocalName</a>.<a href="@0@mscorlib/A.html#e1eaac9b427f9c78" class="i method">ToLower</a>(<a href="@0@mscorlib/A.html#e319c6636909012f" class="t t">CultureInfo</a>.<a href="@0@mscorlib/A.html#26ef1c020f0dbb7a" class="i property">InvariantCulture</a>) == <span class="s">&quot;html&quot;</span>)
            {
                <span class="r15 r">htmlRootElement</span> = (<a href="@0@System.Xml/A.html#184875ff599860f7" class="t t">XmlElement</a>)<span class="r15 r">htmlRootElement</span>.<a href="@0@System.Xml/A.html#a94b83e085390fb4" class="i property">FirstChild</a>;
            }
 
            <b>return</b> <span class="r15 r">htmlRootElement</span>;
        }
 
        <b>private</b> <a href="@0@System.Xml/A.html#184875ff599860f7" class="t t">XmlElement</a> <a id="2f4a2e9d68beafcf" href="../R/2f4a2e9d68beafcf.html" target="n" data-glyph="76,1" class="i method">CreateElementCopy</a>(<a href="@0@System.Xml/A.html#184875ff599860f7" class="t t">XmlElement</a> <span id="r19 rd" class="r19 r">htmlElement</span>)
        {
            <a href="@0@System.Xml/A.html#184875ff599860f7" class="t t">XmlElement</a> <span id="r20 rd" class="r20 r">htmlElementCopy</span> = <a href="#ff9e7776b773ed10" class="i field">_document</a>.<a href="@0@System.Xml/A.html#5bdcd294e2bb6b38" class="i method">CreateElement</a>(<span class="r19 r">htmlElement</span>.<a href="@0@System.Xml/A.html#60198b2dff854e0e" class="i property">LocalName</a>, <a href="#dd5a2f8ccbee6dff" class="i field">XhtmlNamespace</a>);
            <b>for</b> (<b>int</b> <span id="r21 rd" class="r21 r">i</span> = 0; <span class="r21 r">i</span> &lt; <span class="r19 r">htmlElement</span>.<a href="@0@System.Xml/A.html#a4ead10fc0c65e44" class="i property">Attributes</a>.<a href="@0@System.Xml/A.html#4cdccb136a95b7c0" class="i property">Count</a>; <span class="r21 r">i</span>++)
            {
                <a href="@0@System.Xml/A.html#32fc4eecc0eb5ba9" class="t t">XmlAttribute</a> <span id="r22 rd" class="r22 r">attribute</span> = <span class="r19 r">htmlElement</span>.<a href="@0@System.Xml/A.html#a4ead10fc0c65e44" class="i property">Attributes</a><a href="@0@System.Xml/A.html#42c28489ebb9b705">[</a><span class="r21 r">i</span>];
                <span class="r20 r">htmlElementCopy</span>.<a href="@0@System.Xml/A.html#763e334f9e96420c" class="i method">SetAttribute</a>(<span class="r22 r">attribute</span>.<a href="@0@System.Xml/A.html#9d67d946628ac7d1" class="i property">Name</a>, <span class="r22 r">attribute</span>.<a href="@0@System.Xml/A.html#9bc9e8ad31fdcd66" class="i property">Value</a>);
            }
            <b>return</b> <span class="r20 r">htmlElementCopy</span>;
        }
 
        <b>private void</b> <a id="e6a624716b1404b5" href="../R/e6a624716b1404b5.html" target="n" data-glyph="76,1" class="i method">AddEmptyElement</a>(<a href="@0@System.Xml/A.html#184875ff599860f7" class="t t">XmlElement</a> <span id="r23 rd" class="r23 r">htmlEmptyElement</span>)
        {
            <a href="#a9111baad8a757cb" class="i method">InvariantAssert</a>(<a href="#823e7b8b3d3502d3" class="i field">_openedElements</a>.<a href="@0@System/A.html#47350acaee6be7b6" class="i property">Count</a> &gt; 0, <span class="s">&quot;AddEmptyElement: Stack of opened elements cannot be empty, as we have at least one artificial root element&quot;</span>);
            <a href="@0@System.Xml/A.html#184875ff599860f7" class="t t">XmlElement</a> <span id="r24 rd" class="r24 r">htmlParent</span> = <a href="#823e7b8b3d3502d3" class="i field">_openedElements</a>.<a href="@0@System/A.html#20264e6773140faf" class="i method">Peek</a>();
            <span class="r24 r">htmlParent</span>.<a href="@0@System.Xml/A.html#fa87f9fc7daeea9a" class="i method">AppendChild</a>(<span class="r23 r">htmlEmptyElement</span>);
        }
 
        <b>private void</b> <a id="a04bb73815e0b222" href="../R/a04bb73815e0b222.html" target="n" data-glyph="76,1" class="i method">OpenInlineElement</a>(<a href="@0@System.Xml/A.html#184875ff599860f7" class="t t">XmlElement</a> <span id="r25 rd" class="r25 r">htmlInlineElement</span>)
        {
            <a href="#d7b634f6e84469c5" class="i field">_pendingInlineElements</a>.<a href="@0@System/A.html#83b1a3864aaa7198" class="i method">Push</a>(<span class="r25 r">htmlInlineElement</span>);
        }
 
        <span class="c">// Opens structurig element such as Div or Table etc.</span>
        <b>private void</b> <a id="d16a02cd3c39660c" href="../R/d16a02cd3c39660c.html" target="n" data-glyph="76,1" class="i method">OpenStructuringElement</a>(<a href="@0@System.Xml/A.html#184875ff599860f7" class="t t">XmlElement</a> <span id="r26 rd" class="r26 r">htmlElement</span>)
        {
            <span class="c">// Close all pending inline elements</span>
            <span class="c">// All block elements are considered as delimiters for inline elements</span>
            <span class="c">// which forces all inline elements to be closed and re-opened in the following</span>
            <span class="c">// structural element (if any).</span>
            <span class="c">// By doing that we guarantee that all inline elements appear only within most nested blocks</span>
            <b>if</b> (<a href="HtmlSchema.cs.html#55602139b10af512" class="t t">HtmlSchema</a>.<a href="HtmlSchema.cs.html#e98a79a7f75db1f0" class="i method">IsBlockElement</a>(<span class="r26 r">htmlElement</span>.<a href="@0@System.Xml/A.html#60198b2dff854e0e" class="i property">LocalName</a>))
            {
                <b>while</b> (<a href="#823e7b8b3d3502d3" class="i field">_openedElements</a>.<a href="@0@System/A.html#47350acaee6be7b6" class="i property">Count</a> &gt; 0 &amp;&amp; <a href="HtmlSchema.cs.html#55602139b10af512" class="t t">HtmlSchema</a>.<a href="HtmlSchema.cs.html#730dd3b26fb25581" class="i method">IsInlineElement</a>(<a href="#823e7b8b3d3502d3" class="i field">_openedElements</a>.<a href="@0@System/A.html#20264e6773140faf" class="i method">Peek</a>().<a href="@0@System.Xml/A.html#60198b2dff854e0e" class="i property">LocalName</a>))
                {
                    <a href="@0@System.Xml/A.html#184875ff599860f7" class="t t">XmlElement</a> <span id="r27 rd" class="r27 r">htmlInlineElement</span> = <a href="#823e7b8b3d3502d3" class="i field">_openedElements</a>.<a href="@0@System/A.html#fd86d7436e55c84b" class="i method">Pop</a>();
                    <a href="#a9111baad8a757cb" class="i method">InvariantAssert</a>(<a href="#823e7b8b3d3502d3" class="i field">_openedElements</a>.<a href="@0@System/A.html#47350acaee6be7b6" class="i property">Count</a> &gt; 0, <span class="s">&quot;OpenStructuringElement: stack of opened elements cannot become empty here&quot;</span>);
 
                    <a href="#d7b634f6e84469c5" class="i field">_pendingInlineElements</a>.<a href="@0@System/A.html#83b1a3864aaa7198" class="i method">Push</a>(<a href="#2f4a2e9d68beafcf" class="i method">CreateElementCopy</a>(<span class="r27 r">htmlInlineElement</span>));
                }
            }
 
            <span class="c">// Add this block element to its parent</span>
            <b>if</b> (<a href="#823e7b8b3d3502d3" class="i field">_openedElements</a>.<a href="@0@System/A.html#47350acaee6be7b6" class="i property">Count</a> &gt; 0)
            {
                <a href="@0@System.Xml/A.html#184875ff599860f7" class="t t">XmlElement</a> <span id="r28 rd" class="r28 r">htmlParent</span> = <a href="#823e7b8b3d3502d3" class="i field">_openedElements</a>.<a href="@0@System/A.html#20264e6773140faf" class="i method">Peek</a>();
 
                <span class="c">// Check some known block elements for auto-closing (LI and P)</span>
                <b>if</b> (<a href="HtmlSchema.cs.html#55602139b10af512" class="t t">HtmlSchema</a>.<a href="HtmlSchema.cs.html#04dc0d2f5b844f25" class="i method">ClosesOnNextElementStart</a>(<span class="r28 r">htmlParent</span>.<a href="@0@System.Xml/A.html#60198b2dff854e0e" class="i property">LocalName</a>, <span class="r26 r">htmlElement</span>.<a href="@0@System.Xml/A.html#60198b2dff854e0e" class="i property">LocalName</a>))
                {
                    <a href="#823e7b8b3d3502d3" class="i field">_openedElements</a>.<a href="@0@System/A.html#fd86d7436e55c84b" class="i method">Pop</a>();
                    <span class="r28 r">htmlParent</span> = <a href="#823e7b8b3d3502d3" class="i field">_openedElements</a>.<a href="@0@System/A.html#47350acaee6be7b6" class="i property">Count</a> &gt; 0 ? <a href="#823e7b8b3d3502d3" class="i field">_openedElements</a>.<a href="@0@System/A.html#20264e6773140faf" class="i method">Peek</a>() : <b>null</b>;
                }
 
                <b>if</b> (<span class="r28 r">htmlParent</span> != <b>null</b>)
                {
                    <span class="c">// NOTE:</span>
                    <span class="c">// Actually we never expect null - it would mean two top-level P or LI (without a parent).</span>
                    <span class="c">// In such weird case we will loose all paragraphs except the first one...</span>
                    <span class="r28 r">htmlParent</span>.<a href="@0@System.Xml/A.html#fa87f9fc7daeea9a" class="i method">AppendChild</a>(<span class="r26 r">htmlElement</span>);
                }
            }
 
            <span class="c">// Push it onto a stack</span>
            <a href="#823e7b8b3d3502d3" class="i field">_openedElements</a>.<a href="@0@System/A.html#83b1a3864aaa7198" class="i method">Push</a>(<span class="r26 r">htmlElement</span>);
        }
 
        <b>private bool</b> <a id="6c8587a4679b2579" href="../R/6c8587a4679b2579.html" target="n" data-glyph="76,1" class="i method">IsElementOpened</a>(<a href="@0@mscorlib/A.html#8281103e6f23cb5c" class="k">string</a> <span id="r29 rd" class="r29 r">htmlElementName</span>)
        {
            <b>foreach</b> (<a href="@0@System.Xml/A.html#184875ff599860f7" class="t t">XmlElement</a> <span id="r30 rd" class="r30 r">openedElement</span> <b>in</b> <a href="#823e7b8b3d3502d3" class="i field">_openedElements</a>)
            {
                <b>if</b> (<span class="r30 r">openedElement</span>.<a href="@0@System.Xml/A.html#60198b2dff854e0e" class="i property">LocalName</a> == <span class="r29 r">htmlElementName</span>)
                {
                    <b>return</b> <b>true</b>;
                }
            }
            <b>return</b> <b>false</b>;
        }
 
        <b>private void</b> <a id="62f0faa7b2d2cb5f" href="../R/62f0faa7b2d2cb5f.html" target="n" data-glyph="76,1" class="i method">CloseElement</a>(<a href="@0@mscorlib/A.html#8281103e6f23cb5c" class="k">string</a> <span id="r31 rd" class="r31 r">htmlElementName</span>)
        {
            <span class="c">// Check if the element is opened and already added to the parent</span>
            <a href="#a9111baad8a757cb" class="i method">InvariantAssert</a>(<a href="#823e7b8b3d3502d3" class="i field">_openedElements</a>.<a href="@0@System/A.html#47350acaee6be7b6" class="i property">Count</a> &gt; 0, <span class="s">&quot;CloseElement: Stack of opened elements cannot be empty, as we have at least one artificial root element&quot;</span>);
 
            <span class="c">// Check if the element is opened and still waiting to be added to the parent</span>
            <b>if</b> (<a href="#d7b634f6e84469c5" class="i field">_pendingInlineElements</a>.<a href="@0@System/A.html#47350acaee6be7b6" class="i property">Count</a> &gt; 0 &amp;&amp; <a href="#d7b634f6e84469c5" class="i field">_pendingInlineElements</a>.<a href="@0@System/A.html#20264e6773140faf" class="i method">Peek</a>().<a href="@0@System.Xml/A.html#60198b2dff854e0e" class="i property">LocalName</a> == <span class="r31 r">htmlElementName</span>)
            {
                <span class="c">// Closing an empty inline element.</span>
                <span class="c">// Note that HtmlConverter will skip empty inlines, but for completeness we keep them here on parser level.</span>
                <a href="@0@System.Xml/A.html#184875ff599860f7" class="t t">XmlElement</a> <span id="r32 rd" class="r32 r">htmlInlineElement</span> = <a href="#d7b634f6e84469c5" class="i field">_pendingInlineElements</a>.<a href="@0@System/A.html#fd86d7436e55c84b" class="i method">Pop</a>();
                <a href="#a9111baad8a757cb" class="i method">InvariantAssert</a>(<a href="#823e7b8b3d3502d3" class="i field">_openedElements</a>.<a href="@0@System/A.html#47350acaee6be7b6" class="i property">Count</a> &gt; 0, <span class="s">&quot;CloseElement: Stack of opened elements cannot be empty, as we have at least one artificial root element&quot;</span>);
                <a href="@0@System.Xml/A.html#184875ff599860f7" class="t t">XmlElement</a> <span id="r33 rd" class="r33 r">htmlParent</span> = <a href="#823e7b8b3d3502d3" class="i field">_openedElements</a>.<a href="@0@System/A.html#20264e6773140faf" class="i method">Peek</a>();
                <span class="r33 r">htmlParent</span>.<a href="@0@System.Xml/A.html#fa87f9fc7daeea9a" class="i method">AppendChild</a>(<span class="r32 r">htmlInlineElement</span>);
                <b>return</b>;
            }
            <b>else</b> <b>if</b> (<a href="#6c8587a4679b2579" class="i method">IsElementOpened</a>(<span class="r31 r">htmlElementName</span>))
            {
                <b>while</b> (<a href="#823e7b8b3d3502d3" class="i field">_openedElements</a>.<a href="@0@System/A.html#47350acaee6be7b6" class="i property">Count</a> &gt; 1) <span class="c">// we never pop the last element - the artificial root</span>
                {
                    <span class="c">// Close all unbalanced elements.</span>
                    <a href="@0@System.Xml/A.html#184875ff599860f7" class="t t">XmlElement</a> <span id="r34 rd" class="r34 r">htmlOpenedElement</span> = <a href="#823e7b8b3d3502d3" class="i field">_openedElements</a>.<a href="@0@System/A.html#fd86d7436e55c84b" class="i method">Pop</a>();
 
                    <b>if</b> (<span class="r34 r">htmlOpenedElement</span>.<a href="@0@System.Xml/A.html#60198b2dff854e0e" class="i property">LocalName</a> == <span class="r31 r">htmlElementName</span>)
                    {
                        <b>return</b>;
                    }
 
                    <b>if</b> (<a href="HtmlSchema.cs.html#55602139b10af512" class="t t">HtmlSchema</a>.<a href="HtmlSchema.cs.html#730dd3b26fb25581" class="i method">IsInlineElement</a>(<span class="r34 r">htmlOpenedElement</span>.<a href="@0@System.Xml/A.html#60198b2dff854e0e" class="i property">LocalName</a>))
                    {
                        <span class="c">// Unbalances Inlines will be transfered to the next element content</span>
                        <a href="#d7b634f6e84469c5" class="i field">_pendingInlineElements</a>.<a href="@0@System/A.html#83b1a3864aaa7198" class="i method">Push</a>(<a href="#2f4a2e9d68beafcf" class="i method">CreateElementCopy</a>(<span class="r34 r">htmlOpenedElement</span>));
                    }
                }
            }
 
            <span class="c">// If element was not opened, we simply ignore the unbalanced closing tag</span>
            <b>return</b>;
        }
 
        <b>private void</b> <a id="063e308936158f6e" href="../R/063e308936158f6e.html" target="n" data-glyph="76,1" class="i method">AddTextContent</a>(<a href="@0@mscorlib/A.html#8281103e6f23cb5c" class="k">string</a> <span id="r35 rd" class="r35 r">textContent</span>)
        {
            <a href="#d821d37b6bc72420" class="i method">OpenPendingInlineElements</a>();
 
            <a href="#a9111baad8a757cb" class="i method">InvariantAssert</a>(<a href="#823e7b8b3d3502d3" class="i field">_openedElements</a>.<a href="@0@System/A.html#47350acaee6be7b6" class="i property">Count</a> &gt; 0, <span class="s">&quot;AddTextContent: Stack of opened elements cannot be empty, as we have at least one artificial root element&quot;</span>);
 
            <a href="@0@System.Xml/A.html#184875ff599860f7" class="t t">XmlElement</a> <span id="r36 rd" class="r36 r">htmlParent</span> = <a href="#823e7b8b3d3502d3" class="i field">_openedElements</a>.<a href="@0@System/A.html#20264e6773140faf" class="i method">Peek</a>();
            <a href="@0@System.Xml/A.html#5a686adea8810425" class="t t">XmlText</a> <span id="r37 rd" class="r37 r">textNode</span> = <a href="#ff9e7776b773ed10" class="i field">_document</a>.<a href="@0@System.Xml/A.html#b2264e21532e454d" class="i method">CreateTextNode</a>(<span class="r35 r">textContent</span>);
            <span class="r36 r">htmlParent</span>.<a href="@0@System.Xml/A.html#fa87f9fc7daeea9a" class="i method">AppendChild</a>(<span class="r37 r">textNode</span>);
        }
 
        <b>private void</b> <a id="3ce237e6b36aeff1" href="../R/3ce237e6b36aeff1.html" target="n" data-glyph="76,1" class="i method">AddComment</a>(<a href="@0@mscorlib/A.html#8281103e6f23cb5c" class="k">string</a> <span id="r38 rd" class="r38 r">comment</span>)
        {
            <a href="#d821d37b6bc72420" class="i method">OpenPendingInlineElements</a>();
 
            <a href="#a9111baad8a757cb" class="i method">InvariantAssert</a>(<a href="#823e7b8b3d3502d3" class="i field">_openedElements</a>.<a href="@0@System/A.html#47350acaee6be7b6" class="i property">Count</a> &gt; 0, <span class="s">&quot;AddComment: Stack of opened elements cannot be empty, as we have at least one artificial root element&quot;</span>);
 
            <a href="@0@System.Xml/A.html#184875ff599860f7" class="t t">XmlElement</a> <span id="r39 rd" class="r39 r">htmlParent</span> = <a href="#823e7b8b3d3502d3" class="i field">_openedElements</a>.<a href="@0@System/A.html#20264e6773140faf" class="i method">Peek</a>();
            <a href="@0@System.Xml/A.html#fdb35b5b46ded55f" class="t t">XmlComment</a> <span id="r40 rd" class="r40 r">xmlComment</span> = <a href="#ff9e7776b773ed10" class="i field">_document</a>.<a href="@0@System.Xml/A.html#6684162264ba8187" class="i method">CreateComment</a>(<span class="r38 r">comment</span>);
            <span class="r39 r">htmlParent</span>.<a href="@0@System.Xml/A.html#fa87f9fc7daeea9a" class="i method">AppendChild</a>(<span class="r40 r">xmlComment</span>);
        }
 
        <span class="c">// Moves all inline elements pending for opening to actual document</span>
        <span class="c">// and adds them to current open stack.</span>
        <b>private void</b> <a id="d821d37b6bc72420" href="../R/d821d37b6bc72420.html" target="n" data-glyph="76,1" class="i method">OpenPendingInlineElements</a>()
        {
            <b>if</b> (<a href="#d7b634f6e84469c5" class="i field">_pendingInlineElements</a>.<a href="@0@System/A.html#47350acaee6be7b6" class="i property">Count</a> &gt; 0)
            {
                <a href="@0@System.Xml/A.html#184875ff599860f7" class="t t">XmlElement</a> <span id="r41 rd" class="r41 r">htmlInlineElement</span> = <a href="#d7b634f6e84469c5" class="i field">_pendingInlineElements</a>.<a href="@0@System/A.html#fd86d7436e55c84b" class="i method">Pop</a>();
 
                <a href="#d821d37b6bc72420" class="i method">OpenPendingInlineElements</a>();
 
                <a href="#a9111baad8a757cb" class="i method">InvariantAssert</a>(<a href="#823e7b8b3d3502d3" class="i field">_openedElements</a>.<a href="@0@System/A.html#47350acaee6be7b6" class="i property">Count</a> &gt; 0, <span class="s">&quot;OpenPendingInlineElements: Stack of opened elements cannot be empty, as we have at least one artificial root element&quot;</span>);
 
                <a href="@0@System.Xml/A.html#184875ff599860f7" class="t t">XmlElement</a> <span id="r42 rd" class="r42 r">htmlParent</span> = <a href="#823e7b8b3d3502d3" class="i field">_openedElements</a>.<a href="@0@System/A.html#20264e6773140faf" class="i method">Peek</a>();
                <span class="r42 r">htmlParent</span>.<a href="@0@System.Xml/A.html#fa87f9fc7daeea9a" class="i method">AppendChild</a>(<span class="r41 r">htmlInlineElement</span>);
                <a href="#823e7b8b3d3502d3" class="i field">_openedElements</a>.<a href="@0@System/A.html#83b1a3864aaa7198" class="i method">Push</a>(<span class="r41 r">htmlInlineElement</span>);
            }
        }
 
        <b>private void</b> <a id="8be82beab2926b74" href="../R/8be82beab2926b74.html" target="n" data-glyph="76,1" class="i method">ParseAttributes</a>(<a href="@0@System.Xml/A.html#184875ff599860f7" class="t t">XmlElement</a> <span id="r43 rd" class="r43 r">xmlElement</span>)
        {
            <b>while</b> (<a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a>.<a href="HtmlLexicalAnalyzer.cs.html#137ae3c4e8304455" class="i property">NextTokenType</a> != <a href="HtmlTokenType.cs.html#98651734a4a839e4" class="t t">HtmlTokenType</a>.<a href="HtmlTokenType.cs.html#04f6622f4035d47a" class="i field">EOF</a> &amp;&amp; <span class="c">//</span>
                <a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a>.<a href="HtmlLexicalAnalyzer.cs.html#137ae3c4e8304455" class="i property">NextTokenType</a> != <a href="HtmlTokenType.cs.html#98651734a4a839e4" class="t t">HtmlTokenType</a>.<a href="HtmlTokenType.cs.html#a5b28d9bfa862893" class="i field">TagEnd</a> &amp;&amp; <span class="c">//</span>
                <a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a>.<a href="HtmlLexicalAnalyzer.cs.html#137ae3c4e8304455" class="i property">NextTokenType</a> != <a href="HtmlTokenType.cs.html#98651734a4a839e4" class="t t">HtmlTokenType</a>.<a href="HtmlTokenType.cs.html#0c16c6d8e7fef003" class="i field">EmptyTagEnd</a>)
            {
                <span class="c">// read next attribute (name=value)</span>
                <b>if</b> (<a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a>.<a href="HtmlLexicalAnalyzer.cs.html#137ae3c4e8304455" class="i property">NextTokenType</a> == <a href="HtmlTokenType.cs.html#98651734a4a839e4" class="t t">HtmlTokenType</a>.<a href="HtmlTokenType.cs.html#feb69dd54c3adb98" class="i field">Name</a>)
                {
                    <a href="@0@mscorlib/A.html#8281103e6f23cb5c" class="k">string</a> <span id="r44 rd" class="r44 r">attributeName</span> = <a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a>.<a href="HtmlLexicalAnalyzer.cs.html#249660fc94e9bedf" class="i property">NextToken</a>;
                    <a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a>.<a href="HtmlLexicalAnalyzer.cs.html#2f5287e65a3e89ca" class="i method">GetNextEqualSignToken</a>();
 
                    <a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a>.<a href="HtmlLexicalAnalyzer.cs.html#13d3f7833fedbc04" class="i method">GetNextAtomToken</a>();
 
                    <a href="@0@mscorlib/A.html#8281103e6f23cb5c" class="k">string</a> <span id="r45 rd" class="r45 r">attributeValue</span> = <a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a>.<a href="HtmlLexicalAnalyzer.cs.html#249660fc94e9bedf" class="i property">NextToken</a>;
                    <span class="r43 r">xmlElement</span>.<a href="@0@System.Xml/A.html#763e334f9e96420c" class="i method">SetAttribute</a>(<span class="r44 r">attributeName</span>, <span class="r45 r">attributeValue</span>);
                }
                <a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a>.<a href="HtmlLexicalAnalyzer.cs.html#6b0f88c646c98292" class="i method">GetNextTagToken</a>();
            }
        }
 
        <span class="k preprocess">#</span><span class="k preprocess">endregion</span> Private Methods
 
 
        <span class="c">// ---------------------------------------------------------------------</span>
        <span class="c">//</span>
        <span class="c">// Private Fields</span>
        <span class="c">//</span>
        <span class="c">// ---------------------------------------------------------------------</span>
 
        <span class="k preprocess">#</span><span class="k preprocess">region</span> Private Fields
 
        <b>internal const string</b> <a id="dd5a2f8ccbee6dff" href="../R/dd5a2f8ccbee6dff.html" target="n" data-glyph="8,1" class="i field">XhtmlNamespace</a> = <span class="s">&quot;http://www.w3.org/1999/xhtml&quot;</span>;
 
        <b>private</b> <a href="HtmlLexicalAnalyzer.cs.html#6440e2d43ca6835d" class="t t">HtmlLexicalAnalyzer</a> <a id="adaa2ac2a2521bf9" href="../R/adaa2ac2a2521bf9.html" target="n" data-glyph="46,1" class="i field">_htmlLexicalAnalyzer</a> = <b>null</b>;
 
        <span class="c">// document from which all elements are created</span>
        <b>private</b> <a href="@0@System.Xml/A.html#f82a4c1bd1f0ee12" class="t t">XmlDocument</a> <a id="ff9e7776b773ed10" href="../R/ff9e7776b773ed10.html" target="n" data-glyph="46,1" class="i field">_document</a>;
 
        <span class="c">// stack for open elements</span>
        <a href="@0@System/A.html#c5371bef044c6ab6" class="t t">Stack</a>&lt;<a href="@0@System.Xml/A.html#184875ff599860f7" class="t t">XmlElement</a>&gt; <a id="823e7b8b3d3502d3" href="../R/823e7b8b3d3502d3.html" target="n" data-glyph="46,1" class="i field">_openedElements</a>;
        <a href="@0@System/A.html#c5371bef044c6ab6" class="t t">Stack</a>&lt;<a href="@0@System.Xml/A.html#184875ff599860f7" class="t t">XmlElement</a>&gt; <a id="d7b634f6e84469c5" href="../R/d7b634f6e84469c5.html" target="n" data-glyph="46,1" class="i field">_pendingInlineElements</a>;
 
        <span class="k preprocess">#</span><span class="k preprocess">endregion</span> Private Fields
 
		<b>private bool</b> <a id="0186ea3f9122a0cb" href="../R/0186ea3f9122a0cb.html" target="n" data-glyph="46,1" class="i field">isDisposing</a> = <b>false</b>;
		<b>public void</b> <a id="b79820b9915a2dc4" href="../R/b79820b9915a2dc4.html" target="n" data-glyph="72,1" class="i method">Dispose</a>()
		{
			<a href="#9b6371582054544e" class="i method">Dispose</a>(<a href="#0186ea3f9122a0cb" class="i field">isDisposing</a>);
		}
 
		<b>private void</b> <a id="9b6371582054544e" href="../R/9b6371582054544e.html" target="n" data-glyph="76,1" class="i method">Dispose</a>(<b>bool</b> <span id="r46 rd" class="r46 r">disposing</span>)
		{
			<b>if</b> (!<span class="r46 r">disposing</span>)
			{
				<a href="#0186ea3f9122a0cb" class="i field">isDisposing</a> = <b>true</b>;
 
				<b>if</b> (<a href="#047776b6c421dcb9" class="k">this</a>.<a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a> != <b>null</b>)
				{
					<a href="#047776b6c421dcb9" class="k">this</a>.<a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a>.<a href="HtmlLexicalAnalyzer.cs.html#256accd21ddd9593" class="i method">Dispose</a>();
					<a href="#047776b6c421dcb9" class="k">this</a>.<a href="#adaa2ac2a2521bf9" class="i field">_htmlLexicalAnalyzer</a> = <b>null</b>;
				}
			}
		}
 
	}
}
</pre></td></tr></table></div></body></html>
