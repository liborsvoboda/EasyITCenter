/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_prettier_standalone_js"],{

/***/ "./node_modules/prettier/standalone.js":
/*!*********************************************!*\
  !*** ./node_modules/prettier/standalone.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n}(this, (function () { 'use strict';\n\n  var name = \"prettier\";\n  var version = \"1.19.1\";\n  var description = \"Prettier is an opinionated code formatter\";\n  var bin = {\n  \tprettier: \"./bin/prettier.js\"\n  };\n  var repository = \"prettier/prettier\";\n  var homepage = \"https://prettier.io\";\n  var author = \"James Long\";\n  var license = \"MIT\";\n  var main = \"./index.js\";\n  var engines = {\n  \tnode: \">=8\"\n  };\n  var dependencies = {\n  \t\"@angular/compiler\": \"8.2.13\",\n  \t\"@babel/code-frame\": \"7.5.5\",\n  \t\"@babel/parser\": \"7.7.3\",\n  \t\"@glimmer/syntax\": \"0.41.0\",\n  \t\"@iarna/toml\": \"2.2.3\",\n  \t\"@typescript-eslint/typescript-estree\": \"2.6.1\",\n  \t\"angular-estree-parser\": \"1.1.5\",\n  \t\"angular-html-parser\": \"1.3.0\",\n  \tcamelcase: \"5.3.1\",\n  \tchalk: \"2.4.2\",\n  \t\"cjk-regex\": \"2.0.0\",\n  \tcosmiconfig: \"5.2.1\",\n  \tdashify: \"2.0.0\",\n  \tdedent: \"0.7.0\",\n  \tdiff: \"4.0.1\",\n  \teditorconfig: \"0.15.3\",\n  \t\"editorconfig-to-prettier\": \"0.1.1\",\n  \t\"escape-string-regexp\": \"1.0.5\",\n  \tesutils: \"2.0.3\",\n  \t\"find-parent-dir\": \"0.3.0\",\n  \t\"find-project-root\": \"1.1.1\",\n  \t\"flow-parser\": \"0.111.3\",\n  \t\"get-stream\": \"4.1.0\",\n  \tglobby: \"6.1.0\",\n  \tgraphql: \"14.5.8\",\n  \t\"html-element-attributes\": \"2.2.0\",\n  \t\"html-styles\": \"1.0.0\",\n  \t\"html-tag-names\": \"1.1.4\",\n  \tignore: \"4.0.6\",\n  \t\"is-ci\": \"2.0.0\",\n  \t\"jest-docblock\": \"24.9.0\",\n  \t\"json-stable-stringify\": \"1.0.1\",\n  \tleven: \"3.1.0\",\n  \t\"lines-and-columns\": \"1.1.6\",\n  \t\"linguist-languages\": \"7.6.0\",\n  \t\"lodash.uniqby\": \"4.7.0\",\n  \tmem: \"5.1.1\",\n  \tminimatch: \"3.0.4\",\n  \tminimist: \"1.2.0\",\n  \t\"n-readlines\": \"1.0.0\",\n  \t\"normalize-path\": \"3.0.0\",\n  \t\"parse-srcset\": \"ikatyang/parse-srcset#54eb9c1cb21db5c62b4d0e275d7249516df6f0ee\",\n  \t\"postcss-less\": \"2.0.0\",\n  \t\"postcss-media-query-parser\": \"0.2.3\",\n  \t\"postcss-scss\": \"2.0.0\",\n  \t\"postcss-selector-parser\": \"2.2.3\",\n  \t\"postcss-values-parser\": \"1.5.0\",\n  \t\"regexp-util\": \"1.2.2\",\n  \t\"remark-math\": \"1.0.6\",\n  \t\"remark-parse\": \"5.0.0\",\n  \tresolve: \"1.12.0\",\n  \tsemver: \"6.3.0\",\n  \t\"string-width\": \"4.1.0\",\n  \ttypescript: \"3.7.2\",\n  \t\"unicode-regex\": \"3.0.0\",\n  \tunified: \"8.4.1\",\n  \tvnopts: \"1.0.2\",\n  \t\"yaml-unist-parser\": \"1.1.1\"\n  };\n  var devDependencies = {\n  \t\"@babel/core\": \"7.7.2\",\n  \t\"@babel/preset-env\": \"7.7.1\",\n  \t\"@rollup/plugin-alias\": \"2.2.0\",\n  \t\"@rollup/plugin-replace\": \"2.2.1\",\n  \t\"babel-loader\": \"8.0.6\",\n  \tbenchmark: \"2.1.4\",\n  \t\"builtin-modules\": \"3.1.0\",\n  \tcodecov: \"3.6.1\",\n  \t\"cross-env\": \"6.0.3\",\n  \teslint: \"6.6.0\",\n  \t\"eslint-config-prettier\": \"6.5.0\",\n  \t\"eslint-formatter-friendly\": \"7.0.0\",\n  \t\"eslint-plugin-import\": \"2.18.2\",\n  \t\"eslint-plugin-prettier\": \"3.1.1\",\n  \t\"eslint-plugin-react\": \"7.16.0\",\n  \texeca: \"3.2.0\",\n  \tjest: \"23.3.0\",\n  \t\"jest-junit\": \"9.0.0\",\n  \t\"jest-snapshot-serializer-ansi\": \"1.0.0\",\n  \t\"jest-snapshot-serializer-raw\": \"1.1.0\",\n  \t\"jest-watch-typeahead\": \"0.4.0\",\n  \tmkdirp: \"0.5.1\",\n  \tprettier: \"1.19.0\",\n  \tprettylint: \"1.0.0\",\n  \trimraf: \"3.0.0\",\n  \trollup: \"1.26.3\",\n  \t\"rollup-plugin-babel\": \"4.3.3\",\n  \t\"rollup-plugin-commonjs\": \"10.1.0\",\n  \t\"rollup-plugin-json\": \"4.0.0\",\n  \t\"rollup-plugin-node-globals\": \"1.4.0\",\n  \t\"rollup-plugin-node-resolve\": \"5.2.0\",\n  \t\"rollup-plugin-terser\": \"5.1.2\",\n  \tshelljs: \"0.8.3\",\n  \t\"snapshot-diff\": \"0.4.0\",\n  \t\"strip-ansi\": \"5.2.0\",\n  \t\"synchronous-promise\": \"2.0.10\",\n  \ttempy: \"0.2.1\",\n  \t\"terser-webpack-plugin\": \"2.2.1\",\n  \twebpack: \"4.41.2\"\n  };\n  var scripts = {\n  \tprepublishOnly: \"echo \\\"Error: must publish from dist/\\\" && exit 1\",\n  \t\"prepare-release\": \"yarn && yarn build && yarn test:dist\",\n  \ttest: \"jest\",\n  \t\"test:dist\": \"node ./scripts/test-dist.js\",\n  \t\"test-integration\": \"jest tests_integration\",\n  \t\"perf-repeat\": \"yarn && yarn build && cross-env NODE_ENV=production node ./dist/bin-prettier.js --debug-repeat ${PERF_REPEAT:-1000} --loglevel debug ${PERF_FILE:-./index.js} > /dev/null\",\n  \t\"perf-repeat-inspect\": \"yarn && yarn build && cross-env NODE_ENV=production node --inspect-brk ./dist/bin-prettier.js --debug-repeat ${PERF_REPEAT:-1000} --loglevel debug ${PERF_FILE:-./index.js} > /dev/null\",\n  \t\"perf-benchmark\": \"yarn && yarn build && cross-env NODE_ENV=production node ./dist/bin-prettier.js --debug-benchmark --loglevel debug ${PERF_FILE:-./index.js} > /dev/null\",\n  \t\"check-types\": \"tsc\",\n  \tlint: \"cross-env EFF_NO_LINK_RULES=true eslint . --format friendly\",\n  \t\"lint-docs\": \"prettylint {.,docs,website,website/blog}/*.md\",\n  \t\"lint-dist\": \"eslint --no-eslintrc --no-ignore --env=browser \\\"dist/!(bin-prettier|index|third-party).js\\\"\",\n  \tbuild: \"node --max-old-space-size=3072 ./scripts/build/build.js\",\n  \t\"build-docs\": \"node ./scripts/build-docs.js\",\n  \t\"check-deps\": \"node ./scripts/check-deps.js\",\n  \tspellcheck: \"npx -p cspell@4.0.31 cspell {bin,scripts,src}/**/*.js {docs,website/blog,changelog_unreleased}/**/*.md\"\n  };\n  var _package = {\n  \tname: name,\n  \tversion: version,\n  \tdescription: description,\n  \tbin: bin,\n  \trepository: repository,\n  \thomepage: homepage,\n  \tauthor: author,\n  \tlicense: license,\n  \tmain: main,\n  \tengines: engines,\n  \tdependencies: dependencies,\n  \tdevDependencies: devDependencies,\n  \tscripts: scripts\n  };\n\n  var _package$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    name: name,\n    version: version,\n    description: description,\n    bin: bin,\n    repository: repository,\n    homepage: homepage,\n    author: author,\n    license: license,\n    main: main,\n    engines: engines,\n    dependencies: dependencies,\n    devDependencies: devDependencies,\n    scripts: scripts,\n    'default': _package\n  });\n\n  function _typeof(obj) {\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n  }\n\n  function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n      return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n  }\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  function isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n\n    try {\n      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function _construct(Parent, args, Class) {\n    if (isNativeReflectConstruct()) {\n      _construct = Reflect.construct;\n    } else {\n      _construct = function _construct(Parent, args, Class) {\n        var a = [null];\n        a.push.apply(a, args);\n        var Constructor = Function.bind.apply(Parent, a);\n        var instance = new Constructor();\n        if (Class) _setPrototypeOf(instance, Class.prototype);\n        return instance;\n      };\n    }\n\n    return _construct.apply(null, arguments);\n  }\n\n  function _isNativeFunction(fn) {\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n  }\n\n  function _wrapNativeSuper(Class) {\n    var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n      if (Class === null || !_isNativeFunction(Class)) return Class;\n\n      if (typeof Class !== \"function\") {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n\n      if (typeof _cache !== \"undefined\") {\n        if (_cache.has(Class)) return _cache.get(Class);\n\n        _cache.set(Class, Wrapper);\n      }\n\n      function Wrapper() {\n        return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n      }\n\n      Wrapper.prototype = Object.create(Class.prototype, {\n        constructor: {\n          value: Wrapper,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n      return _setPrototypeOf(Wrapper, Class);\n    };\n\n    return _wrapNativeSuper(Class);\n  }\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return self;\n  }\n\n  function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n      return call;\n    }\n\n    return _assertThisInitialized(self);\n  }\n\n  function _superPropBase(object, property) {\n    while (!Object.prototype.hasOwnProperty.call(object, property)) {\n      object = _getPrototypeOf(object);\n      if (object === null) break;\n    }\n\n    return object;\n  }\n\n  function _get(target, property, receiver) {\n    if (typeof Reflect !== \"undefined\" && Reflect.get) {\n      _get = Reflect.get;\n    } else {\n      _get = function _get(target, property, receiver) {\n        var base = _superPropBase(target, property);\n\n        if (!base) return;\n        var desc = Object.getOwnPropertyDescriptor(base, property);\n\n        if (desc.get) {\n          return desc.get.call(receiver);\n        }\n\n        return desc.value;\n      };\n    }\n\n    return _get(target, property, receiver || target);\n  }\n\n  function _taggedTemplateLiteral(strings, raw) {\n    if (!raw) {\n      raw = strings.slice(0);\n    }\n\n    return Object.freeze(Object.defineProperties(strings, {\n      raw: {\n        value: Object.freeze(raw)\n      }\n    }));\n  }\n\n  function _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n  }\n\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n      return arr2;\n    }\n  }\n\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n\n  function _iterableToArray(iter) {\n    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n  }\n\n  function _iterableToArrayLimit(arr, i) {\n    if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n      return;\n    }\n\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n  }\n\n  function _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  }\n\n  function Diff() {}\n\n  Diff.prototype = {\n    diff: function diff(oldString, newString) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var callback = options.callback;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      this.options = options;\n      var self = this;\n\n      function done(value) {\n        if (callback) {\n          setTimeout(function () {\n            callback(undefined, value);\n          }, 0);\n          return true;\n        } else {\n          return value;\n        }\n      } // Allow subclasses to massage the input prior to running\n\n\n      oldString = this.castInput(oldString);\n      newString = this.castInput(newString);\n      oldString = this.removeEmpty(this.tokenize(oldString));\n      newString = this.removeEmpty(this.tokenize(newString));\n      var newLen = newString.length,\n          oldLen = oldString.length;\n      var editLength = 1;\n      var maxEditLength = newLen + oldLen;\n      var bestPath = [{\n        newPos: -1,\n        components: []\n      }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n      var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n\n      if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n        // Identity per the equality and tokenizer\n        return done([{\n          value: this.join(newString),\n          count: newString.length\n        }]);\n      } // Main worker method. checks all permutations of a given edit length for acceptance.\n\n\n      function execEditLength() {\n        for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n          var basePath = void 0;\n\n          var addPath = bestPath[diagonalPath - 1],\n              removePath = bestPath[diagonalPath + 1],\n              _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\n          if (addPath) {\n            // No one else is going to attempt to use this value, clear it\n            bestPath[diagonalPath - 1] = undefined;\n          }\n\n          var canAdd = addPath && addPath.newPos + 1 < newLen,\n              canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\n\n          if (!canAdd && !canRemove) {\n            // If this path is a terminal then prune\n            bestPath[diagonalPath] = undefined;\n            continue;\n          } // Select the diagonal that we want to branch from. We select the prior\n          // path whose position in the new string is the farthest from the origin\n          // and does not pass the bounds of the diff graph\n\n\n          if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n            basePath = clonePath(removePath);\n            self.pushComponent(basePath.components, undefined, true);\n          } else {\n            basePath = addPath; // No need to clone, we've pulled it from the list\n\n            basePath.newPos++;\n            self.pushComponent(basePath.components, true, undefined);\n          }\n\n          _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done\n\n          if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\n            return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n          } else {\n            // Otherwise track this path as a potential candidate and continue.\n            bestPath[diagonalPath] = basePath;\n          }\n        }\n\n        editLength++;\n      } // Performs the length of edit iteration. Is a bit fugly as this has to support the\n      // sync and async mode which is never fun. Loops over execEditLength until a value\n      // is produced.\n\n\n      if (callback) {\n        (function exec() {\n          setTimeout(function () {\n            // This should not happen, but we want to be safe.\n\n            /* istanbul ignore next */\n            if (editLength > maxEditLength) {\n              return callback();\n            }\n\n            if (!execEditLength()) {\n              exec();\n            }\n          }, 0);\n        })();\n      } else {\n        while (editLength <= maxEditLength) {\n          var ret = execEditLength();\n\n          if (ret) {\n            return ret;\n          }\n        }\n      }\n    },\n    pushComponent: function pushComponent(components, added, removed) {\n      var last = components[components.length - 1];\n\n      if (last && last.added === added && last.removed === removed) {\n        // We need to clone here as the component clone operation is just\n        // as shallow array clone\n        components[components.length - 1] = {\n          count: last.count + 1,\n          added: added,\n          removed: removed\n        };\n      } else {\n        components.push({\n          count: 1,\n          added: added,\n          removed: removed\n        });\n      }\n    },\n    extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n      var newLen = newString.length,\n          oldLen = oldString.length,\n          newPos = basePath.newPos,\n          oldPos = newPos - diagonalPath,\n          commonCount = 0;\n\n      while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n        newPos++;\n        oldPos++;\n        commonCount++;\n      }\n\n      if (commonCount) {\n        basePath.components.push({\n          count: commonCount\n        });\n      }\n\n      basePath.newPos = newPos;\n      return oldPos;\n    },\n    equals: function equals(left, right) {\n      if (this.options.comparator) {\n        return this.options.comparator(left, right);\n      } else {\n        return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n      }\n    },\n    removeEmpty: function removeEmpty(array) {\n      var ret = [];\n\n      for (var i = 0; i < array.length; i++) {\n        if (array[i]) {\n          ret.push(array[i]);\n        }\n      }\n\n      return ret;\n    },\n    castInput: function castInput(value) {\n      return value;\n    },\n    tokenize: function tokenize(value) {\n      return value.split('');\n    },\n    join: function join(chars) {\n      return chars.join('');\n    }\n  };\n\n  function buildValues(diff, components, newString, oldString, useLongestToken) {\n    var componentPos = 0,\n        componentLen = components.length,\n        newPos = 0,\n        oldPos = 0;\n\n    for (; componentPos < componentLen; componentPos++) {\n      var component = components[componentPos];\n\n      if (!component.removed) {\n        if (!component.added && useLongestToken) {\n          var value = newString.slice(newPos, newPos + component.count);\n          value = value.map(function (value, i) {\n            var oldValue = oldString[oldPos + i];\n            return oldValue.length > value.length ? oldValue : value;\n          });\n          component.value = diff.join(value);\n        } else {\n          component.value = diff.join(newString.slice(newPos, newPos + component.count));\n        }\n\n        newPos += component.count; // Common case\n\n        if (!component.added) {\n          oldPos += component.count;\n        }\n      } else {\n        component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n        oldPos += component.count; // Reverse add and remove so removes are output first to match common convention\n        // The diffing algorithm is tied to add then remove output and this is the simplest\n        // route to get the desired output with minimal overhead.\n\n        if (componentPos && components[componentPos - 1].added) {\n          var tmp = components[componentPos - 1];\n          components[componentPos - 1] = components[componentPos];\n          components[componentPos] = tmp;\n        }\n      }\n    } // Special case handle for when one terminal is ignored (i.e. whitespace).\n    // For this case we merge the terminal into the prior string and drop the change.\n    // This is only available for string mode.\n\n\n    var lastComponent = components[componentLen - 1];\n\n    if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\n      components[componentLen - 2].value += lastComponent.value;\n      components.pop();\n    }\n\n    return components;\n  }\n\n  function clonePath(path) {\n    return {\n      newPos: path.newPos,\n      components: path.components.slice(0)\n    };\n  }\n\n  var characterDiff = new Diff();\n\n  function diffChars(oldStr, newStr, options) {\n    return characterDiff.diff(oldStr, newStr, options);\n  }\n\n  function generateOptions(options, defaults) {\n    if (typeof options === 'function') {\n      defaults.callback = options;\n    } else if (options) {\n      for (var name in options) {\n        /* istanbul ignore else */\n        if (options.hasOwnProperty(name)) {\n          defaults[name] = options[name];\n        }\n      }\n    }\n\n    return defaults;\n  } //\n  // Ranges and exceptions:\n  // Latin-1 Supplement, 0080–00FF\n  //  - U+00D7  × Multiplication sign\n  //  - U+00F7  ÷ Division sign\n  // Latin Extended-A, 0100–017F\n  // Latin Extended-B, 0180–024F\n  // IPA Extensions, 0250–02AF\n  // Spacing Modifier Letters, 02B0–02FF\n  //  - U+02C7  ˇ &#711;  Caron\n  //  - U+02D8  ˘ &#728;  Breve\n  //  - U+02D9  ˙ &#729;  Dot Above\n  //  - U+02DA  ˚ &#730;  Ring Above\n  //  - U+02DB  ˛ &#731;  Ogonek\n  //  - U+02DC  ˜ &#732;  Small Tilde\n  //  - U+02DD  ˝ &#733;  Double Acute Accent\n  // Latin Extended Additional, 1E00–1EFF\n\n\n  var extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\n  var reWhitespace = /\\S/;\n  var wordDiff = new Diff();\n\n  wordDiff.equals = function (left, right) {\n    if (this.options.ignoreCase) {\n      left = left.toLowerCase();\n      right = right.toLowerCase();\n    }\n\n    return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\n  };\n\n  wordDiff.tokenize = function (value) {\n    var tokens = value.split(/(\\s+|[()[\\]{}'\"]|\\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n\n    for (var i = 0; i < tokens.length - 1; i++) {\n      // If we have an empty string in the next field and we have only word chars before and after, merge\n      if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\n        tokens[i] += tokens[i + 2];\n        tokens.splice(i + 1, 2);\n        i--;\n      }\n    }\n\n    return tokens;\n  };\n\n  function diffWords(oldStr, newStr, options) {\n    options = generateOptions(options, {\n      ignoreWhitespace: true\n    });\n    return wordDiff.diff(oldStr, newStr, options);\n  }\n\n  function diffWordsWithSpace(oldStr, newStr, options) {\n    return wordDiff.diff(oldStr, newStr, options);\n  }\n\n  var lineDiff = new Diff();\n\n  lineDiff.tokenize = function (value) {\n    var retLines = [],\n        linesAndNewlines = value.split(/(\\n|\\r\\n)/); // Ignore the final empty token that occurs if the string ends with a new line\n\n    if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n      linesAndNewlines.pop();\n    } // Merge the content and line separators into single tokens\n\n\n    for (var i = 0; i < linesAndNewlines.length; i++) {\n      var line = linesAndNewlines[i];\n\n      if (i % 2 && !this.options.newlineIsToken) {\n        retLines[retLines.length - 1] += line;\n      } else {\n        if (this.options.ignoreWhitespace) {\n          line = line.trim();\n        }\n\n        retLines.push(line);\n      }\n    }\n\n    return retLines;\n  };\n\n  function diffLines(oldStr, newStr, callback) {\n    return lineDiff.diff(oldStr, newStr, callback);\n  }\n\n  function diffTrimmedLines(oldStr, newStr, callback) {\n    var options = generateOptions(callback, {\n      ignoreWhitespace: true\n    });\n    return lineDiff.diff(oldStr, newStr, options);\n  }\n\n  var sentenceDiff = new Diff();\n\n  sentenceDiff.tokenize = function (value) {\n    return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n  };\n\n  function diffSentences(oldStr, newStr, callback) {\n    return sentenceDiff.diff(oldStr, newStr, callback);\n  }\n\n  var cssDiff = new Diff();\n\n  cssDiff.tokenize = function (value) {\n    return value.split(/([{}:;,]|\\s+)/);\n  };\n\n  function diffCss(oldStr, newStr, callback) {\n    return cssDiff.diff(oldStr, newStr, callback);\n  }\n\n  function _typeof$1(obj) {\n    if (typeof Symbol === \"function\" && _typeof(Symbol.iterator) === \"symbol\") {\n      _typeof$1 = function _typeof$1(obj) {\n        return _typeof(obj);\n      };\n    } else {\n      _typeof$1 = function _typeof$1(obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof(obj);\n      };\n    }\n\n    return _typeof$1(obj);\n  }\n\n  function _toConsumableArray$1(arr) {\n    return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _nonIterableSpread$1();\n  }\n\n  function _arrayWithoutHoles$1(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n        arr2[i] = arr[i];\n      }\n\n      return arr2;\n    }\n  }\n\n  function _iterableToArray$1(iter) {\n    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n  }\n\n  function _nonIterableSpread$1() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n  }\n\n  var objectPrototypeToString = Object.prototype.toString;\n  var jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n  // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n\n  jsonDiff.useLongestToken = true;\n  jsonDiff.tokenize = lineDiff.tokenize;\n\n  jsonDiff.castInput = function (value) {\n    var _this$options = this.options,\n        undefinedReplacement = _this$options.undefinedReplacement,\n        _this$options$stringi = _this$options.stringifyReplacer,\n        stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {\n      return typeof v === 'undefined' ? undefinedReplacement : v;\n    } : _this$options$stringi;\n    return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n  };\n\n  jsonDiff.equals = function (left, right) {\n    return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n  };\n\n  function diffJson(oldObj, newObj, options) {\n    return jsonDiff.diff(oldObj, newObj, options);\n  } // This function handles the presence of circular references by bailing out when encountering an\n  // object that is already on the \"stack\" of items being processed. Accepts an optional replacer\n\n\n  function canonicalize(obj, stack, replacementStack, replacer, key) {\n    stack = stack || [];\n    replacementStack = replacementStack || [];\n\n    if (replacer) {\n      obj = replacer(key, obj);\n    }\n\n    var i;\n\n    for (i = 0; i < stack.length; i += 1) {\n      if (stack[i] === obj) {\n        return replacementStack[i];\n      }\n    }\n\n    var canonicalizedObj;\n\n    if ('[object Array]' === objectPrototypeToString.call(obj)) {\n      stack.push(obj);\n      canonicalizedObj = new Array(obj.length);\n      replacementStack.push(canonicalizedObj);\n\n      for (i = 0; i < obj.length; i += 1) {\n        canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n      }\n\n      stack.pop();\n      replacementStack.pop();\n      return canonicalizedObj;\n    }\n\n    if (obj && obj.toJSON) {\n      obj = obj.toJSON();\n    }\n\n    if (_typeof$1(obj) === 'object' && obj !== null) {\n      stack.push(obj);\n      canonicalizedObj = {};\n      replacementStack.push(canonicalizedObj);\n\n      var sortedKeys = [],\n          _key;\n\n      for (_key in obj) {\n        /* istanbul ignore else */\n        if (obj.hasOwnProperty(_key)) {\n          sortedKeys.push(_key);\n        }\n      }\n\n      sortedKeys.sort();\n\n      for (i = 0; i < sortedKeys.length; i += 1) {\n        _key = sortedKeys[i];\n        canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n      }\n\n      stack.pop();\n      replacementStack.pop();\n    } else {\n      canonicalizedObj = obj;\n    }\n\n    return canonicalizedObj;\n  }\n\n  var arrayDiff = new Diff();\n\n  arrayDiff.tokenize = function (value) {\n    return value.slice();\n  };\n\n  arrayDiff.join = arrayDiff.removeEmpty = function (value) {\n    return value;\n  };\n\n  function diffArrays(oldArr, newArr, callback) {\n    return arrayDiff.diff(oldArr, newArr, callback);\n  }\n\n  function parsePatch(uniDiff) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n        delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n        list = [],\n        i = 0;\n\n    function parseIndex() {\n      var index = {};\n      list.push(index); // Parse diff metadata\n\n      while (i < diffstr.length) {\n        var line = diffstr[i]; // File header found, end parsing diff metadata\n\n        if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n          break;\n        } // Diff index\n\n\n        var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n\n        if (header) {\n          index.index = header[1];\n        }\n\n        i++;\n      } // Parse file headers if they are defined. Unified diff requires them, but\n      // there's no technical issues to have an isolated hunk without file header\n\n\n      parseFileHeader(index);\n      parseFileHeader(index); // Parse hunks\n\n      index.hunks = [];\n\n      while (i < diffstr.length) {\n        var _line = diffstr[i];\n\n        if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n          break;\n        } else if (/^@@/.test(_line)) {\n          index.hunks.push(parseHunk());\n        } else if (_line && options.strict) {\n          // Ignore unexpected content unless in strict mode\n          throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n        } else {\n          i++;\n        }\n      }\n    } // Parses the --- and +++ headers, if none are found, no lines\n    // are consumed.\n\n\n    function parseFileHeader(index) {\n      var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n\n      if (fileHeader) {\n        var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n        var data = fileHeader[2].split('\\t', 2);\n        var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n\n        if (/^\".*\"$/.test(fileName)) {\n          fileName = fileName.substr(1, fileName.length - 2);\n        }\n\n        index[keyPrefix + 'FileName'] = fileName;\n        index[keyPrefix + 'Header'] = (data[1] || '').trim();\n        i++;\n      }\n    } // Parses a hunk\n    // This assumes that we are at the start of a hunk.\n\n\n    function parseHunk() {\n      var chunkHeaderIndex = i,\n          chunkHeaderLine = diffstr[i++],\n          chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n      var hunk = {\n        oldStart: +chunkHeader[1],\n        oldLines: +chunkHeader[2] || 1,\n        newStart: +chunkHeader[3],\n        newLines: +chunkHeader[4] || 1,\n        lines: [],\n        linedelimiters: []\n      };\n      var addCount = 0,\n          removeCount = 0;\n\n      for (; i < diffstr.length; i++) {\n        // Lines starting with '---' could be mistaken for the \"remove line\" operation\n        // But they could be the header for the next file. Therefore prune such cases out.\n        if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\n          break;\n        }\n\n        var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n\n        if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n          hunk.lines.push(diffstr[i]);\n          hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n          if (operation === '+') {\n            addCount++;\n          } else if (operation === '-') {\n            removeCount++;\n          } else if (operation === ' ') {\n            addCount++;\n            removeCount++;\n          }\n        } else {\n          break;\n        }\n      } // Handle the empty block count case\n\n\n      if (!addCount && hunk.newLines === 1) {\n        hunk.newLines = 0;\n      }\n\n      if (!removeCount && hunk.oldLines === 1) {\n        hunk.oldLines = 0;\n      } // Perform optional sanity checking\n\n\n      if (options.strict) {\n        if (addCount !== hunk.newLines) {\n          throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n        }\n\n        if (removeCount !== hunk.oldLines) {\n          throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n        }\n      }\n\n      return hunk;\n    }\n\n    while (i < diffstr.length) {\n      parseIndex();\n    }\n\n    return list;\n  } // Iterator that traverses in the range of [min, max], stepping\n  // by distance from a given start position. I.e. for [0, 4], with\n  // start of 2, this will iterate 2, 3, 1, 4, 0.\n\n\n  function distanceIterator(start, minLine, maxLine) {\n    var wantForward = true,\n        backwardExhausted = false,\n        forwardExhausted = false,\n        localOffset = 1;\n    return function iterator() {\n      if (wantForward && !forwardExhausted) {\n        if (backwardExhausted) {\n          localOffset++;\n        } else {\n          wantForward = false;\n        } // Check if trying to fit beyond text length, and if not, check it fits\n        // after offset location (or desired location on first iteration)\n\n\n        if (start + localOffset <= maxLine) {\n          return localOffset;\n        }\n\n        forwardExhausted = true;\n      }\n\n      if (!backwardExhausted) {\n        if (!forwardExhausted) {\n          wantForward = true;\n        } // Check if trying to fit before text beginning, and if not, check it fits\n        // before offset location\n\n\n        if (minLine <= start - localOffset) {\n          return -localOffset++;\n        }\n\n        backwardExhausted = true;\n        return iterator();\n      } // We tried to fit hunk before text beginning and beyond text length, then\n      // hunk can't fit on the text. Return undefined\n\n    };\n  }\n\n  function applyPatch(source, uniDiff) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (typeof uniDiff === 'string') {\n      uniDiff = parsePatch(uniDiff);\n    }\n\n    if (Array.isArray(uniDiff)) {\n      if (uniDiff.length > 1) {\n        throw new Error('applyPatch only works with a single input.');\n      }\n\n      uniDiff = uniDiff[0];\n    } // Apply the diff to the input\n\n\n    var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n        delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n        hunks = uniDiff.hunks,\n        compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {\n      return line === patchContent;\n    },\n        errorCount = 0,\n        fuzzFactor = options.fuzzFactor || 0,\n        minLine = 0,\n        offset = 0,\n        removeEOFNL,\n        addEOFNL;\n    /**\n     * Checks if the hunk exactly fits on the provided location\n     */\n\n\n    function hunkFits(hunk, toPos) {\n      for (var j = 0; j < hunk.lines.length; j++) {\n        var line = hunk.lines[j],\n            operation = line.length > 0 ? line[0] : ' ',\n            content = line.length > 0 ? line.substr(1) : line;\n\n        if (operation === ' ' || operation === '-') {\n          // Context sanity check\n          if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n            errorCount++;\n\n            if (errorCount > fuzzFactor) {\n              return false;\n            }\n          }\n\n          toPos++;\n        }\n      }\n\n      return true;\n    } // Search best fit offsets for each hunk based on the previous ones\n\n\n    for (var i = 0; i < hunks.length; i++) {\n      var hunk = hunks[i],\n          maxLine = lines.length - hunk.oldLines,\n          localOffset = 0,\n          toPos = offset + hunk.oldStart - 1;\n      var iterator = distanceIterator(toPos, minLine, maxLine);\n\n      for (; localOffset !== undefined; localOffset = iterator()) {\n        if (hunkFits(hunk, toPos + localOffset)) {\n          hunk.offset = offset += localOffset;\n          break;\n        }\n      }\n\n      if (localOffset === undefined) {\n        return false;\n      } // Set lower text limit to end of the current hunk, so next ones don't try\n      // to fit over already patched text\n\n\n      minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n    } // Apply patch hunks\n\n\n    var diffOffset = 0;\n\n    for (var _i = 0; _i < hunks.length; _i++) {\n      var _hunk = hunks[_i],\n          _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n\n      diffOffset += _hunk.newLines - _hunk.oldLines;\n\n      if (_toPos < 0) {\n        // Creating a new file\n        _toPos = 0;\n      }\n\n      for (var j = 0; j < _hunk.lines.length; j++) {\n        var line = _hunk.lines[j],\n            operation = line.length > 0 ? line[0] : ' ',\n            content = line.length > 0 ? line.substr(1) : line,\n            delimiter = _hunk.linedelimiters[j];\n\n        if (operation === ' ') {\n          _toPos++;\n        } else if (operation === '-') {\n          lines.splice(_toPos, 1);\n          delimiters.splice(_toPos, 1);\n          /* istanbul ignore else */\n        } else if (operation === '+') {\n          lines.splice(_toPos, 0, content);\n          delimiters.splice(_toPos, 0, delimiter);\n          _toPos++;\n        } else if (operation === '\\\\') {\n          var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n\n          if (previousOperation === '+') {\n            removeEOFNL = true;\n          } else if (previousOperation === '-') {\n            addEOFNL = true;\n          }\n        }\n      }\n    } // Handle EOFNL insertion/removal\n\n\n    if (removeEOFNL) {\n      while (!lines[lines.length - 1]) {\n        lines.pop();\n        delimiters.pop();\n      }\n    } else if (addEOFNL) {\n      lines.push('');\n      delimiters.push('\\n');\n    }\n\n    for (var _k = 0; _k < lines.length - 1; _k++) {\n      lines[_k] = lines[_k] + delimiters[_k];\n    }\n\n    return lines.join('');\n  } // Wrapper that supports multiple file patches via callbacks.\n\n\n  function applyPatches(uniDiff, options) {\n    if (typeof uniDiff === 'string') {\n      uniDiff = parsePatch(uniDiff);\n    }\n\n    var currentIndex = 0;\n\n    function processIndex() {\n      var index = uniDiff[currentIndex++];\n\n      if (!index) {\n        return options.complete();\n      }\n\n      options.loadFile(index, function (err, data) {\n        if (err) {\n          return options.complete(err);\n        }\n\n        var updatedContent = applyPatch(data, index, options);\n        options.patched(index, updatedContent, function (err) {\n          if (err) {\n            return options.complete(err);\n          }\n\n          processIndex();\n        });\n      });\n    }\n\n    processIndex();\n  }\n\n  function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n    if (!options) {\n      options = {};\n    }\n\n    if (typeof options.context === 'undefined') {\n      options.context = 4;\n    }\n\n    var diff = diffLines(oldStr, newStr, options);\n    diff.push({\n      value: '',\n      lines: []\n    }); // Append an empty value to make cleanup easier\n\n    function contextLines(lines) {\n      return lines.map(function (entry) {\n        return ' ' + entry;\n      });\n    }\n\n    var hunks = [];\n    var oldRangeStart = 0,\n        newRangeStart = 0,\n        curRange = [],\n        oldLine = 1,\n        newLine = 1;\n\n    var _loop = function _loop(i) {\n      var current = diff[i],\n          lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n      current.lines = lines;\n\n      if (current.added || current.removed) {\n        var _curRange; // If we have previous context, start with that\n\n\n        if (!oldRangeStart) {\n          var prev = diff[i - 1];\n          oldRangeStart = oldLine;\n          newRangeStart = newLine;\n\n          if (prev) {\n            curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n            oldRangeStart -= curRange.length;\n            newRangeStart -= curRange.length;\n          }\n        } // Output our changes\n\n\n        (_curRange = curRange).push.apply(_curRange, _toConsumableArray$1(lines.map(function (entry) {\n          return (current.added ? '+' : '-') + entry;\n        }))); // Track the updated file position\n\n\n        if (current.added) {\n          newLine += lines.length;\n        } else {\n          oldLine += lines.length;\n        }\n      } else {\n        // Identical context lines. Track line changes\n        if (oldRangeStart) {\n          // Close out any changes that have been output (or join overlapping)\n          if (lines.length <= options.context * 2 && i < diff.length - 2) {\n            var _curRange2; // Overlapping\n\n\n            (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray$1(contextLines(lines)));\n          } else {\n            var _curRange3; // end the range and output\n\n\n            var contextSize = Math.min(lines.length, options.context);\n\n            (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray$1(contextLines(lines.slice(0, contextSize))));\n\n            var hunk = {\n              oldStart: oldRangeStart,\n              oldLines: oldLine - oldRangeStart + contextSize,\n              newStart: newRangeStart,\n              newLines: newLine - newRangeStart + contextSize,\n              lines: curRange\n            };\n\n            if (i >= diff.length - 2 && lines.length <= options.context) {\n              // EOF is inside this hunk\n              var oldEOFNewline = /\\n$/.test(oldStr);\n              var newEOFNewline = /\\n$/.test(newStr);\n              var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\n\n              if (!oldEOFNewline && noNlBeforeAdds) {\n                // special case: old has no eol and no trailing context; no-nl can end up before adds\n                curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n              }\n\n              if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {\n                curRange.push('\\\\ No newline at end of file');\n              }\n            }\n\n            hunks.push(hunk);\n            oldRangeStart = 0;\n            newRangeStart = 0;\n            curRange = [];\n          }\n        }\n\n        oldLine += lines.length;\n        newLine += lines.length;\n      }\n    };\n\n    for (var i = 0; i < diff.length; i++) {\n      _loop(i);\n    }\n\n    return {\n      oldFileName: oldFileName,\n      newFileName: newFileName,\n      oldHeader: oldHeader,\n      newHeader: newHeader,\n      hunks: hunks\n    };\n  }\n\n  function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n    var diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);\n    var ret = [];\n\n    if (oldFileName == newFileName) {\n      ret.push('Index: ' + oldFileName);\n    }\n\n    ret.push('===================================================================');\n    ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n    ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n    for (var i = 0; i < diff.hunks.length; i++) {\n      var hunk = diff.hunks[i];\n      ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n      ret.push.apply(ret, hunk.lines);\n    }\n\n    return ret.join('\\n') + '\\n';\n  }\n\n  function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n    return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n  }\n\n  function arrayEqual(a, b) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    return arrayStartsWith(a, b);\n  }\n\n  function arrayStartsWith(array, start) {\n    if (start.length > array.length) {\n      return false;\n    }\n\n    for (var i = 0; i < start.length; i++) {\n      if (start[i] !== array[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function calcLineCount(hunk) {\n    var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),\n        oldLines = _calcOldNewLineCount.oldLines,\n        newLines = _calcOldNewLineCount.newLines;\n\n    if (oldLines !== undefined) {\n      hunk.oldLines = oldLines;\n    } else {\n      delete hunk.oldLines;\n    }\n\n    if (newLines !== undefined) {\n      hunk.newLines = newLines;\n    } else {\n      delete hunk.newLines;\n    }\n  }\n\n  function merge(mine, theirs, base) {\n    mine = loadPatch(mine, base);\n    theirs = loadPatch(theirs, base);\n    var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.\n    // Leaving sanity checks on this to the API consumer that may know more about the\n    // meaning in their own context.\n\n    if (mine.index || theirs.index) {\n      ret.index = mine.index || theirs.index;\n    }\n\n    if (mine.newFileName || theirs.newFileName) {\n      if (!fileNameChanged(mine)) {\n        // No header or no change in ours, use theirs (and ours if theirs does not exist)\n        ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n        ret.newFileName = theirs.newFileName || mine.newFileName;\n        ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n        ret.newHeader = theirs.newHeader || mine.newHeader;\n      } else if (!fileNameChanged(theirs)) {\n        // No header or no change in theirs, use ours\n        ret.oldFileName = mine.oldFileName;\n        ret.newFileName = mine.newFileName;\n        ret.oldHeader = mine.oldHeader;\n        ret.newHeader = mine.newHeader;\n      } else {\n        // Both changed... figure it out\n        ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n        ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n        ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n        ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n      }\n    }\n\n    ret.hunks = [];\n    var mineIndex = 0,\n        theirsIndex = 0,\n        mineOffset = 0,\n        theirsOffset = 0;\n\n    while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n      var mineCurrent = mine.hunks[mineIndex] || {\n        oldStart: Infinity\n      },\n          theirsCurrent = theirs.hunks[theirsIndex] || {\n        oldStart: Infinity\n      };\n\n      if (hunkBefore(mineCurrent, theirsCurrent)) {\n        // This patch does not overlap with any of the others, yay.\n        ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n        mineIndex++;\n        theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n      } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n        // This patch does not overlap with any of the others, yay.\n        ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n        theirsIndex++;\n        mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n      } else {\n        // Overlap, merge as best we can\n        var mergedHunk = {\n          oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n          oldLines: 0,\n          newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n          newLines: 0,\n          lines: []\n        };\n        mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n        theirsIndex++;\n        mineIndex++;\n        ret.hunks.push(mergedHunk);\n      }\n    }\n\n    return ret;\n  }\n\n  function loadPatch(param, base) {\n    if (typeof param === 'string') {\n      if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n        return parsePatch(param)[0];\n      }\n\n      if (!base) {\n        throw new Error('Must provide a base reference or pass in a patch');\n      }\n\n      return structuredPatch(undefined, undefined, base, param);\n    }\n\n    return param;\n  }\n\n  function fileNameChanged(patch) {\n    return patch.newFileName && patch.newFileName !== patch.oldFileName;\n  }\n\n  function selectField(index, mine, theirs) {\n    if (mine === theirs) {\n      return mine;\n    } else {\n      index.conflict = true;\n      return {\n        mine: mine,\n        theirs: theirs\n      };\n    }\n  }\n\n  function hunkBefore(test, check) {\n    return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n  }\n\n  function cloneHunk(hunk, offset) {\n    return {\n      oldStart: hunk.oldStart,\n      oldLines: hunk.oldLines,\n      newStart: hunk.newStart + offset,\n      newLines: hunk.newLines,\n      lines: hunk.lines\n    };\n  }\n\n  function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n    // This will generally result in a conflicted hunk, but there are cases where the context\n    // is the only overlap where we can successfully merge the content here.\n    var mine = {\n      offset: mineOffset,\n      lines: mineLines,\n      index: 0\n    },\n        their = {\n      offset: theirOffset,\n      lines: theirLines,\n      index: 0\n    }; // Handle any leading content\n\n    insertLeading(hunk, mine, their);\n    insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.\n\n    while (mine.index < mine.lines.length && their.index < their.lines.length) {\n      var mineCurrent = mine.lines[mine.index],\n          theirCurrent = their.lines[their.index];\n\n      if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n        // Both modified ...\n        mutualChange(hunk, mine, their);\n      } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n        var _hunk$lines; // Mine inserted\n\n\n        (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray$1(collectChange(mine)));\n      } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n        var _hunk$lines2; // Theirs inserted\n\n\n        (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray$1(collectChange(their)));\n      } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n        // Mine removed or edited\n        removal(hunk, mine, their);\n      } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n        // Their removed or edited\n        removal(hunk, their, mine, true);\n      } else if (mineCurrent === theirCurrent) {\n        // Context identity\n        hunk.lines.push(mineCurrent);\n        mine.index++;\n        their.index++;\n      } else {\n        // Context mismatch\n        conflict(hunk, collectChange(mine), collectChange(their));\n      }\n    } // Now push anything that may be remaining\n\n\n    insertTrailing(hunk, mine);\n    insertTrailing(hunk, their);\n    calcLineCount(hunk);\n  }\n\n  function mutualChange(hunk, mine, their) {\n    var myChanges = collectChange(mine),\n        theirChanges = collectChange(their);\n\n    if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n      // Special case for remove changes that are supersets of one another\n      if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n        var _hunk$lines3;\n\n        (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray$1(myChanges));\n\n        return;\n      } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n        var _hunk$lines4;\n\n        (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray$1(theirChanges));\n\n        return;\n      }\n    } else if (arrayEqual(myChanges, theirChanges)) {\n      var _hunk$lines5;\n\n      (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray$1(myChanges));\n\n      return;\n    }\n\n    conflict(hunk, myChanges, theirChanges);\n  }\n\n  function removal(hunk, mine, their, swap) {\n    var myChanges = collectChange(mine),\n        theirChanges = collectContext(their, myChanges);\n\n    if (theirChanges.merged) {\n      var _hunk$lines6;\n\n      (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray$1(theirChanges.merged));\n    } else {\n      conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n    }\n  }\n\n  function conflict(hunk, mine, their) {\n    hunk.conflict = true;\n    hunk.lines.push({\n      conflict: true,\n      mine: mine,\n      theirs: their\n    });\n  }\n\n  function insertLeading(hunk, insert, their) {\n    while (insert.offset < their.offset && insert.index < insert.lines.length) {\n      var line = insert.lines[insert.index++];\n      hunk.lines.push(line);\n      insert.offset++;\n    }\n  }\n\n  function insertTrailing(hunk, insert) {\n    while (insert.index < insert.lines.length) {\n      var line = insert.lines[insert.index++];\n      hunk.lines.push(line);\n    }\n  }\n\n  function collectChange(state) {\n    var ret = [],\n        operation = state.lines[state.index][0];\n\n    while (state.index < state.lines.length) {\n      var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n\n      if (operation === '-' && line[0] === '+') {\n        operation = '+';\n      }\n\n      if (operation === line[0]) {\n        ret.push(line);\n        state.index++;\n      } else {\n        break;\n      }\n    }\n\n    return ret;\n  }\n\n  function collectContext(state, matchChanges) {\n    var changes = [],\n        merged = [],\n        matchIndex = 0,\n        contextChanges = false,\n        conflicted = false;\n\n    while (matchIndex < matchChanges.length && state.index < state.lines.length) {\n      var change = state.lines[state.index],\n          match = matchChanges[matchIndex]; // Once we've hit our add, then we are done\n\n      if (match[0] === '+') {\n        break;\n      }\n\n      contextChanges = contextChanges || change[0] !== ' ';\n      merged.push(match);\n      matchIndex++; // Consume any additions in the other block as a conflict to attempt\n      // to pull in the remaining context after this\n\n      if (change[0] === '+') {\n        conflicted = true;\n\n        while (change[0] === '+') {\n          changes.push(change);\n          change = state.lines[++state.index];\n        }\n      }\n\n      if (match.substr(1) === change.substr(1)) {\n        changes.push(change);\n        state.index++;\n      } else {\n        conflicted = true;\n      }\n    }\n\n    if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\n      conflicted = true;\n    }\n\n    if (conflicted) {\n      return changes;\n    }\n\n    while (matchIndex < matchChanges.length) {\n      merged.push(matchChanges[matchIndex++]);\n    }\n\n    return {\n      merged: merged,\n      changes: changes\n    };\n  }\n\n  function allRemoves(changes) {\n    return changes.reduce(function (prev, change) {\n      return prev && change[0] === '-';\n    }, true);\n  }\n\n  function skipRemoveSuperset(state, removeChanges, delta) {\n    for (var i = 0; i < delta; i++) {\n      var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n\n      if (state.lines[state.index + i] !== ' ' + changeContent) {\n        return false;\n      }\n    }\n\n    state.index += delta;\n    return true;\n  }\n\n  function calcOldNewLineCount(lines) {\n    var oldLines = 0;\n    var newLines = 0;\n    lines.forEach(function (line) {\n      if (typeof line !== 'string') {\n        var myCount = calcOldNewLineCount(line.mine);\n        var theirCount = calcOldNewLineCount(line.theirs);\n\n        if (oldLines !== undefined) {\n          if (myCount.oldLines === theirCount.oldLines) {\n            oldLines += myCount.oldLines;\n          } else {\n            oldLines = undefined;\n          }\n        }\n\n        if (newLines !== undefined) {\n          if (myCount.newLines === theirCount.newLines) {\n            newLines += myCount.newLines;\n          } else {\n            newLines = undefined;\n          }\n        }\n      } else {\n        if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n          newLines++;\n        }\n\n        if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n          oldLines++;\n        }\n      }\n    });\n    return {\n      oldLines: oldLines,\n      newLines: newLines\n    };\n  } // See: http://code.google.com/p/google-diff-match-patch/wiki/API\n\n\n  function convertChangesToDMP(changes) {\n    var ret = [],\n        change,\n        operation;\n\n    for (var i = 0; i < changes.length; i++) {\n      change = changes[i];\n\n      if (change.added) {\n        operation = 1;\n      } else if (change.removed) {\n        operation = -1;\n      } else {\n        operation = 0;\n      }\n\n      ret.push([operation, change.value]);\n    }\n\n    return ret;\n  }\n\n  function convertChangesToXML(changes) {\n    var ret = [];\n\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n\n      if (change.added) {\n        ret.push('<ins>');\n      } else if (change.removed) {\n        ret.push('<del>');\n      }\n\n      ret.push(escapeHTML(change.value));\n\n      if (change.added) {\n        ret.push('</ins>');\n      } else if (change.removed) {\n        ret.push('</del>');\n      }\n    }\n\n    return ret.join('');\n  }\n\n  function escapeHTML(s) {\n    var n = s;\n    n = n.replace(/&/g, '&amp;');\n    n = n.replace(/</g, '&lt;');\n    n = n.replace(/>/g, '&gt;');\n    n = n.replace(/\"/g, '&quot;');\n    return n;\n  }\n\n  var index_es6 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    Diff: Diff,\n    diffChars: diffChars,\n    diffWords: diffWords,\n    diffWordsWithSpace: diffWordsWithSpace,\n    diffLines: diffLines,\n    diffTrimmedLines: diffTrimmedLines,\n    diffSentences: diffSentences,\n    diffCss: diffCss,\n    diffJson: diffJson,\n    diffArrays: diffArrays,\n    structuredPatch: structuredPatch,\n    createTwoFilesPatch: createTwoFilesPatch,\n    createPatch: createPatch,\n    applyPatch: applyPatch,\n    applyPatches: applyPatches,\n    parsePatch: parsePatch,\n    merge: merge,\n    convertChangesToDMP: convertChangesToDMP,\n    convertChangesToXML: convertChangesToXML,\n    canonicalize: canonicalize\n  });\n\n  var _shim_fs = {};\n\n  var _shim_fs$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    'default': _shim_fs\n  });\n\n  /*!\n   * normalize-path <https://github.com/jonschlinkert/normalize-path>\n   *\n   * Copyright (c) 2014-2018, Jon Schlinkert.\n   * Released under the MIT License.\n   */\n  var normalizePath = function normalizePath(path, stripTrailing) {\n    if (typeof path !== 'string') {\n      throw new TypeError('expected path to be a string');\n    }\n\n    if (path === '\\\\' || path === '/') return '/';\n    var len = path.length;\n    if (len <= 1) return path; // ensure that win32 namespaces has two leading slashes, so that the path is\n    // handled properly by the win32 version of path.parse() after being normalized\n    // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces\n\n    var prefix = '';\n\n    if (len > 4 && path[3] === '\\\\') {\n      var ch = path[2];\n\n      if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\\\\\') {\n        path = path.slice(2);\n        prefix = '//';\n      }\n    }\n\n    var segs = path.split(/[/\\\\]+/);\n\n    if (stripTrailing !== false && segs[segs.length - 1] === '') {\n      segs.pop();\n    }\n\n    return prefix + segs.join('/');\n  };\n\n  var global$1 = typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {};\n\n  var lookup = [];\n  var revLookup = [];\n  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n  var inited = false;\n\n  function init() {\n    inited = true;\n    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n    for (var i = 0, len = code.length; i < len; ++i) {\n      lookup[i] = code[i];\n      revLookup[code.charCodeAt(i)] = i;\n    }\n\n    revLookup['-'.charCodeAt(0)] = 62;\n    revLookup['_'.charCodeAt(0)] = 63;\n  }\n\n  function toByteArray(b64) {\n    if (!inited) {\n      init();\n    }\n\n    var i, j, l, tmp, placeHolders, arr;\n    var len = b64.length;\n\n    if (len % 4 > 0) {\n      throw new Error('Invalid string. Length must be a multiple of 4');\n    } // the number of equal signs (place holders)\n    // if there are two placeholders, than the two characters before it\n    // represent one byte\n    // if there is only one, then the three characters before it represent 2 bytes\n    // this is just a cheap hack to not do indexOf twice\n\n\n    placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0; // base64 is 4/3 + up to two characters of the original data\n\n    arr = new Arr(len * 3 / 4 - placeHolders); // if there are placeholders, only get up to the last complete 4 chars\n\n    l = placeHolders > 0 ? len - 4 : len;\n    var L = 0;\n\n    for (i = 0, j = 0; i < l; i += 4, j += 3) {\n      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n      arr[L++] = tmp >> 16 & 0xFF;\n      arr[L++] = tmp >> 8 & 0xFF;\n      arr[L++] = tmp & 0xFF;\n    }\n\n    if (placeHolders === 2) {\n      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n      arr[L++] = tmp & 0xFF;\n    } else if (placeHolders === 1) {\n      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n      arr[L++] = tmp >> 8 & 0xFF;\n      arr[L++] = tmp & 0xFF;\n    }\n\n    return arr;\n  }\n\n  function tripletToBase64(num) {\n    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n  }\n\n  function encodeChunk(uint8, start, end) {\n    var tmp;\n    var output = [];\n\n    for (var i = start; i < end; i += 3) {\n      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n      output.push(tripletToBase64(tmp));\n    }\n\n    return output.join('');\n  }\n\n  function fromByteArray(uint8) {\n    if (!inited) {\n      init();\n    }\n\n    var tmp;\n    var len = uint8.length;\n    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n\n    var output = '';\n    var parts = [];\n    var maxChunkLength = 16383; // must be multiple of 3\n    // go through the array every three bytes, we'll deal with trailing stuff later\n\n    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n      parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n    } // pad the end with zeros, but make sure to not forget the extra bytes\n\n\n    if (extraBytes === 1) {\n      tmp = uint8[len - 1];\n      output += lookup[tmp >> 2];\n      output += lookup[tmp << 4 & 0x3F];\n      output += '==';\n    } else if (extraBytes === 2) {\n      tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n      output += lookup[tmp >> 10];\n      output += lookup[tmp >> 4 & 0x3F];\n      output += lookup[tmp << 2 & 0x3F];\n      output += '=';\n    }\n\n    parts.push(output);\n    return parts.join('');\n  }\n\n  function read(buffer, offset, isLE, mLen, nBytes) {\n    var e, m;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var nBits = -7;\n    var i = isLE ? nBytes - 1 : 0;\n    var d = isLE ? -1 : 1;\n    var s = buffer[offset + i];\n    i += d;\n    e = s & (1 << -nBits) - 1;\n    s >>= -nBits;\n    nBits += eLen;\n\n    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n    m = e & (1 << -nBits) - 1;\n    e >>= -nBits;\n    nBits += mLen;\n\n    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n    if (e === 0) {\n      e = 1 - eBias;\n    } else if (e === eMax) {\n      return m ? NaN : (s ? -1 : 1) * Infinity;\n    } else {\n      m = m + Math.pow(2, mLen);\n      e = e - eBias;\n    }\n\n    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n  }\n  function write(buffer, value, offset, isLE, mLen, nBytes) {\n    var e, m, c;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n    var i = isLE ? 0 : nBytes - 1;\n    var d = isLE ? 1 : -1;\n    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n    value = Math.abs(value);\n\n    if (isNaN(value) || value === Infinity) {\n      m = isNaN(value) ? 1 : 0;\n      e = eMax;\n    } else {\n      e = Math.floor(Math.log(value) / Math.LN2);\n\n      if (value * (c = Math.pow(2, -e)) < 1) {\n        e--;\n        c *= 2;\n      }\n\n      if (e + eBias >= 1) {\n        value += rt / c;\n      } else {\n        value += rt * Math.pow(2, 1 - eBias);\n      }\n\n      if (value * c >= 2) {\n        e++;\n        c /= 2;\n      }\n\n      if (e + eBias >= eMax) {\n        m = 0;\n        e = eMax;\n      } else if (e + eBias >= 1) {\n        m = (value * c - 1) * Math.pow(2, mLen);\n        e = e + eBias;\n      } else {\n        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n        e = 0;\n      }\n    }\n\n    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n    e = e << mLen | m;\n    eLen += mLen;\n\n    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n    buffer[offset + i - d] |= s * 128;\n  }\n\n  var toString = {}.toString;\n  var isArray = Array.isArray || function (arr) {\n    return toString.call(arr) == '[object Array]';\n  };\n\n  var INSPECT_MAX_BYTES = 50;\n  /**\n   * If `Buffer.TYPED_ARRAY_SUPPORT`:\n   *   === true    Use Uint8Array implementation (fastest)\n   *   === false   Use Object implementation (most compatible, even IE6)\n   *\n   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n   * Opera 11.6+, iOS 4.2+.\n   *\n   * Due to various browser bugs, sometimes the Object implementation will be used even\n   * when the browser supports typed arrays.\n   *\n   * Note:\n   *\n   *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n   *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n   *\n   *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n   *\n   *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n   *     incorrect length in some situations.\n\n   * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n   * get the Object implementation, which is slower but behaves correctly.\n   */\n\n  Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined ? global$1.TYPED_ARRAY_SUPPORT : true;\n\n  function kMaxLength() {\n    return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;\n  }\n\n  function createBuffer(that, length) {\n    if (kMaxLength() < length) {\n      throw new RangeError('Invalid typed array length');\n    }\n\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      // Return an augmented `Uint8Array` instance, for best performance\n      that = new Uint8Array(length);\n      that.__proto__ = Buffer.prototype;\n    } else {\n      // Fallback: Return an object instance of the Buffer class\n      if (that === null) {\n        that = new Buffer(length);\n      }\n\n      that.length = length;\n    }\n\n    return that;\n  }\n  /**\n   * The Buffer constructor returns instances of `Uint8Array` that have their\n   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n   * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n   * returns a single octet.\n   *\n   * The `Uint8Array` prototype remains unmodified.\n   */\n\n\n  function Buffer(arg, encodingOrOffset, length) {\n    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n      return new Buffer(arg, encodingOrOffset, length);\n    } // Common case.\n\n\n    if (typeof arg === 'number') {\n      if (typeof encodingOrOffset === 'string') {\n        throw new Error('If encoding is specified then the first argument must be a string');\n      }\n\n      return allocUnsafe(this, arg);\n    }\n\n    return from(this, arg, encodingOrOffset, length);\n  }\n  Buffer.poolSize = 8192; // not used by this implementation\n  // TODO: Legacy, not needed anymore. Remove in next major version.\n\n  Buffer._augment = function (arr) {\n    arr.__proto__ = Buffer.prototype;\n    return arr;\n  };\n\n  function from(that, value, encodingOrOffset, length) {\n    if (typeof value === 'number') {\n      throw new TypeError('\"value\" argument must not be a number');\n    }\n\n    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n      return fromArrayBuffer(that, value, encodingOrOffset, length);\n    }\n\n    if (typeof value === 'string') {\n      return fromString(that, value, encodingOrOffset);\n    }\n\n    return fromObject(that, value);\n  }\n  /**\n   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n   * if value is a number.\n   * Buffer.from(str[, encoding])\n   * Buffer.from(array)\n   * Buffer.from(buffer)\n   * Buffer.from(arrayBuffer[, byteOffset[, length]])\n   **/\n\n\n  Buffer.from = function (value, encodingOrOffset, length) {\n    return from(null, value, encodingOrOffset, length);\n  };\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    Buffer.prototype.__proto__ = Uint8Array.prototype;\n    Buffer.__proto__ = Uint8Array;\n  }\n\n  function assertSize(size) {\n    if (typeof size !== 'number') {\n      throw new TypeError('\"size\" argument must be a number');\n    } else if (size < 0) {\n      throw new RangeError('\"size\" argument must not be negative');\n    }\n  }\n\n  function alloc(that, size, fill, encoding) {\n    assertSize(size);\n\n    if (size <= 0) {\n      return createBuffer(that, size);\n    }\n\n    if (fill !== undefined) {\n      // Only pay attention to encoding if it's a string. This\n      // prevents accidentally sending in a number that would\n      // be interpretted as a start offset.\n      return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);\n    }\n\n    return createBuffer(that, size);\n  }\n  /**\n   * Creates a new filled Buffer instance.\n   * alloc(size[, fill[, encoding]])\n   **/\n\n\n  Buffer.alloc = function (size, fill, encoding) {\n    return alloc(null, size, fill, encoding);\n  };\n\n  function allocUnsafe(that, size) {\n    assertSize(size);\n    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n\n    if (!Buffer.TYPED_ARRAY_SUPPORT) {\n      for (var i = 0; i < size; ++i) {\n        that[i] = 0;\n      }\n    }\n\n    return that;\n  }\n  /**\n   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n   * */\n\n\n  Buffer.allocUnsafe = function (size) {\n    return allocUnsafe(null, size);\n  };\n  /**\n   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n   */\n\n\n  Buffer.allocUnsafeSlow = function (size) {\n    return allocUnsafe(null, size);\n  };\n\n  function fromString(that, string, encoding) {\n    if (typeof encoding !== 'string' || encoding === '') {\n      encoding = 'utf8';\n    }\n\n    if (!Buffer.isEncoding(encoding)) {\n      throw new TypeError('\"encoding\" must be a valid string encoding');\n    }\n\n    var length = byteLength(string, encoding) | 0;\n    that = createBuffer(that, length);\n    var actual = that.write(string, encoding);\n\n    if (actual !== length) {\n      // Writing a hex string, for example, that contains invalid characters will\n      // cause everything after the first invalid character to be ignored. (e.g.\n      // 'abxxcd' will be treated as 'ab')\n      that = that.slice(0, actual);\n    }\n\n    return that;\n  }\n\n  function fromArrayLike(that, array) {\n    var length = array.length < 0 ? 0 : checked(array.length) | 0;\n    that = createBuffer(that, length);\n\n    for (var i = 0; i < length; i += 1) {\n      that[i] = array[i] & 255;\n    }\n\n    return that;\n  }\n\n  function fromArrayBuffer(that, array, byteOffset, length) {\n    array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\n      throw new RangeError('\\'offset\\' is out of bounds');\n    }\n\n    if (array.byteLength < byteOffset + (length || 0)) {\n      throw new RangeError('\\'length\\' is out of bounds');\n    }\n\n    if (byteOffset === undefined && length === undefined) {\n      array = new Uint8Array(array);\n    } else if (length === undefined) {\n      array = new Uint8Array(array, byteOffset);\n    } else {\n      array = new Uint8Array(array, byteOffset, length);\n    }\n\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      // Return an augmented `Uint8Array` instance, for best performance\n      that = array;\n      that.__proto__ = Buffer.prototype;\n    } else {\n      // Fallback: Return an object instance of the Buffer class\n      that = fromArrayLike(that, array);\n    }\n\n    return that;\n  }\n\n  function fromObject(that, obj) {\n    if (internalIsBuffer(obj)) {\n      var len = checked(obj.length) | 0;\n      that = createBuffer(that, len);\n\n      if (that.length === 0) {\n        return that;\n      }\n\n      obj.copy(that, 0, 0, len);\n      return that;\n    }\n\n    if (obj) {\n      if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {\n        if (typeof obj.length !== 'number' || isnan(obj.length)) {\n          return createBuffer(that, 0);\n        }\n\n        return fromArrayLike(that, obj);\n      }\n\n      if (obj.type === 'Buffer' && isArray(obj.data)) {\n        return fromArrayLike(that, obj.data);\n      }\n    }\n\n    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');\n  }\n\n  function checked(length) {\n    // Note: cannot use `length < kMaxLength()` here because that fails when\n    // length is NaN (which is otherwise coerced to zero.)\n    if (length >= kMaxLength()) {\n      throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');\n    }\n\n    return length | 0;\n  }\n  Buffer.isBuffer = isBuffer;\n\n  function internalIsBuffer(b) {\n    return !!(b != null && b._isBuffer);\n  }\n\n  Buffer.compare = function compare(a, b) {\n    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {\n      throw new TypeError('Arguments must be Buffers');\n    }\n\n    if (a === b) return 0;\n    var x = a.length;\n    var y = b.length;\n\n    for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n      if (a[i] !== b[i]) {\n        x = a[i];\n        y = b[i];\n        break;\n      }\n    }\n\n    if (x < y) return -1;\n    if (y < x) return 1;\n    return 0;\n  };\n\n  Buffer.isEncoding = function isEncoding(encoding) {\n    switch (String(encoding).toLowerCase()) {\n      case 'hex':\n      case 'utf8':\n      case 'utf-8':\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n      case 'base64':\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return true;\n\n      default:\n        return false;\n    }\n  };\n\n  Buffer.concat = function concat(list, length) {\n    if (!isArray(list)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers');\n    }\n\n    if (list.length === 0) {\n      return Buffer.alloc(0);\n    }\n\n    var i;\n\n    if (length === undefined) {\n      length = 0;\n\n      for (i = 0; i < list.length; ++i) {\n        length += list[i].length;\n      }\n    }\n\n    var buffer = Buffer.allocUnsafe(length);\n    var pos = 0;\n\n    for (i = 0; i < list.length; ++i) {\n      var buf = list[i];\n\n      if (!internalIsBuffer(buf)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n      }\n\n      buf.copy(buffer, pos);\n      pos += buf.length;\n    }\n\n    return buffer;\n  };\n\n  function byteLength(string, encoding) {\n    if (internalIsBuffer(string)) {\n      return string.length;\n    }\n\n    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n      return string.byteLength;\n    }\n\n    if (typeof string !== 'string') {\n      string = '' + string;\n    }\n\n    var len = string.length;\n    if (len === 0) return 0; // Use a for loop to avoid recursion\n\n    var loweredCase = false;\n\n    for (;;) {\n      switch (encoding) {\n        case 'ascii':\n        case 'latin1':\n        case 'binary':\n          return len;\n\n        case 'utf8':\n        case 'utf-8':\n        case undefined:\n          return utf8ToBytes(string).length;\n\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n          return len * 2;\n\n        case 'hex':\n          return len >>> 1;\n\n        case 'base64':\n          return base64ToBytes(string).length;\n\n        default:\n          if (loweredCase) return utf8ToBytes(string).length; // assume utf8\n\n          encoding = ('' + encoding).toLowerCase();\n          loweredCase = true;\n      }\n    }\n  }\n\n  Buffer.byteLength = byteLength;\n\n  function slowToString(encoding, start, end) {\n    var loweredCase = false; // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n    // property of a typed array.\n    // This behaves neither like String nor Uint8Array in that we set start/end\n    // to their upper/lower bounds if the value passed is out of range.\n    // undefined is handled specially as per ECMA-262 6th Edition,\n    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\n    if (start === undefined || start < 0) {\n      start = 0;\n    } // Return early if start > this.length. Done here to prevent potential uint32\n    // coercion fail below.\n\n\n    if (start > this.length) {\n      return '';\n    }\n\n    if (end === undefined || end > this.length) {\n      end = this.length;\n    }\n\n    if (end <= 0) {\n      return '';\n    } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n\n\n    end >>>= 0;\n    start >>>= 0;\n\n    if (end <= start) {\n      return '';\n    }\n\n    if (!encoding) encoding = 'utf8';\n\n    while (true) {\n      switch (encoding) {\n        case 'hex':\n          return hexSlice(this, start, end);\n\n        case 'utf8':\n        case 'utf-8':\n          return utf8Slice(this, start, end);\n\n        case 'ascii':\n          return asciiSlice(this, start, end);\n\n        case 'latin1':\n        case 'binary':\n          return latin1Slice(this, start, end);\n\n        case 'base64':\n          return base64Slice(this, start, end);\n\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n          return utf16leSlice(this, start, end);\n\n        default:\n          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n          encoding = (encoding + '').toLowerCase();\n          loweredCase = true;\n      }\n    }\n  } // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n  // Buffer instances.\n\n\n  Buffer.prototype._isBuffer = true;\n\n  function swap(b, n, m) {\n    var i = b[n];\n    b[n] = b[m];\n    b[m] = i;\n  }\n\n  Buffer.prototype.swap16 = function swap16() {\n    var len = this.length;\n\n    if (len % 2 !== 0) {\n      throw new RangeError('Buffer size must be a multiple of 16-bits');\n    }\n\n    for (var i = 0; i < len; i += 2) {\n      swap(this, i, i + 1);\n    }\n\n    return this;\n  };\n\n  Buffer.prototype.swap32 = function swap32() {\n    var len = this.length;\n\n    if (len % 4 !== 0) {\n      throw new RangeError('Buffer size must be a multiple of 32-bits');\n    }\n\n    for (var i = 0; i < len; i += 4) {\n      swap(this, i, i + 3);\n      swap(this, i + 1, i + 2);\n    }\n\n    return this;\n  };\n\n  Buffer.prototype.swap64 = function swap64() {\n    var len = this.length;\n\n    if (len % 8 !== 0) {\n      throw new RangeError('Buffer size must be a multiple of 64-bits');\n    }\n\n    for (var i = 0; i < len; i += 8) {\n      swap(this, i, i + 7);\n      swap(this, i + 1, i + 6);\n      swap(this, i + 2, i + 5);\n      swap(this, i + 3, i + 4);\n    }\n\n    return this;\n  };\n\n  Buffer.prototype.toString = function toString() {\n    var length = this.length | 0;\n    if (length === 0) return '';\n    if (arguments.length === 0) return utf8Slice(this, 0, length);\n    return slowToString.apply(this, arguments);\n  };\n\n  Buffer.prototype.equals = function equals(b) {\n    if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer');\n    if (this === b) return true;\n    return Buffer.compare(this, b) === 0;\n  };\n\n  Buffer.prototype.inspect = function inspect() {\n    var str = '';\n    var max = INSPECT_MAX_BYTES;\n\n    if (this.length > 0) {\n      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\n      if (this.length > max) str += ' ... ';\n    }\n\n    return '<Buffer ' + str + '>';\n  };\n\n  Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n    if (!internalIsBuffer(target)) {\n      throw new TypeError('Argument must be a Buffer');\n    }\n\n    if (start === undefined) {\n      start = 0;\n    }\n\n    if (end === undefined) {\n      end = target ? target.length : 0;\n    }\n\n    if (thisStart === undefined) {\n      thisStart = 0;\n    }\n\n    if (thisEnd === undefined) {\n      thisEnd = this.length;\n    }\n\n    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n      throw new RangeError('out of range index');\n    }\n\n    if (thisStart >= thisEnd && start >= end) {\n      return 0;\n    }\n\n    if (thisStart >= thisEnd) {\n      return -1;\n    }\n\n    if (start >= end) {\n      return 1;\n    }\n\n    start >>>= 0;\n    end >>>= 0;\n    thisStart >>>= 0;\n    thisEnd >>>= 0;\n    if (this === target) return 0;\n    var x = thisEnd - thisStart;\n    var y = end - start;\n    var len = Math.min(x, y);\n    var thisCopy = this.slice(thisStart, thisEnd);\n    var targetCopy = target.slice(start, end);\n\n    for (var i = 0; i < len; ++i) {\n      if (thisCopy[i] !== targetCopy[i]) {\n        x = thisCopy[i];\n        y = targetCopy[i];\n        break;\n      }\n    }\n\n    if (x < y) return -1;\n    if (y < x) return 1;\n    return 0;\n  }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n  //\n  // Arguments:\n  // - buffer - a Buffer to search\n  // - val - a string, Buffer, or number\n  // - byteOffset - an index into `buffer`; will be clamped to an int32\n  // - encoding - an optional encoding, relevant is val is a string\n  // - dir - true for indexOf, false for lastIndexOf\n\n\n  function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n    // Empty buffer means no match\n    if (buffer.length === 0) return -1; // Normalize byteOffset\n\n    if (typeof byteOffset === 'string') {\n      encoding = byteOffset;\n      byteOffset = 0;\n    } else if (byteOffset > 0x7fffffff) {\n      byteOffset = 0x7fffffff;\n    } else if (byteOffset < -0x80000000) {\n      byteOffset = -0x80000000;\n    }\n\n    byteOffset = +byteOffset; // Coerce to Number.\n\n    if (isNaN(byteOffset)) {\n      // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n      byteOffset = dir ? 0 : buffer.length - 1;\n    } // Normalize byteOffset: negative offsets start from the end of the buffer\n\n\n    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n\n    if (byteOffset >= buffer.length) {\n      if (dir) return -1;else byteOffset = buffer.length - 1;\n    } else if (byteOffset < 0) {\n      if (dir) byteOffset = 0;else return -1;\n    } // Normalize val\n\n\n    if (typeof val === 'string') {\n      val = Buffer.from(val, encoding);\n    } // Finally, search either indexOf (if dir is true) or lastIndexOf\n\n\n    if (internalIsBuffer(val)) {\n      // Special case: looking for empty string/buffer always fails\n      if (val.length === 0) {\n        return -1;\n      }\n\n      return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n    } else if (typeof val === 'number') {\n      val = val & 0xFF; // Search for a byte value [0-255]\n\n      if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {\n        if (dir) {\n          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n        } else {\n          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n        }\n      }\n\n      return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n    }\n\n    throw new TypeError('val must be string, number or Buffer');\n  }\n\n  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n    var indexSize = 1;\n    var arrLength = arr.length;\n    var valLength = val.length;\n\n    if (encoding !== undefined) {\n      encoding = String(encoding).toLowerCase();\n\n      if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {\n        if (arr.length < 2 || val.length < 2) {\n          return -1;\n        }\n\n        indexSize = 2;\n        arrLength /= 2;\n        valLength /= 2;\n        byteOffset /= 2;\n      }\n    }\n\n    function read(buf, i) {\n      if (indexSize === 1) {\n        return buf[i];\n      } else {\n        return buf.readUInt16BE(i * indexSize);\n      }\n    }\n\n    var i;\n\n    if (dir) {\n      var foundIndex = -1;\n\n      for (i = byteOffset; i < arrLength; i++) {\n        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n          if (foundIndex === -1) foundIndex = i;\n          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n        } else {\n          if (foundIndex !== -1) i -= i - foundIndex;\n          foundIndex = -1;\n        }\n      }\n    } else {\n      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n\n      for (i = byteOffset; i >= 0; i--) {\n        var found = true;\n\n        for (var j = 0; j < valLength; j++) {\n          if (read(arr, i + j) !== read(val, j)) {\n            found = false;\n            break;\n          }\n        }\n\n        if (found) return i;\n      }\n    }\n\n    return -1;\n  }\n\n  Buffer.prototype.includes = function includes(val, byteOffset, encoding) {\n    return this.indexOf(val, byteOffset, encoding) !== -1;\n  };\n\n  Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n  };\n\n  Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n  };\n\n  function hexWrite(buf, string, offset, length) {\n    offset = Number(offset) || 0;\n    var remaining = buf.length - offset;\n\n    if (!length) {\n      length = remaining;\n    } else {\n      length = Number(length);\n\n      if (length > remaining) {\n        length = remaining;\n      }\n    } // must be an even number of digits\n\n\n    var strLen = string.length;\n    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');\n\n    if (length > strLen / 2) {\n      length = strLen / 2;\n    }\n\n    for (var i = 0; i < length; ++i) {\n      var parsed = parseInt(string.substr(i * 2, 2), 16);\n      if (isNaN(parsed)) return i;\n      buf[offset + i] = parsed;\n    }\n\n    return i;\n  }\n\n  function utf8Write(buf, string, offset, length) {\n    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n  }\n\n  function asciiWrite(buf, string, offset, length) {\n    return blitBuffer(asciiToBytes(string), buf, offset, length);\n  }\n\n  function latin1Write(buf, string, offset, length) {\n    return asciiWrite(buf, string, offset, length);\n  }\n\n  function base64Write(buf, string, offset, length) {\n    return blitBuffer(base64ToBytes(string), buf, offset, length);\n  }\n\n  function ucs2Write(buf, string, offset, length) {\n    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n  }\n\n  Buffer.prototype.write = function write(string, offset, length, encoding) {\n    // Buffer#write(string)\n    if (offset === undefined) {\n      encoding = 'utf8';\n      length = this.length;\n      offset = 0; // Buffer#write(string, encoding)\n    } else if (length === undefined && typeof offset === 'string') {\n      encoding = offset;\n      length = this.length;\n      offset = 0; // Buffer#write(string, offset[, length][, encoding])\n    } else if (isFinite(offset)) {\n      offset = offset | 0;\n\n      if (isFinite(length)) {\n        length = length | 0;\n        if (encoding === undefined) encoding = 'utf8';\n      } else {\n        encoding = length;\n        length = undefined;\n      } // legacy write(string, encoding, offset, length) - remove in v0.13\n\n    } else {\n      throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');\n    }\n\n    var remaining = this.length - offset;\n    if (length === undefined || length > remaining) length = remaining;\n\n    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n      throw new RangeError('Attempt to write outside buffer bounds');\n    }\n\n    if (!encoding) encoding = 'utf8';\n    var loweredCase = false;\n\n    for (;;) {\n      switch (encoding) {\n        case 'hex':\n          return hexWrite(this, string, offset, length);\n\n        case 'utf8':\n        case 'utf-8':\n          return utf8Write(this, string, offset, length);\n\n        case 'ascii':\n          return asciiWrite(this, string, offset, length);\n\n        case 'latin1':\n        case 'binary':\n          return latin1Write(this, string, offset, length);\n\n        case 'base64':\n          // Warning: maxLength not taken into account in base64Write\n          return base64Write(this, string, offset, length);\n\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n          return ucs2Write(this, string, offset, length);\n\n        default:\n          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n          encoding = ('' + encoding).toLowerCase();\n          loweredCase = true;\n      }\n    }\n  };\n\n  Buffer.prototype.toJSON = function toJSON() {\n    return {\n      type: 'Buffer',\n      data: Array.prototype.slice.call(this._arr || this, 0)\n    };\n  };\n\n  function base64Slice(buf, start, end) {\n    if (start === 0 && end === buf.length) {\n      return fromByteArray(buf);\n    } else {\n      return fromByteArray(buf.slice(start, end));\n    }\n  }\n\n  function utf8Slice(buf, start, end) {\n    end = Math.min(buf.length, end);\n    var res = [];\n    var i = start;\n\n    while (i < end) {\n      var firstByte = buf[i];\n      var codePoint = null;\n      var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n\n      if (i + bytesPerSequence <= end) {\n        var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n        switch (bytesPerSequence) {\n          case 1:\n            if (firstByte < 0x80) {\n              codePoint = firstByte;\n            }\n\n            break;\n\n          case 2:\n            secondByte = buf[i + 1];\n\n            if ((secondByte & 0xC0) === 0x80) {\n              tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n\n              if (tempCodePoint > 0x7F) {\n                codePoint = tempCodePoint;\n              }\n            }\n\n            break;\n\n          case 3:\n            secondByte = buf[i + 1];\n            thirdByte = buf[i + 2];\n\n            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n\n              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n                codePoint = tempCodePoint;\n              }\n            }\n\n            break;\n\n          case 4:\n            secondByte = buf[i + 1];\n            thirdByte = buf[i + 2];\n            fourthByte = buf[i + 3];\n\n            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n\n              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n                codePoint = tempCodePoint;\n              }\n            }\n\n        }\n      }\n\n      if (codePoint === null) {\n        // we did not generate a valid codePoint so insert a\n        // replacement char (U+FFFD) and advance only 1 byte\n        codePoint = 0xFFFD;\n        bytesPerSequence = 1;\n      } else if (codePoint > 0xFFFF) {\n        // encode to utf16 (surrogate pair dance)\n        codePoint -= 0x10000;\n        res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n        codePoint = 0xDC00 | codePoint & 0x3FF;\n      }\n\n      res.push(codePoint);\n      i += bytesPerSequence;\n    }\n\n    return decodeCodePointsArray(res);\n  } // Based on http://stackoverflow.com/a/22747272/680742, the browser with\n  // the lowest limit is Chrome, with 0x10000 args.\n  // We go 1 magnitude less, for safety\n\n\n  var MAX_ARGUMENTS_LENGTH = 0x1000;\n\n  function decodeCodePointsArray(codePoints) {\n    var len = codePoints.length;\n\n    if (len <= MAX_ARGUMENTS_LENGTH) {\n      return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\n    } // Decode in chunks to avoid \"call stack size exceeded\".\n\n\n    var res = '';\n    var i = 0;\n\n    while (i < len) {\n      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n    }\n\n    return res;\n  }\n\n  function asciiSlice(buf, start, end) {\n    var ret = '';\n    end = Math.min(buf.length, end);\n\n    for (var i = start; i < end; ++i) {\n      ret += String.fromCharCode(buf[i] & 0x7F);\n    }\n\n    return ret;\n  }\n\n  function latin1Slice(buf, start, end) {\n    var ret = '';\n    end = Math.min(buf.length, end);\n\n    for (var i = start; i < end; ++i) {\n      ret += String.fromCharCode(buf[i]);\n    }\n\n    return ret;\n  }\n\n  function hexSlice(buf, start, end) {\n    var len = buf.length;\n    if (!start || start < 0) start = 0;\n    if (!end || end < 0 || end > len) end = len;\n    var out = '';\n\n    for (var i = start; i < end; ++i) {\n      out += toHex(buf[i]);\n    }\n\n    return out;\n  }\n\n  function utf16leSlice(buf, start, end) {\n    var bytes = buf.slice(start, end);\n    var res = '';\n\n    for (var i = 0; i < bytes.length; i += 2) {\n      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n    }\n\n    return res;\n  }\n\n  Buffer.prototype.slice = function slice(start, end) {\n    var len = this.length;\n    start = ~~start;\n    end = end === undefined ? len : ~~end;\n\n    if (start < 0) {\n      start += len;\n      if (start < 0) start = 0;\n    } else if (start > len) {\n      start = len;\n    }\n\n    if (end < 0) {\n      end += len;\n      if (end < 0) end = 0;\n    } else if (end > len) {\n      end = len;\n    }\n\n    if (end < start) end = start;\n    var newBuf;\n\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      newBuf = this.subarray(start, end);\n      newBuf.__proto__ = Buffer.prototype;\n    } else {\n      var sliceLen = end - start;\n      newBuf = new Buffer(sliceLen, undefined);\n\n      for (var i = 0; i < sliceLen; ++i) {\n        newBuf[i] = this[i + start];\n      }\n    }\n\n    return newBuf;\n  };\n  /*\n   * Need to make sure that buffer isn't trying to write out of bounds.\n   */\n\n\n  function checkOffset(offset, ext, length) {\n    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');\n    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');\n  }\n\n  Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) checkOffset(offset, byteLength, this.length);\n    var val = this[offset];\n    var mul = 1;\n    var i = 0;\n\n    while (++i < byteLength && (mul *= 0x100)) {\n      val += this[offset + i] * mul;\n    }\n\n    return val;\n  };\n\n  Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n\n    if (!noAssert) {\n      checkOffset(offset, byteLength, this.length);\n    }\n\n    var val = this[offset + --byteLength];\n    var mul = 1;\n\n    while (byteLength > 0 && (mul *= 0x100)) {\n      val += this[offset + --byteLength] * mul;\n    }\n\n    return val;\n  };\n\n  Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 1, this.length);\n    return this[offset];\n  };\n\n  Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    return this[offset] | this[offset + 1] << 8;\n  };\n\n  Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    return this[offset] << 8 | this[offset + 1];\n  };\n\n  Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n  };\n\n  Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n  };\n\n  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) checkOffset(offset, byteLength, this.length);\n    var val = this[offset];\n    var mul = 1;\n    var i = 0;\n\n    while (++i < byteLength && (mul *= 0x100)) {\n      val += this[offset + i] * mul;\n    }\n\n    mul *= 0x80;\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n    return val;\n  };\n\n  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n    if (!noAssert) checkOffset(offset, byteLength, this.length);\n    var i = byteLength;\n    var mul = 1;\n    var val = this[offset + --i];\n\n    while (i > 0 && (mul *= 0x100)) {\n      val += this[offset + --i] * mul;\n    }\n\n    mul *= 0x80;\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n    return val;\n  };\n\n  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 1, this.length);\n    if (!(this[offset] & 0x80)) return this[offset];\n    return (0xff - this[offset] + 1) * -1;\n  };\n\n  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    var val = this[offset] | this[offset + 1] << 8;\n    return val & 0x8000 ? val | 0xFFFF0000 : val;\n  };\n\n  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 2, this.length);\n    var val = this[offset + 1] | this[offset] << 8;\n    return val & 0x8000 ? val | 0xFFFF0000 : val;\n  };\n\n  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n  };\n\n  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n  };\n\n  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return read(this, offset, true, 23, 4);\n  };\n\n  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 4, this.length);\n    return read(this, offset, false, 23, 4);\n  };\n\n  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 8, this.length);\n    return read(this, offset, true, 52, 8);\n  };\n\n  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n    if (!noAssert) checkOffset(offset, 8, this.length);\n    return read(this, offset, false, 52, 8);\n  };\n\n  function checkInt(buf, value, offset, ext, max, min) {\n    if (!internalIsBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n    if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n    if (offset + ext > buf.length) throw new RangeError('Index out of range');\n  }\n\n  Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n\n    if (!noAssert) {\n      var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n      checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n\n    var mul = 1;\n    var i = 0;\n    this[offset] = value & 0xFF;\n\n    while (++i < byteLength && (mul *= 0x100)) {\n      this[offset + i] = value / mul & 0xFF;\n    }\n\n    return offset + byteLength;\n  };\n\n  Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    byteLength = byteLength | 0;\n\n    if (!noAssert) {\n      var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n      checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n\n    var i = byteLength - 1;\n    var mul = 1;\n    this[offset + i] = value & 0xFF;\n\n    while (--i >= 0 && (mul *= 0x100)) {\n      this[offset + i] = value / mul & 0xFF;\n    }\n\n    return offset + byteLength;\n  };\n\n  Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n    this[offset] = value & 0xff;\n    return offset + 1;\n  };\n\n  function objectWriteUInt16(buf, value, offset, littleEndian) {\n    if (value < 0) value = 0xffff + value + 1;\n\n    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n      buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;\n    }\n  }\n\n  Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      this[offset] = value & 0xff;\n      this[offset + 1] = value >>> 8;\n    } else {\n      objectWriteUInt16(this, value, offset, true);\n    }\n\n    return offset + 2;\n  };\n\n  Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      this[offset] = value >>> 8;\n      this[offset + 1] = value & 0xff;\n    } else {\n      objectWriteUInt16(this, value, offset, false);\n    }\n\n    return offset + 2;\n  };\n\n  function objectWriteUInt32(buf, value, offset, littleEndian) {\n    if (value < 0) value = 0xffffffff + value + 1;\n\n    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n      buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;\n    }\n  }\n\n  Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      this[offset + 3] = value >>> 24;\n      this[offset + 2] = value >>> 16;\n      this[offset + 1] = value >>> 8;\n      this[offset] = value & 0xff;\n    } else {\n      objectWriteUInt32(this, value, offset, true);\n    }\n\n    return offset + 4;\n  };\n\n  Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      this[offset] = value >>> 24;\n      this[offset + 1] = value >>> 16;\n      this[offset + 2] = value >>> 8;\n      this[offset + 3] = value & 0xff;\n    } else {\n      objectWriteUInt32(this, value, offset, false);\n    }\n\n    return offset + 4;\n  };\n\n  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n\n    if (!noAssert) {\n      var limit = Math.pow(2, 8 * byteLength - 1);\n      checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n\n    var i = 0;\n    var mul = 1;\n    var sub = 0;\n    this[offset] = value & 0xFF;\n\n    while (++i < byteLength && (mul *= 0x100)) {\n      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n        sub = 1;\n      }\n\n      this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n    }\n\n    return offset + byteLength;\n  };\n\n  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset | 0;\n\n    if (!noAssert) {\n      var limit = Math.pow(2, 8 * byteLength - 1);\n      checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n\n    var i = byteLength - 1;\n    var mul = 1;\n    var sub = 0;\n    this[offset + i] = value & 0xFF;\n\n    while (--i >= 0 && (mul *= 0x100)) {\n      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n        sub = 1;\n      }\n\n      this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n    }\n\n    return offset + byteLength;\n  };\n\n  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n    if (value < 0) value = 0xff + value + 1;\n    this[offset] = value & 0xff;\n    return offset + 1;\n  };\n\n  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      this[offset] = value & 0xff;\n      this[offset + 1] = value >>> 8;\n    } else {\n      objectWriteUInt16(this, value, offset, true);\n    }\n\n    return offset + 2;\n  };\n\n  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      this[offset] = value >>> 8;\n      this[offset + 1] = value & 0xff;\n    } else {\n      objectWriteUInt16(this, value, offset, false);\n    }\n\n    return offset + 2;\n  };\n\n  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      this[offset] = value & 0xff;\n      this[offset + 1] = value >>> 8;\n      this[offset + 2] = value >>> 16;\n      this[offset + 3] = value >>> 24;\n    } else {\n      objectWriteUInt32(this, value, offset, true);\n    }\n\n    return offset + 4;\n  };\n\n  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset | 0;\n    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n    if (value < 0) value = 0xffffffff + value + 1;\n\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      this[offset] = value >>> 24;\n      this[offset + 1] = value >>> 16;\n      this[offset + 2] = value >>> 8;\n      this[offset + 3] = value & 0xff;\n    } else {\n      objectWriteUInt32(this, value, offset, false);\n    }\n\n    return offset + 4;\n  };\n\n  function checkIEEE754(buf, value, offset, ext, max, min) {\n    if (offset + ext > buf.length) throw new RangeError('Index out of range');\n    if (offset < 0) throw new RangeError('Index out of range');\n  }\n\n  function writeFloat(buf, value, offset, littleEndian, noAssert) {\n    if (!noAssert) {\n      checkIEEE754(buf, value, offset, 4);\n    }\n\n    write(buf, value, offset, littleEndian, 23, 4);\n    return offset + 4;\n  }\n\n  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, true, noAssert);\n  };\n\n  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n    return writeFloat(this, value, offset, false, noAssert);\n  };\n\n  function writeDouble(buf, value, offset, littleEndian, noAssert) {\n    if (!noAssert) {\n      checkIEEE754(buf, value, offset, 8);\n    }\n\n    write(buf, value, offset, littleEndian, 52, 8);\n    return offset + 8;\n  }\n\n  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n    return writeDouble(this, value, offset, true, noAssert);\n  };\n\n  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n    return writeDouble(this, value, offset, false, noAssert);\n  }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\n\n  Buffer.prototype.copy = function copy(target, targetStart, start, end) {\n    if (!start) start = 0;\n    if (!end && end !== 0) end = this.length;\n    if (targetStart >= target.length) targetStart = target.length;\n    if (!targetStart) targetStart = 0;\n    if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done\n\n    if (end === start) return 0;\n    if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions\n\n    if (targetStart < 0) {\n      throw new RangeError('targetStart out of bounds');\n    }\n\n    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');\n    if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?\n\n    if (end > this.length) end = this.length;\n\n    if (target.length - targetStart < end - start) {\n      end = target.length - targetStart + start;\n    }\n\n    var len = end - start;\n    var i;\n\n    if (this === target && start < targetStart && targetStart < end) {\n      // descending copy from end\n      for (i = len - 1; i >= 0; --i) {\n        target[i + targetStart] = this[i + start];\n      }\n    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n      // ascending copy from start\n      for (i = 0; i < len; ++i) {\n        target[i + targetStart] = this[i + start];\n      }\n    } else {\n      Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);\n    }\n\n    return len;\n  }; // Usage:\n  //    buffer.fill(number[, offset[, end]])\n  //    buffer.fill(buffer[, offset[, end]])\n  //    buffer.fill(string[, offset[, end]][, encoding])\n\n\n  Buffer.prototype.fill = function fill(val, start, end, encoding) {\n    // Handle string cases:\n    if (typeof val === 'string') {\n      if (typeof start === 'string') {\n        encoding = start;\n        start = 0;\n        end = this.length;\n      } else if (typeof end === 'string') {\n        encoding = end;\n        end = this.length;\n      }\n\n      if (val.length === 1) {\n        var code = val.charCodeAt(0);\n\n        if (code < 256) {\n          val = code;\n        }\n      }\n\n      if (encoding !== undefined && typeof encoding !== 'string') {\n        throw new TypeError('encoding must be a string');\n      }\n\n      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n        throw new TypeError('Unknown encoding: ' + encoding);\n      }\n    } else if (typeof val === 'number') {\n      val = val & 255;\n    } // Invalid ranges are not set to a default, so can range check early.\n\n\n    if (start < 0 || this.length < start || this.length < end) {\n      throw new RangeError('Out of range index');\n    }\n\n    if (end <= start) {\n      return this;\n    }\n\n    start = start >>> 0;\n    end = end === undefined ? this.length : end >>> 0;\n    if (!val) val = 0;\n    var i;\n\n    if (typeof val === 'number') {\n      for (i = start; i < end; ++i) {\n        this[i] = val;\n      }\n    } else {\n      var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());\n      var len = bytes.length;\n\n      for (i = 0; i < end - start; ++i) {\n        this[i + start] = bytes[i % len];\n      }\n    }\n\n    return this;\n  }; // HELPER FUNCTIONS\n  // ================\n\n\n  var INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\n\n  function base64clean(str) {\n    // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n    str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''\n\n    if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\n    while (str.length % 4 !== 0) {\n      str = str + '=';\n    }\n\n    return str;\n  }\n\n  function stringtrim(str) {\n    if (str.trim) return str.trim();\n    return str.replace(/^\\s+|\\s+$/g, '');\n  }\n\n  function toHex(n) {\n    if (n < 16) return '0' + n.toString(16);\n    return n.toString(16);\n  }\n\n  function utf8ToBytes(string, units) {\n    units = units || Infinity;\n    var codePoint;\n    var length = string.length;\n    var leadSurrogate = null;\n    var bytes = [];\n\n    for (var i = 0; i < length; ++i) {\n      codePoint = string.charCodeAt(i); // is surrogate component\n\n      if (codePoint > 0xD7FF && codePoint < 0xE000) {\n        // last char was a lead\n        if (!leadSurrogate) {\n          // no lead yet\n          if (codePoint > 0xDBFF) {\n            // unexpected trail\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n            continue;\n          } else if (i + 1 === length) {\n            // unpaired lead\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n            continue;\n          } // valid lead\n\n\n          leadSurrogate = codePoint;\n          continue;\n        } // 2 leads in a row\n\n\n        if (codePoint < 0xDC00) {\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          leadSurrogate = codePoint;\n          continue;\n        } // valid surrogate pair\n\n\n        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n      } else if (leadSurrogate) {\n        // valid bmp char, but last char was a lead\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n      }\n\n      leadSurrogate = null; // encode utf8\n\n      if (codePoint < 0x80) {\n        if ((units -= 1) < 0) break;\n        bytes.push(codePoint);\n      } else if (codePoint < 0x800) {\n        if ((units -= 2) < 0) break;\n        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n      } else if (codePoint < 0x10000) {\n        if ((units -= 3) < 0) break;\n        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n      } else if (codePoint < 0x110000) {\n        if ((units -= 4) < 0) break;\n        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n      } else {\n        throw new Error('Invalid code point');\n      }\n    }\n\n    return bytes;\n  }\n\n  function asciiToBytes(str) {\n    var byteArray = [];\n\n    for (var i = 0; i < str.length; ++i) {\n      // Node's code seems to be doing this and not & 0x7F..\n      byteArray.push(str.charCodeAt(i) & 0xFF);\n    }\n\n    return byteArray;\n  }\n\n  function utf16leToBytes(str, units) {\n    var c, hi, lo;\n    var byteArray = [];\n\n    for (var i = 0; i < str.length; ++i) {\n      if ((units -= 2) < 0) break;\n      c = str.charCodeAt(i);\n      hi = c >> 8;\n      lo = c % 256;\n      byteArray.push(lo);\n      byteArray.push(hi);\n    }\n\n    return byteArray;\n  }\n\n  function base64ToBytes(str) {\n    return toByteArray(base64clean(str));\n  }\n\n  function blitBuffer(src, dst, offset, length) {\n    for (var i = 0; i < length; ++i) {\n      if (i + offset >= dst.length || i >= src.length) break;\n      dst[i + offset] = src[i];\n    }\n\n    return i;\n  }\n\n  function isnan(val) {\n    return val !== val; // eslint-disable-line no-self-compare\n  } // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence\n  // The _isBuffer check is for Safari 5-7 support, because it's missing\n  // Object.prototype.constructor. Remove this eventually\n\n\n  function isBuffer(obj) {\n    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));\n  }\n\n  function isFastBuffer(obj) {\n    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);\n  } // For Node v0.10 support. Remove this eventually.\n\n\n  function isSlowBuffer(obj) {\n    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0));\n  }\n\n  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};\n\n  function unwrapExports (x) {\n  \treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n  }\n\n  function createCommonjsModule(fn, module) {\n  \treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n  }\n\n  function getCjsExportFromNamespace (n) {\n  \treturn n && n['default'] || n;\n  }\n\n  var fs = getCjsExportFromNamespace(_shim_fs$1);\n\n  /**\n   * @class\n   */\n\n\n  var LineByLine =\n  /*#__PURE__*/\n  function () {\n    function LineByLine(file, options) {\n      _classCallCheck(this, LineByLine);\n\n      options = options || {};\n      if (!options.readChunk) options.readChunk = 1024;\n\n      if (!options.newLineCharacter) {\n        options.newLineCharacter = 0x0a; //linux line ending\n      } else {\n        options.newLineCharacter = options.newLineCharacter.charCodeAt(0);\n      }\n\n      if (typeof file === 'number') {\n        this.fd = file;\n      } else {\n        this.fd = fs.openSync(file, 'r');\n      }\n\n      this.options = options;\n      this.newLineCharacter = options.newLineCharacter;\n      this.reset();\n    }\n\n    _createClass(LineByLine, [{\n      key: \"_searchInBuffer\",\n      value: function _searchInBuffer(buffer, hexNeedle) {\n        var found = -1;\n\n        for (var i = 0; i <= buffer.length; i++) {\n          var b_byte = buffer[i];\n\n          if (b_byte === hexNeedle) {\n            found = i;\n            break;\n          }\n        }\n\n        return found;\n      }\n    }, {\n      key: \"reset\",\n      value: function reset() {\n        this.eofReached = false;\n        this.linesCache = [];\n        this.fdPosition = 0;\n      }\n    }, {\n      key: \"close\",\n      value: function close() {\n        fs.closeSync(this.fd);\n        this.fd = null;\n      }\n    }, {\n      key: \"_extractLines\",\n      value: function _extractLines(buffer) {\n        var line;\n        var lines = [];\n        var bufferPosition = 0;\n        var lastNewLineBufferPosition = 0;\n\n        while (true) {\n          var bufferPositionValue = buffer[bufferPosition++];\n\n          if (bufferPositionValue === this.newLineCharacter) {\n            line = buffer.slice(lastNewLineBufferPosition, bufferPosition);\n            lines.push(line);\n            lastNewLineBufferPosition = bufferPosition;\n          } else if (!bufferPositionValue) {\n            break;\n          }\n        }\n\n        var leftovers = buffer.slice(lastNewLineBufferPosition, bufferPosition);\n\n        if (leftovers.length) {\n          lines.push(leftovers);\n        }\n\n        return lines;\n      }\n    }, {\n      key: \"_readChunk\",\n      value: function _readChunk(lineLeftovers) {\n        var totalBytesRead = 0;\n        var bytesRead;\n        var buffers = [];\n\n        do {\n          var readBuffer = new Buffer(this.options.readChunk);\n          bytesRead = fs.readSync(this.fd, readBuffer, 0, this.options.readChunk, this.fdPosition);\n          totalBytesRead = totalBytesRead + bytesRead;\n          this.fdPosition = this.fdPosition + bytesRead;\n          buffers.push(readBuffer);\n        } while (bytesRead && this._searchInBuffer(buffers[buffers.length - 1], this.options.newLineCharacter) === -1);\n\n        var bufferData = Buffer.concat(buffers);\n\n        if (bytesRead < this.options.readChunk) {\n          this.eofReached = true;\n          bufferData = bufferData.slice(0, totalBytesRead);\n        }\n\n        if (totalBytesRead) {\n          this.linesCache = this._extractLines(bufferData);\n\n          if (lineLeftovers) {\n            this.linesCache[0] = Buffer.concat([lineLeftovers, this.linesCache[0]]);\n          }\n        }\n\n        return totalBytesRead;\n      }\n    }, {\n      key: \"next\",\n      value: function next() {\n        if (!this.fd) return false;\n        var line = false;\n\n        if (this.eofReached && this.linesCache.length === 0) {\n          return line;\n        }\n\n        var bytesRead;\n\n        if (!this.linesCache.length) {\n          bytesRead = this._readChunk();\n        }\n\n        if (this.linesCache.length) {\n          line = this.linesCache.shift();\n          var lastLineCharacter = line[line.length - 1];\n\n          if (lastLineCharacter !== 0x0a) {\n            bytesRead = this._readChunk(line);\n\n            if (bytesRead) {\n              line = this.linesCache.shift();\n            }\n          }\n        }\n\n        if (this.eofReached && this.linesCache.length === 0) {\n          this.close();\n        }\n\n        if (line && line[line.length - 1] === this.newLineCharacter) {\n          line = line.slice(0, line.length - 1);\n        }\n\n        return line;\n      }\n    }]);\n\n    return LineByLine;\n  }();\n\n  var readlines = LineByLine;\n\n  var ConfigError =\n  /*#__PURE__*/\n  function (_Error) {\n    _inherits(ConfigError, _Error);\n\n    function ConfigError() {\n      _classCallCheck(this, ConfigError);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(ConfigError).apply(this, arguments));\n    }\n\n    return ConfigError;\n  }(_wrapNativeSuper(Error));\n\n  var DebugError =\n  /*#__PURE__*/\n  function (_Error2) {\n    _inherits(DebugError, _Error2);\n\n    function DebugError() {\n      _classCallCheck(this, DebugError);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(DebugError).apply(this, arguments));\n    }\n\n    return DebugError;\n  }(_wrapNativeSuper(Error));\n\n  var UndefinedParserError =\n  /*#__PURE__*/\n  function (_Error3) {\n    _inherits(UndefinedParserError, _Error3);\n\n    function UndefinedParserError() {\n      _classCallCheck(this, UndefinedParserError);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(UndefinedParserError).apply(this, arguments));\n    }\n\n    return UndefinedParserError;\n  }(_wrapNativeSuper(Error));\n\n  var errors = {\n    ConfigError: ConfigError,\n    DebugError: DebugError,\n    UndefinedParserError: UndefinedParserError\n  };\n\n  // based off https://github.com/defunctzombie/node-process/blob/master/browser.js\n\n  function defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n  }\n\n  function defaultClearTimeout() {\n    throw new Error('clearTimeout has not been defined');\n  }\n\n  var cachedSetTimeout = defaultSetTimout;\n  var cachedClearTimeout = defaultClearTimeout;\n\n  if (typeof global$1.setTimeout === 'function') {\n    cachedSetTimeout = setTimeout;\n  }\n\n  if (typeof global$1.clearTimeout === 'function') {\n    cachedClearTimeout = clearTimeout;\n  }\n\n  function runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n      //normal enviroments in sane situations\n      return setTimeout(fun, 0);\n    } // if setTimeout wasn't available but was latter defined\n\n\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n      cachedSetTimeout = setTimeout;\n      return setTimeout(fun, 0);\n    }\n\n    try {\n      // when when somebody has screwed with setTimeout but no I.E. maddness\n      return cachedSetTimeout(fun, 0);\n    } catch (e) {\n      try {\n        // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n        return cachedSetTimeout.call(null, fun, 0);\n      } catch (e) {\n        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n        return cachedSetTimeout.call(this, fun, 0);\n      }\n    }\n  }\n\n  function runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n      //normal enviroments in sane situations\n      return clearTimeout(marker);\n    } // if clearTimeout wasn't available but was latter defined\n\n\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n      cachedClearTimeout = clearTimeout;\n      return clearTimeout(marker);\n    }\n\n    try {\n      // when when somebody has screwed with setTimeout but no I.E. maddness\n      return cachedClearTimeout(marker);\n    } catch (e) {\n      try {\n        // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n        return cachedClearTimeout.call(null, marker);\n      } catch (e) {\n        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n        // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n        return cachedClearTimeout.call(this, marker);\n      }\n    }\n  }\n\n  var queue = [];\n  var draining = false;\n  var currentQueue;\n  var queueIndex = -1;\n\n  function cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n      return;\n    }\n\n    draining = false;\n\n    if (currentQueue.length) {\n      queue = currentQueue.concat(queue);\n    } else {\n      queueIndex = -1;\n    }\n\n    if (queue.length) {\n      drainQueue();\n    }\n  }\n\n  function drainQueue() {\n    if (draining) {\n      return;\n    }\n\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n    var len = queue.length;\n\n    while (len) {\n      currentQueue = queue;\n      queue = [];\n\n      while (++queueIndex < len) {\n        if (currentQueue) {\n          currentQueue[queueIndex].run();\n        }\n      }\n\n      queueIndex = -1;\n      len = queue.length;\n    }\n\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n  }\n\n  function nextTick(fun) {\n    var args = new Array(arguments.length - 1);\n\n    if (arguments.length > 1) {\n      for (var i = 1; i < arguments.length; i++) {\n        args[i - 1] = arguments[i];\n      }\n    }\n\n    queue.push(new Item(fun, args));\n\n    if (queue.length === 1 && !draining) {\n      runTimeout(drainQueue);\n    }\n  } // v8 likes predictible objects\n\n  function Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n  }\n\n  Item.prototype.run = function () {\n    this.fun.apply(null, this.array);\n  };\n\n  var title = 'browser';\n  var platform = 'browser';\n  var browser = true;\n  var env = {};\n  var argv = [];\n  var version$1 = ''; // empty string to avoid regexp issues\n\n  var versions = {};\n  var release = {};\n  var config = {};\n\n  function noop() {}\n\n  var on = noop;\n  var addListener = noop;\n  var once = noop;\n  var off = noop;\n  var removeListener = noop;\n  var removeAllListeners = noop;\n  var emit = noop;\n  function binding(name) {\n    throw new Error('process.binding is not supported');\n  }\n  function cwd() {\n    return '/';\n  }\n  function chdir(dir) {\n    throw new Error('process.chdir is not supported');\n  }\n  function umask() {\n    return 0;\n  } // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js\n\n  var performance = global$1.performance || {};\n\n  var performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function () {\n    return new Date().getTime();\n  }; // generate timestamp or delta\n  // see http://nodejs.org/api/process.html#process_process_hrtime\n\n\n  function hrtime(previousTimestamp) {\n    var clocktime = performanceNow.call(performance) * 1e-3;\n    var seconds = Math.floor(clocktime);\n    var nanoseconds = Math.floor(clocktime % 1 * 1e9);\n\n    if (previousTimestamp) {\n      seconds = seconds - previousTimestamp[0];\n      nanoseconds = nanoseconds - previousTimestamp[1];\n\n      if (nanoseconds < 0) {\n        seconds--;\n        nanoseconds += 1e9;\n      }\n    }\n\n    return [seconds, nanoseconds];\n  }\n  var startTime = new Date();\n  function uptime() {\n    var currentTime = new Date();\n    var dif = currentTime - startTime;\n    return dif / 1000;\n  }\n  var process = {\n    nextTick: nextTick,\n    title: title,\n    browser: browser,\n    env: env,\n    argv: argv,\n    version: version$1,\n    versions: versions,\n    on: on,\n    addListener: addListener,\n    once: once,\n    off: off,\n    removeListener: removeListener,\n    removeAllListeners: removeAllListeners,\n    emit: emit,\n    binding: binding,\n    cwd: cwd,\n    chdir: chdir,\n    umask: umask,\n    hrtime: hrtime,\n    platform: platform,\n    release: release,\n    config: config,\n    uptime: uptime\n  };\n\n  var semver = createCommonjsModule(function (module, exports) {\n    exports = module.exports = SemVer;\n    var debug;\n    /* istanbul ignore next */\n\n    if (_typeof(process) === 'object' && process.env && process.env.NODE_DEBUG && /\\bsemver\\b/i.test(process.env.NODE_DEBUG)) {\n      debug = function debug() {\n        var args = Array.prototype.slice.call(arguments, 0);\n        args.unshift('SEMVER');\n        console.log.apply(console, args);\n      };\n    } else {\n      debug = function debug() {};\n    } // Note: this is the semver.org version of the spec that it implements\n    // Not necessarily the package version of this code.\n\n\n    exports.SEMVER_SPEC_VERSION = '2.0.0';\n    var MAX_LENGTH = 256;\n    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n    /* istanbul ignore next */\n    9007199254740991; // Max safe segment length for coercion.\n\n    var MAX_SAFE_COMPONENT_LENGTH = 16; // The actual regexps go on exports.re\n\n    var re = exports.re = [];\n    var src = exports.src = [];\n    var t = exports.tokens = {};\n    var R = 0;\n\n    function tok(n) {\n      t[n] = R++;\n    } // The following Regular Expressions can be used for tokenizing,\n    // validating, and parsing SemVer version strings.\n    // ## Numeric Identifier\n    // A single `0`, or a non-zero digit followed by zero or more digits.\n\n\n    tok('NUMERICIDENTIFIER');\n    src[t.NUMERICIDENTIFIER] = '0|[1-9]\\\\d*';\n    tok('NUMERICIDENTIFIERLOOSE');\n    src[t.NUMERICIDENTIFIERLOOSE] = '[0-9]+'; // ## Non-numeric Identifier\n    // Zero or more digits, followed by a letter or hyphen, and then zero or\n    // more letters, digits, or hyphens.\n\n    tok('NONNUMERICIDENTIFIER');\n    src[t.NONNUMERICIDENTIFIER] = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*'; // ## Main Version\n    // Three dot-separated numeric identifiers.\n\n    tok('MAINVERSION');\n    src[t.MAINVERSION] = '(' + src[t.NUMERICIDENTIFIER] + ')\\\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')\\\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')';\n    tok('MAINVERSIONLOOSE');\n    src[t.MAINVERSIONLOOSE] = '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')'; // ## Pre-release Version Identifier\n    // A numeric identifier, or a non-numeric identifier.\n\n    tok('PRERELEASEIDENTIFIER');\n    src[t.PRERELEASEIDENTIFIER] = '(?:' + src[t.NUMERICIDENTIFIER] + '|' + src[t.NONNUMERICIDENTIFIER] + ')';\n    tok('PRERELEASEIDENTIFIERLOOSE');\n    src[t.PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[t.NUMERICIDENTIFIERLOOSE] + '|' + src[t.NONNUMERICIDENTIFIER] + ')'; // ## Pre-release Version\n    // Hyphen, followed by one or more dot-separated pre-release version\n    // identifiers.\n\n    tok('PRERELEASE');\n    src[t.PRERELEASE] = '(?:-(' + src[t.PRERELEASEIDENTIFIER] + '(?:\\\\.' + src[t.PRERELEASEIDENTIFIER] + ')*))';\n    tok('PRERELEASELOOSE');\n    src[t.PRERELEASELOOSE] = '(?:-?(' + src[t.PRERELEASEIDENTIFIERLOOSE] + '(?:\\\\.' + src[t.PRERELEASEIDENTIFIERLOOSE] + ')*))'; // ## Build Metadata Identifier\n    // Any combination of digits, letters, or hyphens.\n\n    tok('BUILDIDENTIFIER');\n    src[t.BUILDIDENTIFIER] = '[0-9A-Za-z-]+'; // ## Build Metadata\n    // Plus sign, followed by one or more period-separated build metadata\n    // identifiers.\n\n    tok('BUILD');\n    src[t.BUILD] = '(?:\\\\+(' + src[t.BUILDIDENTIFIER] + '(?:\\\\.' + src[t.BUILDIDENTIFIER] + ')*))'; // ## Full Version String\n    // A main version, followed optionally by a pre-release version and\n    // build metadata.\n    // Note that the only major, minor, patch, and pre-release sections of\n    // the version string are capturing groups.  The build metadata is not a\n    // capturing group, because it should not ever be used in version\n    // comparison.\n\n    tok('FULL');\n    tok('FULLPLAIN');\n    src[t.FULLPLAIN] = 'v?' + src[t.MAINVERSION] + src[t.PRERELEASE] + '?' + src[t.BUILD] + '?';\n    src[t.FULL] = '^' + src[t.FULLPLAIN] + '$'; // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n    // also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n    // common in the npm registry.\n\n    tok('LOOSEPLAIN');\n    src[t.LOOSEPLAIN] = '[v=\\\\s]*' + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + '?' + src[t.BUILD] + '?';\n    tok('LOOSE');\n    src[t.LOOSE] = '^' + src[t.LOOSEPLAIN] + '$';\n    tok('GTLT');\n    src[t.GTLT] = '((?:<|>)?=?)'; // Something like \"2.*\" or \"1.2.x\".\n    // Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n    // Only the first item is strictly required.\n\n    tok('XRANGEIDENTIFIERLOOSE');\n    src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + '|x|X|\\\\*';\n    tok('XRANGEIDENTIFIER');\n    src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + '|x|X|\\\\*';\n    tok('XRANGEPLAIN');\n    src[t.XRANGEPLAIN] = '[v=\\\\s]*(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:' + src[t.PRERELEASE] + ')?' + src[t.BUILD] + '?' + ')?)?';\n    tok('XRANGEPLAINLOOSE');\n    src[t.XRANGEPLAINLOOSE] = '[v=\\\\s]*(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[t.PRERELEASELOOSE] + ')?' + src[t.BUILD] + '?' + ')?)?';\n    tok('XRANGE');\n    src[t.XRANGE] = '^' + src[t.GTLT] + '\\\\s*' + src[t.XRANGEPLAIN] + '$';\n    tok('XRANGELOOSE');\n    src[t.XRANGELOOSE] = '^' + src[t.GTLT] + '\\\\s*' + src[t.XRANGEPLAINLOOSE] + '$'; // Coercion.\n    // Extract anything that could conceivably be a part of a valid semver\n\n    tok('COERCE');\n    src[t.COERCE] = '(^|[^\\\\d])' + '(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' + '(?:\\\\.(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:\\\\.(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:$|[^\\\\d])';\n    tok('COERCERTL');\n    re[t.COERCERTL] = new RegExp(src[t.COERCE], 'g'); // Tilde ranges.\n    // Meaning is \"reasonably at or greater than\"\n\n    tok('LONETILDE');\n    src[t.LONETILDE] = '(?:~>?)';\n    tok('TILDETRIM');\n    src[t.TILDETRIM] = '(\\\\s*)' + src[t.LONETILDE] + '\\\\s+';\n    re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], 'g');\n    var tildeTrimReplace = '$1~';\n    tok('TILDE');\n    src[t.TILDE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAIN] + '$';\n    tok('TILDELOOSE');\n    src[t.TILDELOOSE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + '$'; // Caret ranges.\n    // Meaning is \"at least and backwards compatible with\"\n\n    tok('LONECARET');\n    src[t.LONECARET] = '(?:\\\\^)';\n    tok('CARETTRIM');\n    src[t.CARETTRIM] = '(\\\\s*)' + src[t.LONECARET] + '\\\\s+';\n    re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], 'g');\n    var caretTrimReplace = '$1^';\n    tok('CARET');\n    src[t.CARET] = '^' + src[t.LONECARET] + src[t.XRANGEPLAIN] + '$';\n    tok('CARETLOOSE');\n    src[t.CARETLOOSE] = '^' + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + '$'; // A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\n\n    tok('COMPARATORLOOSE');\n    src[t.COMPARATORLOOSE] = '^' + src[t.GTLT] + '\\\\s*(' + src[t.LOOSEPLAIN] + ')$|^$';\n    tok('COMPARATOR');\n    src[t.COMPARATOR] = '^' + src[t.GTLT] + '\\\\s*(' + src[t.FULLPLAIN] + ')$|^$'; // An expression to strip any whitespace between the gtlt and the thing\n    // it modifies, so that `> 1.2.3` ==> `>1.2.3`\n\n    tok('COMPARATORTRIM');\n    src[t.COMPARATORTRIM] = '(\\\\s*)' + src[t.GTLT] + '\\\\s*(' + src[t.LOOSEPLAIN] + '|' + src[t.XRANGEPLAIN] + ')'; // this one has to use the /g flag\n\n    re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], 'g');\n    var comparatorTrimReplace = '$1$2$3'; // Something like `1.2.3 - 1.2.4`\n    // Note that these all use the loose form, because they'll be\n    // checked against either the strict or loose comparator form\n    // later.\n\n    tok('HYPHENRANGE');\n    src[t.HYPHENRANGE] = '^\\\\s*(' + src[t.XRANGEPLAIN] + ')' + '\\\\s+-\\\\s+' + '(' + src[t.XRANGEPLAIN] + ')' + '\\\\s*$';\n    tok('HYPHENRANGELOOSE');\n    src[t.HYPHENRANGELOOSE] = '^\\\\s*(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\\\s+-\\\\s+' + '(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\\\s*$'; // Star ranges basically just allow anything at all.\n\n    tok('STAR');\n    src[t.STAR] = '(<|>)?=?\\\\s*\\\\*'; // Compile to actual regexp objects.\n    // All are flag-free, unless they were created above with a flag.\n\n    for (var i = 0; i < R; i++) {\n      debug(i, src[i]);\n\n      if (!re[i]) {\n        re[i] = new RegExp(src[i]);\n      }\n    }\n\n    exports.parse = parse;\n\n    function parse(version, options) {\n      if (!options || _typeof(options) !== 'object') {\n        options = {\n          loose: !!options,\n          includePrerelease: false\n        };\n      }\n\n      if (version instanceof SemVer) {\n        return version;\n      }\n\n      if (typeof version !== 'string') {\n        return null;\n      }\n\n      if (version.length > MAX_LENGTH) {\n        return null;\n      }\n\n      var r = options.loose ? re[t.LOOSE] : re[t.FULL];\n\n      if (!r.test(version)) {\n        return null;\n      }\n\n      try {\n        return new SemVer(version, options);\n      } catch (er) {\n        return null;\n      }\n    }\n\n    exports.valid = valid;\n\n    function valid(version, options) {\n      var v = parse(version, options);\n      return v ? v.version : null;\n    }\n\n    exports.clean = clean;\n\n    function clean(version, options) {\n      var s = parse(version.trim().replace(/^[=v]+/, ''), options);\n      return s ? s.version : null;\n    }\n\n    exports.SemVer = SemVer;\n\n    function SemVer(version, options) {\n      if (!options || _typeof(options) !== 'object') {\n        options = {\n          loose: !!options,\n          includePrerelease: false\n        };\n      }\n\n      if (version instanceof SemVer) {\n        if (version.loose === options.loose) {\n          return version;\n        } else {\n          version = version.version;\n        }\n      } else if (typeof version !== 'string') {\n        throw new TypeError('Invalid Version: ' + version);\n      }\n\n      if (version.length > MAX_LENGTH) {\n        throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');\n      }\n\n      if (!(this instanceof SemVer)) {\n        return new SemVer(version, options);\n      }\n\n      debug('SemVer', version, options);\n      this.options = options;\n      this.loose = !!options.loose;\n      var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);\n\n      if (!m) {\n        throw new TypeError('Invalid Version: ' + version);\n      }\n\n      this.raw = version; // these are actually numbers\n\n      this.major = +m[1];\n      this.minor = +m[2];\n      this.patch = +m[3];\n\n      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n        throw new TypeError('Invalid major version');\n      }\n\n      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n        throw new TypeError('Invalid minor version');\n      }\n\n      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n        throw new TypeError('Invalid patch version');\n      } // numberify any prerelease numeric ids\n\n\n      if (!m[4]) {\n        this.prerelease = [];\n      } else {\n        this.prerelease = m[4].split('.').map(function (id) {\n          if (/^[0-9]+$/.test(id)) {\n            var num = +id;\n\n            if (num >= 0 && num < MAX_SAFE_INTEGER) {\n              return num;\n            }\n          }\n\n          return id;\n        });\n      }\n\n      this.build = m[5] ? m[5].split('.') : [];\n      this.format();\n    }\n\n    SemVer.prototype.format = function () {\n      this.version = this.major + '.' + this.minor + '.' + this.patch;\n\n      if (this.prerelease.length) {\n        this.version += '-' + this.prerelease.join('.');\n      }\n\n      return this.version;\n    };\n\n    SemVer.prototype.toString = function () {\n      return this.version;\n    };\n\n    SemVer.prototype.compare = function (other) {\n      debug('SemVer.compare', this.version, this.options, other);\n\n      if (!(other instanceof SemVer)) {\n        other = new SemVer(other, this.options);\n      }\n\n      return this.compareMain(other) || this.comparePre(other);\n    };\n\n    SemVer.prototype.compareMain = function (other) {\n      if (!(other instanceof SemVer)) {\n        other = new SemVer(other, this.options);\n      }\n\n      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);\n    };\n\n    SemVer.prototype.comparePre = function (other) {\n      if (!(other instanceof SemVer)) {\n        other = new SemVer(other, this.options);\n      } // NOT having a prerelease is > having one\n\n\n      if (this.prerelease.length && !other.prerelease.length) {\n        return -1;\n      } else if (!this.prerelease.length && other.prerelease.length) {\n        return 1;\n      } else if (!this.prerelease.length && !other.prerelease.length) {\n        return 0;\n      }\n\n      var i = 0;\n\n      do {\n        var a = this.prerelease[i];\n        var b = other.prerelease[i];\n        debug('prerelease compare', i, a, b);\n\n        if (a === undefined && b === undefined) {\n          return 0;\n        } else if (b === undefined) {\n          return 1;\n        } else if (a === undefined) {\n          return -1;\n        } else if (a === b) {\n          continue;\n        } else {\n          return compareIdentifiers(a, b);\n        }\n      } while (++i);\n    };\n\n    SemVer.prototype.compareBuild = function (other) {\n      if (!(other instanceof SemVer)) {\n        other = new SemVer(other, this.options);\n      }\n\n      var i = 0;\n\n      do {\n        var a = this.build[i];\n        var b = other.build[i];\n        debug('prerelease compare', i, a, b);\n\n        if (a === undefined && b === undefined) {\n          return 0;\n        } else if (b === undefined) {\n          return 1;\n        } else if (a === undefined) {\n          return -1;\n        } else if (a === b) {\n          continue;\n        } else {\n          return compareIdentifiers(a, b);\n        }\n      } while (++i);\n    }; // preminor will bump the version up to the next minor release, and immediately\n    // down to pre-release. premajor and prepatch work the same way.\n\n\n    SemVer.prototype.inc = function (release, identifier) {\n      switch (release) {\n        case 'premajor':\n          this.prerelease.length = 0;\n          this.patch = 0;\n          this.minor = 0;\n          this.major++;\n          this.inc('pre', identifier);\n          break;\n\n        case 'preminor':\n          this.prerelease.length = 0;\n          this.patch = 0;\n          this.minor++;\n          this.inc('pre', identifier);\n          break;\n\n        case 'prepatch':\n          // If this is already a prerelease, it will bump to the next version\n          // drop any prereleases that might already exist, since they are not\n          // relevant at this point.\n          this.prerelease.length = 0;\n          this.inc('patch', identifier);\n          this.inc('pre', identifier);\n          break;\n        // If the input is a non-prerelease version, this acts the same as\n        // prepatch.\n\n        case 'prerelease':\n          if (this.prerelease.length === 0) {\n            this.inc('patch', identifier);\n          }\n\n          this.inc('pre', identifier);\n          break;\n\n        case 'major':\n          // If this is a pre-major version, bump up to the same major version.\n          // Otherwise increment major.\n          // 1.0.0-5 bumps to 1.0.0\n          // 1.1.0 bumps to 2.0.0\n          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {\n            this.major++;\n          }\n\n          this.minor = 0;\n          this.patch = 0;\n          this.prerelease = [];\n          break;\n\n        case 'minor':\n          // If this is a pre-minor version, bump up to the same minor version.\n          // Otherwise increment minor.\n          // 1.2.0-5 bumps to 1.2.0\n          // 1.2.1 bumps to 1.3.0\n          if (this.patch !== 0 || this.prerelease.length === 0) {\n            this.minor++;\n          }\n\n          this.patch = 0;\n          this.prerelease = [];\n          break;\n\n        case 'patch':\n          // If this is not a pre-release version, it will increment the patch.\n          // If it is a pre-release it will bump up to the same patch version.\n          // 1.2.0-5 patches to 1.2.0\n          // 1.2.0 patches to 1.2.1\n          if (this.prerelease.length === 0) {\n            this.patch++;\n          }\n\n          this.prerelease = [];\n          break;\n        // This probably shouldn't be used publicly.\n        // 1.0.0 \"pre\" would become 1.0.0-0 which is the wrong direction.\n\n        case 'pre':\n          if (this.prerelease.length === 0) {\n            this.prerelease = [0];\n          } else {\n            var i = this.prerelease.length;\n\n            while (--i >= 0) {\n              if (typeof this.prerelease[i] === 'number') {\n                this.prerelease[i]++;\n                i = -2;\n              }\n            }\n\n            if (i === -1) {\n              // didn't increment anything\n              this.prerelease.push(0);\n            }\n          }\n\n          if (identifier) {\n            // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n            // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n            if (this.prerelease[0] === identifier) {\n              if (isNaN(this.prerelease[1])) {\n                this.prerelease = [identifier, 0];\n              }\n            } else {\n              this.prerelease = [identifier, 0];\n            }\n          }\n\n          break;\n\n        default:\n          throw new Error('invalid increment argument: ' + release);\n      }\n\n      this.format();\n      this.raw = this.version;\n      return this;\n    };\n\n    exports.inc = inc;\n\n    function inc(version, release, loose, identifier) {\n      if (typeof loose === 'string') {\n        identifier = loose;\n        loose = undefined;\n      }\n\n      try {\n        return new SemVer(version, loose).inc(release, identifier).version;\n      } catch (er) {\n        return null;\n      }\n    }\n\n    exports.diff = diff;\n\n    function diff(version1, version2) {\n      if (eq(version1, version2)) {\n        return null;\n      } else {\n        var v1 = parse(version1);\n        var v2 = parse(version2);\n        var prefix = '';\n\n        if (v1.prerelease.length || v2.prerelease.length) {\n          prefix = 'pre';\n          var defaultResult = 'prerelease';\n        }\n\n        for (var key in v1) {\n          if (key === 'major' || key === 'minor' || key === 'patch') {\n            if (v1[key] !== v2[key]) {\n              return prefix + key;\n            }\n          }\n        }\n\n        return defaultResult; // may be undefined\n      }\n    }\n\n    exports.compareIdentifiers = compareIdentifiers;\n    var numeric = /^[0-9]+$/;\n\n    function compareIdentifiers(a, b) {\n      var anum = numeric.test(a);\n      var bnum = numeric.test(b);\n\n      if (anum && bnum) {\n        a = +a;\n        b = +b;\n      }\n\n      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;\n    }\n\n    exports.rcompareIdentifiers = rcompareIdentifiers;\n\n    function rcompareIdentifiers(a, b) {\n      return compareIdentifiers(b, a);\n    }\n\n    exports.major = major;\n\n    function major(a, loose) {\n      return new SemVer(a, loose).major;\n    }\n\n    exports.minor = minor;\n\n    function minor(a, loose) {\n      return new SemVer(a, loose).minor;\n    }\n\n    exports.patch = patch;\n\n    function patch(a, loose) {\n      return new SemVer(a, loose).patch;\n    }\n\n    exports.compare = compare;\n\n    function compare(a, b, loose) {\n      return new SemVer(a, loose).compare(new SemVer(b, loose));\n    }\n\n    exports.compareLoose = compareLoose;\n\n    function compareLoose(a, b) {\n      return compare(a, b, true);\n    }\n\n    exports.compareBuild = compareBuild;\n\n    function compareBuild(a, b, loose) {\n      var versionA = new SemVer(a, loose);\n      var versionB = new SemVer(b, loose);\n      return versionA.compare(versionB) || versionA.compareBuild(versionB);\n    }\n\n    exports.rcompare = rcompare;\n\n    function rcompare(a, b, loose) {\n      return compare(b, a, loose);\n    }\n\n    exports.sort = sort;\n\n    function sort(list, loose) {\n      return list.sort(function (a, b) {\n        return exports.compareBuild(a, b, loose);\n      });\n    }\n\n    exports.rsort = rsort;\n\n    function rsort(list, loose) {\n      return list.sort(function (a, b) {\n        return exports.compareBuild(b, a, loose);\n      });\n    }\n\n    exports.gt = gt;\n\n    function gt(a, b, loose) {\n      return compare(a, b, loose) > 0;\n    }\n\n    exports.lt = lt;\n\n    function lt(a, b, loose) {\n      return compare(a, b, loose) < 0;\n    }\n\n    exports.eq = eq;\n\n    function eq(a, b, loose) {\n      return compare(a, b, loose) === 0;\n    }\n\n    exports.neq = neq;\n\n    function neq(a, b, loose) {\n      return compare(a, b, loose) !== 0;\n    }\n\n    exports.gte = gte;\n\n    function gte(a, b, loose) {\n      return compare(a, b, loose) >= 0;\n    }\n\n    exports.lte = lte;\n\n    function lte(a, b, loose) {\n      return compare(a, b, loose) <= 0;\n    }\n\n    exports.cmp = cmp;\n\n    function cmp(a, op, b, loose) {\n      switch (op) {\n        case '===':\n          if (_typeof(a) === 'object') a = a.version;\n          if (_typeof(b) === 'object') b = b.version;\n          return a === b;\n\n        case '!==':\n          if (_typeof(a) === 'object') a = a.version;\n          if (_typeof(b) === 'object') b = b.version;\n          return a !== b;\n\n        case '':\n        case '=':\n        case '==':\n          return eq(a, b, loose);\n\n        case '!=':\n          return neq(a, b, loose);\n\n        case '>':\n          return gt(a, b, loose);\n\n        case '>=':\n          return gte(a, b, loose);\n\n        case '<':\n          return lt(a, b, loose);\n\n        case '<=':\n          return lte(a, b, loose);\n\n        default:\n          throw new TypeError('Invalid operator: ' + op);\n      }\n    }\n\n    exports.Comparator = Comparator;\n\n    function Comparator(comp, options) {\n      if (!options || _typeof(options) !== 'object') {\n        options = {\n          loose: !!options,\n          includePrerelease: false\n        };\n      }\n\n      if (comp instanceof Comparator) {\n        if (comp.loose === !!options.loose) {\n          return comp;\n        } else {\n          comp = comp.value;\n        }\n      }\n\n      if (!(this instanceof Comparator)) {\n        return new Comparator(comp, options);\n      }\n\n      debug('comparator', comp, options);\n      this.options = options;\n      this.loose = !!options.loose;\n      this.parse(comp);\n\n      if (this.semver === ANY) {\n        this.value = '';\n      } else {\n        this.value = this.operator + this.semver.version;\n      }\n\n      debug('comp', this);\n    }\n\n    var ANY = {};\n\n    Comparator.prototype.parse = function (comp) {\n      var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];\n      var m = comp.match(r);\n\n      if (!m) {\n        throw new TypeError('Invalid comparator: ' + comp);\n      }\n\n      this.operator = m[1] !== undefined ? m[1] : '';\n\n      if (this.operator === '=') {\n        this.operator = '';\n      } // if it literally is just '>' or '' then allow anything.\n\n\n      if (!m[2]) {\n        this.semver = ANY;\n      } else {\n        this.semver = new SemVer(m[2], this.options.loose);\n      }\n    };\n\n    Comparator.prototype.toString = function () {\n      return this.value;\n    };\n\n    Comparator.prototype.test = function (version) {\n      debug('Comparator.test', version, this.options.loose);\n\n      if (this.semver === ANY || version === ANY) {\n        return true;\n      }\n\n      if (typeof version === 'string') {\n        try {\n          version = new SemVer(version, this.options);\n        } catch (er) {\n          return false;\n        }\n      }\n\n      return cmp(version, this.operator, this.semver, this.options);\n    };\n\n    Comparator.prototype.intersects = function (comp, options) {\n      if (!(comp instanceof Comparator)) {\n        throw new TypeError('a Comparator is required');\n      }\n\n      if (!options || _typeof(options) !== 'object') {\n        options = {\n          loose: !!options,\n          includePrerelease: false\n        };\n      }\n\n      var rangeTmp;\n\n      if (this.operator === '') {\n        if (this.value === '') {\n          return true;\n        }\n\n        rangeTmp = new Range(comp.value, options);\n        return satisfies(this.value, rangeTmp, options);\n      } else if (comp.operator === '') {\n        if (comp.value === '') {\n          return true;\n        }\n\n        rangeTmp = new Range(this.value, options);\n        return satisfies(comp.semver, rangeTmp, options);\n      }\n\n      var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');\n      var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');\n      var sameSemVer = this.semver.version === comp.semver.version;\n      var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');\n      var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');\n      var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');\n      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;\n    };\n\n    exports.Range = Range;\n\n    function Range(range, options) {\n      if (!options || _typeof(options) !== 'object') {\n        options = {\n          loose: !!options,\n          includePrerelease: false\n        };\n      }\n\n      if (range instanceof Range) {\n        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {\n          return range;\n        } else {\n          return new Range(range.raw, options);\n        }\n      }\n\n      if (range instanceof Comparator) {\n        return new Range(range.value, options);\n      }\n\n      if (!(this instanceof Range)) {\n        return new Range(range, options);\n      }\n\n      this.options = options;\n      this.loose = !!options.loose;\n      this.includePrerelease = !!options.includePrerelease; // First, split based on boolean or ||\n\n      this.raw = range;\n      this.set = range.split(/\\s*\\|\\|\\s*/).map(function (range) {\n        return this.parseRange(range.trim());\n      }, this).filter(function (c) {\n        // throw out any that are not relevant for whatever reason\n        return c.length;\n      });\n\n      if (!this.set.length) {\n        throw new TypeError('Invalid SemVer Range: ' + range);\n      }\n\n      this.format();\n    }\n\n    Range.prototype.format = function () {\n      this.range = this.set.map(function (comps) {\n        return comps.join(' ').trim();\n      }).join('||').trim();\n      return this.range;\n    };\n\n    Range.prototype.toString = function () {\n      return this.range;\n    };\n\n    Range.prototype.parseRange = function (range) {\n      var loose = this.options.loose;\n      range = range.trim(); // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n\n      var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];\n      range = range.replace(hr, hyphenReplace);\n      debug('hyphen replace', range); // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n\n      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);\n      debug('comparator trim', range, re[t.COMPARATORTRIM]); // `~ 1.2.3` => `~1.2.3`\n\n      range = range.replace(re[t.TILDETRIM], tildeTrimReplace); // `^ 1.2.3` => `^1.2.3`\n\n      range = range.replace(re[t.CARETTRIM], caretTrimReplace); // normalize spaces\n\n      range = range.split(/\\s+/).join(' '); // At this point, the range is completely trimmed and\n      // ready to be split into comparators.\n\n      var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];\n      var set = range.split(' ').map(function (comp) {\n        return parseComparator(comp, this.options);\n      }, this).join(' ').split(/\\s+/);\n\n      if (this.options.loose) {\n        // in loose mode, throw out any that are not valid comparators\n        set = set.filter(function (comp) {\n          return !!comp.match(compRe);\n        });\n      }\n\n      set = set.map(function (comp) {\n        return new Comparator(comp, this.options);\n      }, this);\n      return set;\n    };\n\n    Range.prototype.intersects = function (range, options) {\n      if (!(range instanceof Range)) {\n        throw new TypeError('a Range is required');\n      }\n\n      return this.set.some(function (thisComparators) {\n        return isSatisfiable(thisComparators, options) && range.set.some(function (rangeComparators) {\n          return isSatisfiable(rangeComparators, options) && thisComparators.every(function (thisComparator) {\n            return rangeComparators.every(function (rangeComparator) {\n              return thisComparator.intersects(rangeComparator, options);\n            });\n          });\n        });\n      });\n    }; // take a set of comparators and determine whether there\n    // exists a version which can satisfy it\n\n\n    function isSatisfiable(comparators, options) {\n      var result = true;\n      var remainingComparators = comparators.slice();\n      var testComparator = remainingComparators.pop();\n\n      while (result && remainingComparators.length) {\n        result = remainingComparators.every(function (otherComparator) {\n          return testComparator.intersects(otherComparator, options);\n        });\n        testComparator = remainingComparators.pop();\n      }\n\n      return result;\n    } // Mostly just for testing and legacy API reasons\n\n\n    exports.toComparators = toComparators;\n\n    function toComparators(range, options) {\n      return new Range(range, options).set.map(function (comp) {\n        return comp.map(function (c) {\n          return c.value;\n        }).join(' ').trim().split(' ');\n      });\n    } // comprised of xranges, tildes, stars, and gtlt's at this point.\n    // already replaced the hyphen ranges\n    // turn into a set of JUST comparators.\n\n\n    function parseComparator(comp, options) {\n      debug('comp', comp, options);\n      comp = replaceCarets(comp, options);\n      debug('caret', comp);\n      comp = replaceTildes(comp, options);\n      debug('tildes', comp);\n      comp = replaceXRanges(comp, options);\n      debug('xrange', comp);\n      comp = replaceStars(comp, options);\n      debug('stars', comp);\n      return comp;\n    }\n\n    function isX(id) {\n      return !id || id.toLowerCase() === 'x' || id === '*';\n    } // ~, ~> --> * (any, kinda silly)\n    // ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0\n    // ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0\n    // ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0\n    // ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0\n    // ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0\n\n\n    function replaceTildes(comp, options) {\n      return comp.trim().split(/\\s+/).map(function (comp) {\n        return replaceTilde(comp, options);\n      }).join(' ');\n    }\n\n    function replaceTilde(comp, options) {\n      var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];\n      return comp.replace(r, function (_, M, m, p, pr) {\n        debug('tilde', comp, _, M, m, p, pr);\n        var ret;\n\n        if (isX(M)) {\n          ret = '';\n        } else if (isX(m)) {\n          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n        } else if (isX(p)) {\n          // ~1.2 == >=1.2.0 <1.3.0\n          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n        } else if (pr) {\n          debug('replaceTilde pr', pr);\n          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';\n        } else {\n          // ~1.2.3 == >=1.2.3 <1.3.0\n          ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';\n        }\n\n        debug('tilde return', ret);\n        return ret;\n      });\n    } // ^ --> * (any, kinda silly)\n    // ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0\n    // ^2.0, ^2.0.x --> >=2.0.0 <3.0.0\n    // ^1.2, ^1.2.x --> >=1.2.0 <2.0.0\n    // ^1.2.3 --> >=1.2.3 <2.0.0\n    // ^1.2.0 --> >=1.2.0 <2.0.0\n\n\n    function replaceCarets(comp, options) {\n      return comp.trim().split(/\\s+/).map(function (comp) {\n        return replaceCaret(comp, options);\n      }).join(' ');\n    }\n\n    function replaceCaret(comp, options) {\n      debug('caret', comp, options);\n      var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];\n      return comp.replace(r, function (_, M, m, p, pr) {\n        debug('caret', comp, _, M, m, p, pr);\n        var ret;\n\n        if (isX(M)) {\n          ret = '';\n        } else if (isX(m)) {\n          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n        } else if (isX(p)) {\n          if (M === '0') {\n            ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n          } else {\n            ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';\n          }\n        } else if (pr) {\n          debug('replaceCaret pr', pr);\n\n          if (M === '0') {\n            if (m === '0') {\n              ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + m + '.' + (+p + 1);\n            } else {\n              ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';\n            }\n          } else {\n            ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + (+M + 1) + '.0.0';\n          }\n        } else {\n          debug('no pr');\n\n          if (M === '0') {\n            if (m === '0') {\n              ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);\n            } else {\n              ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';\n            }\n          } else {\n            ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';\n          }\n        }\n\n        debug('caret return', ret);\n        return ret;\n      });\n    }\n\n    function replaceXRanges(comp, options) {\n      debug('replaceXRanges', comp, options);\n      return comp.split(/\\s+/).map(function (comp) {\n        return replaceXRange(comp, options);\n      }).join(' ');\n    }\n\n    function replaceXRange(comp, options) {\n      comp = comp.trim();\n      var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];\n      return comp.replace(r, function (ret, gtlt, M, m, p, pr) {\n        debug('xRange', comp, ret, gtlt, M, m, p, pr);\n        var xM = isX(M);\n        var xm = xM || isX(m);\n        var xp = xm || isX(p);\n        var anyX = xp;\n\n        if (gtlt === '=' && anyX) {\n          gtlt = '';\n        } // if we're including prereleases in the match, then we need\n        // to fix this to -0, the lowest possible prerelease value\n\n\n        pr = options.includePrerelease ? '-0' : '';\n\n        if (xM) {\n          if (gtlt === '>' || gtlt === '<') {\n            // nothing is allowed\n            ret = '<0.0.0-0';\n          } else {\n            // nothing is forbidden\n            ret = '*';\n          }\n        } else if (gtlt && anyX) {\n          // we know patch is an x, because we have any x at all.\n          // replace X with 0\n          if (xm) {\n            m = 0;\n          }\n\n          p = 0;\n\n          if (gtlt === '>') {\n            // >1 => >=2.0.0\n            // >1.2 => >=1.3.0\n            // >1.2.3 => >= 1.2.4\n            gtlt = '>=';\n\n            if (xm) {\n              M = +M + 1;\n              m = 0;\n              p = 0;\n            } else {\n              m = +m + 1;\n              p = 0;\n            }\n          } else if (gtlt === '<=') {\n            // <=0.7.x is actually <0.8.0, since any 0.7.x should\n            // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n            gtlt = '<';\n\n            if (xm) {\n              M = +M + 1;\n            } else {\n              m = +m + 1;\n            }\n          }\n\n          ret = gtlt + M + '.' + m + '.' + p + pr;\n        } else if (xm) {\n          ret = '>=' + M + '.0.0' + pr + ' <' + (+M + 1) + '.0.0' + pr;\n        } else if (xp) {\n          ret = '>=' + M + '.' + m + '.0' + pr + ' <' + M + '.' + (+m + 1) + '.0' + pr;\n        }\n\n        debug('xRange return', ret);\n        return ret;\n      });\n    } // Because * is AND-ed with everything else in the comparator,\n    // and '' means \"any version\", just remove the *s entirely.\n\n\n    function replaceStars(comp, options) {\n      debug('replaceStars', comp, options); // Looseness is ignored here.  star is always as loose as it gets!\n\n      return comp.trim().replace(re[t.STAR], '');\n    } // This function is passed to string.replace(re[t.HYPHENRANGE])\n    // M, m, patch, prerelease, build\n    // 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n    // 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do\n    // 1.2 - 3.4 => >=1.2.0 <3.5.0\n\n\n    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {\n      if (isX(fM)) {\n        from = '';\n      } else if (isX(fm)) {\n        from = '>=' + fM + '.0.0';\n      } else if (isX(fp)) {\n        from = '>=' + fM + '.' + fm + '.0';\n      } else {\n        from = '>=' + from;\n      }\n\n      if (isX(tM)) {\n        to = '';\n      } else if (isX(tm)) {\n        to = '<' + (+tM + 1) + '.0.0';\n      } else if (isX(tp)) {\n        to = '<' + tM + '.' + (+tm + 1) + '.0';\n      } else if (tpr) {\n        to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;\n      } else {\n        to = '<=' + to;\n      }\n\n      return (from + ' ' + to).trim();\n    } // if ANY of the sets match ALL of its comparators, then pass\n\n\n    Range.prototype.test = function (version) {\n      if (!version) {\n        return false;\n      }\n\n      if (typeof version === 'string') {\n        try {\n          version = new SemVer(version, this.options);\n        } catch (er) {\n          return false;\n        }\n      }\n\n      for (var i = 0; i < this.set.length; i++) {\n        if (testSet(this.set[i], version, this.options)) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    function testSet(set, version, options) {\n      for (var i = 0; i < set.length; i++) {\n        if (!set[i].test(version)) {\n          return false;\n        }\n      }\n\n      if (version.prerelease.length && !options.includePrerelease) {\n        // Find the set of versions that are allowed to have prereleases\n        // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n        // That should allow `1.2.3-pr.2` to pass.\n        // However, `1.2.4-alpha.notready` should NOT be allowed,\n        // even though it's within the range set by the comparators.\n        for (i = 0; i < set.length; i++) {\n          debug(set[i].semver);\n\n          if (set[i].semver === ANY) {\n            continue;\n          }\n\n          if (set[i].semver.prerelease.length > 0) {\n            var allowed = set[i].semver;\n\n            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {\n              return true;\n            }\n          }\n        } // Version has a -pre, but it's not one of the ones we like.\n\n\n        return false;\n      }\n\n      return true;\n    }\n\n    exports.satisfies = satisfies;\n\n    function satisfies(version, range, options) {\n      try {\n        range = new Range(range, options);\n      } catch (er) {\n        return false;\n      }\n\n      return range.test(version);\n    }\n\n    exports.maxSatisfying = maxSatisfying;\n\n    function maxSatisfying(versions, range, options) {\n      var max = null;\n      var maxSV = null;\n\n      try {\n        var rangeObj = new Range(range, options);\n      } catch (er) {\n        return null;\n      }\n\n      versions.forEach(function (v) {\n        if (rangeObj.test(v)) {\n          // satisfies(v, range, options)\n          if (!max || maxSV.compare(v) === -1) {\n            // compare(max, v, true)\n            max = v;\n            maxSV = new SemVer(max, options);\n          }\n        }\n      });\n      return max;\n    }\n\n    exports.minSatisfying = minSatisfying;\n\n    function minSatisfying(versions, range, options) {\n      var min = null;\n      var minSV = null;\n\n      try {\n        var rangeObj = new Range(range, options);\n      } catch (er) {\n        return null;\n      }\n\n      versions.forEach(function (v) {\n        if (rangeObj.test(v)) {\n          // satisfies(v, range, options)\n          if (!min || minSV.compare(v) === 1) {\n            // compare(min, v, true)\n            min = v;\n            minSV = new SemVer(min, options);\n          }\n        }\n      });\n      return min;\n    }\n\n    exports.minVersion = minVersion;\n\n    function minVersion(range, loose) {\n      range = new Range(range, loose);\n      var minver = new SemVer('0.0.0');\n\n      if (range.test(minver)) {\n        return minver;\n      }\n\n      minver = new SemVer('0.0.0-0');\n\n      if (range.test(minver)) {\n        return minver;\n      }\n\n      minver = null;\n\n      for (var i = 0; i < range.set.length; ++i) {\n        var comparators = range.set[i];\n        comparators.forEach(function (comparator) {\n          // Clone to avoid manipulating the comparator's semver object.\n          var compver = new SemVer(comparator.semver.version);\n\n          switch (comparator.operator) {\n            case '>':\n              if (compver.prerelease.length === 0) {\n                compver.patch++;\n              } else {\n                compver.prerelease.push(0);\n              }\n\n              compver.raw = compver.format();\n\n            /* fallthrough */\n\n            case '':\n            case '>=':\n              if (!minver || gt(minver, compver)) {\n                minver = compver;\n              }\n\n              break;\n\n            case '<':\n            case '<=':\n              /* Ignore maximum versions */\n              break;\n\n            /* istanbul ignore next */\n\n            default:\n              throw new Error('Unexpected operation: ' + comparator.operator);\n          }\n        });\n      }\n\n      if (minver && range.test(minver)) {\n        return minver;\n      }\n\n      return null;\n    }\n\n    exports.validRange = validRange;\n\n    function validRange(range, options) {\n      try {\n        // Return '*' instead of '' so that truthiness works.\n        // This will throw if it's invalid anyway\n        return new Range(range, options).range || '*';\n      } catch (er) {\n        return null;\n      }\n    } // Determine if version is less than all the versions possible in the range\n\n\n    exports.ltr = ltr;\n\n    function ltr(version, range, options) {\n      return outside(version, range, '<', options);\n    } // Determine if version is greater than all the versions possible in the range.\n\n\n    exports.gtr = gtr;\n\n    function gtr(version, range, options) {\n      return outside(version, range, '>', options);\n    }\n\n    exports.outside = outside;\n\n    function outside(version, range, hilo, options) {\n      version = new SemVer(version, options);\n      range = new Range(range, options);\n      var gtfn, ltefn, ltfn, comp, ecomp;\n\n      switch (hilo) {\n        case '>':\n          gtfn = gt;\n          ltefn = lte;\n          ltfn = lt;\n          comp = '>';\n          ecomp = '>=';\n          break;\n\n        case '<':\n          gtfn = lt;\n          ltefn = gte;\n          ltfn = gt;\n          comp = '<';\n          ecomp = '<=';\n          break;\n\n        default:\n          throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n      } // If it satisifes the range it is not outside\n\n\n      if (satisfies(version, range, options)) {\n        return false;\n      } // From now on, variable terms are as if we're in \"gtr\" mode.\n      // but note that everything is flipped for the \"ltr\" function.\n\n\n      for (var i = 0; i < range.set.length; ++i) {\n        var comparators = range.set[i];\n        var high = null;\n        var low = null;\n        comparators.forEach(function (comparator) {\n          if (comparator.semver === ANY) {\n            comparator = new Comparator('>=0.0.0');\n          }\n\n          high = high || comparator;\n          low = low || comparator;\n\n          if (gtfn(comparator.semver, high.semver, options)) {\n            high = comparator;\n          } else if (ltfn(comparator.semver, low.semver, options)) {\n            low = comparator;\n          }\n        }); // If the edge version comparator has a operator then our version\n        // isn't outside it\n\n        if (high.operator === comp || high.operator === ecomp) {\n          return false;\n        } // If the lowest version comparator has an operator and our version\n        // is less than it then it isn't higher than the range\n\n\n        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {\n          return false;\n        } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    exports.prerelease = prerelease;\n\n    function prerelease(version, options) {\n      var parsed = parse(version, options);\n      return parsed && parsed.prerelease.length ? parsed.prerelease : null;\n    }\n\n    exports.intersects = intersects;\n\n    function intersects(r1, r2, options) {\n      r1 = new Range(r1, options);\n      r2 = new Range(r2, options);\n      return r1.intersects(r2);\n    }\n\n    exports.coerce = coerce;\n\n    function coerce(version, options) {\n      if (version instanceof SemVer) {\n        return version;\n      }\n\n      if (typeof version === 'number') {\n        version = String(version);\n      }\n\n      if (typeof version !== 'string') {\n        return null;\n      }\n\n      options = options || {};\n      var match = null;\n\n      if (!options.rtl) {\n        match = version.match(re[t.COERCE]);\n      } else {\n        // Find the right-most coercible string that does not share\n        // a terminus with a more left-ward coercible string.\n        // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n        //\n        // Walk through the string checking with a /g regexp\n        // Manually set the index so as to pick up overlapping matches.\n        // Stop when we get a match that ends at the string end, since no\n        // coercible string can be more right-ward without the same terminus.\n        var next;\n\n        while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {\n          if (!match || next.index + next[0].length !== match.index + match[0].length) {\n            match = next;\n          }\n\n          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;\n        } // leave it in a clean state\n\n\n        re[t.COERCERTL].lastIndex = -1;\n      }\n\n      if (match === null) {\n        return null;\n      }\n\n      return parse(match[2] + '.' + (match[3] || '0') + '.' + (match[4] || '0'), options);\n    }\n  });\n  var semver_1 = semver.SEMVER_SPEC_VERSION;\n  var semver_2 = semver.re;\n  var semver_3 = semver.src;\n  var semver_4 = semver.tokens;\n  var semver_5 = semver.parse;\n  var semver_6 = semver.valid;\n  var semver_7 = semver.clean;\n  var semver_8 = semver.SemVer;\n  var semver_9 = semver.inc;\n  var semver_10 = semver.diff;\n  var semver_11 = semver.compareIdentifiers;\n  var semver_12 = semver.rcompareIdentifiers;\n  var semver_13 = semver.major;\n  var semver_14 = semver.minor;\n  var semver_15 = semver.patch;\n  var semver_16 = semver.compare;\n  var semver_17 = semver.compareLoose;\n  var semver_18 = semver.compareBuild;\n  var semver_19 = semver.rcompare;\n  var semver_20 = semver.sort;\n  var semver_21 = semver.rsort;\n  var semver_22 = semver.gt;\n  var semver_23 = semver.lt;\n  var semver_24 = semver.eq;\n  var semver_25 = semver.neq;\n  var semver_26 = semver.gte;\n  var semver_27 = semver.lte;\n  var semver_28 = semver.cmp;\n  var semver_29 = semver.Comparator;\n  var semver_30 = semver.Range;\n  var semver_31 = semver.toComparators;\n  var semver_32 = semver.satisfies;\n  var semver_33 = semver.maxSatisfying;\n  var semver_34 = semver.minSatisfying;\n  var semver_35 = semver.minVersion;\n  var semver_36 = semver.validRange;\n  var semver_37 = semver.ltr;\n  var semver_38 = semver.gtr;\n  var semver_39 = semver.outside;\n  var semver_40 = semver.prerelease;\n  var semver_41 = semver.intersects;\n  var semver_42 = semver.coerce;\n\n  var arrayify = function arrayify(object, keyName) {\n    return Object.keys(object).reduce(function (array, key) {\n      return array.concat(Object.assign(_defineProperty({}, keyName, key), object[key]));\n    }, []);\n  };\n\n  var dedent_1 = createCommonjsModule(function (module) {\n\n    function dedent(strings) {\n      var raw = void 0;\n\n      if (typeof strings === \"string\") {\n        // dedent can be used as a plain function\n        raw = [strings];\n      } else {\n        raw = strings.raw;\n      } // first, perform interpolation\n\n\n      var result = \"\";\n\n      for (var i = 0; i < raw.length; i++) {\n        result += raw[i]. // join lines when there is a suppressed newline\n        replace(/\\\\\\n[ \\t]*/g, \"\"). // handle escaped backticks\n        replace(/\\\\`/g, \"`\");\n\n        if (i < (arguments.length <= 1 ? 0 : arguments.length - 1)) {\n          result += arguments.length <= i + 1 ? undefined : arguments[i + 1];\n        }\n      } // now strip indentation\n\n\n      var lines = result.split(\"\\n\");\n      var mindent = null;\n      lines.forEach(function (l) {\n        var m = l.match(/^(\\s+)\\S+/);\n\n        if (m) {\n          var indent = m[1].length;\n\n          if (!mindent) {\n            // this is the first indented line\n            mindent = indent;\n          } else {\n            mindent = Math.min(mindent, indent);\n          }\n        }\n      });\n\n      if (mindent !== null) {\n        result = lines.map(function (l) {\n          return l[0] === \" \" ? l.slice(mindent) : l;\n        }).join(\"\\n\");\n      } // dedent eats leading and trailing whitespace too\n\n\n      result = result.trim(); // handle escaped newlines at the end to ensure they don't get stripped too\n\n      return result.replace(/\\\\n/g, \"\\n\");\n    }\n\n    {\n      module.exports = dedent;\n    }\n  });\n\n  function _templateObject6() {\n    var data = _taggedTemplateLiteral([\"\\n      Require either '@prettier' or '@format' to be present in the file's first docblock comment\\n      in order for it to be formatted.\\n    \"]);\n\n    _templateObject6 = function _templateObject6() {\n      return data;\n    };\n\n    return data;\n  }\n\n  function _templateObject5() {\n    var data = _taggedTemplateLiteral([\"\\n      Format code starting at a given character offset.\\n      The range will extend backwards to the start of the first line containing the selected statement.\\n      This option cannot be used with --cursor-offset.\\n    \"]);\n\n    _templateObject5 = function _templateObject5() {\n      return data;\n    };\n\n    return data;\n  }\n\n  function _templateObject4() {\n    var data = _taggedTemplateLiteral([\"\\n      Format code ending at a given character offset (exclusive).\\n      The range will extend forwards to the end of the selected statement.\\n      This option cannot be used with --cursor-offset.\\n    \"]);\n\n    _templateObject4 = function _templateObject4() {\n      return data;\n    };\n\n    return data;\n  }\n\n  function _templateObject3() {\n    var data = _taggedTemplateLiteral([\"\\n      Custom directory that contains prettier plugins in node_modules subdirectory.\\n      Overrides default behavior when plugins are searched relatively to the location of Prettier.\\n      Multiple values are accepted.\\n    \"]);\n\n    _templateObject3 = function _templateObject3() {\n      return data;\n    };\n\n    return data;\n  }\n\n  function _templateObject2() {\n    var data = _taggedTemplateLiteral([\"\\n          Maintain existing\\n          (mixed values within one file are normalised by looking at what's used after the first line)\\n        \"]);\n\n    _templateObject2 = function _templateObject2() {\n      return data;\n    };\n\n    return data;\n  }\n\n  function _templateObject() {\n    var data = _taggedTemplateLiteral([\"\\n      Print (to stderr) where a cursor at the given position would move to after formatting.\\n      This option cannot be used with --range-start and --range-end.\\n    \"]);\n\n    _templateObject = function _templateObject() {\n      return data;\n    };\n\n    return data;\n  }\n\n  var CATEGORY_CONFIG = \"Config\";\n  var CATEGORY_EDITOR = \"Editor\";\n  var CATEGORY_FORMAT = \"Format\";\n  var CATEGORY_OTHER = \"Other\";\n  var CATEGORY_OUTPUT = \"Output\";\n  var CATEGORY_GLOBAL = \"Global\";\n  var CATEGORY_SPECIAL = \"Special\";\n  /**\n   * @typedef {Object} OptionInfo\n   * @property {string} [since] - available since version\n   * @property {string} category\n   * @property {'int' | 'boolean' | 'choice' | 'path'} type\n   * @property {boolean} [array] - indicate it's an array of the specified type\n   * @property {OptionValueInfo} [default]\n   * @property {OptionRangeInfo} [range] - for type int\n   * @property {string} description\n   * @property {string} [deprecated] - deprecated since version\n   * @property {OptionRedirectInfo} [redirect] - redirect deprecated option\n   * @property {(value: any) => boolean} [exception]\n   * @property {OptionChoiceInfo[]} [choices] - for type choice\n   * @property {string} [cliName]\n   * @property {string} [cliCategory]\n   * @property {string} [cliDescription]\n   *\n   * @typedef {number | boolean | string} OptionValue\n   * @typedef {OptionValue | [{ value: OptionValue[] }] | Array<{ since: string, value: OptionValue}>} OptionValueInfo\n   *\n   * @typedef {Object} OptionRedirectInfo\n   * @property {string} option\n   * @property {OptionValue} value\n   *\n   * @typedef {Object} OptionRangeInfo\n   * @property {number} start - recommended range start\n   * @property {number} end - recommended range end\n   * @property {number} step - recommended range step\n   *\n   * @typedef {Object} OptionChoiceInfo\n   * @property {boolean | string} value - boolean for the option that is originally boolean type\n   * @property {string} description\n   * @property {string} [since] - undefined if available since the first version of the option\n   * @property {string} [deprecated] - deprecated since version\n   * @property {OptionValueInfo} [redirect] - redirect deprecated value\n   */\n\n  /** @type {{ [name: string]: OptionInfo }} */\n\n  var options = {\n    cursorOffset: {\n      since: \"1.4.0\",\n      category: CATEGORY_SPECIAL,\n      type: \"int\",\n      default: -1,\n      range: {\n        start: -1,\n        end: Infinity,\n        step: 1\n      },\n      description: dedent_1(_templateObject()),\n      cliCategory: CATEGORY_EDITOR\n    },\n    endOfLine: {\n      since: \"1.15.0\",\n      category: CATEGORY_GLOBAL,\n      type: \"choice\",\n      default: \"auto\",\n      description: \"Which end of line characters to apply.\",\n      choices: [{\n        value: \"auto\",\n        description: dedent_1(_templateObject2())\n      }, {\n        value: \"lf\",\n        description: \"Line Feed only (\\\\n), common on Linux and macOS as well as inside git repos\"\n      }, {\n        value: \"crlf\",\n        description: \"Carriage Return + Line Feed characters (\\\\r\\\\n), common on Windows\"\n      }, {\n        value: \"cr\",\n        description: \"Carriage Return character only (\\\\r), used very rarely\"\n      }]\n    },\n    filepath: {\n      since: \"1.4.0\",\n      category: CATEGORY_SPECIAL,\n      type: \"path\",\n      description: \"Specify the input filepath. This will be used to do parser inference.\",\n      cliName: \"stdin-filepath\",\n      cliCategory: CATEGORY_OTHER,\n      cliDescription: \"Path to the file to pretend that stdin comes from.\"\n    },\n    insertPragma: {\n      since: \"1.8.0\",\n      category: CATEGORY_SPECIAL,\n      type: \"boolean\",\n      default: false,\n      description: \"Insert @format pragma into file's first docblock comment.\",\n      cliCategory: CATEGORY_OTHER\n    },\n    parser: {\n      since: \"0.0.10\",\n      category: CATEGORY_GLOBAL,\n      type: \"choice\",\n      default: [{\n        since: \"0.0.10\",\n        value: \"babylon\"\n      }, {\n        since: \"1.13.0\",\n        value: undefined\n      }],\n      description: \"Which parser to use.\",\n      exception: function exception(value) {\n        return typeof value === \"string\" || typeof value === \"function\";\n      },\n      choices: [{\n        value: \"flow\",\n        description: \"Flow\"\n      }, {\n        value: \"babylon\",\n        description: \"JavaScript\",\n        deprecated: \"1.16.0\",\n        redirect: \"babel\"\n      }, {\n        value: \"babel\",\n        since: \"1.16.0\",\n        description: \"JavaScript\"\n      }, {\n        value: \"babel-flow\",\n        since: \"1.16.0\",\n        description: \"Flow\"\n      }, {\n        value: \"typescript\",\n        since: \"1.4.0\",\n        description: \"TypeScript\"\n      }, {\n        value: \"css\",\n        since: \"1.7.1\",\n        description: \"CSS\"\n      }, {\n        value: \"postcss\",\n        since: \"1.4.0\",\n        description: \"CSS/Less/SCSS\",\n        deprecated: \"1.7.1\",\n        redirect: \"css\"\n      }, {\n        value: \"less\",\n        since: \"1.7.1\",\n        description: \"Less\"\n      }, {\n        value: \"scss\",\n        since: \"1.7.1\",\n        description: \"SCSS\"\n      }, {\n        value: \"json\",\n        since: \"1.5.0\",\n        description: \"JSON\"\n      }, {\n        value: \"json5\",\n        since: \"1.13.0\",\n        description: \"JSON5\"\n      }, {\n        value: \"json-stringify\",\n        since: \"1.13.0\",\n        description: \"JSON.stringify\"\n      }, {\n        value: \"graphql\",\n        since: \"1.5.0\",\n        description: \"GraphQL\"\n      }, {\n        value: \"markdown\",\n        since: \"1.8.0\",\n        description: \"Markdown\"\n      }, {\n        value: \"mdx\",\n        since: \"1.15.0\",\n        description: \"MDX\"\n      }, {\n        value: \"vue\",\n        since: \"1.10.0\",\n        description: \"Vue\"\n      }, {\n        value: \"yaml\",\n        since: \"1.14.0\",\n        description: \"YAML\"\n      }, {\n        value: \"glimmer\",\n        since: null,\n        description: \"Handlebars\"\n      }, {\n        value: \"html\",\n        since: \"1.15.0\",\n        description: \"HTML\"\n      }, {\n        value: \"angular\",\n        since: \"1.15.0\",\n        description: \"Angular\"\n      }, {\n        value: \"lwc\",\n        since: \"1.17.0\",\n        description: \"Lightning Web Components\"\n      }]\n    },\n    plugins: {\n      since: \"1.10.0\",\n      type: \"path\",\n      array: true,\n      default: [{\n        value: []\n      }],\n      category: CATEGORY_GLOBAL,\n      description: \"Add a plugin. Multiple plugins can be passed as separate `--plugin`s.\",\n      exception: function exception(value) {\n        return typeof value === \"string\" || _typeof(value) === \"object\";\n      },\n      cliName: \"plugin\",\n      cliCategory: CATEGORY_CONFIG\n    },\n    pluginSearchDirs: {\n      since: \"1.13.0\",\n      type: \"path\",\n      array: true,\n      default: [{\n        value: []\n      }],\n      category: CATEGORY_GLOBAL,\n      description: dedent_1(_templateObject3()),\n      exception: function exception(value) {\n        return typeof value === \"string\" || _typeof(value) === \"object\";\n      },\n      cliName: \"plugin-search-dir\",\n      cliCategory: CATEGORY_CONFIG\n    },\n    printWidth: {\n      since: \"0.0.0\",\n      category: CATEGORY_GLOBAL,\n      type: \"int\",\n      default: 80,\n      description: \"The line length where Prettier will try wrap.\",\n      range: {\n        start: 0,\n        end: Infinity,\n        step: 1\n      }\n    },\n    rangeEnd: {\n      since: \"1.4.0\",\n      category: CATEGORY_SPECIAL,\n      type: \"int\",\n      default: Infinity,\n      range: {\n        start: 0,\n        end: Infinity,\n        step: 1\n      },\n      description: dedent_1(_templateObject4()),\n      cliCategory: CATEGORY_EDITOR\n    },\n    rangeStart: {\n      since: \"1.4.0\",\n      category: CATEGORY_SPECIAL,\n      type: \"int\",\n      default: 0,\n      range: {\n        start: 0,\n        end: Infinity,\n        step: 1\n      },\n      description: dedent_1(_templateObject5()),\n      cliCategory: CATEGORY_EDITOR\n    },\n    requirePragma: {\n      since: \"1.7.0\",\n      category: CATEGORY_SPECIAL,\n      type: \"boolean\",\n      default: false,\n      description: dedent_1(_templateObject6()),\n      cliCategory: CATEGORY_OTHER\n    },\n    tabWidth: {\n      type: \"int\",\n      category: CATEGORY_GLOBAL,\n      default: 2,\n      description: \"Number of spaces per indentation level.\",\n      range: {\n        start: 0,\n        end: Infinity,\n        step: 1\n      }\n    },\n    useFlowParser: {\n      since: \"0.0.0\",\n      category: CATEGORY_GLOBAL,\n      type: \"boolean\",\n      default: [{\n        since: \"0.0.0\",\n        value: false\n      }, {\n        since: \"1.15.0\",\n        value: undefined\n      }],\n      deprecated: \"0.0.10\",\n      description: \"Use flow parser.\",\n      redirect: {\n        option: \"parser\",\n        value: \"flow\"\n      },\n      cliName: \"flow-parser\"\n    },\n    useTabs: {\n      since: \"1.0.0\",\n      category: CATEGORY_GLOBAL,\n      type: \"boolean\",\n      default: false,\n      description: \"Indent with tabs instead of spaces.\"\n    }\n  };\n  var coreOptions = {\n    CATEGORY_CONFIG: CATEGORY_CONFIG,\n    CATEGORY_EDITOR: CATEGORY_EDITOR,\n    CATEGORY_FORMAT: CATEGORY_FORMAT,\n    CATEGORY_OTHER: CATEGORY_OTHER,\n    CATEGORY_OUTPUT: CATEGORY_OUTPUT,\n    CATEGORY_GLOBAL: CATEGORY_GLOBAL,\n    CATEGORY_SPECIAL: CATEGORY_SPECIAL,\n    options: options\n  };\n\n  var require$$0 = getCjsExportFromNamespace(_package$1);\n\n  var currentVersion = require$$0.version;\n  var coreOptions$1 = coreOptions.options;\n\n  function getSupportInfo(version, opts) {\n    opts = Object.assign({\n      plugins: [],\n      showUnreleased: false,\n      showDeprecated: false,\n      showInternal: false\n    }, opts);\n\n    if (!version) {\n      // pre-release version is smaller than the normal version in semver,\n      // we need to treat it as the normal one so as to test new features.\n      version = currentVersion.split(\"-\", 1)[0];\n    }\n\n    var plugins = opts.plugins;\n    var options = arrayify(Object.assign(plugins.reduce(function (currentOptions, plugin) {\n      return Object.assign(currentOptions, plugin.options);\n    }, {}), coreOptions$1), \"name\").sort(function (a, b) {\n      return a.name === b.name ? 0 : a.name < b.name ? -1 : 1;\n    }).filter(filterSince).filter(filterDeprecated).map(mapDeprecated).map(mapInternal).map(function (option) {\n      var newOption = Object.assign({}, option);\n\n      if (Array.isArray(newOption.default)) {\n        newOption.default = newOption.default.length === 1 ? newOption.default[0].value : newOption.default.filter(filterSince).sort(function (info1, info2) {\n          return semver.compare(info2.since, info1.since);\n        })[0].value;\n      }\n\n      if (Array.isArray(newOption.choices)) {\n        newOption.choices = newOption.choices.filter(filterSince).filter(filterDeprecated).map(mapDeprecated);\n      }\n\n      return newOption;\n    }).map(function (option) {\n      var filteredPlugins = plugins.filter(function (plugin) {\n        return plugin.defaultOptions && plugin.defaultOptions[option.name] !== undefined;\n      });\n      var pluginDefaults = filteredPlugins.reduce(function (reduced, plugin) {\n        reduced[plugin.name] = plugin.defaultOptions[option.name];\n        return reduced;\n      }, {});\n      return Object.assign(option, {\n        pluginDefaults: pluginDefaults\n      });\n    });\n    var usePostCssParser = semver.lt(version, \"1.7.1\");\n    var useBabylonParser = semver.lt(version, \"1.16.0\");\n    var languages = plugins.reduce(function (all, plugin) {\n      return all.concat(plugin.languages || []);\n    }, []).filter(filterSince).map(function (language) {\n      // Prevent breaking changes\n      if (language.name === \"Markdown\") {\n        return Object.assign({}, language, {\n          parsers: [\"markdown\"]\n        });\n      }\n\n      if (language.name === \"TypeScript\") {\n        return Object.assign({}, language, {\n          parsers: [\"typescript\"]\n        });\n      } // \"babylon\" was renamed to \"babel\" in 1.16.0\n\n\n      if (useBabylonParser && language.parsers.indexOf(\"babel\") !== -1) {\n        return Object.assign({}, language, {\n          parsers: language.parsers.map(function (parser) {\n            return parser === \"babel\" ? \"babylon\" : parser;\n          })\n        });\n      }\n\n      if (usePostCssParser && (language.name === \"CSS\" || language.group === \"CSS\")) {\n        return Object.assign({}, language, {\n          parsers: [\"postcss\"]\n        });\n      }\n\n      return language;\n    });\n    return {\n      languages: languages,\n      options: options\n    };\n\n    function filterSince(object) {\n      return opts.showUnreleased || !(\"since\" in object) || object.since && semver.gte(version, object.since);\n    }\n\n    function filterDeprecated(object) {\n      return opts.showDeprecated || !(\"deprecated\" in object) || object.deprecated && semver.lt(version, object.deprecated);\n    }\n\n    function mapDeprecated(object) {\n      if (!object.deprecated || opts.showDeprecated) {\n        return object;\n      }\n\n      var newObject = Object.assign({}, object);\n      delete newObject.deprecated;\n      delete newObject.redirect;\n      return newObject;\n    }\n\n    function mapInternal(object) {\n      if (opts.showInternal) {\n        return object;\n      }\n\n      var newObject = Object.assign({}, object);\n      delete newObject.cliName;\n      delete newObject.cliCategory;\n      delete newObject.cliDescription;\n      return newObject;\n    }\n  }\n\n  var support = {\n    getSupportInfo: getSupportInfo\n  };\n\n  /*! *****************************************************************************\r\n  Copyright (c) Microsoft Corporation. All rights reserved.\r\n  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n  this file except in compliance with the License. You may obtain a copy of the\r\n  License at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n  MERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\n  See the Apache Version 2.0 License for specific language governing permissions\r\n  and limitations under the License.\r\n  ***************************************************************************** */\n\n  /* global Reflect, Promise */\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  function __extends(d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  }\n\n  var _assign = function __assign() {\n    _assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n\n        for (var p in s) {\n          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n      }\n\n      return t;\n    };\n\n    return _assign.apply(this, arguments);\n  };\n  function __rest(s, e) {\n    var t = {};\n\n    for (var p in s) {\n      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    }\n\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n  }\n  function __decorate(decorators, target, key, desc) {\n    var c = arguments.length,\n        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n        d;\n    if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n      if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    }\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n  }\n  function __param(paramIndex, decorator) {\n    return function (target, key) {\n      decorator(target, key, paramIndex);\n    };\n  }\n  function __metadata(metadataKey, metadataValue) {\n    if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n  }\n  function __awaiter(thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n\n      function rejected(value) {\n        try {\n          step(generator[\"throw\"](value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n\n      function step(result) {\n        result.done ? resolve(result.value) : new P(function (resolve) {\n          resolve(result.value);\n        }).then(fulfilled, rejected);\n      }\n\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n  }\n  function __generator(thisArg, body) {\n    var _ = {\n      label: 0,\n      sent: function sent() {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n        f,\n        y,\n        t,\n        g;\n    return g = {\n      next: verb(0),\n      \"throw\": verb(1),\n      \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n      return this;\n    }), g;\n\n    function verb(n) {\n      return function (v) {\n        return step([n, v]);\n      };\n    }\n\n    function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n\n      while (_) {\n        try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n\n          switch (op[0]) {\n            case 0:\n            case 1:\n              t = op;\n              break;\n\n            case 4:\n              _.label++;\n              return {\n                value: op[1],\n                done: false\n              };\n\n            case 5:\n              _.label++;\n              y = op[1];\n              op = [0];\n              continue;\n\n            case 7:\n              op = _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n\n            default:\n              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                _ = 0;\n                continue;\n              }\n\n              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                _.label = op[1];\n                break;\n              }\n\n              if (op[0] === 6 && _.label < t[1]) {\n                _.label = t[1];\n                t = op;\n                break;\n              }\n\n              if (t && _.label < t[2]) {\n                _.label = t[2];\n\n                _.ops.push(op);\n\n                break;\n              }\n\n              if (t[2]) _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n          }\n\n          op = body.call(thisArg, _);\n        } catch (e) {\n          op = [6, e];\n          y = 0;\n        } finally {\n          f = t = 0;\n        }\n      }\n\n      if (op[0] & 5) throw op[1];\n      return {\n        value: op[0] ? op[1] : void 0,\n        done: true\n      };\n    }\n  }\n  function __exportStar(m, exports) {\n    for (var p in m) {\n      if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n    }\n  }\n  function __values(o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n        i = 0;\n    if (m) return m.call(o);\n    return {\n      next: function next() {\n        if (o && i >= o.length) o = void 0;\n        return {\n          value: o && o[i++],\n          done: !o\n        };\n      }\n    };\n  }\n  function __read(o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o),\n        r,\n        ar = [],\n        e;\n\n    try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n        ar.push(r.value);\n      }\n    } catch (error) {\n      e = {\n        error: error\n      };\n    } finally {\n      try {\n        if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      } finally {\n        if (e) throw e.error;\n      }\n    }\n\n    return ar;\n  }\n  function __spread() {\n    for (var ar = [], i = 0; i < arguments.length; i++) {\n      ar = ar.concat(__read(arguments[i]));\n    }\n\n    return ar;\n  }\n  function __spreadArrays() {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n      s += arguments[i].length;\n    }\n\n    for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n        r[k] = a[j];\n      }\n    }\n\n    return r;\n  }\n  function __await(v) {\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\n  }\n  function __asyncGenerator(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []),\n        i,\n        q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n      return this;\n    }, i;\n\n    function verb(n) {\n      if (g[n]) i[n] = function (v) {\n        return new Promise(function (a, b) {\n          q.push([n, v, a, b]) > 1 || resume(n, v);\n        });\n      };\n    }\n\n    function resume(n, v) {\n      try {\n        step(g[n](v));\n      } catch (e) {\n        settle(q[0][3], e);\n      }\n    }\n\n    function step(r) {\n      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n    }\n\n    function fulfill(value) {\n      resume(\"next\", value);\n    }\n\n    function reject(value) {\n      resume(\"throw\", value);\n    }\n\n    function settle(f, v) {\n      if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n    }\n  }\n  function __asyncDelegator(o) {\n    var i, p;\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) {\n      throw e;\n    }), verb(\"return\"), i[Symbol.iterator] = function () {\n      return this;\n    }, i;\n\n    function verb(n, f) {\n      i[n] = o[n] ? function (v) {\n        return (p = !p) ? {\n          value: __await(o[n](v)),\n          done: n === \"return\"\n        } : f ? f(v) : v;\n      } : f;\n    }\n  }\n  function __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator],\n        i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n      return this;\n    }, i);\n\n    function verb(n) {\n      i[n] = o[n] && function (v) {\n        return new Promise(function (resolve, reject) {\n          v = o[n](v), settle(resolve, reject, v.done, v.value);\n        });\n      };\n    }\n\n    function settle(resolve, reject, d, v) {\n      Promise.resolve(v).then(function (v) {\n        resolve({\n          value: v,\n          done: d\n        });\n      }, reject);\n    }\n  }\n  function __makeTemplateObject(cooked, raw) {\n    if (Object.defineProperty) {\n      Object.defineProperty(cooked, \"raw\", {\n        value: raw\n      });\n    } else {\n      cooked.raw = raw;\n    }\n\n    return cooked;\n  }\n  function __importStar(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) {\n      if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    }\n    result.default = mod;\n    return result;\n  }\n  function __importDefault(mod) {\n    return mod && mod.__esModule ? mod : {\n      default: mod\n    };\n  }\n\n  var tslib_es6 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    __extends: __extends,\n    get __assign () { return _assign; },\n    __rest: __rest,\n    __decorate: __decorate,\n    __param: __param,\n    __metadata: __metadata,\n    __awaiter: __awaiter,\n    __generator: __generator,\n    __exportStar: __exportStar,\n    __values: __values,\n    __read: __read,\n    __spread: __spread,\n    __spreadArrays: __spreadArrays,\n    __await: __await,\n    __asyncGenerator: __asyncGenerator,\n    __asyncDelegator: __asyncDelegator,\n    __asyncValues: __asyncValues,\n    __makeTemplateObject: __makeTemplateObject,\n    __importStar: __importStar,\n    __importDefault: __importDefault\n  });\n\n  var api = createCommonjsModule(function (module, exports) {\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.apiDescriptor = {\n      key: function key(_key) {\n        return /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(_key) ? _key : JSON.stringify(_key);\n      },\n      value: function value(_value) {\n        if (_value === null || _typeof(_value) !== 'object') {\n          return JSON.stringify(_value);\n        }\n\n        if (Array.isArray(_value)) {\n          return \"[\".concat(_value.map(function (subValue) {\n            return exports.apiDescriptor.value(subValue);\n          }).join(', '), \"]\");\n        }\n\n        var keys = Object.keys(_value);\n        return keys.length === 0 ? '{}' : \"{ \".concat(keys.map(function (key) {\n          return \"\".concat(exports.apiDescriptor.key(key), \": \").concat(exports.apiDescriptor.value(_value[key]));\n        }).join(', '), \" }\");\n      },\n      pair: function pair(_ref) {\n        var key = _ref.key,\n            value = _ref.value;\n        return exports.apiDescriptor.value(_defineProperty({}, key, value));\n      }\n    };\n  });\n  unwrapExports(api);\n  var api_1 = api.apiDescriptor;\n\n  var tslib_1 = getCjsExportFromNamespace(tslib_es6);\n\n  var descriptors = createCommonjsModule(function (module, exports) {\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    tslib_1.__exportStar(api, exports);\n  });\n  unwrapExports(descriptors);\n\n  var matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\n\n  var escapeStringRegexp = function escapeStringRegexp(str) {\n    if (typeof str !== 'string') {\n      throw new TypeError('Expected a string');\n    }\n\n    return str.replace(matchOperatorsRe, '\\\\$&');\n  };\n\n  var colorName = {\n    \"aliceblue\": [240, 248, 255],\n    \"antiquewhite\": [250, 235, 215],\n    \"aqua\": [0, 255, 255],\n    \"aquamarine\": [127, 255, 212],\n    \"azure\": [240, 255, 255],\n    \"beige\": [245, 245, 220],\n    \"bisque\": [255, 228, 196],\n    \"black\": [0, 0, 0],\n    \"blanchedalmond\": [255, 235, 205],\n    \"blue\": [0, 0, 255],\n    \"blueviolet\": [138, 43, 226],\n    \"brown\": [165, 42, 42],\n    \"burlywood\": [222, 184, 135],\n    \"cadetblue\": [95, 158, 160],\n    \"chartreuse\": [127, 255, 0],\n    \"chocolate\": [210, 105, 30],\n    \"coral\": [255, 127, 80],\n    \"cornflowerblue\": [100, 149, 237],\n    \"cornsilk\": [255, 248, 220],\n    \"crimson\": [220, 20, 60],\n    \"cyan\": [0, 255, 255],\n    \"darkblue\": [0, 0, 139],\n    \"darkcyan\": [0, 139, 139],\n    \"darkgoldenrod\": [184, 134, 11],\n    \"darkgray\": [169, 169, 169],\n    \"darkgreen\": [0, 100, 0],\n    \"darkgrey\": [169, 169, 169],\n    \"darkkhaki\": [189, 183, 107],\n    \"darkmagenta\": [139, 0, 139],\n    \"darkolivegreen\": [85, 107, 47],\n    \"darkorange\": [255, 140, 0],\n    \"darkorchid\": [153, 50, 204],\n    \"darkred\": [139, 0, 0],\n    \"darksalmon\": [233, 150, 122],\n    \"darkseagreen\": [143, 188, 143],\n    \"darkslateblue\": [72, 61, 139],\n    \"darkslategray\": [47, 79, 79],\n    \"darkslategrey\": [47, 79, 79],\n    \"darkturquoise\": [0, 206, 209],\n    \"darkviolet\": [148, 0, 211],\n    \"deeppink\": [255, 20, 147],\n    \"deepskyblue\": [0, 191, 255],\n    \"dimgray\": [105, 105, 105],\n    \"dimgrey\": [105, 105, 105],\n    \"dodgerblue\": [30, 144, 255],\n    \"firebrick\": [178, 34, 34],\n    \"floralwhite\": [255, 250, 240],\n    \"forestgreen\": [34, 139, 34],\n    \"fuchsia\": [255, 0, 255],\n    \"gainsboro\": [220, 220, 220],\n    \"ghostwhite\": [248, 248, 255],\n    \"gold\": [255, 215, 0],\n    \"goldenrod\": [218, 165, 32],\n    \"gray\": [128, 128, 128],\n    \"green\": [0, 128, 0],\n    \"greenyellow\": [173, 255, 47],\n    \"grey\": [128, 128, 128],\n    \"honeydew\": [240, 255, 240],\n    \"hotpink\": [255, 105, 180],\n    \"indianred\": [205, 92, 92],\n    \"indigo\": [75, 0, 130],\n    \"ivory\": [255, 255, 240],\n    \"khaki\": [240, 230, 140],\n    \"lavender\": [230, 230, 250],\n    \"lavenderblush\": [255, 240, 245],\n    \"lawngreen\": [124, 252, 0],\n    \"lemonchiffon\": [255, 250, 205],\n    \"lightblue\": [173, 216, 230],\n    \"lightcoral\": [240, 128, 128],\n    \"lightcyan\": [224, 255, 255],\n    \"lightgoldenrodyellow\": [250, 250, 210],\n    \"lightgray\": [211, 211, 211],\n    \"lightgreen\": [144, 238, 144],\n    \"lightgrey\": [211, 211, 211],\n    \"lightpink\": [255, 182, 193],\n    \"lightsalmon\": [255, 160, 122],\n    \"lightseagreen\": [32, 178, 170],\n    \"lightskyblue\": [135, 206, 250],\n    \"lightslategray\": [119, 136, 153],\n    \"lightslategrey\": [119, 136, 153],\n    \"lightsteelblue\": [176, 196, 222],\n    \"lightyellow\": [255, 255, 224],\n    \"lime\": [0, 255, 0],\n    \"limegreen\": [50, 205, 50],\n    \"linen\": [250, 240, 230],\n    \"magenta\": [255, 0, 255],\n    \"maroon\": [128, 0, 0],\n    \"mediumaquamarine\": [102, 205, 170],\n    \"mediumblue\": [0, 0, 205],\n    \"mediumorchid\": [186, 85, 211],\n    \"mediumpurple\": [147, 112, 219],\n    \"mediumseagreen\": [60, 179, 113],\n    \"mediumslateblue\": [123, 104, 238],\n    \"mediumspringgreen\": [0, 250, 154],\n    \"mediumturquoise\": [72, 209, 204],\n    \"mediumvioletred\": [199, 21, 133],\n    \"midnightblue\": [25, 25, 112],\n    \"mintcream\": [245, 255, 250],\n    \"mistyrose\": [255, 228, 225],\n    \"moccasin\": [255, 228, 181],\n    \"navajowhite\": [255, 222, 173],\n    \"navy\": [0, 0, 128],\n    \"oldlace\": [253, 245, 230],\n    \"olive\": [128, 128, 0],\n    \"olivedrab\": [107, 142, 35],\n    \"orange\": [255, 165, 0],\n    \"orangered\": [255, 69, 0],\n    \"orchid\": [218, 112, 214],\n    \"palegoldenrod\": [238, 232, 170],\n    \"palegreen\": [152, 251, 152],\n    \"paleturquoise\": [175, 238, 238],\n    \"palevioletred\": [219, 112, 147],\n    \"papayawhip\": [255, 239, 213],\n    \"peachpuff\": [255, 218, 185],\n    \"peru\": [205, 133, 63],\n    \"pink\": [255, 192, 203],\n    \"plum\": [221, 160, 221],\n    \"powderblue\": [176, 224, 230],\n    \"purple\": [128, 0, 128],\n    \"rebeccapurple\": [102, 51, 153],\n    \"red\": [255, 0, 0],\n    \"rosybrown\": [188, 143, 143],\n    \"royalblue\": [65, 105, 225],\n    \"saddlebrown\": [139, 69, 19],\n    \"salmon\": [250, 128, 114],\n    \"sandybrown\": [244, 164, 96],\n    \"seagreen\": [46, 139, 87],\n    \"seashell\": [255, 245, 238],\n    \"sienna\": [160, 82, 45],\n    \"silver\": [192, 192, 192],\n    \"skyblue\": [135, 206, 235],\n    \"slateblue\": [106, 90, 205],\n    \"slategray\": [112, 128, 144],\n    \"slategrey\": [112, 128, 144],\n    \"snow\": [255, 250, 250],\n    \"springgreen\": [0, 255, 127],\n    \"steelblue\": [70, 130, 180],\n    \"tan\": [210, 180, 140],\n    \"teal\": [0, 128, 128],\n    \"thistle\": [216, 191, 216],\n    \"tomato\": [255, 99, 71],\n    \"turquoise\": [64, 224, 208],\n    \"violet\": [238, 130, 238],\n    \"wheat\": [245, 222, 179],\n    \"white\": [255, 255, 255],\n    \"whitesmoke\": [245, 245, 245],\n    \"yellow\": [255, 255, 0],\n    \"yellowgreen\": [154, 205, 50]\n  };\n\n  var conversions = createCommonjsModule(function (module) {\n    /* MIT license */\n    // NOTE: conversions should only return primitive values (i.e. arrays, or\n    //       values that give correct `typeof` results).\n    //       do not use box values types (i.e. Number(), String(), etc.)\n    var reverseKeywords = {};\n\n    for (var key in colorName) {\n      if (colorName.hasOwnProperty(key)) {\n        reverseKeywords[colorName[key]] = key;\n      }\n    }\n\n    var convert = module.exports = {\n      rgb: {\n        channels: 3,\n        labels: 'rgb'\n      },\n      hsl: {\n        channels: 3,\n        labels: 'hsl'\n      },\n      hsv: {\n        channels: 3,\n        labels: 'hsv'\n      },\n      hwb: {\n        channels: 3,\n        labels: 'hwb'\n      },\n      cmyk: {\n        channels: 4,\n        labels: 'cmyk'\n      },\n      xyz: {\n        channels: 3,\n        labels: 'xyz'\n      },\n      lab: {\n        channels: 3,\n        labels: 'lab'\n      },\n      lch: {\n        channels: 3,\n        labels: 'lch'\n      },\n      hex: {\n        channels: 1,\n        labels: ['hex']\n      },\n      keyword: {\n        channels: 1,\n        labels: ['keyword']\n      },\n      ansi16: {\n        channels: 1,\n        labels: ['ansi16']\n      },\n      ansi256: {\n        channels: 1,\n        labels: ['ansi256']\n      },\n      hcg: {\n        channels: 3,\n        labels: ['h', 'c', 'g']\n      },\n      apple: {\n        channels: 3,\n        labels: ['r16', 'g16', 'b16']\n      },\n      gray: {\n        channels: 1,\n        labels: ['gray']\n      }\n    }; // hide .channels and .labels properties\n\n    for (var model in convert) {\n      if (convert.hasOwnProperty(model)) {\n        if (!('channels' in convert[model])) {\n          throw new Error('missing channels property: ' + model);\n        }\n\n        if (!('labels' in convert[model])) {\n          throw new Error('missing channel labels property: ' + model);\n        }\n\n        if (convert[model].labels.length !== convert[model].channels) {\n          throw new Error('channel and label counts mismatch: ' + model);\n        }\n\n        var channels = convert[model].channels;\n        var labels = convert[model].labels;\n        delete convert[model].channels;\n        delete convert[model].labels;\n        Object.defineProperty(convert[model], 'channels', {\n          value: channels\n        });\n        Object.defineProperty(convert[model], 'labels', {\n          value: labels\n        });\n      }\n    }\n\n    convert.rgb.hsl = function (rgb) {\n      var r = rgb[0] / 255;\n      var g = rgb[1] / 255;\n      var b = rgb[2] / 255;\n      var min = Math.min(r, g, b);\n      var max = Math.max(r, g, b);\n      var delta = max - min;\n      var h;\n      var s;\n      var l;\n\n      if (max === min) {\n        h = 0;\n      } else if (r === max) {\n        h = (g - b) / delta;\n      } else if (g === max) {\n        h = 2 + (b - r) / delta;\n      } else if (b === max) {\n        h = 4 + (r - g) / delta;\n      }\n\n      h = Math.min(h * 60, 360);\n\n      if (h < 0) {\n        h += 360;\n      }\n\n      l = (min + max) / 2;\n\n      if (max === min) {\n        s = 0;\n      } else if (l <= 0.5) {\n        s = delta / (max + min);\n      } else {\n        s = delta / (2 - max - min);\n      }\n\n      return [h, s * 100, l * 100];\n    };\n\n    convert.rgb.hsv = function (rgb) {\n      var r = rgb[0];\n      var g = rgb[1];\n      var b = rgb[2];\n      var min = Math.min(r, g, b);\n      var max = Math.max(r, g, b);\n      var delta = max - min;\n      var h;\n      var s;\n      var v;\n\n      if (max === 0) {\n        s = 0;\n      } else {\n        s = delta / max * 1000 / 10;\n      }\n\n      if (max === min) {\n        h = 0;\n      } else if (r === max) {\n        h = (g - b) / delta;\n      } else if (g === max) {\n        h = 2 + (b - r) / delta;\n      } else if (b === max) {\n        h = 4 + (r - g) / delta;\n      }\n\n      h = Math.min(h * 60, 360);\n\n      if (h < 0) {\n        h += 360;\n      }\n\n      v = max / 255 * 1000 / 10;\n      return [h, s, v];\n    };\n\n    convert.rgb.hwb = function (rgb) {\n      var r = rgb[0];\n      var g = rgb[1];\n      var b = rgb[2];\n      var h = convert.rgb.hsl(rgb)[0];\n      var w = 1 / 255 * Math.min(r, Math.min(g, b));\n      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\n      return [h, w * 100, b * 100];\n    };\n\n    convert.rgb.cmyk = function (rgb) {\n      var r = rgb[0] / 255;\n      var g = rgb[1] / 255;\n      var b = rgb[2] / 255;\n      var c;\n      var m;\n      var y;\n      var k;\n      k = Math.min(1 - r, 1 - g, 1 - b);\n      c = (1 - r - k) / (1 - k) || 0;\n      m = (1 - g - k) / (1 - k) || 0;\n      y = (1 - b - k) / (1 - k) || 0;\n      return [c * 100, m * 100, y * 100, k * 100];\n    };\n    /**\n     * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance\n     * */\n\n\n    function comparativeDistance(x, y) {\n      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);\n    }\n\n    convert.rgb.keyword = function (rgb) {\n      var reversed = reverseKeywords[rgb];\n\n      if (reversed) {\n        return reversed;\n      }\n\n      var currentClosestDistance = Infinity;\n      var currentClosestKeyword;\n\n      for (var keyword in colorName) {\n        if (colorName.hasOwnProperty(keyword)) {\n          var value = colorName[keyword]; // Compute comparative distance\n\n          var distance = comparativeDistance(rgb, value); // Check if its less, if so set as closest\n\n          if (distance < currentClosestDistance) {\n            currentClosestDistance = distance;\n            currentClosestKeyword = keyword;\n          }\n        }\n      }\n\n      return currentClosestKeyword;\n    };\n\n    convert.keyword.rgb = function (keyword) {\n      return colorName[keyword];\n    };\n\n    convert.rgb.xyz = function (rgb) {\n      var r = rgb[0] / 255;\n      var g = rgb[1] / 255;\n      var b = rgb[2] / 255; // assume sRGB\n\n      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;\n      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;\n      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;\n      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;\n      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;\n      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;\n      return [x * 100, y * 100, z * 100];\n    };\n\n    convert.rgb.lab = function (rgb) {\n      var xyz = convert.rgb.xyz(rgb);\n      var x = xyz[0];\n      var y = xyz[1];\n      var z = xyz[2];\n      var l;\n      var a;\n      var b;\n      x /= 95.047;\n      y /= 100;\n      z /= 108.883;\n      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;\n      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;\n      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;\n      l = 116 * y - 16;\n      a = 500 * (x - y);\n      b = 200 * (y - z);\n      return [l, a, b];\n    };\n\n    convert.hsl.rgb = function (hsl) {\n      var h = hsl[0] / 360;\n      var s = hsl[1] / 100;\n      var l = hsl[2] / 100;\n      var t1;\n      var t2;\n      var t3;\n      var rgb;\n      var val;\n\n      if (s === 0) {\n        val = l * 255;\n        return [val, val, val];\n      }\n\n      if (l < 0.5) {\n        t2 = l * (1 + s);\n      } else {\n        t2 = l + s - l * s;\n      }\n\n      t1 = 2 * l - t2;\n      rgb = [0, 0, 0];\n\n      for (var i = 0; i < 3; i++) {\n        t3 = h + 1 / 3 * -(i - 1);\n\n        if (t3 < 0) {\n          t3++;\n        }\n\n        if (t3 > 1) {\n          t3--;\n        }\n\n        if (6 * t3 < 1) {\n          val = t1 + (t2 - t1) * 6 * t3;\n        } else if (2 * t3 < 1) {\n          val = t2;\n        } else if (3 * t3 < 2) {\n          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n        } else {\n          val = t1;\n        }\n\n        rgb[i] = val * 255;\n      }\n\n      return rgb;\n    };\n\n    convert.hsl.hsv = function (hsl) {\n      var h = hsl[0];\n      var s = hsl[1] / 100;\n      var l = hsl[2] / 100;\n      var smin = s;\n      var lmin = Math.max(l, 0.01);\n      var sv;\n      var v;\n      l *= 2;\n      s *= l <= 1 ? l : 2 - l;\n      smin *= lmin <= 1 ? lmin : 2 - lmin;\n      v = (l + s) / 2;\n      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);\n      return [h, sv * 100, v * 100];\n    };\n\n    convert.hsv.rgb = function (hsv) {\n      var h = hsv[0] / 60;\n      var s = hsv[1] / 100;\n      var v = hsv[2] / 100;\n      var hi = Math.floor(h) % 6;\n      var f = h - Math.floor(h);\n      var p = 255 * v * (1 - s);\n      var q = 255 * v * (1 - s * f);\n      var t = 255 * v * (1 - s * (1 - f));\n      v *= 255;\n\n      switch (hi) {\n        case 0:\n          return [v, t, p];\n\n        case 1:\n          return [q, v, p];\n\n        case 2:\n          return [p, v, t];\n\n        case 3:\n          return [p, q, v];\n\n        case 4:\n          return [t, p, v];\n\n        case 5:\n          return [v, p, q];\n      }\n    };\n\n    convert.hsv.hsl = function (hsv) {\n      var h = hsv[0];\n      var s = hsv[1] / 100;\n      var v = hsv[2] / 100;\n      var vmin = Math.max(v, 0.01);\n      var lmin;\n      var sl;\n      var l;\n      l = (2 - s) * v;\n      lmin = (2 - s) * vmin;\n      sl = s * vmin;\n      sl /= lmin <= 1 ? lmin : 2 - lmin;\n      sl = sl || 0;\n      l /= 2;\n      return [h, sl * 100, l * 100];\n    }; // http://dev.w3.org/csswg/css-color/#hwb-to-rgb\n\n\n    convert.hwb.rgb = function (hwb) {\n      var h = hwb[0] / 360;\n      var wh = hwb[1] / 100;\n      var bl = hwb[2] / 100;\n      var ratio = wh + bl;\n      var i;\n      var v;\n      var f;\n      var n; // wh + bl cant be > 1\n\n      if (ratio > 1) {\n        wh /= ratio;\n        bl /= ratio;\n      }\n\n      i = Math.floor(6 * h);\n      v = 1 - bl;\n      f = 6 * h - i;\n\n      if ((i & 0x01) !== 0) {\n        f = 1 - f;\n      }\n\n      n = wh + f * (v - wh); // linear interpolation\n\n      var r;\n      var g;\n      var b;\n\n      switch (i) {\n        default:\n        case 6:\n        case 0:\n          r = v;\n          g = n;\n          b = wh;\n          break;\n\n        case 1:\n          r = n;\n          g = v;\n          b = wh;\n          break;\n\n        case 2:\n          r = wh;\n          g = v;\n          b = n;\n          break;\n\n        case 3:\n          r = wh;\n          g = n;\n          b = v;\n          break;\n\n        case 4:\n          r = n;\n          g = wh;\n          b = v;\n          break;\n\n        case 5:\n          r = v;\n          g = wh;\n          b = n;\n          break;\n      }\n\n      return [r * 255, g * 255, b * 255];\n    };\n\n    convert.cmyk.rgb = function (cmyk) {\n      var c = cmyk[0] / 100;\n      var m = cmyk[1] / 100;\n      var y = cmyk[2] / 100;\n      var k = cmyk[3] / 100;\n      var r;\n      var g;\n      var b;\n      r = 1 - Math.min(1, c * (1 - k) + k);\n      g = 1 - Math.min(1, m * (1 - k) + k);\n      b = 1 - Math.min(1, y * (1 - k) + k);\n      return [r * 255, g * 255, b * 255];\n    };\n\n    convert.xyz.rgb = function (xyz) {\n      var x = xyz[0] / 100;\n      var y = xyz[1] / 100;\n      var z = xyz[2] / 100;\n      var r;\n      var g;\n      var b;\n      r = x * 3.2406 + y * -1.5372 + z * -0.4986;\n      g = x * -0.9689 + y * 1.8758 + z * 0.0415;\n      b = x * 0.0557 + y * -0.2040 + z * 1.0570; // assume sRGB\n\n      r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r * 12.92;\n      g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g * 12.92;\n      b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b * 12.92;\n      r = Math.min(Math.max(0, r), 1);\n      g = Math.min(Math.max(0, g), 1);\n      b = Math.min(Math.max(0, b), 1);\n      return [r * 255, g * 255, b * 255];\n    };\n\n    convert.xyz.lab = function (xyz) {\n      var x = xyz[0];\n      var y = xyz[1];\n      var z = xyz[2];\n      var l;\n      var a;\n      var b;\n      x /= 95.047;\n      y /= 100;\n      z /= 108.883;\n      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;\n      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;\n      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;\n      l = 116 * y - 16;\n      a = 500 * (x - y);\n      b = 200 * (y - z);\n      return [l, a, b];\n    };\n\n    convert.lab.xyz = function (lab) {\n      var l = lab[0];\n      var a = lab[1];\n      var b = lab[2];\n      var x;\n      var y;\n      var z;\n      y = (l + 16) / 116;\n      x = a / 500 + y;\n      z = y - b / 200;\n      var y2 = Math.pow(y, 3);\n      var x2 = Math.pow(x, 3);\n      var z2 = Math.pow(z, 3);\n      y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;\n      x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;\n      z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;\n      x *= 95.047;\n      y *= 100;\n      z *= 108.883;\n      return [x, y, z];\n    };\n\n    convert.lab.lch = function (lab) {\n      var l = lab[0];\n      var a = lab[1];\n      var b = lab[2];\n      var hr;\n      var h;\n      var c;\n      hr = Math.atan2(b, a);\n      h = hr * 360 / 2 / Math.PI;\n\n      if (h < 0) {\n        h += 360;\n      }\n\n      c = Math.sqrt(a * a + b * b);\n      return [l, c, h];\n    };\n\n    convert.lch.lab = function (lch) {\n      var l = lch[0];\n      var c = lch[1];\n      var h = lch[2];\n      var a;\n      var b;\n      var hr;\n      hr = h / 360 * 2 * Math.PI;\n      a = c * Math.cos(hr);\n      b = c * Math.sin(hr);\n      return [l, a, b];\n    };\n\n    convert.rgb.ansi16 = function (args) {\n      var r = args[0];\n      var g = args[1];\n      var b = args[2];\n      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization\n\n      value = Math.round(value / 50);\n\n      if (value === 0) {\n        return 30;\n      }\n\n      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));\n\n      if (value === 2) {\n        ansi += 60;\n      }\n\n      return ansi;\n    };\n\n    convert.hsv.ansi16 = function (args) {\n      // optimization here; we already know the value and don't need to get\n      // it converted for us.\n      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\n    };\n\n    convert.rgb.ansi256 = function (args) {\n      var r = args[0];\n      var g = args[1];\n      var b = args[2]; // we use the extended greyscale palette here, with the exception of\n      // black and white. normal palette only has 4 greyscale shades.\n\n      if (r === g && g === b) {\n        if (r < 8) {\n          return 16;\n        }\n\n        if (r > 248) {\n          return 231;\n        }\n\n        return Math.round((r - 8) / 247 * 24) + 232;\n      }\n\n      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);\n      return ansi;\n    };\n\n    convert.ansi16.rgb = function (args) {\n      var color = args % 10; // handle greyscale\n\n      if (color === 0 || color === 7) {\n        if (args > 50) {\n          color += 3.5;\n        }\n\n        color = color / 10.5 * 255;\n        return [color, color, color];\n      }\n\n      var mult = (~~(args > 50) + 1) * 0.5;\n      var r = (color & 1) * mult * 255;\n      var g = (color >> 1 & 1) * mult * 255;\n      var b = (color >> 2 & 1) * mult * 255;\n      return [r, g, b];\n    };\n\n    convert.ansi256.rgb = function (args) {\n      // handle greyscale\n      if (args >= 232) {\n        var c = (args - 232) * 10 + 8;\n        return [c, c, c];\n      }\n\n      args -= 16;\n      var rem;\n      var r = Math.floor(args / 36) / 5 * 255;\n      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;\n      var b = rem % 6 / 5 * 255;\n      return [r, g, b];\n    };\n\n    convert.rgb.hex = function (args) {\n      var integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);\n      var string = integer.toString(16).toUpperCase();\n      return '000000'.substring(string.length) + string;\n    };\n\n    convert.hex.rgb = function (args) {\n      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n\n      if (!match) {\n        return [0, 0, 0];\n      }\n\n      var colorString = match[0];\n\n      if (match[0].length === 3) {\n        colorString = colorString.split('').map(function (char) {\n          return char + char;\n        }).join('');\n      }\n\n      var integer = parseInt(colorString, 16);\n      var r = integer >> 16 & 0xFF;\n      var g = integer >> 8 & 0xFF;\n      var b = integer & 0xFF;\n      return [r, g, b];\n    };\n\n    convert.rgb.hcg = function (rgb) {\n      var r = rgb[0] / 255;\n      var g = rgb[1] / 255;\n      var b = rgb[2] / 255;\n      var max = Math.max(Math.max(r, g), b);\n      var min = Math.min(Math.min(r, g), b);\n      var chroma = max - min;\n      var grayscale;\n      var hue;\n\n      if (chroma < 1) {\n        grayscale = min / (1 - chroma);\n      } else {\n        grayscale = 0;\n      }\n\n      if (chroma <= 0) {\n        hue = 0;\n      } else if (max === r) {\n        hue = (g - b) / chroma % 6;\n      } else if (max === g) {\n        hue = 2 + (b - r) / chroma;\n      } else {\n        hue = 4 + (r - g) / chroma + 4;\n      }\n\n      hue /= 6;\n      hue %= 1;\n      return [hue * 360, chroma * 100, grayscale * 100];\n    };\n\n    convert.hsl.hcg = function (hsl) {\n      var s = hsl[1] / 100;\n      var l = hsl[2] / 100;\n      var c = 1;\n      var f = 0;\n\n      if (l < 0.5) {\n        c = 2.0 * s * l;\n      } else {\n        c = 2.0 * s * (1.0 - l);\n      }\n\n      if (c < 1.0) {\n        f = (l - 0.5 * c) / (1.0 - c);\n      }\n\n      return [hsl[0], c * 100, f * 100];\n    };\n\n    convert.hsv.hcg = function (hsv) {\n      var s = hsv[1] / 100;\n      var v = hsv[2] / 100;\n      var c = s * v;\n      var f = 0;\n\n      if (c < 1.0) {\n        f = (v - c) / (1 - c);\n      }\n\n      return [hsv[0], c * 100, f * 100];\n    };\n\n    convert.hcg.rgb = function (hcg) {\n      var h = hcg[0] / 360;\n      var c = hcg[1] / 100;\n      var g = hcg[2] / 100;\n\n      if (c === 0.0) {\n        return [g * 255, g * 255, g * 255];\n      }\n\n      var pure = [0, 0, 0];\n      var hi = h % 1 * 6;\n      var v = hi % 1;\n      var w = 1 - v;\n      var mg = 0;\n\n      switch (Math.floor(hi)) {\n        case 0:\n          pure[0] = 1;\n          pure[1] = v;\n          pure[2] = 0;\n          break;\n\n        case 1:\n          pure[0] = w;\n          pure[1] = 1;\n          pure[2] = 0;\n          break;\n\n        case 2:\n          pure[0] = 0;\n          pure[1] = 1;\n          pure[2] = v;\n          break;\n\n        case 3:\n          pure[0] = 0;\n          pure[1] = w;\n          pure[2] = 1;\n          break;\n\n        case 4:\n          pure[0] = v;\n          pure[1] = 0;\n          pure[2] = 1;\n          break;\n\n        default:\n          pure[0] = 1;\n          pure[1] = 0;\n          pure[2] = w;\n      }\n\n      mg = (1.0 - c) * g;\n      return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];\n    };\n\n    convert.hcg.hsv = function (hcg) {\n      var c = hcg[1] / 100;\n      var g = hcg[2] / 100;\n      var v = c + g * (1.0 - c);\n      var f = 0;\n\n      if (v > 0.0) {\n        f = c / v;\n      }\n\n      return [hcg[0], f * 100, v * 100];\n    };\n\n    convert.hcg.hsl = function (hcg) {\n      var c = hcg[1] / 100;\n      var g = hcg[2] / 100;\n      var l = g * (1.0 - c) + 0.5 * c;\n      var s = 0;\n\n      if (l > 0.0 && l < 0.5) {\n        s = c / (2 * l);\n      } else if (l >= 0.5 && l < 1.0) {\n        s = c / (2 * (1 - l));\n      }\n\n      return [hcg[0], s * 100, l * 100];\n    };\n\n    convert.hcg.hwb = function (hcg) {\n      var c = hcg[1] / 100;\n      var g = hcg[2] / 100;\n      var v = c + g * (1.0 - c);\n      return [hcg[0], (v - c) * 100, (1 - v) * 100];\n    };\n\n    convert.hwb.hcg = function (hwb) {\n      var w = hwb[1] / 100;\n      var b = hwb[2] / 100;\n      var v = 1 - b;\n      var c = v - w;\n      var g = 0;\n\n      if (c < 1) {\n        g = (v - c) / (1 - c);\n      }\n\n      return [hwb[0], c * 100, g * 100];\n    };\n\n    convert.apple.rgb = function (apple) {\n      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];\n    };\n\n    convert.rgb.apple = function (rgb) {\n      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];\n    };\n\n    convert.gray.rgb = function (args) {\n      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];\n    };\n\n    convert.gray.hsl = convert.gray.hsv = function (args) {\n      return [0, 0, args[0]];\n    };\n\n    convert.gray.hwb = function (gray) {\n      return [0, 100, gray[0]];\n    };\n\n    convert.gray.cmyk = function (gray) {\n      return [0, 0, 0, gray[0]];\n    };\n\n    convert.gray.lab = function (gray) {\n      return [gray[0], 0, 0];\n    };\n\n    convert.gray.hex = function (gray) {\n      var val = Math.round(gray[0] / 100 * 255) & 0xFF;\n      var integer = (val << 16) + (val << 8) + val;\n      var string = integer.toString(16).toUpperCase();\n      return '000000'.substring(string.length) + string;\n    };\n\n    convert.rgb.gray = function (rgb) {\n      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;\n      return [val / 255 * 100];\n    };\n  });\n  var conversions_1 = conversions.rgb;\n  var conversions_2 = conversions.hsl;\n  var conversions_3 = conversions.hsv;\n  var conversions_4 = conversions.hwb;\n  var conversions_5 = conversions.cmyk;\n  var conversions_6 = conversions.xyz;\n  var conversions_7 = conversions.lab;\n  var conversions_8 = conversions.lch;\n  var conversions_9 = conversions.hex;\n  var conversions_10 = conversions.keyword;\n  var conversions_11 = conversions.ansi16;\n  var conversions_12 = conversions.ansi256;\n  var conversions_13 = conversions.hcg;\n  var conversions_14 = conversions.apple;\n  var conversions_15 = conversions.gray;\n\n  /*\n  \tthis function routes a model to all other models.\n\n  \tall functions that are routed have a property `.conversion` attached\n  \tto the returned synthetic function. This property is an array\n  \tof strings, each with the steps in between the 'from' and 'to'\n  \tcolor models (inclusive).\n\n  \tconversions that are not possible simply are not included.\n  */\n  // https://jsperf.com/object-keys-vs-for-in-with-closure/3\n\n  var models = Object.keys(conversions);\n\n  function buildGraph() {\n    var graph = {};\n\n    for (var len = models.length, i = 0; i < len; i++) {\n      graph[models[i]] = {\n        // http://jsperf.com/1-vs-infinity\n        // micro-opt, but this is simple.\n        distance: -1,\n        parent: null\n      };\n    }\n\n    return graph;\n  } // https://en.wikipedia.org/wiki/Breadth-first_search\n\n\n  function deriveBFS(fromModel) {\n    var graph = buildGraph();\n    var queue = [fromModel]; // unshift -> queue -> pop\n\n    graph[fromModel].distance = 0;\n\n    while (queue.length) {\n      var current = queue.pop();\n      var adjacents = Object.keys(conversions[current]);\n\n      for (var len = adjacents.length, i = 0; i < len; i++) {\n        var adjacent = adjacents[i];\n        var node = graph[adjacent];\n\n        if (node.distance === -1) {\n          node.distance = graph[current].distance + 1;\n          node.parent = current;\n          queue.unshift(adjacent);\n        }\n      }\n    }\n\n    return graph;\n  }\n\n  function link(from, to) {\n    return function (args) {\n      return to(from(args));\n    };\n  }\n\n  function wrapConversion(toModel, graph) {\n    var path = [graph[toModel].parent, toModel];\n    var fn = conversions[graph[toModel].parent][toModel];\n    var cur = graph[toModel].parent;\n\n    while (graph[cur].parent) {\n      path.unshift(graph[cur].parent);\n      fn = link(conversions[graph[cur].parent][cur], fn);\n      cur = graph[cur].parent;\n    }\n\n    fn.conversion = path;\n    return fn;\n  }\n\n  var route = function route(fromModel) {\n    var graph = deriveBFS(fromModel);\n    var conversion = {};\n    var models = Object.keys(graph);\n\n    for (var len = models.length, i = 0; i < len; i++) {\n      var toModel = models[i];\n      var node = graph[toModel];\n\n      if (node.parent === null) {\n        // no possible conversion, or this node is the source model.\n        continue;\n      }\n\n      conversion[toModel] = wrapConversion(toModel, graph);\n    }\n\n    return conversion;\n  };\n\n  var convert = {};\n  var models$1 = Object.keys(conversions);\n\n  function wrapRaw(fn) {\n    var wrappedFn = function wrappedFn(args) {\n      if (args === undefined || args === null) {\n        return args;\n      }\n\n      if (arguments.length > 1) {\n        args = Array.prototype.slice.call(arguments);\n      }\n\n      return fn(args);\n    }; // preserve .conversion property if there is one\n\n\n    if ('conversion' in fn) {\n      wrappedFn.conversion = fn.conversion;\n    }\n\n    return wrappedFn;\n  }\n\n  function wrapRounded(fn) {\n    var wrappedFn = function wrappedFn(args) {\n      if (args === undefined || args === null) {\n        return args;\n      }\n\n      if (arguments.length > 1) {\n        args = Array.prototype.slice.call(arguments);\n      }\n\n      var result = fn(args); // we're assuming the result is an array here.\n      // see notice in conversions.js; don't use box types\n      // in conversion functions.\n\n      if (_typeof(result) === 'object') {\n        for (var len = result.length, i = 0; i < len; i++) {\n          result[i] = Math.round(result[i]);\n        }\n      }\n\n      return result;\n    }; // preserve .conversion property if there is one\n\n\n    if ('conversion' in fn) {\n      wrappedFn.conversion = fn.conversion;\n    }\n\n    return wrappedFn;\n  }\n\n  models$1.forEach(function (fromModel) {\n    convert[fromModel] = {};\n    Object.defineProperty(convert[fromModel], 'channels', {\n      value: conversions[fromModel].channels\n    });\n    Object.defineProperty(convert[fromModel], 'labels', {\n      value: conversions[fromModel].labels\n    });\n    var routes = route(fromModel);\n    var routeModels = Object.keys(routes);\n    routeModels.forEach(function (toModel) {\n      var fn = routes[toModel];\n      convert[fromModel][toModel] = wrapRounded(fn);\n      convert[fromModel][toModel].raw = wrapRaw(fn);\n    });\n  });\n  var colorConvert = convert;\n\n  var ansiStyles = createCommonjsModule(function (module) {\n\n    var wrapAnsi16 = function wrapAnsi16(fn, offset) {\n      return function () {\n        var code = fn.apply(colorConvert, arguments);\n        return \"\\x1B[\".concat(code + offset, \"m\");\n      };\n    };\n\n    var wrapAnsi256 = function wrapAnsi256(fn, offset) {\n      return function () {\n        var code = fn.apply(colorConvert, arguments);\n        return \"\\x1B[\".concat(38 + offset, \";5;\").concat(code, \"m\");\n      };\n    };\n\n    var wrapAnsi16m = function wrapAnsi16m(fn, offset) {\n      return function () {\n        var rgb = fn.apply(colorConvert, arguments);\n        return \"\\x1B[\".concat(38 + offset, \";2;\").concat(rgb[0], \";\").concat(rgb[1], \";\").concat(rgb[2], \"m\");\n      };\n    };\n\n    function assembleStyles() {\n      var codes = new Map();\n      var styles = {\n        modifier: {\n          reset: [0, 0],\n          // 21 isn't widely supported and 22 does the same thing\n          bold: [1, 22],\n          dim: [2, 22],\n          italic: [3, 23],\n          underline: [4, 24],\n          inverse: [7, 27],\n          hidden: [8, 28],\n          strikethrough: [9, 29]\n        },\n        color: {\n          black: [30, 39],\n          red: [31, 39],\n          green: [32, 39],\n          yellow: [33, 39],\n          blue: [34, 39],\n          magenta: [35, 39],\n          cyan: [36, 39],\n          white: [37, 39],\n          gray: [90, 39],\n          // Bright color\n          redBright: [91, 39],\n          greenBright: [92, 39],\n          yellowBright: [93, 39],\n          blueBright: [94, 39],\n          magentaBright: [95, 39],\n          cyanBright: [96, 39],\n          whiteBright: [97, 39]\n        },\n        bgColor: {\n          bgBlack: [40, 49],\n          bgRed: [41, 49],\n          bgGreen: [42, 49],\n          bgYellow: [43, 49],\n          bgBlue: [44, 49],\n          bgMagenta: [45, 49],\n          bgCyan: [46, 49],\n          bgWhite: [47, 49],\n          // Bright color\n          bgBlackBright: [100, 49],\n          bgRedBright: [101, 49],\n          bgGreenBright: [102, 49],\n          bgYellowBright: [103, 49],\n          bgBlueBright: [104, 49],\n          bgMagentaBright: [105, 49],\n          bgCyanBright: [106, 49],\n          bgWhiteBright: [107, 49]\n        }\n      }; // Fix humans\n\n      styles.color.grey = styles.color.gray;\n\n      for (var _i = 0, _Object$keys = Object.keys(styles); _i < _Object$keys.length; _i++) {\n        var groupName = _Object$keys[_i];\n        var group = styles[groupName];\n\n        for (var _i3 = 0, _Object$keys3 = Object.keys(group); _i3 < _Object$keys3.length; _i3++) {\n          var styleName = _Object$keys3[_i3];\n          var style = group[styleName];\n          styles[styleName] = {\n            open: \"\\x1B[\".concat(style[0], \"m\"),\n            close: \"\\x1B[\".concat(style[1], \"m\")\n          };\n          group[styleName] = styles[styleName];\n          codes.set(style[0], style[1]);\n        }\n\n        Object.defineProperty(styles, groupName, {\n          value: group,\n          enumerable: false\n        });\n        Object.defineProperty(styles, 'codes', {\n          value: codes,\n          enumerable: false\n        });\n      }\n\n      var ansi2ansi = function ansi2ansi(n) {\n        return n;\n      };\n\n      var rgb2rgb = function rgb2rgb(r, g, b) {\n        return [r, g, b];\n      };\n\n      styles.color.close = \"\\x1B[39m\";\n      styles.bgColor.close = \"\\x1B[49m\";\n      styles.color.ansi = {\n        ansi: wrapAnsi16(ansi2ansi, 0)\n      };\n      styles.color.ansi256 = {\n        ansi256: wrapAnsi256(ansi2ansi, 0)\n      };\n      styles.color.ansi16m = {\n        rgb: wrapAnsi16m(rgb2rgb, 0)\n      };\n      styles.bgColor.ansi = {\n        ansi: wrapAnsi16(ansi2ansi, 10)\n      };\n      styles.bgColor.ansi256 = {\n        ansi256: wrapAnsi256(ansi2ansi, 10)\n      };\n      styles.bgColor.ansi16m = {\n        rgb: wrapAnsi16m(rgb2rgb, 10)\n      };\n\n      for (var _i2 = 0, _Object$keys2 = Object.keys(colorConvert); _i2 < _Object$keys2.length; _i2++) {\n        var key = _Object$keys2[_i2];\n\n        if (_typeof(colorConvert[key]) !== 'object') {\n          continue;\n        }\n\n        var suite = colorConvert[key];\n\n        if (key === 'ansi16') {\n          key = 'ansi';\n        }\n\n        if ('ansi16' in suite) {\n          styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);\n          styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);\n        }\n\n        if ('ansi256' in suite) {\n          styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);\n          styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);\n        }\n\n        if ('rgb' in suite) {\n          styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);\n          styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);\n        }\n      }\n\n      return styles;\n    } // Make the export immutable\n\n\n    Object.defineProperty(module, 'exports', {\n      enumerable: true,\n      get: assembleStyles\n    });\n  });\n\n  var require$$0$1 = {\n    EOL: \"\\n\"\n  };\n\n  var hasFlag = function hasFlag(flag, argv) {\n    argv = argv || process.argv;\n    var prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';\n    var pos = argv.indexOf(prefix + flag);\n    var terminatorPos = argv.indexOf('--');\n    return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);\n  };\n\n  var env$1 = process.env;\n  var forceColor;\n\n  if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) {\n    forceColor = false;\n  } else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {\n    forceColor = true;\n  }\n\n  if ('FORCE_COLOR' in env$1) {\n    forceColor = env$1.FORCE_COLOR.length === 0 || parseInt(env$1.FORCE_COLOR, 10) !== 0;\n  }\n\n  function translateLevel(level) {\n    if (level === 0) {\n      return false;\n    }\n\n    return {\n      level: level,\n      hasBasic: true,\n      has256: level >= 2,\n      has16m: level >= 3\n    };\n  }\n\n  function supportsColor(stream) {\n    if (forceColor === false) {\n      return 0;\n    }\n\n    if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {\n      return 3;\n    }\n\n    if (hasFlag('color=256')) {\n      return 2;\n    }\n\n    if (stream && !stream.isTTY && forceColor !== true) {\n      return 0;\n    }\n\n    var min = forceColor ? 1 : 0;\n\n    if (process.platform === 'win32') {\n      // Node.js 7.5.0 is the first version of Node.js to include a patch to\n      // libuv that enables 256 color output on Windows. Anything earlier and it\n      // won't work. However, here we target Node.js 8 at minimum as it is an LTS\n      // release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows\n      // release that supports 256 colors. Windows 10 build 14931 is the first release\n      // that supports 16m/TrueColor.\n      var osRelease = require$$0$1.release().split('.');\n\n      if (Number(process.versions.node.split('.')[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {\n        return Number(osRelease[2]) >= 14931 ? 3 : 2;\n      }\n\n      return 1;\n    }\n\n    if ('CI' in env$1) {\n      if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(function (sign) {\n        return sign in env$1;\n      }) || env$1.CI_NAME === 'codeship') {\n        return 1;\n      }\n\n      return min;\n    }\n\n    if ('TEAMCITY_VERSION' in env$1) {\n      return /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env$1.TEAMCITY_VERSION) ? 1 : 0;\n    }\n\n    if (env$1.COLORTERM === 'truecolor') {\n      return 3;\n    }\n\n    if ('TERM_PROGRAM' in env$1) {\n      var version = parseInt((env$1.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n      switch (env$1.TERM_PROGRAM) {\n        case 'iTerm.app':\n          return version >= 3 ? 3 : 2;\n\n        case 'Apple_Terminal':\n          return 2;\n        // No default\n      }\n    }\n\n    if (/-256(color)?$/i.test(env$1.TERM)) {\n      return 2;\n    }\n\n    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env$1.TERM)) {\n      return 1;\n    }\n\n    if ('COLORTERM' in env$1) {\n      return 1;\n    }\n\n    if (env$1.TERM === 'dumb') {\n      return min;\n    }\n\n    return min;\n  }\n\n  function getSupportLevel(stream) {\n    var level = supportsColor(stream);\n    return translateLevel(level);\n  }\n\n  var supportsColor_1 = {\n    supportsColor: getSupportLevel,\n    stdout: getSupportLevel(process.stdout),\n    stderr: getSupportLevel(process.stderr)\n  };\n\n  var TEMPLATE_REGEX = /(?:\\\\(u[a-f\\d]{4}|x[a-f\\d]{2}|.))|(?:\\{(~)?(\\w+(?:\\([^)]*\\))?(?:\\.\\w+(?:\\([^)]*\\))?)*)(?:[ \\t]|(?=\\r?\\n)))|(\\})|((?:.|[\\r\\n\\f])+?)/gi;\n  var STYLE_REGEX = /(?:^|\\.)(\\w+)(?:\\(([^)]*)\\))?/g;\n  var STRING_REGEX = /^(['\"])((?:\\\\.|(?!\\1)[^\\\\])*)\\1$/;\n  var ESCAPE_REGEX = /\\\\(u[a-f\\d]{4}|x[a-f\\d]{2}|.)|([^\\\\])/gi;\n  var ESCAPES = new Map([['n', '\\n'], ['r', '\\r'], ['t', '\\t'], ['b', '\\b'], ['f', '\\f'], ['v', '\\v'], ['0', '\\0'], ['\\\\', '\\\\'], ['e', \"\\x1B\"], ['a', \"\\x07\"]]);\n\n  function unescape(c) {\n    if (c[0] === 'u' && c.length === 5 || c[0] === 'x' && c.length === 3) {\n      return String.fromCharCode(parseInt(c.slice(1), 16));\n    }\n\n    return ESCAPES.get(c) || c;\n  }\n\n  function parseArguments(name, args) {\n    var results = [];\n    var chunks = args.trim().split(/\\s*,\\s*/g);\n    var matches;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = chunks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var chunk = _step.value;\n\n        if (!isNaN(chunk)) {\n          results.push(Number(chunk));\n        } else if (matches = chunk.match(STRING_REGEX)) {\n          results.push(matches[2].replace(ESCAPE_REGEX, function (m, escape, chr) {\n            return escape ? unescape(escape) : chr;\n          }));\n        } else {\n          throw new Error(\"Invalid Chalk template style argument: \".concat(chunk, \" (in style '\").concat(name, \"')\"));\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return results;\n  }\n\n  function parseStyle(style) {\n    STYLE_REGEX.lastIndex = 0;\n    var results = [];\n    var matches;\n\n    while ((matches = STYLE_REGEX.exec(style)) !== null) {\n      var name = matches[1];\n\n      if (matches[2]) {\n        var args = parseArguments(name, matches[2]);\n        results.push([name].concat(args));\n      } else {\n        results.push([name]);\n      }\n    }\n\n    return results;\n  }\n\n  function buildStyle(chalk, styles) {\n    var enabled = {};\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = styles[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var layer = _step2.value;\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = layer.styles[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var style = _step3.value;\n            enabled[style[0]] = layer.inverse ? null : style.slice(1);\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    var current = chalk;\n\n    for (var _i = 0, _Object$keys = Object.keys(enabled); _i < _Object$keys.length; _i++) {\n      var styleName = _Object$keys[_i];\n\n      if (Array.isArray(enabled[styleName])) {\n        if (!(styleName in current)) {\n          throw new Error(\"Unknown Chalk style: \".concat(styleName));\n        }\n\n        if (enabled[styleName].length > 0) {\n          current = current[styleName].apply(current, enabled[styleName]);\n        } else {\n          current = current[styleName];\n        }\n      }\n    }\n\n    return current;\n  }\n\n  var templates = function templates(chalk, tmp) {\n    var styles = [];\n    var chunks = [];\n    var chunk = []; // eslint-disable-next-line max-params\n\n    tmp.replace(TEMPLATE_REGEX, function (m, escapeChar, inverse, style, close, chr) {\n      if (escapeChar) {\n        chunk.push(unescape(escapeChar));\n      } else if (style) {\n        var str = chunk.join('');\n        chunk = [];\n        chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));\n        styles.push({\n          inverse: inverse,\n          styles: parseStyle(style)\n        });\n      } else if (close) {\n        if (styles.length === 0) {\n          throw new Error('Found extraneous } in Chalk template literal');\n        }\n\n        chunks.push(buildStyle(chalk, styles)(chunk.join('')));\n        chunk = [];\n        styles.pop();\n      } else {\n        chunk.push(chr);\n      }\n    });\n    chunks.push(chunk.join(''));\n\n    if (styles.length > 0) {\n      var errMsg = \"Chalk template literal is missing \".concat(styles.length, \" closing bracket\").concat(styles.length === 1 ? '' : 's', \" (`}`)\");\n      throw new Error(errMsg);\n    }\n\n    return chunks.join('');\n  };\n\n  var chalk = createCommonjsModule(function (module) {\n\n    var stdoutColor = supportsColor_1.stdout;\n    var isSimpleWindowsTerm = process.platform === 'win32' && !(process.env.TERM || '').toLowerCase().startsWith('xterm'); // `supportsColor.level` → `ansiStyles.color[name]` mapping\n\n    var levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m']; // `color-convert` models to exclude from the Chalk API due to conflicts and such\n\n    var skipModels = new Set(['gray']);\n    var styles = Object.create(null);\n\n    function applyOptions(obj, options) {\n      options = options || {}; // Detect level if not set manually\n\n      var scLevel = stdoutColor ? stdoutColor.level : 0;\n      obj.level = options.level === undefined ? scLevel : options.level;\n      obj.enabled = 'enabled' in options ? options.enabled : obj.level > 0;\n    }\n\n    function Chalk(options) {\n      // We check for this.template here since calling `chalk.constructor()`\n      // by itself will have a `this` of a previously constructed chalk object\n      if (!this || !(this instanceof Chalk) || this.template) {\n        var _chalk = {};\n        applyOptions(_chalk, options);\n\n        _chalk.template = function () {\n          var args = [].slice.call(arguments);\n          return chalkTag.apply(null, [_chalk.template].concat(args));\n        };\n\n        Object.setPrototypeOf(_chalk, Chalk.prototype);\n        Object.setPrototypeOf(_chalk.template, _chalk);\n        _chalk.template.constructor = Chalk;\n        return _chalk.template;\n      }\n\n      applyOptions(this, options);\n    } // Use bright blue on Windows as the normal blue color is illegible\n\n\n    if (isSimpleWindowsTerm) {\n      ansiStyles.blue.open = \"\\x1B[94m\";\n    }\n\n    var _loop = function _loop() {\n      var key = _Object$keys[_i];\n      ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');\n      styles[key] = {\n        get: function get() {\n          var codes = ansiStyles[key];\n          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);\n        }\n      };\n    };\n\n    for (var _i = 0, _Object$keys = Object.keys(ansiStyles); _i < _Object$keys.length; _i++) {\n      _loop();\n    }\n\n    styles.visible = {\n      get: function get() {\n        return build.call(this, this._styles || [], true, 'visible');\n      }\n    };\n    ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), 'g');\n\n    var _loop2 = function _loop2() {\n      var model = _Object$keys2[_i2];\n\n      if (skipModels.has(model)) {\n        return \"continue\";\n      }\n\n      styles[model] = {\n        get: function get() {\n          var level = this.level;\n          return function () {\n            var open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);\n            var codes = {\n              open: open,\n              close: ansiStyles.color.close,\n              closeRe: ansiStyles.color.closeRe\n            };\n            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);\n          };\n        }\n      };\n    };\n\n    for (var _i2 = 0, _Object$keys2 = Object.keys(ansiStyles.color.ansi); _i2 < _Object$keys2.length; _i2++) {\n      var _ret = _loop2();\n\n      if (_ret === \"continue\") continue;\n    }\n\n    ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), 'g');\n\n    var _loop3 = function _loop3() {\n      var model = _Object$keys3[_i3];\n\n      if (skipModels.has(model)) {\n        return \"continue\";\n      }\n\n      var bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);\n      styles[bgModel] = {\n        get: function get() {\n          var level = this.level;\n          return function () {\n            var open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);\n            var codes = {\n              open: open,\n              close: ansiStyles.bgColor.close,\n              closeRe: ansiStyles.bgColor.closeRe\n            };\n            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);\n          };\n        }\n      };\n    };\n\n    for (var _i3 = 0, _Object$keys3 = Object.keys(ansiStyles.bgColor.ansi); _i3 < _Object$keys3.length; _i3++) {\n      var _ret2 = _loop3();\n\n      if (_ret2 === \"continue\") continue;\n    }\n\n    var proto = Object.defineProperties(function () {}, styles);\n\n    function build(_styles, _empty, key) {\n      var builder = function builder() {\n        return applyStyle.apply(builder, arguments);\n      };\n\n      builder._styles = _styles;\n      builder._empty = _empty;\n      var self = this;\n      Object.defineProperty(builder, 'level', {\n        enumerable: true,\n        get: function get() {\n          return self.level;\n        },\n        set: function set(level) {\n          self.level = level;\n        }\n      });\n      Object.defineProperty(builder, 'enabled', {\n        enumerable: true,\n        get: function get() {\n          return self.enabled;\n        },\n        set: function set(enabled) {\n          self.enabled = enabled;\n        }\n      }); // See below for fix regarding invisible grey/dim combination on Windows\n\n      builder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey'; // `__proto__` is used because we must return a function, but there is\n      // no way to create a function with a different prototype\n\n      builder.__proto__ = proto; // eslint-disable-line no-proto\n\n      return builder;\n    }\n\n    function applyStyle() {\n      // Support varags, but simply cast to string in case there's only one arg\n      var args = arguments;\n      var argsLen = args.length;\n      var str = String(arguments[0]);\n\n      if (argsLen === 0) {\n        return '';\n      }\n\n      if (argsLen > 1) {\n        // Don't slice `arguments`, it prevents V8 optimizations\n        for (var a = 1; a < argsLen; a++) {\n          str += ' ' + args[a];\n        }\n      }\n\n      if (!this.enabled || this.level <= 0 || !str) {\n        return this._empty ? '' : str;\n      } // Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,\n      // see https://github.com/chalk/chalk/issues/58\n      // If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.\n\n\n      var originalDim = ansiStyles.dim.open;\n\n      if (isSimpleWindowsTerm && this.hasGrey) {\n        ansiStyles.dim.open = '';\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this._styles.slice().reverse()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var code = _step.value;\n          // Replace any instances already present with a re-opening code\n          // otherwise only the part of the string until said closing code\n          // will be colored, and the rest will simply be 'plain'.\n          str = code.open + str.replace(code.closeRe, code.open) + code.close; // Close the styling before a linebreak and reopen\n          // after next line to fix a bleed issue on macOS\n          // https://github.com/chalk/chalk/pull/92\n\n          str = str.replace(/\\r?\\n/g, \"\".concat(code.close, \"$&\").concat(code.open));\n        } // Reset the original `dim` if we changed it to work around the Windows dimmed gray issue\n\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      ansiStyles.dim.open = originalDim;\n      return str;\n    }\n\n    function chalkTag(chalk, strings) {\n      if (!Array.isArray(strings)) {\n        // If chalk() was called by itself or with a string,\n        // return the string itself as a string.\n        return [].slice.call(arguments, 1).join(' ');\n      }\n\n      var args = [].slice.call(arguments, 2);\n      var parts = [strings.raw[0]];\n\n      for (var i = 1; i < strings.length; i++) {\n        parts.push(String(args[i - 1]).replace(/[{}\\\\]/g, '\\\\$&'));\n        parts.push(String(strings.raw[i]));\n      }\n\n      return templates(chalk, parts.join(''));\n    }\n\n    Object.defineProperties(Chalk.prototype, styles);\n    module.exports = Chalk(); // eslint-disable-line new-cap\n\n    module.exports.supportsColor = stdoutColor;\n    module.exports.default = module.exports; // For TypeScript\n  });\n  var chalk_1 = chalk.supportsColor;\n\n  var common = createCommonjsModule(function (module, exports) {\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    exports.commonDeprecatedHandler = function (keyOrPair, redirectTo, _ref) {\n      var descriptor = _ref.descriptor;\n      var messages = [\"\".concat(chalk.default.yellow(typeof keyOrPair === 'string' ? descriptor.key(keyOrPair) : descriptor.pair(keyOrPair)), \" is deprecated\")];\n\n      if (redirectTo) {\n        messages.push(\"we now treat it as \".concat(chalk.default.blue(typeof redirectTo === 'string' ? descriptor.key(redirectTo) : descriptor.pair(redirectTo))));\n      }\n\n      return messages.join('; ') + '.';\n    };\n  });\n  unwrapExports(common);\n  var common_1 = common.commonDeprecatedHandler;\n\n  var deprecated = createCommonjsModule(function (module, exports) {\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    tslib_1.__exportStar(common, exports);\n  });\n  unwrapExports(deprecated);\n\n  var common$1 = createCommonjsModule(function (module, exports) {\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    exports.commonInvalidHandler = function (key, value, utils) {\n      return [\"Invalid \".concat(chalk.default.red(utils.descriptor.key(key)), \" value.\"), \"Expected \".concat(chalk.default.blue(utils.schemas[key].expected(utils)), \",\"), \"but received \".concat(chalk.default.red(utils.descriptor.value(value)), \".\")].join(' ');\n    };\n  });\n  unwrapExports(common$1);\n  var common_1$1 = common$1.commonInvalidHandler;\n\n  var invalid = createCommonjsModule(function (module, exports) {\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    tslib_1.__exportStar(common$1, exports);\n  });\n  unwrapExports(invalid);\n\n  /* eslint-disable no-nested-ternary */\n\n  var arr = [];\n  var charCodeCache = [];\n\n  var leven = function leven(a, b) {\n    if (a === b) {\n      return 0;\n    }\n\n    var swap = a; // Swapping the strings if `a` is longer than `b` so we know which one is the\n    // shortest & which one is the longest\n\n    if (a.length > b.length) {\n      a = b;\n      b = swap;\n    }\n\n    var aLen = a.length;\n    var bLen = b.length;\n\n    if (aLen === 0) {\n      return bLen;\n    }\n\n    if (bLen === 0) {\n      return aLen;\n    } // Performing suffix trimming:\n    // We can linearly drop suffix common to both strings since they\n    // don't increase distance at all\n    // Note: `~-` is the bitwise way to perform a `- 1` operation\n\n\n    while (aLen > 0 && a.charCodeAt(~-aLen) === b.charCodeAt(~-bLen)) {\n      aLen--;\n      bLen--;\n    }\n\n    if (aLen === 0) {\n      return bLen;\n    } // Performing prefix trimming\n    // We can linearly drop prefix common to both strings since they\n    // don't increase distance at all\n\n\n    var start = 0;\n\n    while (start < aLen && a.charCodeAt(start) === b.charCodeAt(start)) {\n      start++;\n    }\n\n    aLen -= start;\n    bLen -= start;\n\n    if (aLen === 0) {\n      return bLen;\n    }\n\n    var bCharCode;\n    var ret;\n    var tmp;\n    var tmp2;\n    var i = 0;\n    var j = 0;\n\n    while (i < aLen) {\n      charCodeCache[start + i] = a.charCodeAt(start + i);\n      arr[i] = ++i;\n    }\n\n    while (j < bLen) {\n      bCharCode = b.charCodeAt(start + j);\n      tmp = j++;\n      ret = j;\n\n      for (i = 0; i < aLen; i++) {\n        tmp2 = bCharCode === charCodeCache[start + i] ? tmp : tmp + 1;\n        tmp = arr[i];\n        ret = arr[i] = tmp > ret ? tmp2 > ret ? ret + 1 : tmp2 : tmp2 > tmp ? tmp + 1 : tmp2;\n      }\n    }\n\n    return ret;\n  };\n\n  var leven_1 = createCommonjsModule(function (module, exports) {\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    exports.levenUnknownHandler = function (key, value, _ref) {\n      var descriptor = _ref.descriptor,\n          logger = _ref.logger,\n          schemas = _ref.schemas;\n      var messages = [\"Ignored unknown option \".concat(chalk.default.yellow(descriptor.pair({\n        key: key,\n        value: value\n      })), \".\")];\n      var suggestion = Object.keys(schemas).sort().find(function (knownKey) {\n        return leven(key, knownKey) < 3;\n      });\n\n      if (suggestion) {\n        messages.push(\"Did you mean \".concat(chalk.default.blue(descriptor.key(suggestion)), \"?\"));\n      }\n\n      logger.warn(messages.join(' '));\n    };\n  });\n  unwrapExports(leven_1);\n  var leven_2 = leven_1.levenUnknownHandler;\n\n  var unknown = createCommonjsModule(function (module, exports) {\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    tslib_1.__exportStar(leven_1, exports);\n  });\n  unwrapExports(unknown);\n\n  var handlers = createCommonjsModule(function (module, exports) {\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    tslib_1.__exportStar(deprecated, exports);\n\n    tslib_1.__exportStar(invalid, exports);\n\n    tslib_1.__exportStar(unknown, exports);\n  });\n  unwrapExports(handlers);\n\n  var schema = createCommonjsModule(function (module, exports) {\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    var HANDLER_KEYS = ['default', 'expected', 'validate', 'deprecated', 'forward', 'redirect', 'overlap', 'preprocess', 'postprocess'];\n\n    function createSchema(SchemaConstructor, parameters) {\n      var schema = new SchemaConstructor(parameters);\n      var subSchema = Object.create(schema);\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = HANDLER_KEYS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var handlerKey = _step.value;\n\n          if (handlerKey in parameters) {\n            subSchema[handlerKey] = normalizeHandler(parameters[handlerKey], schema, Schema.prototype[handlerKey].length);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return subSchema;\n    }\n\n    exports.createSchema = createSchema;\n\n    var Schema =\n    /*#__PURE__*/\n    function () {\n      function Schema(parameters) {\n        _classCallCheck(this, Schema);\n\n        this.name = parameters.name;\n      }\n\n      _createClass(Schema, [{\n        key: \"default\",\n        value: function _default(_utils) {\n          return undefined;\n        } // istanbul ignore next: this is actually an abstract method but we need a placeholder to get `function.length`\n\n      }, {\n        key: \"expected\",\n        value: function expected(_utils) {\n          return 'nothing';\n        } // istanbul ignore next: this is actually an abstract method but we need a placeholder to get `function.length`\n\n      }, {\n        key: \"validate\",\n        value: function validate(_value, _utils) {\n          return false;\n        }\n      }, {\n        key: \"deprecated\",\n        value: function deprecated(_value, _utils) {\n          return false;\n        }\n      }, {\n        key: \"forward\",\n        value: function forward(_value, _utils) {\n          return undefined;\n        }\n      }, {\n        key: \"redirect\",\n        value: function redirect(_value, _utils) {\n          return undefined;\n        }\n      }, {\n        key: \"overlap\",\n        value: function overlap(currentValue, _newValue, _utils) {\n          return currentValue;\n        }\n      }, {\n        key: \"preprocess\",\n        value: function preprocess(value, _utils) {\n          return value;\n        }\n      }, {\n        key: \"postprocess\",\n        value: function postprocess(value, _utils) {\n          return value;\n        }\n      }], [{\n        key: \"create\",\n        value: function create(parameters) {\n          // @ts-ignore: https://github.com/Microsoft/TypeScript/issues/5863\n          return createSchema(this, parameters);\n        }\n      }]);\n\n      return Schema;\n    }();\n\n    exports.Schema = Schema;\n\n    function normalizeHandler(handler, superSchema, handlerArgumentsLength) {\n      return typeof handler === 'function' ? function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        return handler.apply(void 0, _toConsumableArray(args.slice(0, handlerArgumentsLength - 1)).concat([superSchema], _toConsumableArray(args.slice(handlerArgumentsLength - 1))));\n      } : function () {\n        return handler;\n      };\n    }\n  });\n  unwrapExports(schema);\n  var schema_1 = schema.createSchema;\n  var schema_2 = schema.Schema;\n\n  var alias = createCommonjsModule(function (module, exports) {\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var AliasSchema =\n    /*#__PURE__*/\n    function (_schema_1$Schema) {\n      _inherits(AliasSchema, _schema_1$Schema);\n\n      function AliasSchema(parameters) {\n        var _this;\n\n        _classCallCheck(this, AliasSchema);\n\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(AliasSchema).call(this, parameters));\n        _this._sourceName = parameters.sourceName;\n        return _this;\n      }\n\n      _createClass(AliasSchema, [{\n        key: \"expected\",\n        value: function expected(utils) {\n          return utils.schemas[this._sourceName].expected(utils);\n        }\n      }, {\n        key: \"validate\",\n        value: function validate(value, utils) {\n          return utils.schemas[this._sourceName].validate(value, utils);\n        }\n      }, {\n        key: \"redirect\",\n        value: function redirect(_value, _utils) {\n          return this._sourceName;\n        }\n      }]);\n\n      return AliasSchema;\n    }(schema.Schema);\n\n    exports.AliasSchema = AliasSchema;\n  });\n  unwrapExports(alias);\n  var alias_1 = alias.AliasSchema;\n\n  var any = createCommonjsModule(function (module, exports) {\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var AnySchema =\n    /*#__PURE__*/\n    function (_schema_1$Schema) {\n      _inherits(AnySchema, _schema_1$Schema);\n\n      function AnySchema() {\n        _classCallCheck(this, AnySchema);\n\n        return _possibleConstructorReturn(this, _getPrototypeOf(AnySchema).apply(this, arguments));\n      }\n\n      _createClass(AnySchema, [{\n        key: \"expected\",\n        value: function expected() {\n          return 'anything';\n        }\n      }, {\n        key: \"validate\",\n        value: function validate() {\n          return true;\n        }\n      }]);\n\n      return AnySchema;\n    }(schema.Schema);\n\n    exports.AnySchema = AnySchema;\n  });\n  unwrapExports(any);\n  var any_1 = any.AnySchema;\n\n  var array = createCommonjsModule(function (module, exports) {\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var ArraySchema =\n    /*#__PURE__*/\n    function (_schema_1$Schema) {\n      _inherits(ArraySchema, _schema_1$Schema);\n\n      function ArraySchema(_a) {\n        var _this;\n\n        _classCallCheck(this, ArraySchema);\n\n        var valueSchema = _a.valueSchema,\n            _a$name = _a.name,\n            name = _a$name === void 0 ? valueSchema.name : _a$name,\n            handlers = tslib_1.__rest(_a, [\"valueSchema\", \"name\"]);\n\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(ArraySchema).call(this, Object.assign({}, handlers, {\n          name: name\n        })));\n        _this._valueSchema = valueSchema;\n        return _this;\n      }\n\n      _createClass(ArraySchema, [{\n        key: \"expected\",\n        value: function expected(utils) {\n          return \"an array of \".concat(this._valueSchema.expected(utils));\n        }\n      }, {\n        key: \"validate\",\n        value: function validate(value, utils) {\n          if (!Array.isArray(value)) {\n            return false;\n          }\n\n          var invalidValues = [];\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = value[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var subValue = _step.value;\n              var subValidateResult = utils.normalizeValidateResult(this._valueSchema.validate(subValue, utils), subValue);\n\n              if (subValidateResult !== true) {\n                invalidValues.push(subValidateResult.value);\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n\n          return invalidValues.length === 0 ? true : {\n            value: invalidValues\n          };\n        }\n      }, {\n        key: \"deprecated\",\n        value: function deprecated(value, utils) {\n          var deprecatedResult = [];\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = value[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var subValue = _step2.value;\n              var subDeprecatedResult = utils.normalizeDeprecatedResult(this._valueSchema.deprecated(subValue, utils), subValue);\n\n              if (subDeprecatedResult !== false) {\n                deprecatedResult.push.apply(deprecatedResult, _toConsumableArray(subDeprecatedResult.map(function (_ref) {\n                  var deprecatedValue = _ref.value;\n                  return {\n                    value: [deprecatedValue]\n                  };\n                })));\n              }\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n\n          return deprecatedResult;\n        }\n      }, {\n        key: \"forward\",\n        value: function forward(value, utils) {\n          var forwardResult = [];\n          var _iteratorNormalCompletion3 = true;\n          var _didIteratorError3 = false;\n          var _iteratorError3 = undefined;\n\n          try {\n            for (var _iterator3 = value[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n              var subValue = _step3.value;\n              var subForwardResult = utils.normalizeForwardResult(this._valueSchema.forward(subValue, utils), subValue);\n              forwardResult.push.apply(forwardResult, _toConsumableArray(subForwardResult.map(wrapTransferResult)));\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                _iterator3.return();\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n\n          return forwardResult;\n        }\n      }, {\n        key: \"redirect\",\n        value: function redirect(value, utils) {\n          var remain = [];\n          var redirect = [];\n          var _iteratorNormalCompletion4 = true;\n          var _didIteratorError4 = false;\n          var _iteratorError4 = undefined;\n\n          try {\n            for (var _iterator4 = value[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n              var subValue = _step4.value;\n              var subRedirectResult = utils.normalizeRedirectResult(this._valueSchema.redirect(subValue, utils), subValue);\n\n              if ('remain' in subRedirectResult) {\n                remain.push(subRedirectResult.remain);\n              }\n\n              redirect.push.apply(redirect, _toConsumableArray(subRedirectResult.redirect.map(wrapTransferResult)));\n            }\n          } catch (err) {\n            _didIteratorError4 = true;\n            _iteratorError4 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n                _iterator4.return();\n              }\n            } finally {\n              if (_didIteratorError4) {\n                throw _iteratorError4;\n              }\n            }\n          }\n\n          return remain.length === 0 ? {\n            redirect: redirect\n          } : {\n            redirect: redirect,\n            remain: remain\n          };\n        }\n      }, {\n        key: \"overlap\",\n        value: function overlap(currentValue, newValue) {\n          return currentValue.concat(newValue);\n        }\n      }]);\n\n      return ArraySchema;\n    }(schema.Schema);\n\n    exports.ArraySchema = ArraySchema;\n\n    function wrapTransferResult(_ref2) {\n      var from = _ref2.from,\n          to = _ref2.to;\n      return {\n        from: [from],\n        to: to\n      };\n    }\n  });\n  unwrapExports(array);\n  var array_1 = array.ArraySchema;\n\n  var boolean_1 = createCommonjsModule(function (module, exports) {\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var BooleanSchema =\n    /*#__PURE__*/\n    function (_schema_1$Schema) {\n      _inherits(BooleanSchema, _schema_1$Schema);\n\n      function BooleanSchema() {\n        _classCallCheck(this, BooleanSchema);\n\n        return _possibleConstructorReturn(this, _getPrototypeOf(BooleanSchema).apply(this, arguments));\n      }\n\n      _createClass(BooleanSchema, [{\n        key: \"expected\",\n        value: function expected() {\n          return 'true or false';\n        }\n      }, {\n        key: \"validate\",\n        value: function validate(value) {\n          return typeof value === 'boolean';\n        }\n      }]);\n\n      return BooleanSchema;\n    }(schema.Schema);\n\n    exports.BooleanSchema = BooleanSchema;\n  });\n  unwrapExports(boolean_1);\n  var boolean_2 = boolean_1.BooleanSchema;\n\n  var utils = createCommonjsModule(function (module, exports) {\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    function recordFromArray(array, mainKey) {\n      var record = Object.create(null);\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = array[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var value = _step.value;\n          var key = value[mainKey]; // istanbul ignore next\n\n          if (record[key]) {\n            throw new Error(\"Duplicate \".concat(mainKey, \" \").concat(JSON.stringify(key)));\n          } // @ts-ignore\n\n\n          record[key] = value;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return record;\n    }\n\n    exports.recordFromArray = recordFromArray;\n\n    function mapFromArray(array, mainKey) {\n      var map = new Map();\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = array[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var value = _step2.value;\n          var key = value[mainKey]; // istanbul ignore next\n\n          if (map.has(key)) {\n            throw new Error(\"Duplicate \".concat(mainKey, \" \").concat(JSON.stringify(key)));\n          }\n\n          map.set(key, value);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return map;\n    }\n\n    exports.mapFromArray = mapFromArray;\n\n    function createAutoChecklist() {\n      var map = Object.create(null);\n      return function (id) {\n        var idString = JSON.stringify(id);\n\n        if (map[idString]) {\n          return true;\n        }\n\n        map[idString] = true;\n        return false;\n      };\n    }\n\n    exports.createAutoChecklist = createAutoChecklist;\n\n    function partition(array, predicate) {\n      var trueArray = [];\n      var falseArray = [];\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = array[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var value = _step3.value;\n\n          if (predicate(value)) {\n            trueArray.push(value);\n          } else {\n            falseArray.push(value);\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return [trueArray, falseArray];\n    }\n\n    exports.partition = partition;\n\n    function isInt(value) {\n      return value === Math.floor(value);\n    }\n\n    exports.isInt = isInt;\n\n    function comparePrimitive(a, b) {\n      if (a === b) {\n        return 0;\n      }\n\n      var typeofA = _typeof(a);\n\n      var typeofB = _typeof(b);\n\n      var orders = ['undefined', 'object', 'boolean', 'number', 'string'];\n\n      if (typeofA !== typeofB) {\n        return orders.indexOf(typeofA) - orders.indexOf(typeofB);\n      }\n\n      if (typeofA !== 'string') {\n        return Number(a) - Number(b);\n      }\n\n      return a.localeCompare(b);\n    }\n\n    exports.comparePrimitive = comparePrimitive;\n\n    function normalizeDefaultResult(result) {\n      return result === undefined ? {} : result;\n    }\n\n    exports.normalizeDefaultResult = normalizeDefaultResult;\n\n    function normalizeValidateResult(result, value) {\n      return result === true ? true : result === false ? {\n        value: value\n      } : result;\n    }\n\n    exports.normalizeValidateResult = normalizeValidateResult;\n\n    function normalizeDeprecatedResult(result, value) {\n      var doNotNormalizeTrue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      return result === false ? false : result === true ? doNotNormalizeTrue ? true : [{\n        value: value\n      }] : 'value' in result ? [result] : result.length === 0 ? false : result;\n    }\n\n    exports.normalizeDeprecatedResult = normalizeDeprecatedResult;\n\n    function normalizeTransferResult(result, value) {\n      return typeof result === 'string' || 'key' in result ? {\n        from: value,\n        to: result\n      } : 'from' in result ? {\n        from: result.from,\n        to: result.to\n      } : {\n        from: value,\n        to: result.to\n      };\n    }\n\n    exports.normalizeTransferResult = normalizeTransferResult;\n\n    function normalizeForwardResult(result, value) {\n      return result === undefined ? [] : Array.isArray(result) ? result.map(function (transferResult) {\n        return normalizeTransferResult(transferResult, value);\n      }) : [normalizeTransferResult(result, value)];\n    }\n\n    exports.normalizeForwardResult = normalizeForwardResult;\n\n    function normalizeRedirectResult(result, value) {\n      var redirect = normalizeForwardResult(_typeof(result) === 'object' && 'redirect' in result ? result.redirect : result, value);\n      return redirect.length === 0 ? {\n        remain: value,\n        redirect: redirect\n      } : _typeof(result) === 'object' && 'remain' in result ? {\n        remain: result.remain,\n        redirect: redirect\n      } : {\n        redirect: redirect\n      };\n    }\n\n    exports.normalizeRedirectResult = normalizeRedirectResult;\n  });\n  unwrapExports(utils);\n  var utils_1 = utils.recordFromArray;\n  var utils_2 = utils.mapFromArray;\n  var utils_3 = utils.createAutoChecklist;\n  var utils_4 = utils.partition;\n  var utils_5 = utils.isInt;\n  var utils_6 = utils.comparePrimitive;\n  var utils_7 = utils.normalizeDefaultResult;\n  var utils_8 = utils.normalizeValidateResult;\n  var utils_9 = utils.normalizeDeprecatedResult;\n  var utils_10 = utils.normalizeTransferResult;\n  var utils_11 = utils.normalizeForwardResult;\n  var utils_12 = utils.normalizeRedirectResult;\n\n  var choice = createCommonjsModule(function (module, exports) {\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var ChoiceSchema =\n    /*#__PURE__*/\n    function (_schema_1$Schema) {\n      _inherits(ChoiceSchema, _schema_1$Schema);\n\n      function ChoiceSchema(parameters) {\n        var _this;\n\n        _classCallCheck(this, ChoiceSchema);\n\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(ChoiceSchema).call(this, parameters));\n        _this._choices = utils.mapFromArray(parameters.choices.map(function (choice) {\n          return choice && _typeof(choice) === 'object' ? choice : {\n            value: choice\n          };\n        }), 'value');\n        return _this;\n      }\n\n      _createClass(ChoiceSchema, [{\n        key: \"expected\",\n        value: function expected(_ref) {\n          var _this2 = this;\n\n          var descriptor = _ref.descriptor;\n          var choiceValues = Array.from(this._choices.keys()).map(function (value) {\n            return _this2._choices.get(value);\n          }).filter(function (choiceInfo) {\n            return !choiceInfo.deprecated;\n          }).map(function (choiceInfo) {\n            return choiceInfo.value;\n          }).sort(utils.comparePrimitive).map(descriptor.value);\n          var head = choiceValues.slice(0, -2);\n          var tail = choiceValues.slice(-2);\n          return head.concat(tail.join(' or ')).join(', ');\n        }\n      }, {\n        key: \"validate\",\n        value: function validate(value) {\n          return this._choices.has(value);\n        }\n      }, {\n        key: \"deprecated\",\n        value: function deprecated(value) {\n          var choiceInfo = this._choices.get(value);\n\n          return choiceInfo && choiceInfo.deprecated ? {\n            value: value\n          } : false;\n        }\n      }, {\n        key: \"forward\",\n        value: function forward(value) {\n          var choiceInfo = this._choices.get(value);\n\n          return choiceInfo ? choiceInfo.forward : undefined;\n        }\n      }, {\n        key: \"redirect\",\n        value: function redirect(value) {\n          var choiceInfo = this._choices.get(value);\n\n          return choiceInfo ? choiceInfo.redirect : undefined;\n        }\n      }]);\n\n      return ChoiceSchema;\n    }(schema.Schema);\n\n    exports.ChoiceSchema = ChoiceSchema;\n  });\n  unwrapExports(choice);\n  var choice_1 = choice.ChoiceSchema;\n\n  var number = createCommonjsModule(function (module, exports) {\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var NumberSchema =\n    /*#__PURE__*/\n    function (_schema_1$Schema) {\n      _inherits(NumberSchema, _schema_1$Schema);\n\n      function NumberSchema() {\n        _classCallCheck(this, NumberSchema);\n\n        return _possibleConstructorReturn(this, _getPrototypeOf(NumberSchema).apply(this, arguments));\n      }\n\n      _createClass(NumberSchema, [{\n        key: \"expected\",\n        value: function expected() {\n          return 'a number';\n        }\n      }, {\n        key: \"validate\",\n        value: function validate(value, _utils) {\n          return typeof value === 'number';\n        }\n      }]);\n\n      return NumberSchema;\n    }(schema.Schema);\n\n    exports.NumberSchema = NumberSchema;\n  });\n  unwrapExports(number);\n  var number_1 = number.NumberSchema;\n\n  var integer = createCommonjsModule(function (module, exports) {\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var IntegerSchema =\n    /*#__PURE__*/\n    function (_number_1$NumberSchem) {\n      _inherits(IntegerSchema, _number_1$NumberSchem);\n\n      function IntegerSchema() {\n        _classCallCheck(this, IntegerSchema);\n\n        return _possibleConstructorReturn(this, _getPrototypeOf(IntegerSchema).apply(this, arguments));\n      }\n\n      _createClass(IntegerSchema, [{\n        key: \"expected\",\n        value: function expected() {\n          return 'an integer';\n        }\n      }, {\n        key: \"validate\",\n        value: function validate(value, utils$1) {\n          return utils$1.normalizeValidateResult(_get(_getPrototypeOf(IntegerSchema.prototype), \"validate\", this).call(this, value, utils$1), value) === true && utils.isInt(value);\n        }\n      }]);\n\n      return IntegerSchema;\n    }(number.NumberSchema);\n\n    exports.IntegerSchema = IntegerSchema;\n  });\n  unwrapExports(integer);\n  var integer_1 = integer.IntegerSchema;\n\n  var string = createCommonjsModule(function (module, exports) {\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var StringSchema =\n    /*#__PURE__*/\n    function (_schema_1$Schema) {\n      _inherits(StringSchema, _schema_1$Schema);\n\n      function StringSchema() {\n        _classCallCheck(this, StringSchema);\n\n        return _possibleConstructorReturn(this, _getPrototypeOf(StringSchema).apply(this, arguments));\n      }\n\n      _createClass(StringSchema, [{\n        key: \"expected\",\n        value: function expected() {\n          return 'a string';\n        }\n      }, {\n        key: \"validate\",\n        value: function validate(value) {\n          return typeof value === 'string';\n        }\n      }]);\n\n      return StringSchema;\n    }(schema.Schema);\n\n    exports.StringSchema = StringSchema;\n  });\n  unwrapExports(string);\n  var string_1 = string.StringSchema;\n\n  var schemas = createCommonjsModule(function (module, exports) {\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    tslib_1.__exportStar(alias, exports);\n\n    tslib_1.__exportStar(any, exports);\n\n    tslib_1.__exportStar(array, exports);\n\n    tslib_1.__exportStar(boolean_1, exports);\n\n    tslib_1.__exportStar(choice, exports);\n\n    tslib_1.__exportStar(integer, exports);\n\n    tslib_1.__exportStar(number, exports);\n\n    tslib_1.__exportStar(string, exports);\n  });\n  unwrapExports(schemas);\n\n  var defaults = createCommonjsModule(function (module, exports) {\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.defaultDescriptor = api.apiDescriptor;\n    exports.defaultUnknownHandler = leven_1.levenUnknownHandler;\n    exports.defaultInvalidHandler = invalid.commonInvalidHandler;\n    exports.defaultDeprecatedHandler = common.commonDeprecatedHandler;\n  });\n  unwrapExports(defaults);\n  var defaults_1 = defaults.defaultDescriptor;\n  var defaults_2 = defaults.defaultUnknownHandler;\n  var defaults_3 = defaults.defaultInvalidHandler;\n  var defaults_4 = defaults.defaultDeprecatedHandler;\n\n  var normalize = createCommonjsModule(function (module, exports) {\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    exports.normalize = function (options, schemas, opts) {\n      return new Normalizer(schemas, opts).normalize(options);\n    };\n\n    var Normalizer =\n    /*#__PURE__*/\n    function () {\n      function Normalizer(schemas, opts) {\n        _classCallCheck(this, Normalizer);\n\n        // istanbul ignore next\n        var _ref = opts || {},\n            _ref$logger = _ref.logger,\n            logger = _ref$logger === void 0 ? console : _ref$logger,\n            _ref$descriptor = _ref.descriptor,\n            descriptor = _ref$descriptor === void 0 ? defaults.defaultDescriptor : _ref$descriptor,\n            _ref$unknown = _ref.unknown,\n            unknown = _ref$unknown === void 0 ? defaults.defaultUnknownHandler : _ref$unknown,\n            _ref$invalid = _ref.invalid,\n            invalid = _ref$invalid === void 0 ? defaults.defaultInvalidHandler : _ref$invalid,\n            _ref$deprecated = _ref.deprecated,\n            deprecated = _ref$deprecated === void 0 ? defaults.defaultDeprecatedHandler : _ref$deprecated;\n\n        this._utils = {\n          descriptor: descriptor,\n          logger:\n          /* istanbul ignore next */\n          logger || {\n            warn: function warn() {}\n          },\n          schemas: utils.recordFromArray(schemas, 'name'),\n          normalizeDefaultResult: utils.normalizeDefaultResult,\n          normalizeDeprecatedResult: utils.normalizeDeprecatedResult,\n          normalizeForwardResult: utils.normalizeForwardResult,\n          normalizeRedirectResult: utils.normalizeRedirectResult,\n          normalizeValidateResult: utils.normalizeValidateResult\n        };\n        this._unknownHandler = unknown;\n        this._invalidHandler = invalid;\n        this._deprecatedHandler = deprecated;\n        this.cleanHistory();\n      }\n\n      _createClass(Normalizer, [{\n        key: \"cleanHistory\",\n        value: function cleanHistory() {\n          this._hasDeprecationWarned = utils.createAutoChecklist();\n        }\n      }, {\n        key: \"normalize\",\n        value: function normalize(options) {\n          var _this = this;\n\n          var normalized = {};\n          var restOptionsArray = [options];\n\n          var applyNormalization = function applyNormalization() {\n            while (restOptionsArray.length !== 0) {\n              var currentOptions = restOptionsArray.shift();\n\n              var transferredOptionsArray = _this._applyNormalization(currentOptions, normalized);\n\n              restOptionsArray.push.apply(restOptionsArray, _toConsumableArray(transferredOptionsArray));\n            }\n          };\n\n          applyNormalization();\n\n          for (var _i = 0, _Object$keys = Object.keys(this._utils.schemas); _i < _Object$keys.length; _i++) {\n            var key = _Object$keys[_i];\n            var schema = this._utils.schemas[key];\n\n            if (!(key in normalized)) {\n              var defaultResult = utils.normalizeDefaultResult(schema.default(this._utils));\n\n              if ('value' in defaultResult) {\n                restOptionsArray.push(_defineProperty({}, key, defaultResult.value));\n              }\n            }\n          }\n\n          applyNormalization();\n\n          for (var _i2 = 0, _Object$keys2 = Object.keys(this._utils.schemas); _i2 < _Object$keys2.length; _i2++) {\n            var _key = _Object$keys2[_i2];\n            var _schema = this._utils.schemas[_key];\n\n            if (_key in normalized) {\n              normalized[_key] = _schema.postprocess(normalized[_key], this._utils);\n            }\n          }\n\n          return normalized;\n        }\n      }, {\n        key: \"_applyNormalization\",\n        value: function _applyNormalization(options, normalized) {\n          var _this2 = this;\n\n          var transferredOptionsArray = [];\n\n          var _utils_1$partition = utils.partition(Object.keys(options), function (key) {\n            return key in _this2._utils.schemas;\n          }),\n              _utils_1$partition2 = _slicedToArray(_utils_1$partition, 2),\n              knownOptionNames = _utils_1$partition2[0],\n              unknownOptionNames = _utils_1$partition2[1];\n\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            var _loop = function _loop() {\n              var key = _step.value;\n              var schema = _this2._utils.schemas[key];\n              var value = schema.preprocess(options[key], _this2._utils);\n              var validateResult = utils.normalizeValidateResult(schema.validate(value, _this2._utils), value);\n\n              if (validateResult !== true) {\n                var invalidValue = validateResult.value;\n\n                var errorMessageOrError = _this2._invalidHandler(key, invalidValue, _this2._utils);\n\n                throw typeof errorMessageOrError === 'string' ? new Error(errorMessageOrError) :\n                /* istanbul ignore next*/\n                errorMessageOrError;\n              }\n\n              var appendTransferredOptions = function appendTransferredOptions(_ref2) {\n                var from = _ref2.from,\n                    to = _ref2.to;\n                transferredOptionsArray.push(typeof to === 'string' ? _defineProperty({}, to, from) : _defineProperty({}, to.key, to.value));\n              };\n\n              var warnDeprecated = function warnDeprecated(_ref5) {\n                var currentValue = _ref5.value,\n                    redirectTo = _ref5.redirectTo;\n                var deprecatedResult = utils.normalizeDeprecatedResult(schema.deprecated(currentValue, _this2._utils), value,\n                /* doNotNormalizeTrue */\n                true);\n\n                if (deprecatedResult === false) {\n                  return;\n                }\n\n                if (deprecatedResult === true) {\n                  if (!_this2._hasDeprecationWarned(key)) {\n                    _this2._utils.logger.warn(_this2._deprecatedHandler(key, redirectTo, _this2._utils));\n                  }\n                } else {\n                  var _iteratorNormalCompletion3 = true;\n                  var _didIteratorError3 = false;\n                  var _iteratorError3 = undefined;\n\n                  try {\n                    for (var _iterator3 = deprecatedResult[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                      var deprecatedValue = _step3.value.value;\n                      var pair = {\n                        key: key,\n                        value: deprecatedValue\n                      };\n\n                      if (!_this2._hasDeprecationWarned(pair)) {\n                        var redirectToPair = typeof redirectTo === 'string' ? {\n                          key: redirectTo,\n                          value: deprecatedValue\n                        } : redirectTo;\n\n                        _this2._utils.logger.warn(_this2._deprecatedHandler(pair, redirectToPair, _this2._utils));\n                      }\n                    }\n                  } catch (err) {\n                    _didIteratorError3 = true;\n                    _iteratorError3 = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                        _iterator3.return();\n                      }\n                    } finally {\n                      if (_didIteratorError3) {\n                        throw _iteratorError3;\n                      }\n                    }\n                  }\n                }\n              };\n\n              var forwardResult = utils.normalizeForwardResult(schema.forward(value, _this2._utils), value);\n              forwardResult.forEach(appendTransferredOptions);\n              var redirectResult = utils.normalizeRedirectResult(schema.redirect(value, _this2._utils), value);\n              redirectResult.redirect.forEach(appendTransferredOptions);\n\n              if ('remain' in redirectResult) {\n                var remainingValue = redirectResult.remain;\n                normalized[key] = key in normalized ? schema.overlap(normalized[key], remainingValue, _this2._utils) : remainingValue;\n                warnDeprecated({\n                  value: remainingValue\n                });\n              }\n\n              var _iteratorNormalCompletion4 = true;\n              var _didIteratorError4 = false;\n              var _iteratorError4 = undefined;\n\n              try {\n                for (var _iterator4 = redirectResult.redirect[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                  var _step4$value = _step4.value,\n                      from = _step4$value.from,\n                      to = _step4$value.to;\n                  warnDeprecated({\n                    value: from,\n                    redirectTo: to\n                  });\n                }\n              } catch (err) {\n                _didIteratorError4 = true;\n                _iteratorError4 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n                    _iterator4.return();\n                  }\n                } finally {\n                  if (_didIteratorError4) {\n                    throw _iteratorError4;\n                  }\n                }\n              }\n            };\n\n            for (var _iterator = knownOptionNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              _loop();\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = unknownOptionNames[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var key = _step2.value;\n              var value = options[key];\n\n              var unknownResult = this._unknownHandler(key, value, this._utils);\n\n              if (unknownResult) {\n                for (var _i3 = 0, _Object$keys3 = Object.keys(unknownResult); _i3 < _Object$keys3.length; _i3++) {\n                  var unknownKey = _Object$keys3[_i3];\n\n                  var unknownOption = _defineProperty({}, unknownKey, unknownResult[unknownKey]);\n\n                  if (unknownKey in this._utils.schemas) {\n                    transferredOptionsArray.push(unknownOption);\n                  } else {\n                    Object.assign(normalized, unknownOption);\n                  }\n                }\n              }\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n\n          return transferredOptionsArray;\n        }\n      }]);\n\n      return Normalizer;\n    }();\n\n    exports.Normalizer = Normalizer;\n  });\n  unwrapExports(normalize);\n  var normalize_1 = normalize.normalize;\n  var normalize_2 = normalize.Normalizer;\n\n  var lib = createCommonjsModule(function (module, exports) {\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    tslib_1.__exportStar(descriptors, exports);\n\n    tslib_1.__exportStar(handlers, exports);\n\n    tslib_1.__exportStar(schemas, exports);\n\n    tslib_1.__exportStar(normalize, exports);\n\n    tslib_1.__exportStar(schema, exports);\n  });\n  unwrapExports(lib);\n\n  var array$1 = [];\n  var charCodeCache$1 = [];\n\n  var leven$1 = function leven(left, right) {\n    if (left === right) {\n      return 0;\n    }\n\n    var swap = left; // Swapping the strings if `a` is longer than `b` so we know which one is the\n    // shortest & which one is the longest\n\n    if (left.length > right.length) {\n      left = right;\n      right = swap;\n    }\n\n    var leftLength = left.length;\n    var rightLength = right.length; // Performing suffix trimming:\n    // We can linearly drop suffix common to both strings since they\n    // don't increase distance at all\n    // Note: `~-` is the bitwise way to perform a `- 1` operation\n\n    while (leftLength > 0 && left.charCodeAt(~-leftLength) === right.charCodeAt(~-rightLength)) {\n      leftLength--;\n      rightLength--;\n    } // Performing prefix trimming\n    // We can linearly drop prefix common to both strings since they\n    // don't increase distance at all\n\n\n    var start = 0;\n\n    while (start < leftLength && left.charCodeAt(start) === right.charCodeAt(start)) {\n      start++;\n    }\n\n    leftLength -= start;\n    rightLength -= start;\n\n    if (leftLength === 0) {\n      return rightLength;\n    }\n\n    var bCharCode;\n    var result;\n    var temp;\n    var temp2;\n    var i = 0;\n    var j = 0;\n\n    while (i < leftLength) {\n      charCodeCache$1[i] = left.charCodeAt(start + i);\n      array$1[i] = ++i;\n    }\n\n    while (j < rightLength) {\n      bCharCode = right.charCodeAt(start + j);\n      temp = j++;\n      result = j;\n\n      for (i = 0; i < leftLength; i++) {\n        temp2 = bCharCode === charCodeCache$1[i] ? temp : temp + 1;\n        temp = array$1[i]; // eslint-disable-next-line no-multi-assign\n\n        result = array$1[i] = temp > result ? temp2 > result ? result + 1 : temp2 : temp2 > temp ? temp + 1 : temp2;\n      }\n    }\n\n    return result;\n  };\n\n  var leven_1$1 = leven$1; // TODO: Remove this for the next major release\n\n  var default_1 = leven$1;\n  leven_1$1.default = default_1;\n\n  var cliDescriptor = {\n    key: function key(_key) {\n      return _key.length === 1 ? \"-\".concat(_key) : \"--\".concat(_key);\n    },\n    value: function value(_value) {\n      return lib.apiDescriptor.value(_value);\n    },\n    pair: function pair(_ref) {\n      var key = _ref.key,\n          value = _ref.value;\n      return value === false ? \"--no-\".concat(key) : value === true ? cliDescriptor.key(key) : value === \"\" ? \"\".concat(cliDescriptor.key(key), \" without an argument\") : \"\".concat(cliDescriptor.key(key), \"=\").concat(value);\n    }\n  };\n\n  var FlagSchema =\n  /*#__PURE__*/\n  function (_vnopts$ChoiceSchema) {\n    _inherits(FlagSchema, _vnopts$ChoiceSchema);\n\n    function FlagSchema(_ref2) {\n      var _this;\n\n      var name = _ref2.name,\n          flags = _ref2.flags;\n\n      _classCallCheck(this, FlagSchema);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(FlagSchema).call(this, {\n        name: name,\n        choices: flags\n      }));\n      _this._flags = flags.slice().sort();\n      return _this;\n    }\n\n    _createClass(FlagSchema, [{\n      key: \"preprocess\",\n      value: function preprocess(value, utils) {\n        if (typeof value === \"string\" && value.length !== 0 && this._flags.indexOf(value) === -1) {\n          var suggestion = this._flags.find(function (flag) {\n            return leven_1$1(flag, value) < 3;\n          });\n\n          if (suggestion) {\n            utils.logger.warn([\"Unknown flag \".concat(chalk.yellow(utils.descriptor.value(value)), \",\"), \"did you mean \".concat(chalk.blue(utils.descriptor.value(suggestion)), \"?\")].join(\" \"));\n            return suggestion;\n          }\n        }\n\n        return value;\n      }\n    }, {\n      key: \"expected\",\n      value: function expected() {\n        return \"a flag\";\n      }\n    }]);\n\n    return FlagSchema;\n  }(lib.ChoiceSchema);\n\n  var hasDeprecationWarned;\n\n  function normalizeOptions(options, optionInfos) {\n    var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        logger = _ref3.logger,\n        _ref3$isCLI = _ref3.isCLI,\n        isCLI = _ref3$isCLI === void 0 ? false : _ref3$isCLI,\n        _ref3$passThrough = _ref3.passThrough,\n        passThrough = _ref3$passThrough === void 0 ? false : _ref3$passThrough;\n\n    var unknown = !passThrough ? lib.levenUnknownHandler : Array.isArray(passThrough) ? function (key, value) {\n      return passThrough.indexOf(key) === -1 ? undefined : _defineProperty({}, key, value);\n    } : function (key, value) {\n      return _defineProperty({}, key, value);\n    };\n    var descriptor = isCLI ? cliDescriptor : lib.apiDescriptor;\n    var schemas = optionInfosToSchemas(optionInfos, {\n      isCLI: isCLI\n    });\n    var normalizer = new lib.Normalizer(schemas, {\n      logger: logger,\n      unknown: unknown,\n      descriptor: descriptor\n    });\n    var shouldSuppressDuplicateDeprecationWarnings = logger !== false;\n\n    if (shouldSuppressDuplicateDeprecationWarnings && hasDeprecationWarned) {\n      normalizer._hasDeprecationWarned = hasDeprecationWarned;\n    }\n\n    var normalized = normalizer.normalize(options);\n\n    if (shouldSuppressDuplicateDeprecationWarnings) {\n      hasDeprecationWarned = normalizer._hasDeprecationWarned;\n    }\n\n    return normalized;\n  }\n\n  function optionInfosToSchemas(optionInfos, _ref6) {\n    var isCLI = _ref6.isCLI;\n    var schemas = [];\n\n    if (isCLI) {\n      schemas.push(lib.AnySchema.create({\n        name: \"_\"\n      }));\n    }\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = optionInfos[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var optionInfo = _step.value;\n        schemas.push(optionInfoToSchema(optionInfo, {\n          isCLI: isCLI,\n          optionInfos: optionInfos\n        }));\n\n        if (optionInfo.alias && isCLI) {\n          schemas.push(lib.AliasSchema.create({\n            name: optionInfo.alias,\n            sourceName: optionInfo.name\n          }));\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return schemas;\n  }\n\n  function optionInfoToSchema(optionInfo, _ref7) {\n    var isCLI = _ref7.isCLI,\n        optionInfos = _ref7.optionInfos;\n    var SchemaConstructor;\n    var parameters = {\n      name: optionInfo.name\n    };\n    var handlers = {};\n\n    switch (optionInfo.type) {\n      case \"int\":\n        SchemaConstructor = lib.IntegerSchema;\n\n        if (isCLI) {\n          parameters.preprocess = function (value) {\n            return Number(value);\n          };\n        }\n\n        break;\n\n      case \"string\":\n        SchemaConstructor = lib.StringSchema;\n        break;\n\n      case \"choice\":\n        SchemaConstructor = lib.ChoiceSchema;\n        parameters.choices = optionInfo.choices.map(function (choiceInfo) {\n          return _typeof(choiceInfo) === \"object\" && choiceInfo.redirect ? Object.assign({}, choiceInfo, {\n            redirect: {\n              to: {\n                key: optionInfo.name,\n                value: choiceInfo.redirect\n              }\n            }\n          }) : choiceInfo;\n        });\n        break;\n\n      case \"boolean\":\n        SchemaConstructor = lib.BooleanSchema;\n        break;\n\n      case \"flag\":\n        SchemaConstructor = FlagSchema;\n        parameters.flags = optionInfos.map(function (optionInfo) {\n          return [].concat(optionInfo.alias || [], optionInfo.description ? optionInfo.name : [], optionInfo.oppositeDescription ? \"no-\".concat(optionInfo.name) : []);\n        }).reduce(function (a, b) {\n          return a.concat(b);\n        }, []);\n        break;\n\n      case \"path\":\n        SchemaConstructor = lib.StringSchema;\n        break;\n\n      default:\n        throw new Error(\"Unexpected type \".concat(optionInfo.type));\n    }\n\n    if (optionInfo.exception) {\n      parameters.validate = function (value, schema, utils) {\n        return optionInfo.exception(value) || schema.validate(value, utils);\n      };\n    } else {\n      parameters.validate = function (value, schema, utils) {\n        return value === undefined || schema.validate(value, utils);\n      };\n    }\n\n    if (optionInfo.redirect) {\n      handlers.redirect = function (value) {\n        return !value ? undefined : {\n          to: {\n            key: optionInfo.redirect.option,\n            value: optionInfo.redirect.value\n          }\n        };\n      };\n    }\n\n    if (optionInfo.deprecated) {\n      handlers.deprecated = true;\n    } // allow CLI overriding, e.g., prettier package.json --tab-width 1 --tab-width 2\n\n\n    if (isCLI && !optionInfo.array) {\n      var originalPreprocess = parameters.preprocess || function (x) {\n        return x;\n      };\n\n      parameters.preprocess = function (value, schema, utils) {\n        return schema.preprocess(originalPreprocess(Array.isArray(value) ? value[value.length - 1] : value), utils);\n      };\n    }\n\n    return optionInfo.array ? lib.ArraySchema.create(Object.assign(isCLI ? {\n      preprocess: function preprocess(v) {\n        return [].concat(v);\n      }\n    } : {}, handlers, {\n      valueSchema: SchemaConstructor.create(parameters)\n    })) : SchemaConstructor.create(Object.assign({}, parameters, handlers));\n  }\n\n  function normalizeApiOptions(options, optionInfos, opts) {\n    return normalizeOptions(options, optionInfos, opts);\n  }\n\n  function normalizeCliOptions(options, optionInfos, opts) {\n    return normalizeOptions(options, optionInfos, Object.assign({\n      isCLI: true\n    }, opts));\n  }\n\n  var optionsNormalizer = {\n    normalizeApiOptions: normalizeApiOptions,\n    normalizeCliOptions: normalizeCliOptions\n  };\n\n  var getLast = function getLast(arr) {\n    return arr.length > 0 ? arr[arr.length - 1] : null;\n  };\n\n  function locStart(node, opts) {\n    opts = opts || {}; // Handle nodes with decorators. They should start at the first decorator\n\n    if (!opts.ignoreDecorators && node.declaration && node.declaration.decorators && node.declaration.decorators.length > 0) {\n      return locStart(node.declaration.decorators[0]);\n    }\n\n    if (!opts.ignoreDecorators && node.decorators && node.decorators.length > 0) {\n      return locStart(node.decorators[0]);\n    }\n\n    if (node.__location) {\n      return node.__location.startOffset;\n    }\n\n    if (node.range) {\n      return node.range[0];\n    }\n\n    if (typeof node.start === \"number\") {\n      return node.start;\n    }\n\n    if (node.loc) {\n      return node.loc.start;\n    }\n\n    return null;\n  }\n\n  function locEnd(node) {\n    var endNode = node.nodes && getLast(node.nodes);\n\n    if (endNode && node.source && !node.source.end) {\n      node = endNode;\n    }\n\n    if (node.__location) {\n      return node.__location.endOffset;\n    }\n\n    var loc = node.range ? node.range[1] : typeof node.end === \"number\" ? node.end : null;\n\n    if (node.typeAnnotation) {\n      return Math.max(loc, locEnd(node.typeAnnotation));\n    }\n\n    if (node.loc && !loc) {\n      return node.loc.end;\n    }\n\n    return loc;\n  }\n\n  var loc = {\n    locStart: locStart,\n    locEnd: locEnd\n  };\n\n  var jsTokens = createCommonjsModule(function (module, exports) {\n    // Copyright 2014, 2015, 2016, 2017, 2018 Simon Lydell\n    // License: MIT. (See LICENSE.)\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    }); // This regex comes from regex.coffee, and is inserted here by generate-index.js\n    // (run `npm run build`).\n\n    exports.default = /((['\"])(?:(?!\\2|\\\\).|\\\\(?:\\r\\n|[\\s\\S]))*(\\2)?|`(?:[^`\\\\$]|\\\\[\\s\\S]|\\$(?!\\{)|\\$\\{(?:[^{}]|\\{[^}]*\\}?)*\\}?)*(`)?)|(\\/\\/.*)|(\\/\\*(?:[^*]|\\*(?!\\/))*(\\*\\/)?)|(\\/(?!\\*)(?:\\[(?:(?![\\]\\\\]).|\\\\.)*\\]|(?![\\/\\]\\\\]).|\\\\.)+\\/(?:(?!\\s*(?:\\b|[\\u0080-\\uFFFF$\\\\'\"~({]|[+\\-!](?!=)|\\.?\\d))|[gmiyus]{1,6}\\b(?![\\u0080-\\uFFFF$\\\\]|\\s*(?:[+\\-*%&|^<>!=?({]|\\/(?![\\/*])))))|(0[xX][\\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?)|((?!\\d)(?:(?!\\s)[$\\w\\u0080-\\uFFFF]|\\\\u[\\da-fA-F]{4}|\\\\u\\{[\\da-fA-F]+\\})+)|(--|\\+\\+|&&|\\|\\||=>|\\.{3}|(?:[+\\-\\/%&|^]|\\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\\](){}])|(\\s+)|(^$|[\\s\\S])/g;\n\n    exports.matchToToken = function (match) {\n      var token = {\n        type: \"invalid\",\n        value: match[0],\n        closed: undefined\n      };\n      if (match[1]) token.type = \"string\", token.closed = !!(match[3] || match[4]);else if (match[5]) token.type = \"comment\";else if (match[6]) token.type = \"comment\", token.closed = !!match[7];else if (match[8]) token.type = \"regex\";else if (match[9]) token.type = \"number\";else if (match[10]) token.type = \"name\";else if (match[11]) token.type = \"punctuator\";else if (match[12]) token.type = \"whitespace\";\n      return token;\n    };\n  });\n  unwrapExports(jsTokens);\n  var jsTokens_1 = jsTokens.matchToToken;\n\n  var ast = createCommonjsModule(function (module) {\n    /*\n      Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>\n    \n      Redistribution and use in source and binary forms, with or without\n      modification, are permitted provided that the following conditions are met:\n    \n        * Redistributions of source code must retain the above copyright\n          notice, this list of conditions and the following disclaimer.\n        * Redistributions in binary form must reproduce the above copyright\n          notice, this list of conditions and the following disclaimer in the\n          documentation and/or other materials provided with the distribution.\n    \n      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'\n      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n    */\n    (function () {\n\n      function isExpression(node) {\n        if (node == null) {\n          return false;\n        }\n\n        switch (node.type) {\n          case 'ArrayExpression':\n          case 'AssignmentExpression':\n          case 'BinaryExpression':\n          case 'CallExpression':\n          case 'ConditionalExpression':\n          case 'FunctionExpression':\n          case 'Identifier':\n          case 'Literal':\n          case 'LogicalExpression':\n          case 'MemberExpression':\n          case 'NewExpression':\n          case 'ObjectExpression':\n          case 'SequenceExpression':\n          case 'ThisExpression':\n          case 'UnaryExpression':\n          case 'UpdateExpression':\n            return true;\n        }\n\n        return false;\n      }\n\n      function isIterationStatement(node) {\n        if (node == null) {\n          return false;\n        }\n\n        switch (node.type) {\n          case 'DoWhileStatement':\n          case 'ForInStatement':\n          case 'ForStatement':\n          case 'WhileStatement':\n            return true;\n        }\n\n        return false;\n      }\n\n      function isStatement(node) {\n        if (node == null) {\n          return false;\n        }\n\n        switch (node.type) {\n          case 'BlockStatement':\n          case 'BreakStatement':\n          case 'ContinueStatement':\n          case 'DebuggerStatement':\n          case 'DoWhileStatement':\n          case 'EmptyStatement':\n          case 'ExpressionStatement':\n          case 'ForInStatement':\n          case 'ForStatement':\n          case 'IfStatement':\n          case 'LabeledStatement':\n          case 'ReturnStatement':\n          case 'SwitchStatement':\n          case 'ThrowStatement':\n          case 'TryStatement':\n          case 'VariableDeclaration':\n          case 'WhileStatement':\n          case 'WithStatement':\n            return true;\n        }\n\n        return false;\n      }\n\n      function isSourceElement(node) {\n        return isStatement(node) || node != null && node.type === 'FunctionDeclaration';\n      }\n\n      function trailingStatement(node) {\n        switch (node.type) {\n          case 'IfStatement':\n            if (node.alternate != null) {\n              return node.alternate;\n            }\n\n            return node.consequent;\n\n          case 'LabeledStatement':\n          case 'ForStatement':\n          case 'ForInStatement':\n          case 'WhileStatement':\n          case 'WithStatement':\n            return node.body;\n        }\n\n        return null;\n      }\n\n      function isProblematicIfStatement(node) {\n        var current;\n\n        if (node.type !== 'IfStatement') {\n          return false;\n        }\n\n        if (node.alternate == null) {\n          return false;\n        }\n\n        current = node.consequent;\n\n        do {\n          if (current.type === 'IfStatement') {\n            if (current.alternate == null) {\n              return true;\n            }\n          }\n\n          current = trailingStatement(current);\n        } while (current);\n\n        return false;\n      }\n\n      module.exports = {\n        isExpression: isExpression,\n        isStatement: isStatement,\n        isIterationStatement: isIterationStatement,\n        isSourceElement: isSourceElement,\n        isProblematicIfStatement: isProblematicIfStatement,\n        trailingStatement: trailingStatement\n      };\n    })();\n    /* vim: set sw=4 ts=4 et tw=80 : */\n\n  });\n  var ast_1 = ast.isExpression;\n  var ast_2 = ast.isStatement;\n  var ast_3 = ast.isIterationStatement;\n  var ast_4 = ast.isSourceElement;\n  var ast_5 = ast.isProblematicIfStatement;\n  var ast_6 = ast.trailingStatement;\n\n  var code = createCommonjsModule(function (module) {\n    /*\n      Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>\n      Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>\n    \n      Redistribution and use in source and binary forms, with or without\n      modification, are permitted provided that the following conditions are met:\n    \n        * Redistributions of source code must retain the above copyright\n          notice, this list of conditions and the following disclaimer.\n        * Redistributions in binary form must reproduce the above copyright\n          notice, this list of conditions and the following disclaimer in the\n          documentation and/or other materials provided with the distribution.\n    \n      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n    */\n    (function () {\n\n      var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch; // See `tools/generate-identifier-regex.js`.\n\n      ES5Regex = {\n        // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierStart:\n        NonAsciiIdentifierStart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/,\n        // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierPart:\n        NonAsciiIdentifierPart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B4\\u08B6-\\u08BD\\u08D4-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFB-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/\n      };\n      ES6Regex = {\n        // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierStart:\n        NonAsciiIdentifierStart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDF00-\\uDF19]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F\\uDFE0]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1]|\\uD87E[\\uDC00-\\uDE1D]/,\n        // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierPart:\n        NonAsciiIdentifierPart: /[\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B4\\u08B6-\\u08BD\\u08D4-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFB-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDCA-\\uDDCC\\uDDD0-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3C-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB7\\uDEC0-\\uDEC9\\uDF00-\\uDF19\\uDF1D-\\uDF2B\\uDF30-\\uDF39]|\\uD806[\\uDCA0-\\uDCE9\\uDCFF\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50-\\uDF7E\\uDF8F-\\uDF9F\\uDFE0]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4A\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF]/\n      };\n\n      function isDecimalDigit(ch) {\n        return 0x30 <= ch && ch <= 0x39; // 0..9\n      }\n\n      function isHexDigit(ch) {\n        return 0x30 <= ch && ch <= 0x39 || // 0..9\n        0x61 <= ch && ch <= 0x66 || // a..f\n        0x41 <= ch && ch <= 0x46; // A..F\n      }\n\n      function isOctalDigit(ch) {\n        return ch >= 0x30 && ch <= 0x37; // 0..7\n      } // 7.2 White Space\n\n\n      NON_ASCII_WHITESPACES = [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF];\n\n      function isWhiteSpace(ch) {\n        return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 || ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;\n      } // 7.3 Line Terminators\n\n\n      function isLineTerminator(ch) {\n        return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;\n      } // 7.6 Identifier Names and Identifiers\n\n\n      function fromCodePoint(cp) {\n        if (cp <= 0xFFFF) {\n          return String.fromCharCode(cp);\n        }\n\n        var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);\n        var cu2 = String.fromCharCode((cp - 0x10000) % 0x400 + 0xDC00);\n        return cu1 + cu2;\n      }\n\n      IDENTIFIER_START = new Array(0x80);\n\n      for (ch = 0; ch < 0x80; ++ch) {\n        IDENTIFIER_START[ch] = ch >= 0x61 && ch <= 0x7A || // a..z\n        ch >= 0x41 && ch <= 0x5A || // A..Z\n        ch === 0x24 || ch === 0x5F; // $ (dollar) and _ (underscore)\n      }\n\n      IDENTIFIER_PART = new Array(0x80);\n\n      for (ch = 0; ch < 0x80; ++ch) {\n        IDENTIFIER_PART[ch] = ch >= 0x61 && ch <= 0x7A || // a..z\n        ch >= 0x41 && ch <= 0x5A || // A..Z\n        ch >= 0x30 && ch <= 0x39 || // 0..9\n        ch === 0x24 || ch === 0x5F; // $ (dollar) and _ (underscore)\n      }\n\n      function isIdentifierStartES5(ch) {\n        return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));\n      }\n\n      function isIdentifierPartES5(ch) {\n        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));\n      }\n\n      function isIdentifierStartES6(ch) {\n        return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));\n      }\n\n      function isIdentifierPartES6(ch) {\n        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));\n      }\n\n      module.exports = {\n        isDecimalDigit: isDecimalDigit,\n        isHexDigit: isHexDigit,\n        isOctalDigit: isOctalDigit,\n        isWhiteSpace: isWhiteSpace,\n        isLineTerminator: isLineTerminator,\n        isIdentifierStartES5: isIdentifierStartES5,\n        isIdentifierPartES5: isIdentifierPartES5,\n        isIdentifierStartES6: isIdentifierStartES6,\n        isIdentifierPartES6: isIdentifierPartES6\n      };\n    })();\n    /* vim: set sw=4 ts=4 et tw=80 : */\n\n  });\n  var code_1 = code.isDecimalDigit;\n  var code_2 = code.isHexDigit;\n  var code_3 = code.isOctalDigit;\n  var code_4 = code.isWhiteSpace;\n  var code_5 = code.isLineTerminator;\n  var code_6 = code.isIdentifierStartES5;\n  var code_7 = code.isIdentifierPartES5;\n  var code_8 = code.isIdentifierStartES6;\n  var code_9 = code.isIdentifierPartES6;\n\n  var keyword = createCommonjsModule(function (module) {\n    /*\n      Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>\n    \n      Redistribution and use in source and binary forms, with or without\n      modification, are permitted provided that the following conditions are met:\n    \n        * Redistributions of source code must retain the above copyright\n          notice, this list of conditions and the following disclaimer.\n        * Redistributions in binary form must reproduce the above copyright\n          notice, this list of conditions and the following disclaimer in the\n          documentation and/or other materials provided with the distribution.\n    \n      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n    */\n    (function () {\n\n      var code$1 = code;\n\n      function isStrictModeReservedWordES6(id) {\n        switch (id) {\n          case 'implements':\n          case 'interface':\n          case 'package':\n          case 'private':\n          case 'protected':\n          case 'public':\n          case 'static':\n          case 'let':\n            return true;\n\n          default:\n            return false;\n        }\n      }\n\n      function isKeywordES5(id, strict) {\n        // yield should not be treated as keyword under non-strict mode.\n        if (!strict && id === 'yield') {\n          return false;\n        }\n\n        return isKeywordES6(id, strict);\n      }\n\n      function isKeywordES6(id, strict) {\n        if (strict && isStrictModeReservedWordES6(id)) {\n          return true;\n        }\n\n        switch (id.length) {\n          case 2:\n            return id === 'if' || id === 'in' || id === 'do';\n\n          case 3:\n            return id === 'var' || id === 'for' || id === 'new' || id === 'try';\n\n          case 4:\n            return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';\n\n          case 5:\n            return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';\n\n          case 6:\n            return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';\n\n          case 7:\n            return id === 'default' || id === 'finally' || id === 'extends';\n\n          case 8:\n            return id === 'function' || id === 'continue' || id === 'debugger';\n\n          case 10:\n            return id === 'instanceof';\n\n          default:\n            return false;\n        }\n      }\n\n      function isReservedWordES5(id, strict) {\n        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);\n      }\n\n      function isReservedWordES6(id, strict) {\n        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);\n      }\n\n      function isRestrictedWord(id) {\n        return id === 'eval' || id === 'arguments';\n      }\n\n      function isIdentifierNameES5(id) {\n        var i, iz, ch;\n\n        if (id.length === 0) {\n          return false;\n        }\n\n        ch = id.charCodeAt(0);\n\n        if (!code$1.isIdentifierStartES5(ch)) {\n          return false;\n        }\n\n        for (i = 1, iz = id.length; i < iz; ++i) {\n          ch = id.charCodeAt(i);\n\n          if (!code$1.isIdentifierPartES5(ch)) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      function decodeUtf16(lead, trail) {\n        return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n      }\n\n      function isIdentifierNameES6(id) {\n        var i, iz, ch, lowCh, check;\n\n        if (id.length === 0) {\n          return false;\n        }\n\n        check = code$1.isIdentifierStartES6;\n\n        for (i = 0, iz = id.length; i < iz; ++i) {\n          ch = id.charCodeAt(i);\n\n          if (0xD800 <= ch && ch <= 0xDBFF) {\n            ++i;\n\n            if (i >= iz) {\n              return false;\n            }\n\n            lowCh = id.charCodeAt(i);\n\n            if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {\n              return false;\n            }\n\n            ch = decodeUtf16(ch, lowCh);\n          }\n\n          if (!check(ch)) {\n            return false;\n          }\n\n          check = code$1.isIdentifierPartES6;\n        }\n\n        return true;\n      }\n\n      function isIdentifierES5(id, strict) {\n        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);\n      }\n\n      function isIdentifierES6(id, strict) {\n        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);\n      }\n\n      module.exports = {\n        isKeywordES5: isKeywordES5,\n        isKeywordES6: isKeywordES6,\n        isReservedWordES5: isReservedWordES5,\n        isReservedWordES6: isReservedWordES6,\n        isRestrictedWord: isRestrictedWord,\n        isIdentifierNameES5: isIdentifierNameES5,\n        isIdentifierNameES6: isIdentifierNameES6,\n        isIdentifierES5: isIdentifierES5,\n        isIdentifierES6: isIdentifierES6\n      };\n    })();\n    /* vim: set sw=4 ts=4 et tw=80 : */\n\n  });\n  var keyword_1 = keyword.isKeywordES5;\n  var keyword_2 = keyword.isKeywordES6;\n  var keyword_3 = keyword.isReservedWordES5;\n  var keyword_4 = keyword.isReservedWordES6;\n  var keyword_5 = keyword.isRestrictedWord;\n  var keyword_6 = keyword.isIdentifierNameES5;\n  var keyword_7 = keyword.isIdentifierNameES6;\n  var keyword_8 = keyword.isIdentifierES5;\n  var keyword_9 = keyword.isIdentifierES6;\n\n  var utils$1 = createCommonjsModule(function (module, exports) {\n    /*\n      Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>\n    \n      Redistribution and use in source and binary forms, with or without\n      modification, are permitted provided that the following conditions are met:\n    \n        * Redistributions of source code must retain the above copyright\n          notice, this list of conditions and the following disclaimer.\n        * Redistributions in binary form must reproduce the above copyright\n          notice, this list of conditions and the following disclaimer in the\n          documentation and/or other materials provided with the distribution.\n    \n      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n    */\n    (function () {\n\n      exports.ast = ast;\n      exports.code = code;\n      exports.keyword = keyword;\n    })();\n    /* vim: set sw=4 ts=4 et tw=80 : */\n\n  });\n  var utils_1$1 = utils$1.ast;\n  var utils_2$1 = utils$1.code;\n  var utils_3$1 = utils$1.keyword;\n\n  var lib$1 = createCommonjsModule(function (module, exports) {\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.shouldHighlight = shouldHighlight;\n    exports.getChalk = getChalk;\n    exports.default = highlight;\n\n    function _jsTokens() {\n      var data = _interopRequireWildcard(jsTokens);\n\n      _jsTokens = function _jsTokens() {\n        return data;\n      };\n\n      return data;\n    }\n\n    function _esutils() {\n      var data = _interopRequireDefault(utils$1);\n\n      _esutils = function _esutils() {\n        return data;\n      };\n\n      return data;\n    }\n\n    function _chalk() {\n      var data = _interopRequireDefault(chalk);\n\n      _chalk = function _chalk() {\n        return data;\n      };\n\n      return data;\n    }\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        default: obj\n      };\n    }\n\n    function _interopRequireWildcard(obj) {\n      if (obj && obj.__esModule) {\n        return obj;\n      } else {\n        var newObj = {};\n\n        if (obj != null) {\n          for (var key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n              var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n              if (desc.get || desc.set) {\n                Object.defineProperty(newObj, key, desc);\n              } else {\n                newObj[key] = obj[key];\n              }\n            }\n          }\n        }\n\n        newObj.default = obj;\n        return newObj;\n      }\n    }\n\n    function getDefs(chalk) {\n      return {\n        keyword: chalk.cyan,\n        capitalized: chalk.yellow,\n        jsx_tag: chalk.yellow,\n        punctuator: chalk.yellow,\n        number: chalk.magenta,\n        string: chalk.green,\n        regex: chalk.magenta,\n        comment: chalk.grey,\n        invalid: chalk.white.bgRed.bold\n      };\n    }\n\n    var NEWLINE = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\n    var JSX_TAG = /^[a-z][\\w-]*$/i;\n    var BRACKET = /^[()[\\]{}]$/;\n\n    function getTokenType(match) {\n      var _match$slice = match.slice(-2),\n          _match$slice2 = _slicedToArray(_match$slice, 2),\n          offset = _match$slice2[0],\n          text = _match$slice2[1];\n\n      var token = (0, _jsTokens().matchToToken)(match);\n\n      if (token.type === \"name\") {\n        if (_esutils().default.keyword.isReservedWordES6(token.value)) {\n          return \"keyword\";\n        }\n\n        if (JSX_TAG.test(token.value) && (text[offset - 1] === \"<\" || text.substr(offset - 2, 2) == \"</\")) {\n          return \"jsx_tag\";\n        }\n\n        if (token.value[0] !== token.value[0].toLowerCase()) {\n          return \"capitalized\";\n        }\n      }\n\n      if (token.type === \"punctuator\" && BRACKET.test(token.value)) {\n        return \"bracket\";\n      }\n\n      if (token.type === \"invalid\" && (token.value === \"@\" || token.value === \"#\")) {\n        return \"punctuator\";\n      }\n\n      return token.type;\n    }\n\n    function highlightTokens(defs, text) {\n      return text.replace(_jsTokens().default, function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        var type = getTokenType(args);\n        var colorize = defs[type];\n\n        if (colorize) {\n          return args[0].split(NEWLINE).map(function (str) {\n            return colorize(str);\n          }).join(\"\\n\");\n        } else {\n          return args[0];\n        }\n      });\n    }\n\n    function shouldHighlight(options) {\n      return _chalk().default.supportsColor || options.forceColor;\n    }\n\n    function getChalk(options) {\n      var chalk = _chalk().default;\n\n      if (options.forceColor) {\n        chalk = new (_chalk().default.constructor)({\n          enabled: true,\n          level: 1\n        });\n      }\n\n      return chalk;\n    }\n\n    function highlight(code) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (shouldHighlight(options)) {\n        var chalk = getChalk(options);\n        var defs = getDefs(chalk);\n        return highlightTokens(defs, code);\n      } else {\n        return code;\n      }\n    }\n  });\n  unwrapExports(lib$1);\n  var lib_1 = lib$1.shouldHighlight;\n  var lib_2 = lib$1.getChalk;\n\n  var lib$2 = createCommonjsModule(function (module, exports) {\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.codeFrameColumns = codeFrameColumns;\n    exports.default = _default;\n\n    function _highlight() {\n      var data = _interopRequireWildcard(lib$1);\n\n      _highlight = function _highlight() {\n        return data;\n      };\n\n      return data;\n    }\n\n    function _interopRequireWildcard(obj) {\n      if (obj && obj.__esModule) {\n        return obj;\n      } else {\n        var newObj = {};\n\n        if (obj != null) {\n          for (var key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n              var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n              if (desc.get || desc.set) {\n                Object.defineProperty(newObj, key, desc);\n              } else {\n                newObj[key] = obj[key];\n              }\n            }\n          }\n        }\n\n        newObj.default = obj;\n        return newObj;\n      }\n    }\n\n    var deprecationWarningShown = false;\n\n    function getDefs(chalk) {\n      return {\n        gutter: chalk.grey,\n        marker: chalk.red.bold,\n        message: chalk.red.bold\n      };\n    }\n\n    var NEWLINE = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\n\n    function getMarkerLines(loc, source, opts) {\n      var startLoc = Object.assign({\n        column: 0,\n        line: -1\n      }, loc.start);\n      var endLoc = Object.assign({}, startLoc, loc.end);\n\n      var _ref = opts || {},\n          _ref$linesAbove = _ref.linesAbove,\n          linesAbove = _ref$linesAbove === void 0 ? 2 : _ref$linesAbove,\n          _ref$linesBelow = _ref.linesBelow,\n          linesBelow = _ref$linesBelow === void 0 ? 3 : _ref$linesBelow;\n\n      var startLine = startLoc.line;\n      var startColumn = startLoc.column;\n      var endLine = endLoc.line;\n      var endColumn = endLoc.column;\n      var start = Math.max(startLine - (linesAbove + 1), 0);\n      var end = Math.min(source.length, endLine + linesBelow);\n\n      if (startLine === -1) {\n        start = 0;\n      }\n\n      if (endLine === -1) {\n        end = source.length;\n      }\n\n      var lineDiff = endLine - startLine;\n      var markerLines = {};\n\n      if (lineDiff) {\n        for (var i = 0; i <= lineDiff; i++) {\n          var lineNumber = i + startLine;\n\n          if (!startColumn) {\n            markerLines[lineNumber] = true;\n          } else if (i === 0) {\n            var sourceLength = source[lineNumber - 1].length;\n            markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];\n          } else if (i === lineDiff) {\n            markerLines[lineNumber] = [0, endColumn];\n          } else {\n            var _sourceLength = source[lineNumber - i].length;\n            markerLines[lineNumber] = [0, _sourceLength];\n          }\n        }\n      } else {\n        if (startColumn === endColumn) {\n          if (startColumn) {\n            markerLines[startLine] = [startColumn, 0];\n          } else {\n            markerLines[startLine] = true;\n          }\n        } else {\n          markerLines[startLine] = [startColumn, endColumn - startColumn];\n        }\n      }\n\n      return {\n        start: start,\n        end: end,\n        markerLines: markerLines\n      };\n    }\n\n    function codeFrameColumns(rawLines, loc) {\n      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight().shouldHighlight)(opts);\n      var chalk = (0, _highlight().getChalk)(opts);\n      var defs = getDefs(chalk);\n\n      var maybeHighlight = function maybeHighlight(chalkFn, string) {\n        return highlighted ? chalkFn(string) : string;\n      };\n\n      var lines = rawLines.split(NEWLINE);\n\n      var _getMarkerLines = getMarkerLines(loc, lines, opts),\n          start = _getMarkerLines.start,\n          end = _getMarkerLines.end,\n          markerLines = _getMarkerLines.markerLines;\n\n      var hasColumns = loc.start && typeof loc.start.column === \"number\";\n      var numberMaxWidth = String(end).length;\n      var highlightedLines = highlighted ? (0, _highlight().default)(rawLines, opts) : rawLines;\n      var frame = highlightedLines.split(NEWLINE).slice(start, end).map(function (line, index) {\n        var number = start + 1 + index;\n        var paddedNumber = \" \".concat(number).slice(-numberMaxWidth);\n        var gutter = \" \".concat(paddedNumber, \" | \");\n        var hasMarker = markerLines[number];\n        var lastMarkerLine = !markerLines[number + 1];\n\n        if (hasMarker) {\n          var markerLine = \"\";\n\n          if (Array.isArray(hasMarker)) {\n            var markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\\t]/g, \" \");\n            var numberOfMarkers = hasMarker[1] || 1;\n            markerLine = [\"\\n \", maybeHighlight(defs.gutter, gutter.replace(/\\d/g, \" \")), markerSpacing, maybeHighlight(defs.marker, \"^\").repeat(numberOfMarkers)].join(\"\");\n\n            if (lastMarkerLine && opts.message) {\n              markerLine += \" \" + maybeHighlight(defs.message, opts.message);\n            }\n          }\n\n          return [maybeHighlight(defs.marker, \">\"), maybeHighlight(defs.gutter, gutter), line, markerLine].join(\"\");\n        } else {\n          return \" \".concat(maybeHighlight(defs.gutter, gutter)).concat(line);\n        }\n      }).join(\"\\n\");\n\n      if (opts.message && !hasColumns) {\n        frame = \"\".concat(\" \".repeat(numberMaxWidth + 1)).concat(opts.message, \"\\n\").concat(frame);\n      }\n\n      if (highlighted) {\n        return chalk.reset(frame);\n      } else {\n        return frame;\n      }\n    }\n\n    function _default(rawLines, lineNumber, colNumber) {\n      var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      if (!deprecationWarningShown) {\n        deprecationWarningShown = true;\n        var message = \"Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.\";\n\n        if (process.emitWarning) {\n          process.emitWarning(message, \"DeprecationWarning\");\n        } else {\n          var deprecationError = new Error(message);\n          deprecationError.name = \"DeprecationWarning\";\n          console.warn(new Error(message));\n        }\n      }\n\n      colNumber = Math.max(colNumber, 0);\n      var location = {\n        start: {\n          column: colNumber,\n          line: lineNumber\n        }\n      };\n      return codeFrameColumns(rawLines, location, opts);\n    }\n  });\n  unwrapExports(lib$2);\n  var lib_1$1 = lib$2.codeFrameColumns;\n\n  var ConfigError$1 = errors.ConfigError;\n  var locStart$1 = loc.locStart,\n      locEnd$1 = loc.locEnd; // Use defineProperties()/getOwnPropertyDescriptor() to prevent\n  // triggering the parsers getters.\n\n  var ownNames = Object.getOwnPropertyNames;\n  var ownDescriptor = Object.getOwnPropertyDescriptor;\n\n  function getParsers(options) {\n    var parsers = {};\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = options.plugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var plugin = _step.value;\n\n        if (!plugin.parsers) {\n          continue;\n        }\n\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = ownNames(plugin.parsers)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var name = _step2.value;\n            Object.defineProperty(parsers, name, ownDescriptor(plugin.parsers, name));\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return parsers;\n  }\n\n  function resolveParser(opts, parsers) {\n    parsers = parsers || getParsers(opts);\n\n    if (typeof opts.parser === \"function\") {\n      // Custom parser API always works with JavaScript.\n      return {\n        parse: opts.parser,\n        astFormat: \"estree\",\n        locStart: locStart$1,\n        locEnd: locEnd$1\n      };\n    }\n\n    if (typeof opts.parser === \"string\") {\n      if (Object.prototype.hasOwnProperty.call(parsers, opts.parser)) {\n        return parsers[opts.parser];\n      }\n      /* istanbul ignore next */\n\n\n      {\n        throw new ConfigError$1(\"Couldn't resolve parser \\\"\".concat(opts.parser, \"\\\". Parsers must be explicitly added to the standalone bundle.\"));\n      }\n    }\n  }\n\n  function parse(text, opts) {\n    var parsers = getParsers(opts); // Create a new object {parserName: parseFn}. Uses defineProperty() to only call\n    // the parsers getters when actually calling the parser `parse` function.\n\n    var parsersForCustomParserApi = Object.keys(parsers).reduce(function (object, parserName) {\n      return Object.defineProperty(object, parserName, {\n        enumerable: true,\n        get: function get() {\n          return parsers[parserName].parse;\n        }\n      });\n    }, {});\n    var parser = resolveParser(opts, parsers);\n\n    try {\n      if (parser.preprocess) {\n        text = parser.preprocess(text, opts);\n      }\n\n      return {\n        text: text,\n        ast: parser.parse(text, parsersForCustomParserApi, opts)\n      };\n    } catch (error) {\n      var loc = error.loc;\n\n      if (loc) {\n        var codeFrame = lib$2;\n        error.codeFrame = codeFrame.codeFrameColumns(text, loc, {\n          highlightCode: true\n        });\n        error.message += \"\\n\" + error.codeFrame;\n        throw error;\n      }\n      /* istanbul ignore next */\n\n\n      throw error.stack;\n    }\n  }\n\n  var parser = {\n    parse: parse,\n    resolveParser: resolveParser\n  };\n\n  var UndefinedParserError$1 = errors.UndefinedParserError;\n  var getSupportInfo$1 = support.getSupportInfo;\n  var resolveParser$1 = parser.resolveParser;\n  var hiddenDefaults = {\n    astFormat: \"estree\",\n    printer: {},\n    originalText: undefined,\n    locStart: null,\n    locEnd: null\n  }; // Copy options and fill in default values.\n\n  function normalize$1(options, opts) {\n    opts = opts || {};\n    var rawOptions = Object.assign({}, options);\n    var supportOptions = getSupportInfo$1(null, {\n      plugins: options.plugins,\n      showUnreleased: true,\n      showDeprecated: true\n    }).options;\n    var defaults = supportOptions.reduce(function (reduced, optionInfo) {\n      return optionInfo.default !== undefined ? Object.assign(reduced, _defineProperty({}, optionInfo.name, optionInfo.default)) : reduced;\n    }, Object.assign({}, hiddenDefaults));\n\n    if (!rawOptions.parser) {\n      if (!rawOptions.filepath) {\n        var logger = opts.logger || console;\n        logger.warn(\"No parser and no filepath given, using 'babel' the parser now \" + \"but this will throw an error in the future. \" + \"Please specify a parser or a filepath so one can be inferred.\");\n        rawOptions.parser = \"babel\";\n      } else {\n        rawOptions.parser = inferParser(rawOptions.filepath, rawOptions.plugins);\n\n        if (!rawOptions.parser) {\n          throw new UndefinedParserError$1(\"No parser could be inferred for file: \".concat(rawOptions.filepath));\n        }\n      }\n    }\n\n    var parser = resolveParser$1(optionsNormalizer.normalizeApiOptions(rawOptions, [supportOptions.find(function (x) {\n      return x.name === \"parser\";\n    })], {\n      passThrough: true,\n      logger: false\n    }));\n    rawOptions.astFormat = parser.astFormat;\n    rawOptions.locEnd = parser.locEnd;\n    rawOptions.locStart = parser.locStart;\n    var plugin = getPlugin(rawOptions);\n    rawOptions.printer = plugin.printers[rawOptions.astFormat];\n    var pluginDefaults = supportOptions.filter(function (optionInfo) {\n      return optionInfo.pluginDefaults && optionInfo.pluginDefaults[plugin.name] !== undefined;\n    }).reduce(function (reduced, optionInfo) {\n      return Object.assign(reduced, _defineProperty({}, optionInfo.name, optionInfo.pluginDefaults[plugin.name]));\n    }, {});\n    var mixedDefaults = Object.assign({}, defaults, pluginDefaults);\n    Object.keys(mixedDefaults).forEach(function (k) {\n      if (rawOptions[k] == null) {\n        rawOptions[k] = mixedDefaults[k];\n      }\n    });\n\n    if (rawOptions.parser === \"json\") {\n      rawOptions.trailingComma = \"none\";\n    }\n\n    return optionsNormalizer.normalizeApiOptions(rawOptions, supportOptions, Object.assign({\n      passThrough: Object.keys(hiddenDefaults)\n    }, opts));\n  }\n\n  function getPlugin(options) {\n    var astFormat = options.astFormat;\n\n    if (!astFormat) {\n      throw new Error(\"getPlugin() requires astFormat to be set\");\n    }\n\n    var printerPlugin = options.plugins.find(function (plugin) {\n      return plugin.printers && plugin.printers[astFormat];\n    });\n\n    if (!printerPlugin) {\n      throw new Error(\"Couldn't find plugin for AST format \\\"\".concat(astFormat, \"\\\"\"));\n    }\n\n    return printerPlugin;\n  }\n\n  function getInterpreter(filepath) {\n    if (typeof filepath !== \"string\") {\n      return \"\";\n    }\n\n    var fd;\n\n    try {\n      fd = fs.openSync(filepath, \"r\");\n    } catch (err) {\n      return \"\";\n    }\n\n    try {\n      var liner = new readlines(fd);\n      var firstLine = liner.next().toString(\"utf8\"); // #!/bin/env node, #!/usr/bin/env node\n\n      var m1 = firstLine.match(/^#!\\/(?:usr\\/)?bin\\/env\\s+(\\S+)/);\n\n      if (m1) {\n        return m1[1];\n      } // #!/bin/node, #!/usr/bin/node, #!/usr/local/bin/node\n\n\n      var m2 = firstLine.match(/^#!\\/(?:usr\\/(?:local\\/)?)?bin\\/(\\S+)/);\n\n      if (m2) {\n        return m2[1];\n      }\n\n      return \"\";\n    } catch (err) {\n      // There are some weird cases where paths are missing, causing Jest\n      // failures. It's unclear what these correspond to in the real world.\n      return \"\";\n    } finally {\n      try {\n        // There are some weird cases where paths are missing, causing Jest\n        // failures. It's unclear what these correspond to in the real world.\n        fs.closeSync(fd);\n      } catch (err) {// nop\n      }\n    }\n  }\n\n  function inferParser(filepath, plugins) {\n    var filepathParts = normalizePath(filepath).split(\"/\");\n    var filename = filepathParts[filepathParts.length - 1].toLowerCase(); // If the file has no extension, we can try to infer the language from the\n    // interpreter in the shebang line, if any; but since this requires FS access,\n    // do it last.\n\n    var language = getSupportInfo$1(null, {\n      plugins: plugins\n    }).languages.find(function (language) {\n      return language.since !== null && (language.extensions && language.extensions.some(function (extension) {\n        return filename.endsWith(extension);\n      }) || language.filenames && language.filenames.find(function (name) {\n        return name.toLowerCase() === filename;\n      }) || filename.indexOf(\".\") === -1 && language.interpreters && language.interpreters.indexOf(getInterpreter(filepath)) !== -1);\n    });\n    return language && language.parsers[0];\n  }\n\n  var options$1 = {\n    normalize: normalize$1,\n    hiddenDefaults: hiddenDefaults,\n    inferParser: inferParser\n  };\n\n  function massageAST(ast, options, parent) {\n    if (Array.isArray(ast)) {\n      return ast.map(function (e) {\n        return massageAST(e, options, parent);\n      }).filter(function (e) {\n        return e;\n      });\n    }\n\n    if (!ast || _typeof(ast) !== \"object\") {\n      return ast;\n    }\n\n    var newObj = {};\n\n    for (var _i = 0, _Object$keys = Object.keys(ast); _i < _Object$keys.length; _i++) {\n      var key = _Object$keys[_i];\n\n      if (typeof ast[key] !== \"function\") {\n        newObj[key] = massageAST(ast[key], options, ast);\n      }\n    }\n\n    if (options.printer.massageAstNode) {\n      var result = options.printer.massageAstNode(ast, newObj, parent);\n\n      if (result === null) {\n        return undefined;\n      }\n\n      if (result) {\n        return result;\n      }\n    }\n\n    return newObj;\n  }\n\n  var massageAst = massageAST;\n\n  function assert() {}\n\n  assert.ok = function () {};\n\n  assert.strictEqual = function () {};\n\n  /**\n   * @param {Doc[]} parts\n   * @returns Doc\n   */\n\n\n  function concat(parts) {\n    // access the internals of a document directly.\n    // if(parts.length === 1) {\n    //   // If it's a single document, no need to concat it.\n    //   return parts[0];\n    // }\n\n\n    return {\n      type: \"concat\",\n      parts: parts\n    };\n  }\n  /**\n   * @param {Doc} contents\n   * @returns Doc\n   */\n\n\n  function indent(contents) {\n\n    return {\n      type: \"indent\",\n      contents: contents\n    };\n  }\n  /**\n   * @param {number} n\n   * @param {Doc} contents\n   * @returns Doc\n   */\n\n\n  function align(n, contents) {\n\n    return {\n      type: \"align\",\n      contents: contents,\n      n: n\n    };\n  }\n  /**\n   * @param {Doc} contents\n   * @param {object} [opts] - TBD ???\n   * @returns Doc\n   */\n\n\n  function group(contents, opts) {\n    opts = opts || {};\n\n    return {\n      type: \"group\",\n      id: opts.id,\n      contents: contents,\n      break: !!opts.shouldBreak,\n      expandedStates: opts.expandedStates\n    };\n  }\n  /**\n   * @param {Doc} contents\n   * @returns Doc\n   */\n\n\n  function dedentToRoot(contents) {\n    return align(-Infinity, contents);\n  }\n  /**\n   * @param {Doc} contents\n   * @returns Doc\n   */\n\n\n  function markAsRoot(contents) {\n    // @ts-ignore - TBD ???:\n    return align({\n      type: \"root\"\n    }, contents);\n  }\n  /**\n   * @param {Doc} contents\n   * @returns Doc\n   */\n\n\n  function dedent(contents) {\n    return align(-1, contents);\n  }\n  /**\n   * @param {Doc[]} states\n   * @param {object} [opts] - TBD ???\n   * @returns Doc\n   */\n\n\n  function conditionalGroup(states, opts) {\n    return group(states[0], Object.assign(opts || {}, {\n      expandedStates: states\n    }));\n  }\n  /**\n   * @param {Doc[]} parts\n   * @returns Doc\n   */\n\n\n  function fill(parts) {\n\n    return {\n      type: \"fill\",\n      parts: parts\n    };\n  }\n  /**\n   * @param {Doc} [breakContents]\n   * @param {Doc} [flatContents]\n   * @param {object} [opts] - TBD ???\n   * @returns Doc\n   */\n\n\n  function ifBreak(breakContents, flatContents, opts) {\n    opts = opts || {};\n\n    return {\n      type: \"if-break\",\n      breakContents: breakContents,\n      flatContents: flatContents,\n      groupId: opts.groupId\n    };\n  }\n  /**\n   * @param {Doc} contents\n   * @returns Doc\n   */\n\n\n  function lineSuffix(contents) {\n\n    return {\n      type: \"line-suffix\",\n      contents: contents\n    };\n  }\n\n  var lineSuffixBoundary = {\n    type: \"line-suffix-boundary\"\n  };\n  var breakParent = {\n    type: \"break-parent\"\n  };\n  var trim = {\n    type: \"trim\"\n  };\n  var line = {\n    type: \"line\"\n  };\n  var softline = {\n    type: \"line\",\n    soft: true\n  };\n  var hardline = concat([{\n    type: \"line\",\n    hard: true\n  }, breakParent]);\n  var literalline = concat([{\n    type: \"line\",\n    hard: true,\n    literal: true\n  }, breakParent]);\n  var cursor = {\n    type: \"cursor\",\n    placeholder: Symbol(\"cursor\")\n  };\n  /**\n   * @param {Doc} sep\n   * @param {Doc[]} arr\n   * @returns Doc\n   */\n\n  function join(sep, arr) {\n    var res = [];\n\n    for (var i = 0; i < arr.length; i++) {\n      if (i !== 0) {\n        res.push(sep);\n      }\n\n      res.push(arr[i]);\n    }\n\n    return concat(res);\n  }\n  /**\n   * @param {Doc} doc\n   * @param {number} size\n   * @param {number} tabWidth\n   */\n\n\n  function addAlignmentToDoc(doc, size, tabWidth) {\n    var aligned = doc;\n\n    if (size > 0) {\n      // Use indent to add tabs for all the levels of tabs we need\n      for (var i = 0; i < Math.floor(size / tabWidth); ++i) {\n        aligned = indent(aligned);\n      } // Use align for all the spaces that are needed\n\n\n      aligned = align(size % tabWidth, aligned); // size is absolute from 0 and not relative to the current\n      // indentation, so we use -Infinity to reset the indentation to 0\n\n      aligned = align(-Infinity, aligned);\n    }\n\n    return aligned;\n  }\n\n  var docBuilders = {\n    concat: concat,\n    join: join,\n    line: line,\n    softline: softline,\n    hardline: hardline,\n    literalline: literalline,\n    group: group,\n    conditionalGroup: conditionalGroup,\n    fill: fill,\n    lineSuffix: lineSuffix,\n    lineSuffixBoundary: lineSuffixBoundary,\n    cursor: cursor,\n    breakParent: breakParent,\n    ifBreak: ifBreak,\n    trim: trim,\n    indent: indent,\n    align: align,\n    addAlignmentToDoc: addAlignmentToDoc,\n    markAsRoot: markAsRoot,\n    dedentToRoot: dedentToRoot,\n    dedent: dedent\n  };\n\n  var ansiRegex = function ansiRegex(options) {\n    options = Object.assign({\n      onlyFirst: false\n    }, options);\n    var pattern = [\"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:[a-zA-Z\\\\d]*(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\", '(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))'].join('|');\n    return new RegExp(pattern, options.onlyFirst ? undefined : 'g');\n  };\n\n  var stripAnsi = function stripAnsi(string) {\n    return typeof string === 'string' ? string.replace(ansiRegex(), '') : string;\n  };\n\n  var stripAnsi_1 = stripAnsi;\n  var default_1$1 = stripAnsi;\n  stripAnsi_1.default = default_1$1;\n\n  /* eslint-disable yoda */\n\n  var isFullwidthCodePoint = function isFullwidthCodePoint(codePoint) {\n    if (Number.isNaN(codePoint)) {\n      return false;\n    } // Code points are derived from:\n    // http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt\n\n\n    if (codePoint >= 0x1100 && (codePoint <= 0x115F || // Hangul Jamo\n    codePoint === 0x2329 || // LEFT-POINTING ANGLE BRACKET\n    codePoint === 0x232A || // RIGHT-POINTING ANGLE BRACKET\n    // CJK Radicals Supplement .. Enclosed CJK Letters and Months\n    0x2E80 <= codePoint && codePoint <= 0x3247 && codePoint !== 0x303F || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\n    0x3250 <= codePoint && codePoint <= 0x4DBF || // CJK Unified Ideographs .. Yi Radicals\n    0x4E00 <= codePoint && codePoint <= 0xA4C6 || // Hangul Jamo Extended-A\n    0xA960 <= codePoint && codePoint <= 0xA97C || // Hangul Syllables\n    0xAC00 <= codePoint && codePoint <= 0xD7A3 || // CJK Compatibility Ideographs\n    0xF900 <= codePoint && codePoint <= 0xFAFF || // Vertical Forms\n    0xFE10 <= codePoint && codePoint <= 0xFE19 || // CJK Compatibility Forms .. Small Form Variants\n    0xFE30 <= codePoint && codePoint <= 0xFE6B || // Halfwidth and Fullwidth Forms\n    0xFF01 <= codePoint && codePoint <= 0xFF60 || 0xFFE0 <= codePoint && codePoint <= 0xFFE6 || // Kana Supplement\n    0x1B000 <= codePoint && codePoint <= 0x1B001 || // Enclosed Ideographic Supplement\n    0x1F200 <= codePoint && codePoint <= 0x1F251 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\n    0x20000 <= codePoint && codePoint <= 0x3FFFD)) {\n      return true;\n    }\n\n    return false;\n  };\n\n  var isFullwidthCodePoint_1 = isFullwidthCodePoint;\n  var default_1$2 = isFullwidthCodePoint;\n  isFullwidthCodePoint_1.default = default_1$2;\n\n  var emojiRegex = function emojiRegex() {\n    // https://mths.be/emoji\n    return /\\uD83C\\uDFF4\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73)\\uDB40\\uDC7F|\\uD83D\\uDC68(?:\\uD83C\\uDFFC\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C\\uDFFB|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFE])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFD])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFC])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D[\\uDC66\\uDC67])|[\\u2695\\u2696\\u2708]\\uFE0F|\\uD83D[\\uDC66\\uDC67]|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|(?:\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708])\\uFE0F|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C[\\uDFFB-\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFB\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFC\\u200D\\uD83E\\uDD1D\\u200D\\uD83D\\uDC69)\\uD83C\\uDFFB|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1(?:\\uD83C[\\uDFFB-\\uDFFF])|\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1)|(?:\\uD83E\\uDDD1\\uD83C\\uDFFE\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFF\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFE])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFC\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFD\\u200D\\uD83E\\uDD1D\\u200D\\uD83D\\uDC69)(?:\\uD83C[\\uDFFB\\uDFFC])|\\uD83D\\uDC69(?:\\uD83C\\uDFFE\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFC-\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|(?:\\uD83E\\uDDD1\\uD83C\\uDFFD\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFE\\u200D\\uD83E\\uDD1D\\u200D\\uD83D\\uDC69)(?:\\uD83C[\\uDFFB-\\uDFFD])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D[\\uDC66\\uDC67])|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83D\\uDC69(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|(?:(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)\\uFE0F|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF])\\u200D[\\u2640\\u2642]|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD6-\\uDDDD])(?:(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|\\u200D[\\u2640\\u2642])|\\uD83C\\uDFF4\\u200D\\u2620)\\uFE0F|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|\\uD83D\\uDC15\\u200D\\uD83E\\uDDBA|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83C\\uDDF6\\uD83C\\uDDE6|[#\\*0-9]\\uFE0F\\u20E3|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83E\\uDDD1(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC70\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDCAA\\uDD74\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD36\\uDDB5\\uDDB6\\uDDBB\\uDDD2-\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDED5\\uDEEB\\uDEEC\\uDEF4-\\uDEFA\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0D-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD71\\uDD73-\\uDD76\\uDD7A-\\uDDA2\\uDDA5-\\uDDAA\\uDDAE-\\uDDCA\\uDDCD-\\uDDFF\\uDE70-\\uDE73\\uDE78-\\uDE7A\\uDE80-\\uDE82\\uDE90-\\uDE95])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDED5\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEFA\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0D-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD71\\uDD73-\\uDD76\\uDD7A-\\uDDA2\\uDDA5-\\uDDAA\\uDDAE-\\uDDCA\\uDDCD-\\uDDFF\\uDE70-\\uDE73\\uDE78-\\uDE7A\\uDE80-\\uDE82\\uDE90-\\uDE95])\\uFE0F|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDC8F\\uDC91\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD0F\\uDD18-\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3C-\\uDD3E\\uDDB5\\uDDB6\\uDDB8\\uDDB9\\uDDBB\\uDDCD-\\uDDCF\\uDDD1-\\uDDDD])/g;\n  };\n\n  var stringWidth = function stringWidth(string) {\n    string = string.replace(emojiRegex(), '  ');\n\n    if (typeof string !== 'string' || string.length === 0) {\n      return 0;\n    }\n\n    string = stripAnsi_1(string);\n    var width = 0;\n\n    for (var i = 0; i < string.length; i++) {\n      var code = string.codePointAt(i); // Ignore control characters\n\n      if (code <= 0x1F || code >= 0x7F && code <= 0x9F) {\n        continue;\n      } // Ignore combining characters\n\n\n      if (code >= 0x300 && code <= 0x36F) {\n        continue;\n      } // Surrogates\n\n\n      if (code > 0xFFFF) {\n        i++;\n      }\n\n      width += isFullwidthCodePoint_1(code) ? 2 : 1;\n    }\n\n    return width;\n  };\n\n  var stringWidth_1 = stringWidth; // TODO: remove this in the next major version\n\n  var default_1$3 = stringWidth;\n  stringWidth_1.default = default_1$3;\n\n  var notAsciiRegex = /[^\\x20-\\x7F]/;\n\n  function isExportDeclaration(node) {\n    if (node) {\n      switch (node.type) {\n        case \"ExportDefaultDeclaration\":\n        case \"ExportDefaultSpecifier\":\n        case \"DeclareExportDeclaration\":\n        case \"ExportNamedDeclaration\":\n        case \"ExportAllDeclaration\":\n          return true;\n      }\n    }\n\n    return false;\n  }\n\n  function getParentExportDeclaration(path) {\n    var parentNode = path.getParentNode();\n\n    if (path.getName() === \"declaration\" && isExportDeclaration(parentNode)) {\n      return parentNode;\n    }\n\n    return null;\n  }\n\n  function getPenultimate(arr) {\n    if (arr.length > 1) {\n      return arr[arr.length - 2];\n    }\n\n    return null;\n  }\n  /**\n   * @typedef {{backwards?: boolean}} SkipOptions\n   */\n\n  /**\n   * @param {string | RegExp} chars\n   * @returns {(text: string, index: number | false, opts?: SkipOptions) => number | false}\n   */\n\n\n  function skip(chars) {\n    return function (text, index, opts) {\n      var backwards = opts && opts.backwards; // Allow `skip` functions to be threaded together without having\n      // to check for failures (did someone say monads?).\n\n      if (index === false) {\n        return false;\n      }\n\n      var length = text.length;\n      var cursor = index;\n\n      while (cursor >= 0 && cursor < length) {\n        var c = text.charAt(cursor);\n\n        if (chars instanceof RegExp) {\n          if (!chars.test(c)) {\n            return cursor;\n          }\n        } else if (chars.indexOf(c) === -1) {\n          return cursor;\n        }\n\n        backwards ? cursor-- : cursor++;\n      }\n\n      if (cursor === -1 || cursor === length) {\n        // If we reached the beginning or end of the file, return the\n        // out-of-bounds cursor. It's up to the caller to handle this\n        // correctly. We don't want to indicate `false` though if it\n        // actually skipped valid characters.\n        return cursor;\n      }\n\n      return false;\n    };\n  }\n  /**\n   * @type {(text: string, index: number | false, opts?: SkipOptions) => number | false}\n   */\n\n\n  var skipWhitespace = skip(/\\s/);\n  /**\n   * @type {(text: string, index: number | false, opts?: SkipOptions) => number | false}\n   */\n\n  var skipSpaces = skip(\" \\t\");\n  /**\n   * @type {(text: string, index: number | false, opts?: SkipOptions) => number | false}\n   */\n\n  var skipToLineEnd = skip(\",; \\t\");\n  /**\n   * @type {(text: string, index: number | false, opts?: SkipOptions) => number | false}\n   */\n\n  var skipEverythingButNewLine = skip(/[^\\r\\n]/);\n  /**\n   * @param {string} text\n   * @param {number | false} index\n   * @returns {number | false}\n   */\n\n  function skipInlineComment(text, index) {\n    if (index === false) {\n      return false;\n    }\n\n    if (text.charAt(index) === \"/\" && text.charAt(index + 1) === \"*\") {\n      for (var i = index + 2; i < text.length; ++i) {\n        if (text.charAt(i) === \"*\" && text.charAt(i + 1) === \"/\") {\n          return i + 2;\n        }\n      }\n    }\n\n    return index;\n  }\n  /**\n   * @param {string} text\n   * @param {number | false} index\n   * @returns {number | false}\n   */\n\n\n  function skipTrailingComment(text, index) {\n    if (index === false) {\n      return false;\n    }\n\n    if (text.charAt(index) === \"/\" && text.charAt(index + 1) === \"/\") {\n      return skipEverythingButNewLine(text, index);\n    }\n\n    return index;\n  } // This one doesn't use the above helper function because it wants to\n  // test \\r\\n in order and `skip` doesn't support ordering and we only\n  // want to skip one newline. It's simple to implement.\n\n  /**\n   * @param {string} text\n   * @param {number | false} index\n   * @param {SkipOptions=} opts\n   * @returns {number | false}\n   */\n\n\n  function skipNewline(text, index, opts) {\n    var backwards = opts && opts.backwards;\n\n    if (index === false) {\n      return false;\n    }\n\n    var atIndex = text.charAt(index);\n\n    if (backwards) {\n      if (text.charAt(index - 1) === \"\\r\" && atIndex === \"\\n\") {\n        return index - 2;\n      }\n\n      if (atIndex === \"\\n\" || atIndex === \"\\r\" || atIndex === \"\\u2028\" || atIndex === \"\\u2029\") {\n        return index - 1;\n      }\n    } else {\n      if (atIndex === \"\\r\" && text.charAt(index + 1) === \"\\n\") {\n        return index + 2;\n      }\n\n      if (atIndex === \"\\n\" || atIndex === \"\\r\" || atIndex === \"\\u2028\" || atIndex === \"\\u2029\") {\n        return index + 1;\n      }\n    }\n\n    return index;\n  }\n  /**\n   * @param {string} text\n   * @param {number} index\n   * @param {SkipOptions=} opts\n   * @returns {boolean}\n   */\n\n\n  function hasNewline(text, index, opts) {\n    opts = opts || {};\n    var idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);\n    var idx2 = skipNewline(text, idx, opts);\n    return idx !== idx2;\n  }\n  /**\n   * @param {string} text\n   * @param {number} start\n   * @param {number} end\n   * @returns {boolean}\n   */\n\n\n  function hasNewlineInRange(text, start, end) {\n    for (var i = start; i < end; ++i) {\n      if (text.charAt(i) === \"\\n\") {\n        return true;\n      }\n    }\n\n    return false;\n  } // Note: this function doesn't ignore leading comments unlike isNextLineEmpty\n\n  /**\n   * @template N\n   * @param {string} text\n   * @param {N} node\n   * @param {(node: N) => number} locStart\n   */\n\n\n  function isPreviousLineEmpty(text, node, locStart) {\n    /** @type {number | false} */\n    var idx = locStart(node) - 1;\n    idx = skipSpaces(text, idx, {\n      backwards: true\n    });\n    idx = skipNewline(text, idx, {\n      backwards: true\n    });\n    idx = skipSpaces(text, idx, {\n      backwards: true\n    });\n    var idx2 = skipNewline(text, idx, {\n      backwards: true\n    });\n    return idx !== idx2;\n  }\n  /**\n   * @param {string} text\n   * @param {number} index\n   * @returns {boolean}\n   */\n\n\n  function isNextLineEmptyAfterIndex(text, index) {\n    /** @type {number | false} */\n    var oldIdx = null;\n    /** @type {number | false} */\n\n    var idx = index;\n\n    while (idx !== oldIdx) {\n      // We need to skip all the potential trailing inline comments\n      oldIdx = idx;\n      idx = skipToLineEnd(text, idx);\n      idx = skipInlineComment(text, idx);\n      idx = skipSpaces(text, idx);\n    }\n\n    idx = skipTrailingComment(text, idx);\n    idx = skipNewline(text, idx);\n    return idx !== false && hasNewline(text, idx);\n  }\n  /**\n   * @template N\n   * @param {string} text\n   * @param {N} node\n   * @param {(node: N) => number} locEnd\n   * @returns {boolean}\n   */\n\n\n  function isNextLineEmpty(text, node, locEnd) {\n    return isNextLineEmptyAfterIndex(text, locEnd(node));\n  }\n  /**\n   * @param {string} text\n   * @param {number} idx\n   * @returns {number | false}\n   */\n\n\n  function getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, idx) {\n    /** @type {number | false} */\n    var oldIdx = null;\n    /** @type {number | false} */\n\n    var nextIdx = idx;\n\n    while (nextIdx !== oldIdx) {\n      oldIdx = nextIdx;\n      nextIdx = skipSpaces(text, nextIdx);\n      nextIdx = skipInlineComment(text, nextIdx);\n      nextIdx = skipTrailingComment(text, nextIdx);\n      nextIdx = skipNewline(text, nextIdx);\n    }\n\n    return nextIdx;\n  }\n  /**\n   * @template N\n   * @param {string} text\n   * @param {N} node\n   * @param {(node: N) => number} locEnd\n   * @returns {number | false}\n   */\n\n\n  function getNextNonSpaceNonCommentCharacterIndex(text, node, locEnd) {\n    return getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, locEnd(node));\n  }\n  /**\n   * @template N\n   * @param {string} text\n   * @param {N} node\n   * @param {(node: N) => number} locEnd\n   * @returns {string}\n   */\n\n\n  function getNextNonSpaceNonCommentCharacter(text, node, locEnd) {\n    return text.charAt( // @ts-ignore => TBD: can return false, should we define a fallback?\n    getNextNonSpaceNonCommentCharacterIndex(text, node, locEnd));\n  }\n  /**\n   * @param {string} text\n   * @param {number} index\n   * @param {SkipOptions=} opts\n   * @returns {boolean}\n   */\n\n\n  function hasSpaces(text, index, opts) {\n    opts = opts || {};\n    var idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);\n    return idx !== index;\n  }\n  /**\n   * @param {{range?: [number, number], start?: number}} node\n   * @param {number} index\n   */\n\n\n  function setLocStart(node, index) {\n    if (node.range) {\n      node.range[0] = index;\n    } else {\n      node.start = index;\n    }\n  }\n  /**\n   * @param {{range?: [number, number], end?: number}} node\n   * @param {number} index\n   */\n\n\n  function setLocEnd(node, index) {\n    if (node.range) {\n      node.range[1] = index;\n    } else {\n      node.end = index;\n    }\n  }\n\n  var PRECEDENCE = {};\n  [[\"|>\"], [\"??\"], [\"||\"], [\"&&\"], [\"|\"], [\"^\"], [\"&\"], [\"==\", \"===\", \"!=\", \"!==\"], [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"], [\">>\", \"<<\", \">>>\"], [\"+\", \"-\"], [\"*\", \"/\", \"%\"], [\"**\"]].forEach(function (tier, i) {\n    tier.forEach(function (op) {\n      PRECEDENCE[op] = i;\n    });\n  });\n\n  function getPrecedence(op) {\n    return PRECEDENCE[op];\n  }\n\n  var equalityOperators = {\n    \"==\": true,\n    \"!=\": true,\n    \"===\": true,\n    \"!==\": true\n  };\n  var multiplicativeOperators = {\n    \"*\": true,\n    \"/\": true,\n    \"%\": true\n  };\n  var bitshiftOperators = {\n    \">>\": true,\n    \">>>\": true,\n    \"<<\": true\n  };\n\n  function shouldFlatten(parentOp, nodeOp) {\n    if (getPrecedence(nodeOp) !== getPrecedence(parentOp)) {\n      return false;\n    } // ** is right-associative\n    // x ** y ** z --> x ** (y ** z)\n\n\n    if (parentOp === \"**\") {\n      return false;\n    } // x == y == z --> (x == y) == z\n\n\n    if (equalityOperators[parentOp] && equalityOperators[nodeOp]) {\n      return false;\n    } // x * y % z --> (x * y) % z\n\n\n    if (nodeOp === \"%\" && multiplicativeOperators[parentOp] || parentOp === \"%\" && multiplicativeOperators[nodeOp]) {\n      return false;\n    } // x * y / z --> (x * y) / z\n    // x / y * z --> (x / y) * z\n\n\n    if (nodeOp !== parentOp && multiplicativeOperators[nodeOp] && multiplicativeOperators[parentOp]) {\n      return false;\n    } // x << y << z --> (x << y) << z\n\n\n    if (bitshiftOperators[parentOp] && bitshiftOperators[nodeOp]) {\n      return false;\n    }\n\n    return true;\n  }\n\n  function isBitwiseOperator(operator) {\n    return !!bitshiftOperators[operator] || operator === \"|\" || operator === \"^\" || operator === \"&\";\n  } // Tests if an expression starts with `{`, or (if forbidFunctionClassAndDoExpr\n  // holds) `function`, `class`, or `do {}`. Will be overzealous if there's\n  // already necessary grouping parentheses.\n\n\n  function startsWithNoLookaheadToken(node, forbidFunctionClassAndDoExpr) {\n    node = getLeftMost(node);\n\n    switch (node.type) {\n      case \"FunctionExpression\":\n      case \"ClassExpression\":\n      case \"DoExpression\":\n        return forbidFunctionClassAndDoExpr;\n\n      case \"ObjectExpression\":\n        return true;\n\n      case \"MemberExpression\":\n      case \"OptionalMemberExpression\":\n        return startsWithNoLookaheadToken(node.object, forbidFunctionClassAndDoExpr);\n\n      case \"TaggedTemplateExpression\":\n        if (node.tag.type === \"FunctionExpression\") {\n          // IIFEs are always already parenthesized\n          return false;\n        }\n\n        return startsWithNoLookaheadToken(node.tag, forbidFunctionClassAndDoExpr);\n\n      case \"CallExpression\":\n      case \"OptionalCallExpression\":\n        if (node.callee.type === \"FunctionExpression\") {\n          // IIFEs are always already parenthesized\n          return false;\n        }\n\n        return startsWithNoLookaheadToken(node.callee, forbidFunctionClassAndDoExpr);\n\n      case \"ConditionalExpression\":\n        return startsWithNoLookaheadToken(node.test, forbidFunctionClassAndDoExpr);\n\n      case \"UpdateExpression\":\n        return !node.prefix && startsWithNoLookaheadToken(node.argument, forbidFunctionClassAndDoExpr);\n\n      case \"BindExpression\":\n        return node.object && startsWithNoLookaheadToken(node.object, forbidFunctionClassAndDoExpr);\n\n      case \"SequenceExpression\":\n        return startsWithNoLookaheadToken(node.expressions[0], forbidFunctionClassAndDoExpr);\n\n      case \"TSAsExpression\":\n        return startsWithNoLookaheadToken(node.expression, forbidFunctionClassAndDoExpr);\n\n      default:\n        return false;\n    }\n  }\n\n  function getLeftMost(node) {\n    if (node.left) {\n      return getLeftMost(node.left);\n    }\n\n    return node;\n  }\n  /**\n   * @param {string} value\n   * @param {number} tabWidth\n   * @param {number=} startIndex\n   * @returns {number}\n   */\n\n\n  function getAlignmentSize(value, tabWidth, startIndex) {\n    startIndex = startIndex || 0;\n    var size = 0;\n\n    for (var i = startIndex; i < value.length; ++i) {\n      if (value[i] === \"\\t\") {\n        // Tabs behave in a way that they are aligned to the nearest\n        // multiple of tabWidth:\n        // 0 -> 4, 1 -> 4, 2 -> 4, 3 -> 4\n        // 4 -> 8, 5 -> 8, 6 -> 8, 7 -> 8 ...\n        size = size + tabWidth - size % tabWidth;\n      } else {\n        size++;\n      }\n    }\n\n    return size;\n  }\n  /**\n   * @param {string} value\n   * @param {number} tabWidth\n   * @returns {number}\n   */\n\n\n  function getIndentSize(value, tabWidth) {\n    var lastNewlineIndex = value.lastIndexOf(\"\\n\");\n\n    if (lastNewlineIndex === -1) {\n      return 0;\n    }\n\n    return getAlignmentSize( // All the leading whitespaces\n    value.slice(lastNewlineIndex + 1).match(/^[ \\t]*/)[0], tabWidth);\n  }\n  /**\n   * @typedef {'\"' | \"'\"} Quote\n   */\n\n  /**\n   *\n   * @param {string} raw\n   * @param {Quote} preferredQuote\n   * @returns {Quote}\n   */\n\n\n  function getPreferredQuote(raw, preferredQuote) {\n    // `rawContent` is the string exactly like it appeared in the input source\n    // code, without its enclosing quotes.\n    var rawContent = raw.slice(1, -1);\n    /** @type {{ quote: '\"', regex: RegExp }} */\n\n    var double = {\n      quote: '\"',\n      regex: /\"/g\n    };\n    /** @type {{ quote: \"'\", regex: RegExp }} */\n\n    var single = {\n      quote: \"'\",\n      regex: /'/g\n    };\n    var preferred = preferredQuote === \"'\" ? single : double;\n    var alternate = preferred === single ? double : single;\n    var result = preferred.quote; // If `rawContent` contains at least one of the quote preferred for enclosing\n    // the string, we might want to enclose with the alternate quote instead, to\n    // minimize the number of escaped quotes.\n\n    if (rawContent.includes(preferred.quote) || rawContent.includes(alternate.quote)) {\n      var numPreferredQuotes = (rawContent.match(preferred.regex) || []).length;\n      var numAlternateQuotes = (rawContent.match(alternate.regex) || []).length;\n      result = numPreferredQuotes > numAlternateQuotes ? alternate.quote : preferred.quote;\n    }\n\n    return result;\n  }\n\n  function printString(raw, options, isDirectiveLiteral) {\n    // `rawContent` is the string exactly like it appeared in the input source\n    // code, without its enclosing quotes.\n    var rawContent = raw.slice(1, -1); // Check for the alternate quote, to determine if we're allowed to swap\n    // the quotes on a DirectiveLiteral.\n\n    var canChangeDirectiveQuotes = !rawContent.includes('\"') && !rawContent.includes(\"'\");\n    /** @type {Quote} */\n\n    var enclosingQuote = options.parser === \"json\" ? '\"' : options.__isInHtmlAttribute ? \"'\" : getPreferredQuote(raw, options.singleQuote ? \"'\" : '\"'); // Directives are exact code unit sequences, which means that you can't\n    // change the escape sequences they use.\n    // See https://github.com/prettier/prettier/issues/1555\n    // and https://tc39.github.io/ecma262/#directive-prologue\n\n    if (isDirectiveLiteral) {\n      if (canChangeDirectiveQuotes) {\n        return enclosingQuote + rawContent + enclosingQuote;\n      }\n\n      return raw;\n    } // It might sound unnecessary to use `makeString` even if the string already\n    // is enclosed with `enclosingQuote`, but it isn't. The string could contain\n    // unnecessary escapes (such as in `\"\\'\"`). Always using `makeString` makes\n    // sure that we consistently output the minimum amount of escaped quotes.\n\n\n    return makeString(rawContent, enclosingQuote, !(options.parser === \"css\" || options.parser === \"less\" || options.parser === \"scss\" || options.embeddedInHtml));\n  }\n  /**\n   * @param {string} rawContent\n   * @param {Quote} enclosingQuote\n   * @param {boolean=} unescapeUnnecessaryEscapes\n   * @returns {string}\n   */\n\n\n  function makeString(rawContent, enclosingQuote, unescapeUnnecessaryEscapes) {\n    var otherQuote = enclosingQuote === '\"' ? \"'\" : '\"'; // Matches _any_ escape and unescaped quotes (both single and double).\n\n    var regex = /\\\\([\\s\\S])|(['\"])/g; // Escape and unescape single and double quotes as needed to be able to\n    // enclose `rawContent` with `enclosingQuote`.\n\n    var newContent = rawContent.replace(regex, function (match, escaped, quote) {\n      // If we matched an escape, and the escaped character is a quote of the\n      // other type than we intend to enclose the string with, there's no need for\n      // it to be escaped, so return it _without_ the backslash.\n      if (escaped === otherQuote) {\n        return escaped;\n      } // If we matched an unescaped quote and it is of the _same_ type as we\n      // intend to enclose the string with, it must be escaped, so return it with\n      // a backslash.\n\n\n      if (quote === enclosingQuote) {\n        return \"\\\\\" + quote;\n      }\n\n      if (quote) {\n        return quote;\n      } // Unescape any unnecessarily escaped character.\n      // Adapted from https://github.com/eslint/eslint/blob/de0b4ad7bd820ade41b1f606008bea68683dc11a/lib/rules/no-useless-escape.js#L27\n\n\n      return unescapeUnnecessaryEscapes && /^[^\\\\nrvtbfux\\r\\n\\u2028\\u2029\"'0-7]$/.test(escaped) ? escaped : \"\\\\\" + escaped;\n    });\n    return enclosingQuote + newContent + enclosingQuote;\n  }\n\n  function printNumber(rawNumber) {\n    return rawNumber.toLowerCase() // Remove unnecessary plus and zeroes from scientific notation.\n    .replace(/^([+-]?[\\d.]+e)(?:\\+|(-))?0*(\\d)/, \"$1$2$3\") // Remove unnecessary scientific notation (1e0).\n    .replace(/^([+-]?[\\d.]+)e[+-]?0+$/, \"$1\") // Make sure numbers always start with a digit.\n    .replace(/^([+-])?\\./, \"$10.\") // Remove extraneous trailing decimal zeroes.\n    .replace(/(\\.\\d+?)0+(?=e|$)/, \"$1\") // Remove trailing dot.\n    .replace(/\\.(?=e|$)/, \"\");\n  }\n  /**\n   * @param {string} str\n   * @param {string} target\n   * @returns {number}\n   */\n\n\n  function getMaxContinuousCount(str, target) {\n    var results = str.match(new RegExp(\"(\".concat(escapeStringRegexp(target), \")+\"), \"g\"));\n\n    if (results === null) {\n      return 0;\n    }\n\n    return results.reduce(function (maxCount, result) {\n      return Math.max(maxCount, result.length / target.length);\n    }, 0);\n  }\n\n  function getMinNotPresentContinuousCount(str, target) {\n    var matches = str.match(new RegExp(\"(\".concat(escapeStringRegexp(target), \")+\"), \"g\"));\n\n    if (matches === null) {\n      return 0;\n    }\n\n    var countPresent = new Map();\n    var max = 0;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = matches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var match = _step.value;\n        var count = match.length / target.length;\n        countPresent.set(count, true);\n\n        if (count > max) {\n          max = count;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    for (var i = 1; i < max; i++) {\n      if (!countPresent.get(i)) {\n        return i;\n      }\n    }\n\n    return max + 1;\n  }\n  /**\n   * @param {string} text\n   * @returns {number}\n   */\n\n\n  function getStringWidth(text) {\n    if (!text) {\n      return 0;\n    } // shortcut to avoid needless string `RegExp`s, replacements, and allocations within `string-width`\n\n\n    if (!notAsciiRegex.test(text)) {\n      return text.length;\n    }\n\n    return stringWidth_1(text);\n  }\n\n  function hasIgnoreComment(path) {\n    var node = path.getValue();\n    return hasNodeIgnoreComment(node);\n  }\n\n  function hasNodeIgnoreComment(node) {\n    return node && node.comments && node.comments.length > 0 && node.comments.some(function (comment) {\n      return comment.value.trim() === \"prettier-ignore\";\n    });\n  }\n\n  function matchAncestorTypes(path, types, index) {\n    index = index || 0;\n    types = types.slice();\n\n    while (types.length) {\n      var parent = path.getParentNode(index);\n      var type = types.shift();\n\n      if (!parent || parent.type !== type) {\n        return false;\n      }\n\n      index++;\n    }\n\n    return true;\n  }\n\n  function addCommentHelper(node, comment) {\n    var comments = node.comments || (node.comments = []);\n    comments.push(comment);\n    comment.printed = false; // For some reason, TypeScript parses `// x` inside of JSXText as a comment\n    // We already \"print\" it via the raw text, we don't need to re-print it as a\n    // comment\n\n    if (node.type === \"JSXText\") {\n      comment.printed = true;\n    }\n  }\n\n  function addLeadingComment(node, comment) {\n    comment.leading = true;\n    comment.trailing = false;\n    addCommentHelper(node, comment);\n  }\n\n  function addDanglingComment(node, comment) {\n    comment.leading = false;\n    comment.trailing = false;\n    addCommentHelper(node, comment);\n  }\n\n  function addTrailingComment(node, comment) {\n    comment.leading = false;\n    comment.trailing = true;\n    addCommentHelper(node, comment);\n  }\n\n  function isWithinParentArrayProperty(path, propertyName) {\n    var node = path.getValue();\n    var parent = path.getParentNode();\n\n    if (parent == null) {\n      return false;\n    }\n\n    if (!Array.isArray(parent[propertyName])) {\n      return false;\n    }\n\n    var key = path.getName();\n    return parent[propertyName][key] === node;\n  }\n\n  function replaceEndOfLineWith(text, replacement) {\n    var parts = [];\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = text.split(\"\\n\")[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var part = _step2.value;\n\n        if (parts.length !== 0) {\n          parts.push(replacement);\n        }\n\n        parts.push(part);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return parts;\n  }\n\n  var util = {\n    replaceEndOfLineWith: replaceEndOfLineWith,\n    getStringWidth: getStringWidth,\n    getMaxContinuousCount: getMaxContinuousCount,\n    getMinNotPresentContinuousCount: getMinNotPresentContinuousCount,\n    getPrecedence: getPrecedence,\n    shouldFlatten: shouldFlatten,\n    isBitwiseOperator: isBitwiseOperator,\n    isExportDeclaration: isExportDeclaration,\n    getParentExportDeclaration: getParentExportDeclaration,\n    getPenultimate: getPenultimate,\n    getLast: getLast,\n    getNextNonSpaceNonCommentCharacterIndexWithStartIndex: getNextNonSpaceNonCommentCharacterIndexWithStartIndex,\n    getNextNonSpaceNonCommentCharacterIndex: getNextNonSpaceNonCommentCharacterIndex,\n    getNextNonSpaceNonCommentCharacter: getNextNonSpaceNonCommentCharacter,\n    skip: skip,\n    skipWhitespace: skipWhitespace,\n    skipSpaces: skipSpaces,\n    skipToLineEnd: skipToLineEnd,\n    skipEverythingButNewLine: skipEverythingButNewLine,\n    skipInlineComment: skipInlineComment,\n    skipTrailingComment: skipTrailingComment,\n    skipNewline: skipNewline,\n    isNextLineEmptyAfterIndex: isNextLineEmptyAfterIndex,\n    isNextLineEmpty: isNextLineEmpty,\n    isPreviousLineEmpty: isPreviousLineEmpty,\n    hasNewline: hasNewline,\n    hasNewlineInRange: hasNewlineInRange,\n    hasSpaces: hasSpaces,\n    setLocStart: setLocStart,\n    setLocEnd: setLocEnd,\n    startsWithNoLookaheadToken: startsWithNoLookaheadToken,\n    getAlignmentSize: getAlignmentSize,\n    getIndentSize: getIndentSize,\n    getPreferredQuote: getPreferredQuote,\n    printString: printString,\n    printNumber: printNumber,\n    hasIgnoreComment: hasIgnoreComment,\n    hasNodeIgnoreComment: hasNodeIgnoreComment,\n    makeString: makeString,\n    matchAncestorTypes: matchAncestorTypes,\n    addLeadingComment: addLeadingComment,\n    addDanglingComment: addDanglingComment,\n    addTrailingComment: addTrailingComment,\n    isWithinParentArrayProperty: isWithinParentArrayProperty\n  };\n\n  function guessEndOfLine(text) {\n    var index = text.indexOf(\"\\r\");\n\n    if (index >= 0) {\n      return text.charAt(index + 1) === \"\\n\" ? \"crlf\" : \"cr\";\n    }\n\n    return \"lf\";\n  }\n\n  function convertEndOfLineToChars(value) {\n    switch (value) {\n      case \"cr\":\n        return \"\\r\";\n\n      case \"crlf\":\n        return \"\\r\\n\";\n\n      default:\n        return \"\\n\";\n    }\n  }\n\n  var endOfLine = {\n    guessEndOfLine: guessEndOfLine,\n    convertEndOfLineToChars: convertEndOfLineToChars\n  };\n\n  var getStringWidth$1 = util.getStringWidth;\n  var convertEndOfLineToChars$1 = endOfLine.convertEndOfLineToChars;\n  var concat$1 = docBuilders.concat,\n      fill$1 = docBuilders.fill,\n      cursor$1 = docBuilders.cursor;\n  /** @type {Record<symbol, typeof MODE_BREAK | typeof MODE_FLAT>} */\n\n  var groupModeMap;\n  var MODE_BREAK = 1;\n  var MODE_FLAT = 2;\n\n  function rootIndent() {\n    return {\n      value: \"\",\n      length: 0,\n      queue: []\n    };\n  }\n\n  function makeIndent(ind, options) {\n    return generateInd(ind, {\n      type: \"indent\"\n    }, options);\n  }\n\n  function makeAlign(ind, n, options) {\n    return n === -Infinity ? ind.root || rootIndent() : n < 0 ? generateInd(ind, {\n      type: \"dedent\"\n    }, options) : !n ? ind : n.type === \"root\" ? Object.assign({}, ind, {\n      root: ind\n    }) : typeof n === \"string\" ? generateInd(ind, {\n      type: \"stringAlign\",\n      n: n\n    }, options) : generateInd(ind, {\n      type: \"numberAlign\",\n      n: n\n    }, options);\n  }\n\n  function generateInd(ind, newPart, options) {\n    var queue = newPart.type === \"dedent\" ? ind.queue.slice(0, -1) : ind.queue.concat(newPart);\n    var value = \"\";\n    var length = 0;\n    var lastTabs = 0;\n    var lastSpaces = 0;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = queue[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var part = _step.value;\n\n        switch (part.type) {\n          case \"indent\":\n            flush();\n\n            if (options.useTabs) {\n              addTabs(1);\n            } else {\n              addSpaces(options.tabWidth);\n            }\n\n            break;\n\n          case \"stringAlign\":\n            flush();\n            value += part.n;\n            length += part.n.length;\n            break;\n\n          case \"numberAlign\":\n            lastTabs += 1;\n            lastSpaces += part.n;\n            break;\n\n          /* istanbul ignore next */\n\n          default:\n            throw new Error(\"Unexpected type '\".concat(part.type, \"'\"));\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    flushSpaces();\n    return Object.assign({}, ind, {\n      value: value,\n      length: length,\n      queue: queue\n    });\n\n    function addTabs(count) {\n      value += \"\\t\".repeat(count);\n      length += options.tabWidth * count;\n    }\n\n    function addSpaces(count) {\n      value += \" \".repeat(count);\n      length += count;\n    }\n\n    function flush() {\n      if (options.useTabs) {\n        flushTabs();\n      } else {\n        flushSpaces();\n      }\n    }\n\n    function flushTabs() {\n      if (lastTabs > 0) {\n        addTabs(lastTabs);\n      }\n\n      resetLast();\n    }\n\n    function flushSpaces() {\n      if (lastSpaces > 0) {\n        addSpaces(lastSpaces);\n      }\n\n      resetLast();\n    }\n\n    function resetLast() {\n      lastTabs = 0;\n      lastSpaces = 0;\n    }\n  }\n\n  function trim$1(out) {\n    if (out.length === 0) {\n      return 0;\n    }\n\n    var trimCount = 0; // Trim whitespace at the end of line\n\n    while (out.length > 0 && typeof out[out.length - 1] === \"string\" && out[out.length - 1].match(/^[ \\t]*$/)) {\n      trimCount += out.pop().length;\n    }\n\n    if (out.length && typeof out[out.length - 1] === \"string\") {\n      var trimmed = out[out.length - 1].replace(/[ \\t]*$/, \"\");\n      trimCount += out[out.length - 1].length - trimmed.length;\n      out[out.length - 1] = trimmed;\n    }\n\n    return trimCount;\n  }\n\n  function fits(next, restCommands, width, options, mustBeFlat) {\n    var restIdx = restCommands.length;\n    var cmds = [next]; // `out` is only used for width counting because `trim` requires to look\n    // backwards for space characters.\n\n    var out = [];\n\n    while (width >= 0) {\n      if (cmds.length === 0) {\n        if (restIdx === 0) {\n          return true;\n        }\n\n        cmds.push(restCommands[restIdx - 1]);\n        restIdx--;\n        continue;\n      }\n\n      var x = cmds.pop();\n      var ind = x[0];\n      var mode = x[1];\n      var doc = x[2];\n\n      if (typeof doc === \"string\") {\n        out.push(doc);\n        width -= getStringWidth$1(doc);\n      } else {\n        switch (doc.type) {\n          case \"concat\":\n            for (var i = doc.parts.length - 1; i >= 0; i--) {\n              cmds.push([ind, mode, doc.parts[i]]);\n            }\n\n            break;\n\n          case \"indent\":\n            cmds.push([makeIndent(ind, options), mode, doc.contents]);\n            break;\n\n          case \"align\":\n            cmds.push([makeAlign(ind, doc.n, options), mode, doc.contents]);\n            break;\n\n          case \"trim\":\n            width += trim$1(out);\n            break;\n\n          case \"group\":\n            if (mustBeFlat && doc.break) {\n              return false;\n            }\n\n            cmds.push([ind, doc.break ? MODE_BREAK : mode, doc.contents]);\n\n            if (doc.id) {\n              groupModeMap[doc.id] = cmds[cmds.length - 1][1];\n            }\n\n            break;\n\n          case \"fill\":\n            for (var _i = doc.parts.length - 1; _i >= 0; _i--) {\n              cmds.push([ind, mode, doc.parts[_i]]);\n            }\n\n            break;\n\n          case \"if-break\":\n            {\n              var groupMode = doc.groupId ? groupModeMap[doc.groupId] : mode;\n\n              if (groupMode === MODE_BREAK) {\n                if (doc.breakContents) {\n                  cmds.push([ind, mode, doc.breakContents]);\n                }\n              }\n\n              if (groupMode === MODE_FLAT) {\n                if (doc.flatContents) {\n                  cmds.push([ind, mode, doc.flatContents]);\n                }\n              }\n\n              break;\n            }\n\n          case \"line\":\n            switch (mode) {\n              // fallthrough\n              case MODE_FLAT:\n                if (!doc.hard) {\n                  if (!doc.soft) {\n                    out.push(\" \");\n                    width -= 1;\n                  }\n\n                  break;\n                }\n\n                return true;\n\n              case MODE_BREAK:\n                return true;\n            }\n\n            break;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  function printDocToString(doc, options) {\n    groupModeMap = {};\n    var width = options.printWidth;\n    var newLine = convertEndOfLineToChars$1(options.endOfLine);\n    var pos = 0; // cmds is basically a stack. We've turned a recursive call into a\n    // while loop which is much faster. The while loop below adds new\n    // cmds to the array instead of recursively calling `print`.\n\n    var cmds = [[rootIndent(), MODE_BREAK, doc]];\n    var out = [];\n    var shouldRemeasure = false;\n    var lineSuffix = [];\n\n    while (cmds.length !== 0) {\n      var x = cmds.pop();\n      var ind = x[0];\n      var mode = x[1];\n      var _doc = x[2];\n\n      if (typeof _doc === \"string\") {\n        out.push(_doc);\n        pos += getStringWidth$1(_doc);\n      } else {\n        switch (_doc.type) {\n          case \"cursor\":\n            out.push(cursor$1.placeholder);\n            break;\n\n          case \"concat\":\n            for (var i = _doc.parts.length - 1; i >= 0; i--) {\n              cmds.push([ind, mode, _doc.parts[i]]);\n            }\n\n            break;\n\n          case \"indent\":\n            cmds.push([makeIndent(ind, options), mode, _doc.contents]);\n            break;\n\n          case \"align\":\n            cmds.push([makeAlign(ind, _doc.n, options), mode, _doc.contents]);\n            break;\n\n          case \"trim\":\n            pos -= trim$1(out);\n            break;\n\n          case \"group\":\n            switch (mode) {\n              case MODE_FLAT:\n                if (!shouldRemeasure) {\n                  cmds.push([ind, _doc.break ? MODE_BREAK : MODE_FLAT, _doc.contents]);\n                  break;\n                }\n\n              // fallthrough\n\n              case MODE_BREAK:\n                {\n                  shouldRemeasure = false;\n                  var next = [ind, MODE_FLAT, _doc.contents];\n                  var rem = width - pos;\n\n                  if (!_doc.break && fits(next, cmds, rem, options)) {\n                    cmds.push(next);\n                  } else {\n                    // Expanded states are a rare case where a document\n                    // can manually provide multiple representations of\n                    // itself. It provides an array of documents\n                    // going from the least expanded (most flattened)\n                    // representation first to the most expanded. If a\n                    // group has these, we need to manually go through\n                    // these states and find the first one that fits.\n                    if (_doc.expandedStates) {\n                      var mostExpanded = _doc.expandedStates[_doc.expandedStates.length - 1];\n\n                      if (_doc.break) {\n                        cmds.push([ind, MODE_BREAK, mostExpanded]);\n                        break;\n                      } else {\n                        for (var _i2 = 1; _i2 < _doc.expandedStates.length + 1; _i2++) {\n                          if (_i2 >= _doc.expandedStates.length) {\n                            cmds.push([ind, MODE_BREAK, mostExpanded]);\n                            break;\n                          } else {\n                            var state = _doc.expandedStates[_i2];\n                            var cmd = [ind, MODE_FLAT, state];\n\n                            if (fits(cmd, cmds, rem, options)) {\n                              cmds.push(cmd);\n                              break;\n                            }\n                          }\n                        }\n                      }\n                    } else {\n                      cmds.push([ind, MODE_BREAK, _doc.contents]);\n                    }\n                  }\n\n                  break;\n                }\n            }\n\n            if (_doc.id) {\n              groupModeMap[_doc.id] = cmds[cmds.length - 1][1];\n            }\n\n            break;\n          // Fills each line with as much code as possible before moving to a new\n          // line with the same indentation.\n          //\n          // Expects doc.parts to be an array of alternating content and\n          // whitespace. The whitespace contains the linebreaks.\n          //\n          // For example:\n          //   [\"I\", line, \"love\", line, \"monkeys\"]\n          // or\n          //   [{ type: group, ... }, softline, { type: group, ... }]\n          //\n          // It uses this parts structure to handle three main layout cases:\n          // * The first two content items fit on the same line without\n          //   breaking\n          //   -> output the first content item and the whitespace \"flat\".\n          // * Only the first content item fits on the line without breaking\n          //   -> output the first content item \"flat\" and the whitespace with\n          //   \"break\".\n          // * Neither content item fits on the line without breaking\n          //   -> output the first content item and the whitespace with \"break\".\n\n          case \"fill\":\n            {\n              var _rem = width - pos;\n\n              var parts = _doc.parts;\n\n              if (parts.length === 0) {\n                break;\n              }\n\n              var content = parts[0];\n              var contentFlatCmd = [ind, MODE_FLAT, content];\n              var contentBreakCmd = [ind, MODE_BREAK, content];\n              var contentFits = fits(contentFlatCmd, [], _rem, options, true);\n\n              if (parts.length === 1) {\n                if (contentFits) {\n                  cmds.push(contentFlatCmd);\n                } else {\n                  cmds.push(contentBreakCmd);\n                }\n\n                break;\n              }\n\n              var whitespace = parts[1];\n              var whitespaceFlatCmd = [ind, MODE_FLAT, whitespace];\n              var whitespaceBreakCmd = [ind, MODE_BREAK, whitespace];\n\n              if (parts.length === 2) {\n                if (contentFits) {\n                  cmds.push(whitespaceFlatCmd);\n                  cmds.push(contentFlatCmd);\n                } else {\n                  cmds.push(whitespaceBreakCmd);\n                  cmds.push(contentBreakCmd);\n                }\n\n                break;\n              } // At this point we've handled the first pair (context, separator)\n              // and will create a new fill doc for the rest of the content.\n              // Ideally we wouldn't mutate the array here but coping all the\n              // elements to a new array would make this algorithm quadratic,\n              // which is unusable for large arrays (e.g. large texts in JSX).\n\n\n              parts.splice(0, 2);\n              var remainingCmd = [ind, mode, fill$1(parts)];\n              var secondContent = parts[0];\n              var firstAndSecondContentFlatCmd = [ind, MODE_FLAT, concat$1([content, whitespace, secondContent])];\n              var firstAndSecondContentFits = fits(firstAndSecondContentFlatCmd, [], _rem, options, true);\n\n              if (firstAndSecondContentFits) {\n                cmds.push(remainingCmd);\n                cmds.push(whitespaceFlatCmd);\n                cmds.push(contentFlatCmd);\n              } else if (contentFits) {\n                cmds.push(remainingCmd);\n                cmds.push(whitespaceBreakCmd);\n                cmds.push(contentFlatCmd);\n              } else {\n                cmds.push(remainingCmd);\n                cmds.push(whitespaceBreakCmd);\n                cmds.push(contentBreakCmd);\n              }\n\n              break;\n            }\n\n          case \"if-break\":\n            {\n              var groupMode = _doc.groupId ? groupModeMap[_doc.groupId] : mode;\n\n              if (groupMode === MODE_BREAK) {\n                if (_doc.breakContents) {\n                  cmds.push([ind, mode, _doc.breakContents]);\n                }\n              }\n\n              if (groupMode === MODE_FLAT) {\n                if (_doc.flatContents) {\n                  cmds.push([ind, mode, _doc.flatContents]);\n                }\n              }\n\n              break;\n            }\n\n          case \"line-suffix\":\n            lineSuffix.push([ind, mode, _doc.contents]);\n            break;\n\n          case \"line-suffix-boundary\":\n            if (lineSuffix.length > 0) {\n              cmds.push([ind, mode, {\n                type: \"line\",\n                hard: true\n              }]);\n            }\n\n            break;\n\n          case \"line\":\n            switch (mode) {\n              case MODE_FLAT:\n                if (!_doc.hard) {\n                  if (!_doc.soft) {\n                    out.push(\" \");\n                    pos += 1;\n                  }\n\n                  break;\n                } else {\n                  // This line was forced into the output even if we\n                  // were in flattened mode, so we need to tell the next\n                  // group that no matter what, it needs to remeasure\n                  // because the previous measurement didn't accurately\n                  // capture the entire expression (this is necessary\n                  // for nested groups)\n                  shouldRemeasure = true;\n                }\n\n              // fallthrough\n\n              case MODE_BREAK:\n                if (lineSuffix.length) {\n                  cmds.push([ind, mode, _doc]);\n                  [].push.apply(cmds, lineSuffix.reverse());\n                  lineSuffix = [];\n                  break;\n                }\n\n                if (_doc.literal) {\n                  if (ind.root) {\n                    out.push(newLine, ind.root.value);\n                    pos = ind.root.length;\n                  } else {\n                    out.push(newLine);\n                    pos = 0;\n                  }\n                } else {\n                  pos -= trim$1(out);\n                  out.push(newLine + ind.value);\n                  pos = ind.length;\n                }\n\n                break;\n            }\n\n            break;\n        }\n      }\n    }\n\n    var cursorPlaceholderIndex = out.indexOf(cursor$1.placeholder);\n\n    if (cursorPlaceholderIndex !== -1) {\n      var otherCursorPlaceholderIndex = out.indexOf(cursor$1.placeholder, cursorPlaceholderIndex + 1);\n      var beforeCursor = out.slice(0, cursorPlaceholderIndex).join(\"\");\n      var aroundCursor = out.slice(cursorPlaceholderIndex + 1, otherCursorPlaceholderIndex).join(\"\");\n      var afterCursor = out.slice(otherCursorPlaceholderIndex + 1).join(\"\");\n      return {\n        formatted: beforeCursor + aroundCursor + afterCursor,\n        cursorNodeStart: beforeCursor.length,\n        cursorNodeText: aroundCursor\n      };\n    }\n\n    return {\n      formatted: out.join(\"\")\n    };\n  }\n\n  var docPrinter = {\n    printDocToString: printDocToString\n  };\n\n  var traverseDocOnExitStackMarker = {};\n\n  function traverseDoc(doc, onEnter, onExit, shouldTraverseConditionalGroups) {\n    var docsStack = [doc];\n\n    while (docsStack.length !== 0) {\n      var _doc = docsStack.pop();\n\n      if (_doc === traverseDocOnExitStackMarker) {\n        onExit(docsStack.pop());\n        continue;\n      }\n\n      var shouldRecurse = true;\n\n      if (onEnter) {\n        if (onEnter(_doc) === false) {\n          shouldRecurse = false;\n        }\n      }\n\n      if (onExit) {\n        docsStack.push(_doc);\n        docsStack.push(traverseDocOnExitStackMarker);\n      }\n\n      if (shouldRecurse) {\n        // When there are multiple parts to process,\n        // the parts need to be pushed onto the stack in reverse order,\n        // so that they are processed in the original order\n        // when the stack is popped.\n        if (_doc.type === \"concat\" || _doc.type === \"fill\") {\n          for (var ic = _doc.parts.length, i = ic - 1; i >= 0; --i) {\n            docsStack.push(_doc.parts[i]);\n          }\n        } else if (_doc.type === \"if-break\") {\n          if (_doc.flatContents) {\n            docsStack.push(_doc.flatContents);\n          }\n\n          if (_doc.breakContents) {\n            docsStack.push(_doc.breakContents);\n          }\n        } else if (_doc.type === \"group\" && _doc.expandedStates) {\n          if (shouldTraverseConditionalGroups) {\n            for (var _ic = _doc.expandedStates.length, _i = _ic - 1; _i >= 0; --_i) {\n              docsStack.push(_doc.expandedStates[_i]);\n            }\n          } else {\n            docsStack.push(_doc.contents);\n          }\n        } else if (_doc.contents) {\n          docsStack.push(_doc.contents);\n        }\n      }\n    }\n  }\n\n  function mapDoc(doc, cb) {\n    if (doc.type === \"concat\" || doc.type === \"fill\") {\n      var parts = doc.parts.map(function (part) {\n        return mapDoc(part, cb);\n      });\n      return cb(Object.assign({}, doc, {\n        parts: parts\n      }));\n    } else if (doc.type === \"if-break\") {\n      var breakContents = doc.breakContents && mapDoc(doc.breakContents, cb);\n      var flatContents = doc.flatContents && mapDoc(doc.flatContents, cb);\n      return cb(Object.assign({}, doc, {\n        breakContents: breakContents,\n        flatContents: flatContents\n      }));\n    } else if (doc.contents) {\n      var contents = mapDoc(doc.contents, cb);\n      return cb(Object.assign({}, doc, {\n        contents: contents\n      }));\n    }\n\n    return cb(doc);\n  }\n\n  function findInDoc(doc, fn, defaultValue) {\n    var result = defaultValue;\n    var hasStopped = false;\n\n    function findInDocOnEnterFn(doc) {\n      var maybeResult = fn(doc);\n\n      if (maybeResult !== undefined) {\n        hasStopped = true;\n        result = maybeResult;\n      }\n\n      if (hasStopped) {\n        return false;\n      }\n    }\n\n    traverseDoc(doc, findInDocOnEnterFn);\n    return result;\n  }\n\n  function isEmpty(n) {\n    return typeof n === \"string\" && n.length === 0;\n  }\n\n  function isLineNextFn(doc) {\n    if (typeof doc === \"string\") {\n      return false;\n    }\n\n    if (doc.type === \"line\") {\n      return true;\n    }\n  }\n\n  function isLineNext(doc) {\n    return findInDoc(doc, isLineNextFn, false);\n  }\n\n  function willBreakFn(doc) {\n    if (doc.type === \"group\" && doc.break) {\n      return true;\n    }\n\n    if (doc.type === \"line\" && doc.hard) {\n      return true;\n    }\n\n    if (doc.type === \"break-parent\") {\n      return true;\n    }\n  }\n\n  function willBreak(doc) {\n    return findInDoc(doc, willBreakFn, false);\n  }\n\n  function breakParentGroup(groupStack) {\n    if (groupStack.length > 0) {\n      var parentGroup = groupStack[groupStack.length - 1]; // Breaks are not propagated through conditional groups because\n      // the user is expected to manually handle what breaks.\n\n      if (!parentGroup.expandedStates) {\n        parentGroup.break = true;\n      }\n    }\n\n    return null;\n  }\n\n  function propagateBreaks(doc) {\n    var alreadyVisitedSet = new Set();\n    var groupStack = [];\n\n    function propagateBreaksOnEnterFn(doc) {\n      if (doc.type === \"break-parent\") {\n        breakParentGroup(groupStack);\n      }\n\n      if (doc.type === \"group\") {\n        groupStack.push(doc);\n\n        if (alreadyVisitedSet.has(doc)) {\n          return false;\n        }\n\n        alreadyVisitedSet.add(doc);\n      }\n    }\n\n    function propagateBreaksOnExitFn(doc) {\n      if (doc.type === \"group\") {\n        var group = groupStack.pop();\n\n        if (group.break) {\n          breakParentGroup(groupStack);\n        }\n      }\n    }\n\n    traverseDoc(doc, propagateBreaksOnEnterFn, propagateBreaksOnExitFn,\n    /* shouldTraverseConditionalGroups */\n    true);\n  }\n\n  function removeLinesFn(doc) {\n    // Force this doc into flat mode by statically converting all\n    // lines into spaces (or soft lines into nothing). Hard lines\n    // should still output because there's too great of a chance\n    // of breaking existing assumptions otherwise.\n    if (doc.type === \"line\" && !doc.hard) {\n      return doc.soft ? \"\" : \" \";\n    } else if (doc.type === \"if-break\") {\n      return doc.flatContents || \"\";\n    }\n\n    return doc;\n  }\n\n  function removeLines(doc) {\n    return mapDoc(doc, removeLinesFn);\n  }\n\n  function stripTrailingHardline(doc) {\n    // HACK remove ending hardline, original PR: #1984\n    if (doc.type === \"concat\" && doc.parts.length !== 0) {\n      var lastPart = doc.parts[doc.parts.length - 1];\n\n      if (lastPart.type === \"concat\") {\n        if (lastPart.parts.length === 2 && lastPart.parts[0].hard && lastPart.parts[1].type === \"break-parent\") {\n          return {\n            type: \"concat\",\n            parts: doc.parts.slice(0, -1)\n          };\n        }\n\n        return {\n          type: \"concat\",\n          parts: doc.parts.slice(0, -1).concat(stripTrailingHardline(lastPart))\n        };\n      }\n    }\n\n    return doc;\n  }\n\n  var docUtils = {\n    isEmpty: isEmpty,\n    willBreak: willBreak,\n    isLineNext: isLineNext,\n    traverseDoc: traverseDoc,\n    findInDoc: findInDoc,\n    mapDoc: mapDoc,\n    propagateBreaks: propagateBreaks,\n    removeLines: removeLines,\n    stripTrailingHardline: stripTrailingHardline\n  };\n\n  function flattenDoc(doc) {\n    if (doc.type === \"concat\") {\n      var res = [];\n\n      for (var i = 0; i < doc.parts.length; ++i) {\n        var doc2 = doc.parts[i];\n\n        if (typeof doc2 !== \"string\" && doc2.type === \"concat\") {\n          [].push.apply(res, flattenDoc(doc2).parts);\n        } else {\n          var flattened = flattenDoc(doc2);\n\n          if (flattened !== \"\") {\n            res.push(flattened);\n          }\n        }\n      }\n\n      return Object.assign({}, doc, {\n        parts: res\n      });\n    } else if (doc.type === \"if-break\") {\n      return Object.assign({}, doc, {\n        breakContents: doc.breakContents != null ? flattenDoc(doc.breakContents) : null,\n        flatContents: doc.flatContents != null ? flattenDoc(doc.flatContents) : null\n      });\n    } else if (doc.type === \"group\") {\n      return Object.assign({}, doc, {\n        contents: flattenDoc(doc.contents),\n        expandedStates: doc.expandedStates ? doc.expandedStates.map(flattenDoc) : doc.expandedStates\n      });\n    } else if (doc.contents) {\n      return Object.assign({}, doc, {\n        contents: flattenDoc(doc.contents)\n      });\n    }\n\n    return doc;\n  }\n\n  function printDoc(doc) {\n    if (typeof doc === \"string\") {\n      return JSON.stringify(doc);\n    }\n\n    if (doc.type === \"line\") {\n      if (doc.literal) {\n        return \"literalline\";\n      }\n\n      if (doc.hard) {\n        return \"hardline\";\n      }\n\n      if (doc.soft) {\n        return \"softline\";\n      }\n\n      return \"line\";\n    }\n\n    if (doc.type === \"break-parent\") {\n      return \"breakParent\";\n    }\n\n    if (doc.type === \"trim\") {\n      return \"trim\";\n    }\n\n    if (doc.type === \"concat\") {\n      return \"[\" + doc.parts.map(printDoc).join(\", \") + \"]\";\n    }\n\n    if (doc.type === \"indent\") {\n      return \"indent(\" + printDoc(doc.contents) + \")\";\n    }\n\n    if (doc.type === \"align\") {\n      return doc.n === -Infinity ? \"dedentToRoot(\" + printDoc(doc.contents) + \")\" : doc.n < 0 ? \"dedent(\" + printDoc(doc.contents) + \")\" : doc.n.type === \"root\" ? \"markAsRoot(\" + printDoc(doc.contents) + \")\" : \"align(\" + JSON.stringify(doc.n) + \", \" + printDoc(doc.contents) + \")\";\n    }\n\n    if (doc.type === \"if-break\") {\n      return \"ifBreak(\" + printDoc(doc.breakContents) + (doc.flatContents ? \", \" + printDoc(doc.flatContents) : \"\") + \")\";\n    }\n\n    if (doc.type === \"group\") {\n      if (doc.expandedStates) {\n        return \"conditionalGroup(\" + \"[\" + doc.expandedStates.map(printDoc).join(\",\") + \"])\";\n      }\n\n      return (doc.break ? \"wrappedGroup\" : \"group\") + \"(\" + printDoc(doc.contents) + \")\";\n    }\n\n    if (doc.type === \"fill\") {\n      return \"fill\" + \"(\" + doc.parts.map(printDoc).join(\", \") + \")\";\n    }\n\n    if (doc.type === \"line-suffix\") {\n      return \"lineSuffix(\" + printDoc(doc.contents) + \")\";\n    }\n\n    if (doc.type === \"line-suffix-boundary\") {\n      return \"lineSuffixBoundary\";\n    }\n\n    throw new Error(\"Unknown doc type \" + doc.type);\n  }\n\n  var docDebug = {\n    printDocToDebug: function printDocToDebug(doc) {\n      return printDoc(flattenDoc(doc));\n    }\n  };\n\n  var doc = {\n    builders: docBuilders,\n    printer: docPrinter,\n    utils: docUtils,\n    debug: docDebug\n  };\n\n  var mapDoc$1 = doc.utils.mapDoc;\n\n  function isNextLineEmpty$1(text, node, options) {\n    return util.isNextLineEmpty(text, node, options.locEnd);\n  }\n\n  function isPreviousLineEmpty$1(text, node, options) {\n    return util.isPreviousLineEmpty(text, node, options.locStart);\n  }\n\n  function getNextNonSpaceNonCommentCharacterIndex$1(text, node, options) {\n    return util.getNextNonSpaceNonCommentCharacterIndex(text, node, options.locEnd);\n  }\n\n  var utilShared = {\n    getMaxContinuousCount: util.getMaxContinuousCount,\n    getStringWidth: util.getStringWidth,\n    getAlignmentSize: util.getAlignmentSize,\n    getIndentSize: util.getIndentSize,\n    skip: util.skip,\n    skipWhitespace: util.skipWhitespace,\n    skipSpaces: util.skipSpaces,\n    skipNewline: util.skipNewline,\n    skipToLineEnd: util.skipToLineEnd,\n    skipEverythingButNewLine: util.skipEverythingButNewLine,\n    skipInlineComment: util.skipInlineComment,\n    skipTrailingComment: util.skipTrailingComment,\n    hasNewline: util.hasNewline,\n    hasNewlineInRange: util.hasNewlineInRange,\n    hasSpaces: util.hasSpaces,\n    isNextLineEmpty: isNextLineEmpty$1,\n    isNextLineEmptyAfterIndex: util.isNextLineEmptyAfterIndex,\n    isPreviousLineEmpty: isPreviousLineEmpty$1,\n    getNextNonSpaceNonCommentCharacterIndex: getNextNonSpaceNonCommentCharacterIndex$1,\n    mapDoc: mapDoc$1,\n    // TODO: remove in 2.0, we already exposed it in docUtils\n    makeString: util.makeString,\n    addLeadingComment: util.addLeadingComment,\n    addDanglingComment: util.addDanglingComment,\n    addTrailingComment: util.addTrailingComment\n  };\n\n  var _require$$0$builders = doc.builders,\n      concat$2 = _require$$0$builders.concat,\n      hardline$1 = _require$$0$builders.hardline,\n      breakParent$1 = _require$$0$builders.breakParent,\n      indent$1 = _require$$0$builders.indent,\n      lineSuffix$1 = _require$$0$builders.lineSuffix,\n      join$1 = _require$$0$builders.join,\n      cursor$2 = _require$$0$builders.cursor;\n  var hasNewline$1 = util.hasNewline,\n      skipNewline$1 = util.skipNewline,\n      isPreviousLineEmpty$2 = util.isPreviousLineEmpty;\n  var addLeadingComment$1 = utilShared.addLeadingComment,\n      addDanglingComment$1 = utilShared.addDanglingComment,\n      addTrailingComment$1 = utilShared.addTrailingComment;\n  var childNodesCacheKey = Symbol(\"child-nodes\");\n\n  function getSortedChildNodes(node, options, resultArray) {\n    if (!node) {\n      return;\n    }\n\n    var printer = options.printer,\n        locStart = options.locStart,\n        locEnd = options.locEnd;\n\n    if (resultArray) {\n      if (node && printer.canAttachComment && printer.canAttachComment(node)) {\n        // This reverse insertion sort almost always takes constant\n        // time because we almost always (maybe always?) append the\n        // nodes in order anyway.\n        var i;\n\n        for (i = resultArray.length - 1; i >= 0; --i) {\n          if (locStart(resultArray[i]) <= locStart(node) && locEnd(resultArray[i]) <= locEnd(node)) {\n            break;\n          }\n        }\n\n        resultArray.splice(i + 1, 0, node);\n        return;\n      }\n    } else if (node[childNodesCacheKey]) {\n      return node[childNodesCacheKey];\n    }\n\n    var childNodes;\n\n    if (printer.getCommentChildNodes) {\n      childNodes = printer.getCommentChildNodes(node);\n    } else if (node && _typeof(node) === \"object\") {\n      childNodes = Object.keys(node).filter(function (n) {\n        return n !== \"enclosingNode\" && n !== \"precedingNode\" && n !== \"followingNode\";\n      }).map(function (n) {\n        return node[n];\n      });\n    }\n\n    if (!childNodes) {\n      return;\n    }\n\n    if (!resultArray) {\n      Object.defineProperty(node, childNodesCacheKey, {\n        value: resultArray = [],\n        enumerable: false\n      });\n    }\n\n    childNodes.forEach(function (childNode) {\n      getSortedChildNodes(childNode, options, resultArray);\n    });\n    return resultArray;\n  } // As efficiently as possible, decorate the comment object with\n  // .precedingNode, .enclosingNode, and/or .followingNode properties, at\n  // least one of which is guaranteed to be defined.\n\n\n  function decorateComment(node, comment, options) {\n    var locStart = options.locStart,\n        locEnd = options.locEnd;\n    var childNodes = getSortedChildNodes(node, options);\n    var precedingNode;\n    var followingNode; // Time to dust off the old binary search robes and wizard hat.\n\n    var left = 0;\n    var right = childNodes.length;\n\n    while (left < right) {\n      var middle = left + right >> 1;\n      var child = childNodes[middle];\n\n      if (locStart(child) - locStart(comment) <= 0 && locEnd(comment) - locEnd(child) <= 0) {\n        // The comment is completely contained by this child node.\n        comment.enclosingNode = child;\n        decorateComment(child, comment, options);\n        return; // Abandon the binary search at this level.\n      }\n\n      if (locEnd(child) - locStart(comment) <= 0) {\n        // This child node falls completely before the comment.\n        // Because we will never consider this node or any nodes\n        // before it again, this node must be the closest preceding\n        // node we have encountered so far.\n        precedingNode = child;\n        left = middle + 1;\n        continue;\n      }\n\n      if (locEnd(comment) - locStart(child) <= 0) {\n        // This child node falls completely after the comment.\n        // Because we will never consider this node or any nodes after\n        // it again, this node must be the closest following node we\n        // have encountered so far.\n        followingNode = child;\n        right = middle;\n        continue;\n      }\n      /* istanbul ignore next */\n\n\n      throw new Error(\"Comment location overlaps with node location\");\n    } // We don't want comments inside of different expressions inside of the same\n    // template literal to move to another expression.\n\n\n    if (comment.enclosingNode && comment.enclosingNode.type === \"TemplateLiteral\") {\n      var quasis = comment.enclosingNode.quasis;\n      var commentIndex = findExpressionIndexForComment(quasis, comment, options);\n\n      if (precedingNode && findExpressionIndexForComment(quasis, precedingNode, options) !== commentIndex) {\n        precedingNode = null;\n      }\n\n      if (followingNode && findExpressionIndexForComment(quasis, followingNode, options) !== commentIndex) {\n        followingNode = null;\n      }\n    }\n\n    if (precedingNode) {\n      comment.precedingNode = precedingNode;\n    }\n\n    if (followingNode) {\n      comment.followingNode = followingNode;\n    }\n  }\n\n  function attach(comments, ast, text, options) {\n    if (!Array.isArray(comments)) {\n      return;\n    }\n\n    var tiesToBreak = [];\n    var locStart = options.locStart,\n        locEnd = options.locEnd;\n    comments.forEach(function (comment, i) {\n      if (options.parser === \"json\" || options.parser === \"json5\" || options.parser === \"__js_expression\" || options.parser === \"__vue_expression\") {\n        if (locStart(comment) - locStart(ast) <= 0) {\n          addLeadingComment$1(ast, comment);\n          return;\n        }\n\n        if (locEnd(comment) - locEnd(ast) >= 0) {\n          addTrailingComment$1(ast, comment);\n          return;\n        }\n      }\n\n      decorateComment(ast, comment, options);\n      var precedingNode = comment.precedingNode,\n          enclosingNode = comment.enclosingNode,\n          followingNode = comment.followingNode;\n      var pluginHandleOwnLineComment = options.printer.handleComments && options.printer.handleComments.ownLine ? options.printer.handleComments.ownLine : function () {\n        return false;\n      };\n      var pluginHandleEndOfLineComment = options.printer.handleComments && options.printer.handleComments.endOfLine ? options.printer.handleComments.endOfLine : function () {\n        return false;\n      };\n      var pluginHandleRemainingComment = options.printer.handleComments && options.printer.handleComments.remaining ? options.printer.handleComments.remaining : function () {\n        return false;\n      };\n      var isLastComment = comments.length - 1 === i;\n\n      if (hasNewline$1(text, locStart(comment), {\n        backwards: true\n      })) {\n        // If a comment exists on its own line, prefer a leading comment.\n        // We also need to check if it's the first line of the file.\n        if (pluginHandleOwnLineComment(comment, text, options, ast, isLastComment)) ; else if (followingNode) {\n          // Always a leading comment.\n          addLeadingComment$1(followingNode, comment);\n        } else if (precedingNode) {\n          addTrailingComment$1(precedingNode, comment);\n        } else if (enclosingNode) {\n          addDanglingComment$1(enclosingNode, comment);\n        } else {\n          // There are no nodes, let's attach it to the root of the ast\n\n          /* istanbul ignore next */\n          addDanglingComment$1(ast, comment);\n        }\n      } else if (hasNewline$1(text, locEnd(comment))) {\n        if (pluginHandleEndOfLineComment(comment, text, options, ast, isLastComment)) ; else if (precedingNode) {\n          // There is content before this comment on the same line, but\n          // none after it, so prefer a trailing comment of the previous node.\n          addTrailingComment$1(precedingNode, comment);\n        } else if (followingNode) {\n          addLeadingComment$1(followingNode, comment);\n        } else if (enclosingNode) {\n          addDanglingComment$1(enclosingNode, comment);\n        } else {\n          // There are no nodes, let's attach it to the root of the ast\n\n          /* istanbul ignore next */\n          addDanglingComment$1(ast, comment);\n        }\n      } else {\n        if (pluginHandleRemainingComment(comment, text, options, ast, isLastComment)) ; else if (precedingNode && followingNode) {\n          // Otherwise, text exists both before and after the comment on\n          // the same line. If there is both a preceding and following\n          // node, use a tie-breaking algorithm to determine if it should\n          // be attached to the next or previous node. In the last case,\n          // simply attach the right node;\n          var tieCount = tiesToBreak.length;\n\n          if (tieCount > 0) {\n            var lastTie = tiesToBreak[tieCount - 1];\n\n            if (lastTie.followingNode !== comment.followingNode) {\n              breakTies(tiesToBreak, text, options);\n            }\n          }\n\n          tiesToBreak.push(comment);\n        } else if (precedingNode) {\n          addTrailingComment$1(precedingNode, comment);\n        } else if (followingNode) {\n          addLeadingComment$1(followingNode, comment);\n        } else if (enclosingNode) {\n          addDanglingComment$1(enclosingNode, comment);\n        } else {\n          // There are no nodes, let's attach it to the root of the ast\n\n          /* istanbul ignore next */\n          addDanglingComment$1(ast, comment);\n        }\n      }\n    });\n    breakTies(tiesToBreak, text, options);\n    comments.forEach(function (comment) {\n      // These node references were useful for breaking ties, but we\n      // don't need them anymore, and they create cycles in the AST that\n      // may lead to infinite recursion if we don't delete them here.\n      delete comment.precedingNode;\n      delete comment.enclosingNode;\n      delete comment.followingNode;\n    });\n  }\n\n  function breakTies(tiesToBreak, text, options) {\n    var tieCount = tiesToBreak.length;\n\n    if (tieCount === 0) {\n      return;\n    }\n\n    var _tiesToBreak$ = tiesToBreak[0],\n        precedingNode = _tiesToBreak$.precedingNode,\n        followingNode = _tiesToBreak$.followingNode;\n    var gapEndPos = options.locStart(followingNode); // Iterate backwards through tiesToBreak, examining the gaps\n    // between the tied comments. In order to qualify as leading, a\n    // comment must be separated from followingNode by an unbroken series of\n    // gaps (or other comments). Gaps should only contain whitespace or open\n    // parentheses.\n\n    var indexOfFirstLeadingComment;\n\n    for (indexOfFirstLeadingComment = tieCount; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {\n      var comment = tiesToBreak[indexOfFirstLeadingComment - 1];\n      assert.strictEqual(comment.precedingNode, precedingNode);\n      assert.strictEqual(comment.followingNode, followingNode);\n      var gap = text.slice(options.locEnd(comment), gapEndPos);\n\n      if (/^[\\s(]*$/.test(gap)) {\n        gapEndPos = options.locStart(comment);\n      } else {\n        // The gap string contained something other than whitespace or open\n        // parentheses.\n        break;\n      }\n    }\n\n    tiesToBreak.forEach(function (comment, i) {\n      if (i < indexOfFirstLeadingComment) {\n        addTrailingComment$1(precedingNode, comment);\n      } else {\n        addLeadingComment$1(followingNode, comment);\n      }\n    });\n    tiesToBreak.length = 0;\n  }\n\n  function printComment(commentPath, options) {\n    var comment = commentPath.getValue();\n    comment.printed = true;\n    return options.printer.printComment(commentPath, options);\n  }\n\n  function findExpressionIndexForComment(quasis, comment, options) {\n    var startPos = options.locStart(comment) - 1;\n\n    for (var i = 1; i < quasis.length; ++i) {\n      if (startPos < getQuasiRange(quasis[i]).start) {\n        return i - 1;\n      }\n    } // We haven't found it, it probably means that some of the locations are off.\n    // Let's just return the first one.\n\n    /* istanbul ignore next */\n\n\n    return 0;\n  }\n\n  function getQuasiRange(expr) {\n    if (expr.start !== undefined) {\n      // Babel\n      return {\n        start: expr.start,\n        end: expr.end\n      };\n    } // Flow\n\n\n    return {\n      start: expr.range[0],\n      end: expr.range[1]\n    };\n  }\n\n  function printLeadingComment(commentPath, print, options) {\n    var comment = commentPath.getValue();\n    var contents = printComment(commentPath, options);\n\n    if (!contents) {\n      return \"\";\n    }\n\n    var isBlock = options.printer.isBlockComment && options.printer.isBlockComment(comment); // Leading block comments should see if they need to stay on the\n    // same line or not.\n\n    if (isBlock) {\n      return concat$2([contents, hasNewline$1(options.originalText, options.locEnd(comment)) ? hardline$1 : \" \"]);\n    }\n\n    return concat$2([contents, hardline$1]);\n  }\n\n  function printTrailingComment(commentPath, print, options) {\n    var comment = commentPath.getValue();\n    var contents = printComment(commentPath, options);\n\n    if (!contents) {\n      return \"\";\n    }\n\n    var isBlock = options.printer.isBlockComment && options.printer.isBlockComment(comment); // We don't want the line to break\n    // when the parentParentNode is a ClassDeclaration/-Expression\n    // And the parentNode is in the superClass property\n\n    var parentNode = commentPath.getNode(1);\n    var parentParentNode = commentPath.getNode(2);\n    var isParentSuperClass = parentParentNode && (parentParentNode.type === \"ClassDeclaration\" || parentParentNode.type === \"ClassExpression\") && parentParentNode.superClass === parentNode;\n\n    if (hasNewline$1(options.originalText, options.locStart(comment), {\n      backwards: true\n    })) {\n      // This allows comments at the end of nested structures:\n      // {\n      //   x: 1,\n      //   y: 2\n      //   // A comment\n      // }\n      // Those kinds of comments are almost always leading comments, but\n      // here it doesn't go \"outside\" the block and turns it into a\n      // trailing comment for `2`. We can simulate the above by checking\n      // if this a comment on its own line; normal trailing comments are\n      // always at the end of another expression.\n      var isLineBeforeEmpty = isPreviousLineEmpty$2(options.originalText, comment, options.locStart);\n      return lineSuffix$1(concat$2([hardline$1, isLineBeforeEmpty ? hardline$1 : \"\", contents]));\n    } else if (isBlock || isParentSuperClass) {\n      // Trailing block comments never need a newline\n      return concat$2([\" \", contents]);\n    }\n\n    return concat$2([lineSuffix$1(concat$2([\" \", contents])), !isBlock ? breakParent$1 : \"\"]);\n  }\n\n  function printDanglingComments(path, options, sameIndent, filter) {\n    var parts = [];\n    var node = path.getValue();\n\n    if (!node || !node.comments) {\n      return \"\";\n    }\n\n    path.each(function (commentPath) {\n      var comment = commentPath.getValue();\n\n      if (comment && !comment.leading && !comment.trailing && (!filter || filter(comment))) {\n        parts.push(printComment(commentPath, options));\n      }\n    }, \"comments\");\n\n    if (parts.length === 0) {\n      return \"\";\n    }\n\n    if (sameIndent) {\n      return join$1(hardline$1, parts);\n    }\n\n    return indent$1(concat$2([hardline$1, join$1(hardline$1, parts)]));\n  }\n\n  function prependCursorPlaceholder(path, options, printed) {\n    if (path.getNode() === options.cursorNode && path.getValue()) {\n      return concat$2([cursor$2, printed, cursor$2]);\n    }\n\n    return printed;\n  }\n\n  function printComments(path, print, options, needsSemi) {\n    var value = path.getValue();\n    var printed = print(path);\n    var comments = value && value.comments;\n\n    if (!comments || comments.length === 0) {\n      return prependCursorPlaceholder(path, options, printed);\n    }\n\n    var leadingParts = [];\n    var trailingParts = [needsSemi ? \";\" : \"\", printed];\n    path.each(function (commentPath) {\n      var comment = commentPath.getValue();\n      var leading = comment.leading,\n          trailing = comment.trailing;\n\n      if (leading) {\n        var contents = printLeadingComment(commentPath, print, options);\n\n        if (!contents) {\n          return;\n        }\n\n        leadingParts.push(contents);\n        var text = options.originalText;\n        var index = skipNewline$1(text, options.locEnd(comment));\n\n        if (index !== false && hasNewline$1(text, index)) {\n          leadingParts.push(hardline$1);\n        }\n      } else if (trailing) {\n        trailingParts.push(printTrailingComment(commentPath, print, options));\n      }\n    }, \"comments\");\n    return prependCursorPlaceholder(path, options, concat$2(leadingParts.concat(trailingParts)));\n  }\n\n  var comments = {\n    attach: attach,\n    printComments: printComments,\n    printDanglingComments: printDanglingComments,\n    getSortedChildNodes: getSortedChildNodes\n  };\n\n  function FastPath(value) {\n    assert.ok(this instanceof FastPath);\n    this.stack = [value];\n  } // The name of the current property is always the penultimate element of\n  // this.stack, and always a String.\n\n\n  FastPath.prototype.getName = function getName() {\n    var s = this.stack;\n    var len = s.length;\n\n    if (len > 1) {\n      return s[len - 2];\n    } // Since the name is always a string, null is a safe sentinel value to\n    // return if we do not know the name of the (root) value.\n\n    /* istanbul ignore next */\n\n\n    return null;\n  }; // The value of the current property is always the final element of\n  // this.stack.\n\n\n  FastPath.prototype.getValue = function getValue() {\n    var s = this.stack;\n    return s[s.length - 1];\n  };\n\n  function getNodeHelper(path, count) {\n    var stackIndex = getNodeStackIndexHelper(path.stack, count);\n    return stackIndex === -1 ? null : path.stack[stackIndex];\n  }\n\n  function getNodeStackIndexHelper(stack, count) {\n    for (var i = stack.length - 1; i >= 0; i -= 2) {\n      var value = stack[i];\n\n      if (value && !Array.isArray(value) && --count < 0) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  FastPath.prototype.getNode = function getNode(count) {\n    return getNodeHelper(this, ~~count);\n  };\n\n  FastPath.prototype.getParentNode = function getParentNode(count) {\n    return getNodeHelper(this, ~~count + 1);\n  }; // Temporarily push properties named by string arguments given after the\n  // callback function onto this.stack, then call the callback with a\n  // reference to this (modified) FastPath object. Note that the stack will\n  // be restored to its original state after the callback is finished, so it\n  // is probably a mistake to retain a reference to the path.\n\n\n  FastPath.prototype.call = function call(callback\n  /*, name1, name2, ... */\n  ) {\n    var s = this.stack;\n    var origLen = s.length;\n    var value = s[origLen - 1];\n    var argc = arguments.length;\n\n    for (var i = 1; i < argc; ++i) {\n      var name = arguments[i];\n      value = value[name];\n      s.push(name, value);\n    }\n\n    var result = callback(this);\n    s.length = origLen;\n    return result;\n  };\n\n  FastPath.prototype.callParent = function callParent(callback, count) {\n    var stackIndex = getNodeStackIndexHelper(this.stack, ~~count + 1);\n    var parentValues = this.stack.splice(stackIndex + 1);\n    var result = callback(this);\n    Array.prototype.push.apply(this.stack, parentValues);\n    return result;\n  }; // Similar to FastPath.prototype.call, except that the value obtained by\n  // accessing this.getValue()[name1][name2]... should be array-like. The\n  // callback will be called with a reference to this path object for each\n  // element of the array.\n\n\n  FastPath.prototype.each = function each(callback\n  /*, name1, name2, ... */\n  ) {\n    var s = this.stack;\n    var origLen = s.length;\n    var value = s[origLen - 1];\n    var argc = arguments.length;\n\n    for (var i = 1; i < argc; ++i) {\n      var name = arguments[i];\n      value = value[name];\n      s.push(name, value);\n    }\n\n    for (var _i = 0; _i < value.length; ++_i) {\n      if (_i in value) {\n        s.push(_i, value[_i]); // If the callback needs to know the value of i, call\n        // path.getName(), assuming path is the parameter name.\n\n        callback(this);\n        s.length -= 2;\n      }\n    }\n\n    s.length = origLen;\n  }; // Similar to FastPath.prototype.each, except that the results of the\n  // callback function invocations are stored in an array and returned at\n  // the end of the iteration.\n\n\n  FastPath.prototype.map = function map(callback\n  /*, name1, name2, ... */\n  ) {\n    var s = this.stack;\n    var origLen = s.length;\n    var value = s[origLen - 1];\n    var argc = arguments.length;\n\n    for (var i = 1; i < argc; ++i) {\n      var name = arguments[i];\n      value = value[name];\n      s.push(name, value);\n    }\n\n    var result = new Array(value.length);\n\n    for (var _i2 = 0; _i2 < value.length; ++_i2) {\n      if (_i2 in value) {\n        s.push(_i2, value[_i2]);\n        result[_i2] = callback(this, _i2);\n        s.length -= 2;\n      }\n    }\n\n    s.length = origLen;\n    return result;\n  };\n\n  var fastPath = FastPath;\n\n  var normalize$2 = options$1.normalize;\n\n  function printSubtree(path, print, options, printAstToDoc) {\n    if (options.printer.embed) {\n      return options.printer.embed(path, print, function (text, partialNextOptions) {\n        return textToDoc(text, partialNextOptions, options, printAstToDoc);\n      }, options);\n    }\n  }\n\n  function textToDoc(text, partialNextOptions, parentOptions, printAstToDoc) {\n    var nextOptions = normalize$2(Object.assign({}, parentOptions, partialNextOptions, {\n      parentParser: parentOptions.parser,\n      embeddedInHtml: !!(parentOptions.embeddedInHtml || parentOptions.parser === \"html\" || parentOptions.parser === \"vue\" || parentOptions.parser === \"angular\" || parentOptions.parser === \"lwc\"),\n      originalText: text\n    }), {\n      passThrough: true\n    });\n    var result = parser.parse(text, nextOptions);\n    var ast = result.ast;\n    text = result.text;\n    var astComments = ast.comments;\n    delete ast.comments;\n    comments.attach(astComments, ast, text, nextOptions);\n    return printAstToDoc(ast, nextOptions);\n  }\n\n  var multiparser = {\n    printSubtree: printSubtree\n  };\n\n  var doc$1 = doc;\n  var docBuilders$1 = doc$1.builders;\n  var concat$3 = docBuilders$1.concat;\n  var hardline$2 = docBuilders$1.hardline;\n  var addAlignmentToDoc$1 = docBuilders$1.addAlignmentToDoc;\n  var docUtils$1 = doc$1.utils;\n  /**\n   * Takes an abstract syntax tree (AST) and recursively converts it to a\n   * document (series of printing primitives).\n   *\n   * This is done by descending down the AST recursively. The recursion\n   * involves two functions that call each other:\n   *\n   * 1. printGenerically(), which is defined as an inner function here.\n   *    It basically takes care of node caching.\n   * 2. callPluginPrintFunction(), which checks for some options, and\n   *    ultimately calls the print() function provided by the plugin.\n   *\n   * The plugin function will call printGenerically() again for child nodes\n   * of the current node, which will do its housekeeping, then call the\n   * plugin function again, and so on.\n   *\n   * All the while, these functions pass a \"path\" variable around, which\n   * is a stack-like data structure (FastPath) that maintains the current\n   * state of the recursion. It is called \"path\", because it represents\n   * the path to the current node through the Abstract Syntax Tree.\n   */\n\n  function printAstToDoc(ast, options) {\n    var alignmentSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var printer = options.printer;\n\n    if (printer.preprocess) {\n      ast = printer.preprocess(ast, options);\n    }\n\n    var cache = new Map();\n\n    function printGenerically(path, args) {\n      var node = path.getValue();\n      var shouldCache = node && _typeof(node) === \"object\" && args === undefined;\n\n      if (shouldCache && cache.has(node)) {\n        return cache.get(node);\n      } // We let JSXElement print its comments itself because it adds () around\n      // UnionTypeAnnotation has to align the child without the comments\n\n\n      var res;\n\n      if (printer.willPrintOwnComments && printer.willPrintOwnComments(path, options)) {\n        res = callPluginPrintFunction(path, options, printGenerically, args);\n      } else {\n        // printComments will call the plugin print function and check for\n        // comments to print\n        res = comments.printComments(path, function (p) {\n          return callPluginPrintFunction(p, options, printGenerically, args);\n        }, options, args && args.needsSemi);\n      }\n\n      if (shouldCache) {\n        cache.set(node, res);\n      }\n\n      return res;\n    }\n\n    var doc = printGenerically(new fastPath(ast));\n\n    if (alignmentSize > 0) {\n      // Add a hardline to make the indents take effect\n      // It should be removed in index.js format()\n      doc = addAlignmentToDoc$1(concat$3([hardline$2, doc]), alignmentSize, options.tabWidth);\n    }\n\n    docUtils$1.propagateBreaks(doc);\n    return doc;\n  }\n\n  function callPluginPrintFunction(path, options, printPath, args) {\n    assert.ok(path instanceof fastPath);\n    var node = path.getValue();\n    var printer = options.printer; // Escape hatch\n\n    if (printer.hasPrettierIgnore && printer.hasPrettierIgnore(path)) {\n      return options.originalText.slice(options.locStart(node), options.locEnd(node));\n    }\n\n    if (node) {\n      try {\n        // Potentially switch to a different parser\n        var sub = multiparser.printSubtree(path, printPath, options, printAstToDoc);\n\n        if (sub) {\n          return sub;\n        }\n      } catch (error) {\n        /* istanbul ignore if */\n        if (commonjsGlobal.PRETTIER_DEBUG) {\n          throw error;\n        } // Continue with current parser\n\n      }\n    }\n\n    return printer.print(path, options, printPath, args);\n  }\n\n  var astToDoc = printAstToDoc;\n\n  function findSiblingAncestors(startNodeAndParents, endNodeAndParents, opts) {\n    var resultStartNode = startNodeAndParents.node;\n    var resultEndNode = endNodeAndParents.node;\n\n    if (resultStartNode === resultEndNode) {\n      return {\n        startNode: resultStartNode,\n        endNode: resultEndNode\n      };\n    }\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = endNodeAndParents.parentNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var endParent = _step.value;\n\n        if (endParent.type !== \"Program\" && endParent.type !== \"File\" && opts.locStart(endParent) >= opts.locStart(startNodeAndParents.node)) {\n          resultEndNode = endParent;\n        } else {\n          break;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = startNodeAndParents.parentNodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var startParent = _step2.value;\n\n        if (startParent.type !== \"Program\" && startParent.type !== \"File\" && opts.locEnd(startParent) <= opts.locEnd(endNodeAndParents.node)) {\n          resultStartNode = startParent;\n        } else {\n          break;\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return {\n      startNode: resultStartNode,\n      endNode: resultEndNode\n    };\n  }\n\n  function findNodeAtOffset(node, offset, options, predicate, parentNodes) {\n    predicate = predicate || function () {\n      return true;\n    };\n\n    parentNodes = parentNodes || [];\n    var start = options.locStart(node, options.locStart);\n    var end = options.locEnd(node, options.locEnd);\n\n    if (start <= offset && offset <= end) {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = comments.getSortedChildNodes(node, options)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var childNode = _step3.value;\n          var childResult = findNodeAtOffset(childNode, offset, options, predicate, [node].concat(parentNodes));\n\n          if (childResult) {\n            return childResult;\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      if (predicate(node)) {\n        return {\n          node: node,\n          parentNodes: parentNodes\n        };\n      }\n    }\n  } // See https://www.ecma-international.org/ecma-262/5.1/#sec-A.5\n\n\n  function isSourceElement(opts, node) {\n    if (node == null) {\n      return false;\n    } // JS and JS like to avoid repetitions\n\n\n    var jsSourceElements = [\"FunctionDeclaration\", \"BlockStatement\", \"BreakStatement\", \"ContinueStatement\", \"DebuggerStatement\", \"DoWhileStatement\", \"EmptyStatement\", \"ExpressionStatement\", \"ForInStatement\", \"ForStatement\", \"IfStatement\", \"LabeledStatement\", \"ReturnStatement\", \"SwitchStatement\", \"ThrowStatement\", \"TryStatement\", \"VariableDeclaration\", \"WhileStatement\", \"WithStatement\", \"ClassDeclaration\", // ES 2015\n    \"ImportDeclaration\", // Module\n    \"ExportDefaultDeclaration\", // Module\n    \"ExportNamedDeclaration\", // Module\n    \"ExportAllDeclaration\", // Module\n    \"TypeAlias\", // Flow\n    \"InterfaceDeclaration\", // Flow, TypeScript\n    \"TypeAliasDeclaration\", // TypeScript\n    \"ExportAssignment\", // TypeScript\n    \"ExportDeclaration\" // TypeScript\n    ];\n    var jsonSourceElements = [\"ObjectExpression\", \"ArrayExpression\", \"StringLiteral\", \"NumericLiteral\", \"BooleanLiteral\", \"NullLiteral\"];\n    var graphqlSourceElements = [\"OperationDefinition\", \"FragmentDefinition\", \"VariableDefinition\", \"TypeExtensionDefinition\", \"ObjectTypeDefinition\", \"FieldDefinition\", \"DirectiveDefinition\", \"EnumTypeDefinition\", \"EnumValueDefinition\", \"InputValueDefinition\", \"InputObjectTypeDefinition\", \"SchemaDefinition\", \"OperationTypeDefinition\", \"InterfaceTypeDefinition\", \"UnionTypeDefinition\", \"ScalarTypeDefinition\"];\n\n    switch (opts.parser) {\n      case \"flow\":\n      case \"babel\":\n      case \"typescript\":\n        return jsSourceElements.indexOf(node.type) > -1;\n\n      case \"json\":\n        return jsonSourceElements.indexOf(node.type) > -1;\n\n      case \"graphql\":\n        return graphqlSourceElements.indexOf(node.kind) > -1;\n\n      case \"vue\":\n        return node.tag !== \"root\";\n    }\n\n    return false;\n  }\n\n  function calculateRange(text, opts, ast) {\n    // Contract the range so that it has non-whitespace characters at its endpoints.\n    // This ensures we can format a range that doesn't end on a node.\n    var rangeStringOrig = text.slice(opts.rangeStart, opts.rangeEnd);\n    var startNonWhitespace = Math.max(opts.rangeStart + rangeStringOrig.search(/\\S/), opts.rangeStart);\n    var endNonWhitespace;\n\n    for (endNonWhitespace = opts.rangeEnd; endNonWhitespace > opts.rangeStart; --endNonWhitespace) {\n      if (text[endNonWhitespace - 1].match(/\\S/)) {\n        break;\n      }\n    }\n\n    var startNodeAndParents = findNodeAtOffset(ast, startNonWhitespace, opts, function (node) {\n      return isSourceElement(opts, node);\n    });\n    var endNodeAndParents = findNodeAtOffset(ast, endNonWhitespace, opts, function (node) {\n      return isSourceElement(opts, node);\n    });\n\n    if (!startNodeAndParents || !endNodeAndParents) {\n      return {\n        rangeStart: 0,\n        rangeEnd: 0\n      };\n    }\n\n    var siblingAncestors = findSiblingAncestors(startNodeAndParents, endNodeAndParents, opts);\n    var startNode = siblingAncestors.startNode,\n        endNode = siblingAncestors.endNode;\n    var rangeStart = Math.min(opts.locStart(startNode, opts.locStart), opts.locStart(endNode, opts.locStart));\n    var rangeEnd = Math.max(opts.locEnd(startNode, opts.locEnd), opts.locEnd(endNode, opts.locEnd));\n    return {\n      rangeStart: rangeStart,\n      rangeEnd: rangeEnd\n    };\n  }\n\n  var rangeUtil = {\n    calculateRange: calculateRange,\n    findNodeAtOffset: findNodeAtOffset\n  };\n\n  var diff = getCjsExportFromNamespace(index_es6);\n\n  var normalizeOptions$1 = options$1.normalize;\n  var guessEndOfLine$1 = endOfLine.guessEndOfLine,\n      convertEndOfLineToChars$2 = endOfLine.convertEndOfLineToChars;\n  var mapDoc$2 = doc.utils.mapDoc,\n      _printDocToString = doc.printer.printDocToString,\n      printDocToDebug = doc.debug.printDocToDebug;\n  var UTF8BOM = 0xfeff;\n  var CURSOR = Symbol(\"cursor\");\n  var PLACEHOLDERS = {\n    cursorOffset: \"<<<PRETTIER_CURSOR>>>\",\n    rangeStart: \"<<<PRETTIER_RANGE_START>>>\",\n    rangeEnd: \"<<<PRETTIER_RANGE_END>>>\"\n  };\n\n  function ensureAllCommentsPrinted(astComments) {\n    if (!astComments) {\n      return;\n    }\n\n    for (var i = 0; i < astComments.length; ++i) {\n      if (astComments[i].value.trim() === \"prettier-ignore\") {\n        // If there's a prettier-ignore, we're not printing that sub-tree so we\n        // don't know if the comments was printed or not.\n        return;\n      }\n    }\n\n    astComments.forEach(function (comment) {\n      if (!comment.printed) {\n        throw new Error('Comment \"' + comment.value.trim() + '\" was not printed. Please report this error!');\n      }\n\n      delete comment.printed;\n    });\n  }\n\n  function attachComments(text, ast, opts) {\n    var astComments = ast.comments;\n\n    if (astComments) {\n      delete ast.comments;\n      comments.attach(astComments, ast, text, opts);\n    }\n\n    ast.tokens = [];\n    opts.originalText = opts.parser === \"yaml\" ? text : text.trimRight();\n    return astComments;\n  }\n\n  function coreFormat(text, opts, addAlignmentSize) {\n    if (!text || !text.trim().length) {\n      return {\n        formatted: \"\",\n        cursorOffset: 0\n      };\n    }\n\n    addAlignmentSize = addAlignmentSize || 0;\n    var parsed = parser.parse(text, opts);\n    var ast = parsed.ast;\n    text = parsed.text;\n\n    if (opts.cursorOffset >= 0) {\n      var nodeResult = rangeUtil.findNodeAtOffset(ast, opts.cursorOffset, opts);\n\n      if (nodeResult && nodeResult.node) {\n        opts.cursorNode = nodeResult.node;\n      }\n    }\n\n    var astComments = attachComments(text, ast, opts);\n    var doc = astToDoc(ast, opts, addAlignmentSize);\n    var eol = convertEndOfLineToChars$2(opts.endOfLine);\n\n    var result = _printDocToString(opts.endOfLine === \"lf\" ? doc : mapDoc$2(doc, function (currentDoc) {\n      return typeof currentDoc === \"string\" && currentDoc.indexOf(\"\\n\") !== -1 ? currentDoc.replace(/\\n/g, eol) : currentDoc;\n    }), opts);\n\n    ensureAllCommentsPrinted(astComments); // Remove extra leading indentation as well as the added indentation after last newline\n\n    if (addAlignmentSize > 0) {\n      var trimmed = result.formatted.trim();\n\n      if (result.cursorNodeStart !== undefined) {\n        result.cursorNodeStart -= result.formatted.indexOf(trimmed);\n      }\n\n      result.formatted = trimmed + convertEndOfLineToChars$2(opts.endOfLine);\n    }\n\n    if (opts.cursorOffset >= 0) {\n      var oldCursorNodeStart;\n      var oldCursorNodeText;\n      var cursorOffsetRelativeToOldCursorNode;\n      var newCursorNodeStart;\n      var newCursorNodeText;\n\n      if (opts.cursorNode && result.cursorNodeText) {\n        oldCursorNodeStart = opts.locStart(opts.cursorNode);\n        oldCursorNodeText = text.slice(oldCursorNodeStart, opts.locEnd(opts.cursorNode));\n        cursorOffsetRelativeToOldCursorNode = opts.cursorOffset - oldCursorNodeStart;\n        newCursorNodeStart = result.cursorNodeStart;\n        newCursorNodeText = result.cursorNodeText;\n      } else {\n        oldCursorNodeStart = 0;\n        oldCursorNodeText = text;\n        cursorOffsetRelativeToOldCursorNode = opts.cursorOffset;\n        newCursorNodeStart = 0;\n        newCursorNodeText = result.formatted;\n      }\n\n      if (oldCursorNodeText === newCursorNodeText) {\n        return {\n          formatted: result.formatted,\n          cursorOffset: newCursorNodeStart + cursorOffsetRelativeToOldCursorNode\n        };\n      } // diff old and new cursor node texts, with a special cursor\n      // symbol inserted to find out where it moves to\n\n\n      var oldCursorNodeCharArray = oldCursorNodeText.split(\"\");\n      oldCursorNodeCharArray.splice(cursorOffsetRelativeToOldCursorNode, 0, CURSOR);\n      var newCursorNodeCharArray = newCursorNodeText.split(\"\");\n      var cursorNodeDiff = diff.diffArrays(oldCursorNodeCharArray, newCursorNodeCharArray);\n      var cursorOffset = newCursorNodeStart;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = cursorNodeDiff[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var entry = _step.value;\n\n          if (entry.removed) {\n            if (entry.value.indexOf(CURSOR) > -1) {\n              break;\n            }\n          } else {\n            cursorOffset += entry.count;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return {\n        formatted: result.formatted,\n        cursorOffset: cursorOffset\n      };\n    }\n\n    return {\n      formatted: result.formatted\n    };\n  }\n\n  function formatRange(text, opts) {\n    var parsed = parser.parse(text, opts);\n    var ast = parsed.ast;\n    text = parsed.text;\n    var range = rangeUtil.calculateRange(text, opts, ast);\n    var rangeStart = range.rangeStart;\n    var rangeEnd = range.rangeEnd;\n    var rangeString = text.slice(rangeStart, rangeEnd); // Try to extend the range backwards to the beginning of the line.\n    // This is so we can detect indentation correctly and restore it.\n    // Use `Math.min` since `lastIndexOf` returns 0 when `rangeStart` is 0\n\n    var rangeStart2 = Math.min(rangeStart, text.lastIndexOf(\"\\n\", rangeStart) + 1);\n    var indentString = text.slice(rangeStart2, rangeStart);\n    var alignmentSize = util.getAlignmentSize(indentString, opts.tabWidth);\n    var rangeResult = coreFormat(rangeString, Object.assign({}, opts, {\n      rangeStart: 0,\n      rangeEnd: Infinity,\n      // track the cursor offset only if it's within our range\n      cursorOffset: opts.cursorOffset >= rangeStart && opts.cursorOffset < rangeEnd ? opts.cursorOffset - rangeStart : -1\n    }), alignmentSize); // Since the range contracts to avoid trailing whitespace,\n    // we need to remove the newline that was inserted by the `format` call.\n\n    var rangeTrimmed = rangeResult.formatted.trimRight();\n    var rangeLeft = text.slice(0, rangeStart);\n    var rangeRight = text.slice(rangeEnd);\n    var cursorOffset = opts.cursorOffset;\n\n    if (opts.cursorOffset >= rangeEnd) {\n      // handle the case where the cursor was past the end of the range\n      cursorOffset = opts.cursorOffset - rangeEnd + (rangeStart + rangeTrimmed.length);\n    } else if (rangeResult.cursorOffset !== undefined) {\n      // handle the case where the cursor was in the range\n      cursorOffset = rangeResult.cursorOffset + rangeStart;\n    } // keep the cursor as it was if it was before the start of the range\n\n\n    var formatted;\n\n    if (opts.endOfLine === \"lf\") {\n      formatted = rangeLeft + rangeTrimmed + rangeRight;\n    } else {\n      var eol = convertEndOfLineToChars$2(opts.endOfLine);\n\n      if (cursorOffset >= 0) {\n        var parts = [rangeLeft, rangeTrimmed, rangeRight];\n        var partIndex = 0;\n        var partOffset = cursorOffset;\n\n        while (partIndex < parts.length) {\n          var part = parts[partIndex];\n\n          if (partOffset < part.length) {\n            parts[partIndex] = parts[partIndex].slice(0, partOffset) + PLACEHOLDERS.cursorOffset + parts[partIndex].slice(partOffset);\n            break;\n          }\n\n          partIndex++;\n          partOffset -= part.length;\n        }\n\n        var newRangeLeft = parts[0],\n            newRangeTrimmed = parts[1],\n            newRangeRight = parts[2];\n        formatted = (newRangeLeft.replace(/\\n/g, eol) + newRangeTrimmed + newRangeRight.replace(/\\n/g, eol)).replace(PLACEHOLDERS.cursorOffset, function (_, index) {\n          cursorOffset = index;\n          return \"\";\n        });\n      } else {\n        formatted = rangeLeft.replace(/\\n/g, eol) + rangeTrimmed + rangeRight.replace(/\\n/g, eol);\n      }\n    }\n\n    return {\n      formatted: formatted,\n      cursorOffset: cursorOffset\n    };\n  }\n\n  function format(text, opts) {\n    var selectedParser = parser.resolveParser(opts);\n    var hasPragma = !selectedParser.hasPragma || selectedParser.hasPragma(text);\n\n    if (opts.requirePragma && !hasPragma) {\n      return {\n        formatted: text\n      };\n    }\n\n    if (opts.endOfLine === \"auto\") {\n      opts.endOfLine = guessEndOfLine$1(text);\n    }\n\n    var hasCursor = opts.cursorOffset >= 0;\n    var hasRangeStart = opts.rangeStart > 0;\n    var hasRangeEnd = opts.rangeEnd < text.length; // get rid of CR/CRLF parsing\n\n    if (text.indexOf(\"\\r\") !== -1) {\n      var offsetKeys = [hasCursor && \"cursorOffset\", hasRangeStart && \"rangeStart\", hasRangeEnd && \"rangeEnd\"].filter(Boolean).sort(function (aKey, bKey) {\n        return opts[aKey] - opts[bKey];\n      });\n\n      for (var i = offsetKeys.length - 1; i >= 0; i--) {\n        var key = offsetKeys[i];\n        text = text.slice(0, opts[key]) + PLACEHOLDERS[key] + text.slice(opts[key]);\n      }\n\n      text = text.replace(/\\r\\n?/g, \"\\n\");\n\n      var _loop = function _loop(_i) {\n        var key = offsetKeys[_i];\n        text = text.replace(PLACEHOLDERS[key], function (_, index) {\n          opts[key] = index;\n          return \"\";\n        });\n      };\n\n      for (var _i = 0; _i < offsetKeys.length; _i++) {\n        _loop(_i);\n      }\n    }\n\n    var hasUnicodeBOM = text.charCodeAt(0) === UTF8BOM;\n\n    if (hasUnicodeBOM) {\n      text = text.substring(1);\n\n      if (hasCursor) {\n        opts.cursorOffset++;\n      }\n\n      if (hasRangeStart) {\n        opts.rangeStart++;\n      }\n\n      if (hasRangeEnd) {\n        opts.rangeEnd++;\n      }\n    }\n\n    if (!hasCursor) {\n      opts.cursorOffset = -1;\n    }\n\n    if (opts.rangeStart < 0) {\n      opts.rangeStart = 0;\n    }\n\n    if (opts.rangeEnd > text.length) {\n      opts.rangeEnd = text.length;\n    }\n\n    var result = hasRangeStart || hasRangeEnd ? formatRange(text, opts) : coreFormat(opts.insertPragma && opts.printer.insertPragma && !hasPragma ? opts.printer.insertPragma(text) : text, opts);\n\n    if (hasUnicodeBOM) {\n      result.formatted = String.fromCharCode(UTF8BOM) + result.formatted;\n\n      if (hasCursor) {\n        result.cursorOffset++;\n      }\n    }\n\n    return result;\n  }\n\n  var core = {\n    formatWithCursor: function formatWithCursor(text, opts) {\n      opts = normalizeOptions$1(opts);\n      return format(text, opts);\n    },\n    parse: function parse(text, opts, massage) {\n      opts = normalizeOptions$1(opts);\n\n      if (text.indexOf(\"\\r\") !== -1) {\n        text = text.replace(/\\r\\n?/g, \"\\n\");\n      }\n\n      var parsed = parser.parse(text, opts);\n\n      if (massage) {\n        parsed.ast = massageAst(parsed.ast, opts);\n      }\n\n      return parsed;\n    },\n    formatAST: function formatAST(ast, opts) {\n      opts = normalizeOptions$1(opts);\n      var doc = astToDoc(ast, opts);\n      return _printDocToString(doc, opts);\n    },\n    // Doesn't handle shebang for now\n    formatDoc: function formatDoc(doc, opts) {\n      var debug = printDocToDebug(doc);\n      opts = normalizeOptions$1(Object.assign({}, opts, {\n        parser: \"babel\"\n      }));\n      return format(debug, opts).formatted;\n    },\n    printToDoc: function printToDoc(text, opts) {\n      opts = normalizeOptions$1(opts);\n      var parsed = parser.parse(text, opts);\n      var ast = parsed.ast;\n      text = parsed.text;\n      attachComments(text, ast, opts);\n      return astToDoc(ast, opts);\n    },\n    printDocToString: function printDocToString(doc, opts) {\n      return _printDocToString(doc, normalizeOptions$1(opts));\n    }\n  };\n\n  var index = [\n  \t\"a\",\n  \t\"abbr\",\n  \t\"acronym\",\n  \t\"address\",\n  \t\"applet\",\n  \t\"area\",\n  \t\"article\",\n  \t\"aside\",\n  \t\"audio\",\n  \t\"b\",\n  \t\"base\",\n  \t\"basefont\",\n  \t\"bdi\",\n  \t\"bdo\",\n  \t\"bgsound\",\n  \t\"big\",\n  \t\"blink\",\n  \t\"blockquote\",\n  \t\"body\",\n  \t\"br\",\n  \t\"button\",\n  \t\"canvas\",\n  \t\"caption\",\n  \t\"center\",\n  \t\"cite\",\n  \t\"code\",\n  \t\"col\",\n  \t\"colgroup\",\n  \t\"command\",\n  \t\"content\",\n  \t\"data\",\n  \t\"datalist\",\n  \t\"dd\",\n  \t\"del\",\n  \t\"details\",\n  \t\"dfn\",\n  \t\"dialog\",\n  \t\"dir\",\n  \t\"div\",\n  \t\"dl\",\n  \t\"dt\",\n  \t\"element\",\n  \t\"em\",\n  \t\"embed\",\n  \t\"fieldset\",\n  \t\"figcaption\",\n  \t\"figure\",\n  \t\"font\",\n  \t\"footer\",\n  \t\"form\",\n  \t\"frame\",\n  \t\"frameset\",\n  \t\"h1\",\n  \t\"h2\",\n  \t\"h3\",\n  \t\"h4\",\n  \t\"h5\",\n  \t\"h6\",\n  \t\"head\",\n  \t\"header\",\n  \t\"hgroup\",\n  \t\"hr\",\n  \t\"html\",\n  \t\"i\",\n  \t\"iframe\",\n  \t\"image\",\n  \t\"img\",\n  \t\"input\",\n  \t\"ins\",\n  \t\"isindex\",\n  \t\"kbd\",\n  \t\"keygen\",\n  \t\"label\",\n  \t\"legend\",\n  \t\"li\",\n  \t\"link\",\n  \t\"listing\",\n  \t\"main\",\n  \t\"map\",\n  \t\"mark\",\n  \t\"marquee\",\n  \t\"math\",\n  \t\"menu\",\n  \t\"menuitem\",\n  \t\"meta\",\n  \t\"meter\",\n  \t\"multicol\",\n  \t\"nav\",\n  \t\"nextid\",\n  \t\"nobr\",\n  \t\"noembed\",\n  \t\"noframes\",\n  \t\"noscript\",\n  \t\"object\",\n  \t\"ol\",\n  \t\"optgroup\",\n  \t\"option\",\n  \t\"output\",\n  \t\"p\",\n  \t\"param\",\n  \t\"picture\",\n  \t\"plaintext\",\n  \t\"pre\",\n  \t\"progress\",\n  \t\"q\",\n  \t\"rb\",\n  \t\"rbc\",\n  \t\"rp\",\n  \t\"rt\",\n  \t\"rtc\",\n  \t\"ruby\",\n  \t\"s\",\n  \t\"samp\",\n  \t\"script\",\n  \t\"section\",\n  \t\"select\",\n  \t\"shadow\",\n  \t\"slot\",\n  \t\"small\",\n  \t\"source\",\n  \t\"spacer\",\n  \t\"span\",\n  \t\"strike\",\n  \t\"strong\",\n  \t\"style\",\n  \t\"sub\",\n  \t\"summary\",\n  \t\"sup\",\n  \t\"svg\",\n  \t\"table\",\n  \t\"tbody\",\n  \t\"td\",\n  \t\"template\",\n  \t\"textarea\",\n  \t\"tfoot\",\n  \t\"th\",\n  \t\"thead\",\n  \t\"time\",\n  \t\"title\",\n  \t\"tr\",\n  \t\"track\",\n  \t\"tt\",\n  \t\"u\",\n  \t\"ul\",\n  \t\"var\",\n  \t\"video\",\n  \t\"wbr\",\n  \t\"xmp\"\n  ];\n\n  var htmlTagNames = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    'default': index\n  });\n\n  var htmlTagNames$1 = getCjsExportFromNamespace(htmlTagNames);\n\n  function clean(ast, newObj, parent) {\n    [\"raw\", // front-matter\n    \"raws\", \"sourceIndex\", \"source\", \"before\", \"after\", \"trailingComma\"].forEach(function (name) {\n      delete newObj[name];\n    });\n\n    if (ast.type === \"yaml\") {\n      delete newObj.value;\n    } // --insert-pragma\n\n\n    if (ast.type === \"css-comment\" && parent.type === \"css-root\" && parent.nodes.length !== 0 && ( // first non-front-matter comment\n    parent.nodes[0] === ast || (parent.nodes[0].type === \"yaml\" || parent.nodes[0].type === \"toml\") && parent.nodes[1] === ast)) {\n      /**\n       * something\n       *\n       * @format\n       */\n      delete newObj.text; // standalone pragma\n\n      if (/^\\*\\s*@(format|prettier)\\s*$/.test(ast.text)) {\n        return null;\n      }\n    }\n\n    if (ast.type === \"media-query\" || ast.type === \"media-query-list\" || ast.type === \"media-feature-expression\") {\n      delete newObj.value;\n    }\n\n    if (ast.type === \"css-rule\") {\n      delete newObj.params;\n    }\n\n    if (ast.type === \"selector-combinator\") {\n      newObj.value = newObj.value.replace(/\\s+/g, \" \");\n    }\n\n    if (ast.type === \"media-feature\") {\n      newObj.value = newObj.value.replace(/ /g, \"\");\n    }\n\n    if (ast.type === \"value-word\" && (ast.isColor && ast.isHex || [\"initial\", \"inherit\", \"unset\", \"revert\"].indexOf(newObj.value.replace().toLowerCase()) !== -1) || ast.type === \"media-feature\" || ast.type === \"selector-root-invalid\" || ast.type === \"selector-pseudo\") {\n      newObj.value = newObj.value.toLowerCase();\n    }\n\n    if (ast.type === \"css-decl\") {\n      newObj.prop = newObj.prop.toLowerCase();\n    }\n\n    if (ast.type === \"css-atrule\" || ast.type === \"css-import\") {\n      newObj.name = newObj.name.toLowerCase();\n    }\n\n    if (ast.type === \"value-number\") {\n      newObj.unit = newObj.unit.toLowerCase();\n    }\n\n    if ((ast.type === \"media-feature\" || ast.type === \"media-keyword\" || ast.type === \"media-type\" || ast.type === \"media-unknown\" || ast.type === \"media-url\" || ast.type === \"media-value\" || ast.type === \"selector-attribute\" || ast.type === \"selector-string\" || ast.type === \"selector-class\" || ast.type === \"selector-combinator\" || ast.type === \"value-string\") && newObj.value) {\n      newObj.value = cleanCSSStrings(newObj.value);\n    }\n\n    if (ast.type === \"selector-attribute\") {\n      newObj.attribute = newObj.attribute.trim();\n\n      if (newObj.namespace) {\n        if (typeof newObj.namespace === \"string\") {\n          newObj.namespace = newObj.namespace.trim();\n\n          if (newObj.namespace.length === 0) {\n            newObj.namespace = true;\n          }\n        }\n      }\n\n      if (newObj.value) {\n        newObj.value = newObj.value.trim().replace(/^['\"]|['\"]$/g, \"\");\n        delete newObj.quoted;\n      }\n    }\n\n    if ((ast.type === \"media-value\" || ast.type === \"media-type\" || ast.type === \"value-number\" || ast.type === \"selector-root-invalid\" || ast.type === \"selector-class\" || ast.type === \"selector-combinator\" || ast.type === \"selector-tag\") && newObj.value) {\n      newObj.value = newObj.value.replace(/([\\d.eE+-]+)([a-zA-Z]*)/g, function (match, numStr, unit) {\n        var num = Number(numStr);\n        return isNaN(num) ? match : num + unit.toLowerCase();\n      });\n    }\n\n    if (ast.type === \"selector-tag\") {\n      var lowercasedValue = ast.value.toLowerCase();\n\n      if (htmlTagNames$1.indexOf(lowercasedValue) !== -1) {\n        newObj.value = lowercasedValue;\n      }\n\n      if ([\"from\", \"to\"].indexOf(lowercasedValue) !== -1) {\n        newObj.value = lowercasedValue;\n      }\n    } // Workaround when `postcss-values-parser` parse `not`, `and` or `or` keywords as `value-func`\n\n\n    if (ast.type === \"css-atrule\" && ast.name.toLowerCase() === \"supports\") {\n      delete newObj.value;\n    } // Workaround for SCSS nested properties\n\n\n    if (ast.type === \"selector-unknown\") {\n      delete newObj.value;\n    }\n  }\n\n  function cleanCSSStrings(value) {\n    return value.replace(/'/g, '\"').replace(/\\\\([^a-fA-F\\d])/g, \"$1\");\n  }\n\n  var clean_1 = clean;\n\n  var _require$$0$builders$1 = doc.builders,\n      hardline$3 = _require$$0$builders$1.hardline,\n      literalline$1 = _require$$0$builders$1.literalline,\n      concat$4 = _require$$0$builders$1.concat,\n      markAsRoot$1 = _require$$0$builders$1.markAsRoot,\n      mapDoc$3 = doc.utils.mapDoc;\n\n  function embed(path, print, textToDoc\n  /*, options */\n  ) {\n    var node = path.getValue();\n\n    if (node.type === \"yaml\") {\n      return markAsRoot$1(concat$4([\"---\", hardline$3, node.value.trim() ? replaceNewlinesWithLiterallines(textToDoc(node.value, {\n        parser: \"yaml\"\n      })) : \"\", \"---\", hardline$3]));\n    }\n\n    return null;\n\n    function replaceNewlinesWithLiterallines(doc) {\n      return mapDoc$3(doc, function (currentDoc) {\n        return typeof currentDoc === \"string\" && currentDoc.includes(\"\\n\") ? concat$4(currentDoc.split(/(\\n)/g).map(function (v, i) {\n          return i % 2 === 0 ? v : literalline$1;\n        })) : currentDoc;\n      });\n    }\n  }\n\n  var embed_1 = embed;\n\n  var detectNewline = createCommonjsModule(function (module) {\n\n    module.exports = function (str) {\n      if (typeof str !== 'string') {\n        throw new TypeError('Expected a string');\n      }\n\n      var newlines = str.match(/(?:\\r?\\n)/g) || [];\n\n      if (newlines.length === 0) {\n        return null;\n      }\n\n      var crlf = newlines.filter(function (el) {\n        return el === '\\r\\n';\n      }).length;\n      var lf = newlines.length - crlf;\n      return crlf > lf ? '\\r\\n' : '\\n';\n    };\n\n    module.exports.graceful = function (str) {\n      return module.exports(str) || '\\n';\n    };\n  });\n  var detectNewline_1 = detectNewline.graceful;\n\n  var build = createCommonjsModule(function (module, exports) {\n\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n    exports.extract = extract;\n    exports.strip = strip;\n    exports.parse = parse;\n    exports.parseWithComments = parseWithComments;\n    exports.print = print;\n\n    function _os() {\n      var data = require$$0$1;\n\n      _os = function _os() {\n        return data;\n      };\n\n      return data;\n    }\n\n    function _detectNewline() {\n      var data = _interopRequireDefault(detectNewline);\n\n      _detectNewline = function _detectNewline() {\n        return data;\n      };\n\n      return data;\n    }\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        default: obj\n      };\n    }\n    /**\n     * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     */\n\n\n    var commentEndRe = /\\*\\/$/;\n    var commentStartRe = /^\\/\\*\\*/;\n    var docblockRe = /^\\s*(\\/\\*\\*?(.|\\r?\\n)*?\\*\\/)/;\n    var lineCommentRe = /(^|\\s+)\\/\\/([^\\r\\n]*)/g;\n    var ltrimNewlineRe = /^(\\r?\\n)+/;\n    var multilineRe = /(?:^|\\r?\\n) *(@[^\\r\\n]*?) *\\r?\\n *(?![^@\\r\\n]*\\/\\/[^]*)([^@\\r\\n\\s][^@\\r\\n]+?) *\\r?\\n/g;\n    var propertyRe = /(?:^|\\r?\\n) *@(\\S+) *([^\\r\\n]*)/g;\n    var stringStartRe = /(\\r?\\n|^) *\\* ?/g;\n\n    function extract(contents) {\n      var match = contents.match(docblockRe);\n      return match ? match[0].trimLeft() : '';\n    }\n\n    function strip(contents) {\n      var match = contents.match(docblockRe);\n      return match && match[0] ? contents.substring(match[0].length) : contents;\n    }\n\n    function parse(docblock) {\n      return parseWithComments(docblock).pragmas;\n    }\n\n    function parseWithComments(docblock) {\n      var line = (0, _detectNewline().default)(docblock) || _os().EOL;\n\n      docblock = docblock.replace(commentStartRe, '').replace(commentEndRe, '').replace(stringStartRe, '$1'); // Normalize multi-line directives\n\n      var prev = '';\n\n      while (prev !== docblock) {\n        prev = docblock;\n        docblock = docblock.replace(multilineRe, \"\".concat(line, \"$1 $2\").concat(line));\n      }\n\n      docblock = docblock.replace(ltrimNewlineRe, '').trimRight();\n      var result = Object.create(null);\n      var comments = docblock.replace(propertyRe, '').replace(ltrimNewlineRe, '').trimRight();\n      var match;\n\n      while (match = propertyRe.exec(docblock)) {\n        // strip linecomments from pragmas\n        var nextPragma = match[2].replace(lineCommentRe, '');\n\n        if (typeof result[match[1]] === 'string' || Array.isArray(result[match[1]])) {\n          result[match[1]] = [].concat(result[match[1]], nextPragma);\n        } else {\n          result[match[1]] = nextPragma;\n        }\n      }\n\n      return {\n        comments: comments,\n        pragmas: result\n      };\n    }\n\n    function print(_ref) {\n      var _ref$comments = _ref.comments,\n          comments = _ref$comments === void 0 ? '' : _ref$comments,\n          _ref$pragmas = _ref.pragmas,\n          pragmas = _ref$pragmas === void 0 ? {} : _ref$pragmas;\n\n      var line = (0, _detectNewline().default)(comments) || _os().EOL;\n\n      var head = '/**';\n      var start = ' *';\n      var tail = ' */';\n      var keys = Object.keys(pragmas);\n      var printedObject = keys.map(function (key) {\n        return printKeyValues(key, pragmas[key]);\n      }).reduce(function (arr, next) {\n        return arr.concat(next);\n      }, []).map(function (keyValue) {\n        return start + ' ' + keyValue + line;\n      }).join('');\n\n      if (!comments) {\n        if (keys.length === 0) {\n          return '';\n        }\n\n        if (keys.length === 1 && !Array.isArray(pragmas[keys[0]])) {\n          var value = pragmas[keys[0]];\n          return \"\".concat(head, \" \").concat(printKeyValues(keys[0], value)[0]).concat(tail);\n        }\n      }\n\n      var printedComments = comments.split(line).map(function (textLine) {\n        return \"\".concat(start, \" \").concat(textLine);\n      }).join(line) + line;\n      return head + line + (comments ? printedComments : '') + (comments && keys.length ? start + line : '') + printedObject + tail;\n    }\n\n    function printKeyValues(key, valueOrArray) {\n      return [].concat(valueOrArray).map(function (value) {\n        return \"@\".concat(key, \" \").concat(value).trim();\n      });\n    }\n  });\n  unwrapExports(build);\n  var build_1 = build.extract;\n  var build_2 = build.strip;\n  var build_3 = build.parse;\n  var build_4 = build.parseWithComments;\n  var build_5 = build.print;\n\n  function hasPragma(text) {\n    var pragmas = Object.keys(build.parse(build.extract(text)));\n    return pragmas.indexOf(\"prettier\") !== -1 || pragmas.indexOf(\"format\") !== -1;\n  }\n\n  function insertPragma(text) {\n    var parsedDocblock = build.parseWithComments(build.extract(text));\n    var pragmas = Object.assign({\n      format: \"\"\n    }, parsedDocblock.pragmas);\n    var newDocblock = build.print({\n      pragmas: pragmas,\n      comments: parsedDocblock.comments.replace(/^(\\s+?\\r?\\n)+/, \"\") // remove leading newlines\n\n    }).replace(/(\\r\\n|\\r)/g, \"\\n\"); // normalise newlines (mitigate use of os.EOL by jest-docblock)\n\n    var strippedText = build.strip(text);\n    var separatingNewlines = strippedText.startsWith(\"\\n\") ? \"\\n\" : \"\\n\\n\";\n    return newDocblock + separatingNewlines + strippedText;\n  }\n\n  var pragma = {\n    hasPragma: hasPragma,\n    insertPragma: insertPragma\n  };\n\n  var DELIMITER_MAP = {\n    \"---\": \"yaml\",\n    \"+++\": \"toml\"\n  };\n\n  function parse$1(text) {\n    var delimiterRegex = Object.keys(DELIMITER_MAP).map(escapeStringRegexp).join(\"|\");\n    var match = text.match( // trailing spaces after delimiters are allowed\n    new RegExp(\"^(\".concat(delimiterRegex, \")[^\\\\n\\\\S]*\\\\n(?:([\\\\s\\\\S]*?)\\\\n)?\\\\1[^\\\\n\\\\S]*(\\\\n|$)\")));\n\n    if (match === null) {\n      return {\n        frontMatter: null,\n        content: text\n      };\n    }\n\n    var raw = match[0].replace(/\\n$/, \"\");\n    var delimiter = match[1];\n    var value = match[2];\n    return {\n      frontMatter: {\n        type: DELIMITER_MAP[delimiter],\n        value: value,\n        raw: raw\n      },\n      content: match[0].replace(/[^\\n]/g, \" \") + text.slice(match[0].length)\n    };\n  }\n\n  var frontMatter = parse$1;\n\n  function hasPragma$1(text) {\n    return pragma.hasPragma(frontMatter(text).content);\n  }\n\n  function insertPragma$1(text) {\n    var _parseFrontMatter = frontMatter(text),\n        frontMatter$1 = _parseFrontMatter.frontMatter,\n        content = _parseFrontMatter.content;\n\n    return (frontMatter$1 ? frontMatter$1.raw + \"\\n\\n\" : \"\") + pragma.insertPragma(content);\n  }\n\n  var pragma$1 = {\n    hasPragma: hasPragma$1,\n    insertPragma: insertPragma$1\n  };\n\n  var colorAdjusterFunctions = [\"red\", \"green\", \"blue\", \"alpha\", \"a\", \"rgb\", \"hue\", \"h\", \"saturation\", \"s\", \"lightness\", \"l\", \"whiteness\", \"w\", \"blackness\", \"b\", \"tint\", \"shade\", \"blend\", \"blenda\", \"contrast\", \"hsl\", \"hsla\", \"hwb\", \"hwba\"];\n\n  function getAncestorCounter(path, typeOrTypes) {\n    var types = [].concat(typeOrTypes);\n    var counter = -1;\n    var ancestorNode;\n\n    while (ancestorNode = path.getParentNode(++counter)) {\n      if (types.indexOf(ancestorNode.type) !== -1) {\n        return counter;\n      }\n    }\n\n    return -1;\n  }\n\n  function getAncestorNode(path, typeOrTypes) {\n    var counter = getAncestorCounter(path, typeOrTypes);\n    return counter === -1 ? null : path.getParentNode(counter);\n  }\n\n  function getPropOfDeclNode(path) {\n    var declAncestorNode = getAncestorNode(path, \"css-decl\");\n    return declAncestorNode && declAncestorNode.prop && declAncestorNode.prop.toLowerCase();\n  }\n\n  function isSCSS(parser, text) {\n    var hasExplicitParserChoice = parser === \"less\" || parser === \"scss\";\n    var IS_POSSIBLY_SCSS = /(\\w\\s*: [^}:]+|#){|@import[^\\n]+(url|,)/;\n    return hasExplicitParserChoice ? parser === \"scss\" : IS_POSSIBLY_SCSS.test(text);\n  }\n\n  function isWideKeywords(value) {\n    return [\"initial\", \"inherit\", \"unset\", \"revert\"].indexOf(value.toLowerCase()) !== -1;\n  }\n\n  function isKeyframeAtRuleKeywords(path, value) {\n    var atRuleAncestorNode = getAncestorNode(path, \"css-atrule\");\n    return atRuleAncestorNode && atRuleAncestorNode.name && atRuleAncestorNode.name.toLowerCase().endsWith(\"keyframes\") && [\"from\", \"to\"].indexOf(value.toLowerCase()) !== -1;\n  }\n\n  function maybeToLowerCase(value) {\n    return value.includes(\"$\") || value.includes(\"@\") || value.includes(\"#\") || value.startsWith(\"%\") || value.startsWith(\"--\") || value.startsWith(\":--\") || value.includes(\"(\") && value.includes(\")\") ? value : value.toLowerCase();\n  }\n\n  function insideValueFunctionNode(path, functionName) {\n    var funcAncestorNode = getAncestorNode(path, \"value-func\");\n    return funcAncestorNode && funcAncestorNode.value && funcAncestorNode.value.toLowerCase() === functionName;\n  }\n\n  function insideICSSRuleNode(path) {\n    var ruleAncestorNode = getAncestorNode(path, \"css-rule\");\n    return ruleAncestorNode && ruleAncestorNode.raws && ruleAncestorNode.raws.selector && (ruleAncestorNode.raws.selector.startsWith(\":import\") || ruleAncestorNode.raws.selector.startsWith(\":export\"));\n  }\n\n  function insideAtRuleNode(path, atRuleNameOrAtRuleNames) {\n    var atRuleNames = [].concat(atRuleNameOrAtRuleNames);\n    var atRuleAncestorNode = getAncestorNode(path, \"css-atrule\");\n    return atRuleAncestorNode && atRuleNames.indexOf(atRuleAncestorNode.name.toLowerCase()) !== -1;\n  }\n\n  function insideURLFunctionInImportAtRuleNode(path) {\n    var node = path.getValue();\n    var atRuleAncestorNode = getAncestorNode(path, \"css-atrule\");\n    return atRuleAncestorNode && atRuleAncestorNode.name === \"import\" && node.groups[0].value === \"url\" && node.groups.length === 2;\n  }\n\n  function isURLFunctionNode(node) {\n    return node.type === \"value-func\" && node.value.toLowerCase() === \"url\";\n  }\n\n  function isLastNode(path, node) {\n    var parentNode = path.getParentNode();\n\n    if (!parentNode) {\n      return false;\n    }\n\n    var nodes = parentNode.nodes;\n    return nodes && nodes.indexOf(node) === nodes.length - 1;\n  }\n\n  function isHTMLTag(value) {\n    return htmlTagNames$1.indexOf(value.toLowerCase()) !== -1;\n  }\n\n  function isDetachedRulesetDeclarationNode(node) {\n    // If a Less file ends up being parsed with the SCSS parser, Less\n    // variable declarations will be parsed as atrules with names ending\n    // with a colon, so keep the original case then.\n    if (!node.selector) {\n      return false;\n    }\n\n    return typeof node.selector === \"string\" && /^@.+:.*$/.test(node.selector) || node.selector.value && /^@.+:.*$/.test(node.selector.value);\n  }\n\n  function isForKeywordNode(node) {\n    return node.type === \"value-word\" && [\"from\", \"through\", \"end\"].indexOf(node.value) !== -1;\n  }\n\n  function isIfElseKeywordNode(node) {\n    return node.type === \"value-word\" && [\"and\", \"or\", \"not\"].indexOf(node.value) !== -1;\n  }\n\n  function isEachKeywordNode(node) {\n    return node.type === \"value-word\" && node.value === \"in\";\n  }\n\n  function isMultiplicationNode(node) {\n    return node.type === \"value-operator\" && node.value === \"*\";\n  }\n\n  function isDivisionNode(node) {\n    return node.type === \"value-operator\" && node.value === \"/\";\n  }\n\n  function isAdditionNode(node) {\n    return node.type === \"value-operator\" && node.value === \"+\";\n  }\n\n  function isSubtractionNode(node) {\n    return node.type === \"value-operator\" && node.value === \"-\";\n  }\n\n  function isModuloNode(node) {\n    return node.type === \"value-operator\" && node.value === \"%\";\n  }\n\n  function isMathOperatorNode(node) {\n    return isMultiplicationNode(node) || isDivisionNode(node) || isAdditionNode(node) || isSubtractionNode(node) || isModuloNode(node);\n  }\n\n  function isEqualityOperatorNode(node) {\n    return node.type === \"value-word\" && [\"==\", \"!=\"].indexOf(node.value) !== -1;\n  }\n\n  function isRelationalOperatorNode(node) {\n    return node.type === \"value-word\" && [\"<\", \">\", \"<=\", \">=\"].indexOf(node.value) !== -1;\n  }\n\n  function isSCSSControlDirectiveNode(node) {\n    return node.type === \"css-atrule\" && [\"if\", \"else\", \"for\", \"each\", \"while\"].indexOf(node.name) !== -1;\n  }\n\n  function isSCSSNestedPropertyNode(node) {\n    if (!node.selector) {\n      return false;\n    }\n\n    return node.selector.replace(/\\/\\*.*?\\*\\//, \"\").replace(/\\/\\/.*?\\n/, \"\").trim().endsWith(\":\");\n  }\n\n  function isDetachedRulesetCallNode(node) {\n    return node.raws && node.raws.params && /^\\(\\s*\\)$/.test(node.raws.params);\n  }\n\n  function isTemplatePlaceholderNode(node) {\n    return node.name.startsWith(\"prettier-placeholder\");\n  }\n\n  function isTemplatePropNode(node) {\n    return node.prop.startsWith(\"@prettier-placeholder\");\n  }\n\n  function isPostcssSimpleVarNode(currentNode, nextNode) {\n    return currentNode.value === \"$$\" && currentNode.type === \"value-func\" && nextNode && nextNode.type === \"value-word\" && !nextNode.raws.before;\n  }\n\n  function hasComposesNode(node) {\n    return node.value && node.value.type === \"value-root\" && node.value.group && node.value.group.type === \"value-value\" && node.prop.toLowerCase() === \"composes\";\n  }\n\n  function hasParensAroundNode(node) {\n    return node.value && node.value.group && node.value.group.group && node.value.group.group.type === \"value-paren_group\" && node.value.group.group.open !== null && node.value.group.group.close !== null;\n  }\n\n  function hasEmptyRawBefore(node) {\n    return node.raws && node.raws.before === \"\";\n  }\n\n  function isKeyValuePairNode(node) {\n    return node.type === \"value-comma_group\" && node.groups && node.groups[1] && node.groups[1].type === \"value-colon\";\n  }\n\n  function isKeyValuePairInParenGroupNode(node) {\n    return node.type === \"value-paren_group\" && node.groups && node.groups[0] && isKeyValuePairNode(node.groups[0]);\n  }\n\n  function isSCSSMapItemNode(path) {\n    var node = path.getValue(); // Ignore empty item (i.e. `$key: ()`)\n\n    if (node.groups.length === 0) {\n      return false;\n    }\n\n    var parentParentNode = path.getParentNode(1); // Check open parens contain key/value pair (i.e. `(key: value)` and `(key: (value, other-value)`)\n\n    if (!isKeyValuePairInParenGroupNode(node) && !(parentParentNode && isKeyValuePairInParenGroupNode(parentParentNode))) {\n      return false;\n    }\n\n    var declNode = getAncestorNode(path, \"css-decl\"); // SCSS map declaration (i.e. `$map: (key: value, other-key: other-value)`)\n\n    if (declNode && declNode.prop && declNode.prop.startsWith(\"$\")) {\n      return true;\n    } // List as value of key inside SCSS map (i.e. `$map: (key: (value other-value other-other-value))`)\n\n\n    if (isKeyValuePairInParenGroupNode(parentParentNode)) {\n      return true;\n    } // SCSS Map is argument of function (i.e. `func((key: value, other-key: other-value))`)\n\n\n    if (parentParentNode.type === \"value-func\") {\n      return true;\n    }\n\n    return false;\n  }\n\n  function isInlineValueCommentNode(node) {\n    return node.type === \"value-comment\" && node.inline;\n  }\n\n  function isHashNode(node) {\n    return node.type === \"value-word\" && node.value === \"#\";\n  }\n\n  function isLeftCurlyBraceNode(node) {\n    return node.type === \"value-word\" && node.value === \"{\";\n  }\n\n  function isRightCurlyBraceNode(node) {\n    return node.type === \"value-word\" && node.value === \"}\";\n  }\n\n  function isWordNode(node) {\n    return [\"value-word\", \"value-atword\"].indexOf(node.type) !== -1;\n  }\n\n  function isColonNode(node) {\n    return node.type === \"value-colon\";\n  }\n\n  function isMediaAndSupportsKeywords(node) {\n    return node.value && [\"not\", \"and\", \"or\"].indexOf(node.value.toLowerCase()) !== -1;\n  }\n\n  function isColorAdjusterFuncNode(node) {\n    if (node.type !== \"value-func\") {\n      return false;\n    }\n\n    return colorAdjusterFunctions.indexOf(node.value.toLowerCase()) !== -1;\n  }\n\n  var utils$2 = {\n    getAncestorCounter: getAncestorCounter,\n    getAncestorNode: getAncestorNode,\n    getPropOfDeclNode: getPropOfDeclNode,\n    maybeToLowerCase: maybeToLowerCase,\n    insideValueFunctionNode: insideValueFunctionNode,\n    insideICSSRuleNode: insideICSSRuleNode,\n    insideAtRuleNode: insideAtRuleNode,\n    insideURLFunctionInImportAtRuleNode: insideURLFunctionInImportAtRuleNode,\n    isKeyframeAtRuleKeywords: isKeyframeAtRuleKeywords,\n    isHTMLTag: isHTMLTag,\n    isWideKeywords: isWideKeywords,\n    isSCSS: isSCSS,\n    isLastNode: isLastNode,\n    isSCSSControlDirectiveNode: isSCSSControlDirectiveNode,\n    isDetachedRulesetDeclarationNode: isDetachedRulesetDeclarationNode,\n    isRelationalOperatorNode: isRelationalOperatorNode,\n    isEqualityOperatorNode: isEqualityOperatorNode,\n    isMultiplicationNode: isMultiplicationNode,\n    isDivisionNode: isDivisionNode,\n    isAdditionNode: isAdditionNode,\n    isSubtractionNode: isSubtractionNode,\n    isModuloNode: isModuloNode,\n    isMathOperatorNode: isMathOperatorNode,\n    isEachKeywordNode: isEachKeywordNode,\n    isForKeywordNode: isForKeywordNode,\n    isURLFunctionNode: isURLFunctionNode,\n    isIfElseKeywordNode: isIfElseKeywordNode,\n    hasComposesNode: hasComposesNode,\n    hasParensAroundNode: hasParensAroundNode,\n    hasEmptyRawBefore: hasEmptyRawBefore,\n    isSCSSNestedPropertyNode: isSCSSNestedPropertyNode,\n    isDetachedRulesetCallNode: isDetachedRulesetCallNode,\n    isTemplatePlaceholderNode: isTemplatePlaceholderNode,\n    isTemplatePropNode: isTemplatePropNode,\n    isPostcssSimpleVarNode: isPostcssSimpleVarNode,\n    isKeyValuePairNode: isKeyValuePairNode,\n    isKeyValuePairInParenGroupNode: isKeyValuePairInParenGroupNode,\n    isSCSSMapItemNode: isSCSSMapItemNode,\n    isInlineValueCommentNode: isInlineValueCommentNode,\n    isHashNode: isHashNode,\n    isLeftCurlyBraceNode: isLeftCurlyBraceNode,\n    isRightCurlyBraceNode: isRightCurlyBraceNode,\n    isWordNode: isWordNode,\n    isColonNode: isColonNode,\n    isMediaAndSupportsKeywords: isMediaAndSupportsKeywords,\n    isColorAdjusterFuncNode: isColorAdjusterFuncNode\n  };\n\n  var insertPragma$2 = pragma$1.insertPragma;\n  var printNumber$1 = util.printNumber,\n      printString$1 = util.printString,\n      hasIgnoreComment$1 = util.hasIgnoreComment,\n      hasNewline$2 = util.hasNewline;\n  var isNextLineEmpty$2 = utilShared.isNextLineEmpty;\n  var _require$$3$builders = doc.builders,\n      concat$5 = _require$$3$builders.concat,\n      join$2 = _require$$3$builders.join,\n      line$1 = _require$$3$builders.line,\n      hardline$4 = _require$$3$builders.hardline,\n      softline$1 = _require$$3$builders.softline,\n      group$1 = _require$$3$builders.group,\n      fill$2 = _require$$3$builders.fill,\n      indent$2 = _require$$3$builders.indent,\n      dedent$1 = _require$$3$builders.dedent,\n      ifBreak$1 = _require$$3$builders.ifBreak,\n      removeLines$1 = doc.utils.removeLines;\n  var getAncestorNode$1 = utils$2.getAncestorNode,\n      getPropOfDeclNode$1 = utils$2.getPropOfDeclNode,\n      maybeToLowerCase$1 = utils$2.maybeToLowerCase,\n      insideValueFunctionNode$1 = utils$2.insideValueFunctionNode,\n      insideICSSRuleNode$1 = utils$2.insideICSSRuleNode,\n      insideAtRuleNode$1 = utils$2.insideAtRuleNode,\n      insideURLFunctionInImportAtRuleNode$1 = utils$2.insideURLFunctionInImportAtRuleNode,\n      isKeyframeAtRuleKeywords$1 = utils$2.isKeyframeAtRuleKeywords,\n      isHTMLTag$1 = utils$2.isHTMLTag,\n      isWideKeywords$1 = utils$2.isWideKeywords,\n      isSCSS$1 = utils$2.isSCSS,\n      isLastNode$1 = utils$2.isLastNode,\n      isSCSSControlDirectiveNode$1 = utils$2.isSCSSControlDirectiveNode,\n      isDetachedRulesetDeclarationNode$1 = utils$2.isDetachedRulesetDeclarationNode,\n      isRelationalOperatorNode$1 = utils$2.isRelationalOperatorNode,\n      isEqualityOperatorNode$1 = utils$2.isEqualityOperatorNode,\n      isMultiplicationNode$1 = utils$2.isMultiplicationNode,\n      isDivisionNode$1 = utils$2.isDivisionNode,\n      isAdditionNode$1 = utils$2.isAdditionNode,\n      isSubtractionNode$1 = utils$2.isSubtractionNode,\n      isMathOperatorNode$1 = utils$2.isMathOperatorNode,\n      isEachKeywordNode$1 = utils$2.isEachKeywordNode,\n      isForKeywordNode$1 = utils$2.isForKeywordNode,\n      isURLFunctionNode$1 = utils$2.isURLFunctionNode,\n      isIfElseKeywordNode$1 = utils$2.isIfElseKeywordNode,\n      hasComposesNode$1 = utils$2.hasComposesNode,\n      hasParensAroundNode$1 = utils$2.hasParensAroundNode,\n      hasEmptyRawBefore$1 = utils$2.hasEmptyRawBefore,\n      isKeyValuePairNode$1 = utils$2.isKeyValuePairNode,\n      isDetachedRulesetCallNode$1 = utils$2.isDetachedRulesetCallNode,\n      isTemplatePlaceholderNode$1 = utils$2.isTemplatePlaceholderNode,\n      isTemplatePropNode$1 = utils$2.isTemplatePropNode,\n      isPostcssSimpleVarNode$1 = utils$2.isPostcssSimpleVarNode,\n      isSCSSMapItemNode$1 = utils$2.isSCSSMapItemNode,\n      isInlineValueCommentNode$1 = utils$2.isInlineValueCommentNode,\n      isHashNode$1 = utils$2.isHashNode,\n      isLeftCurlyBraceNode$1 = utils$2.isLeftCurlyBraceNode,\n      isRightCurlyBraceNode$1 = utils$2.isRightCurlyBraceNode,\n      isWordNode$1 = utils$2.isWordNode,\n      isColonNode$1 = utils$2.isColonNode,\n      isMediaAndSupportsKeywords$1 = utils$2.isMediaAndSupportsKeywords,\n      isColorAdjusterFuncNode$1 = utils$2.isColorAdjusterFuncNode;\n\n  function shouldPrintComma(options) {\n    switch (options.trailingComma) {\n      case \"all\":\n      case \"es5\":\n        return true;\n\n      case \"none\":\n      default:\n        return false;\n    }\n  }\n\n  function genericPrint(path, options, print) {\n    var node = path.getValue();\n    /* istanbul ignore if */\n\n    if (!node) {\n      return \"\";\n    }\n\n    if (typeof node === \"string\") {\n      return node;\n    }\n\n    switch (node.type) {\n      case \"yaml\":\n      case \"toml\":\n        return concat$5([node.raw, hardline$4]);\n\n      case \"css-root\":\n        {\n          var nodes = printNodeSequence(path, options, print);\n\n          if (nodes.parts.length) {\n            return concat$5([nodes, hardline$4]);\n          }\n\n          return nodes;\n        }\n\n      case \"css-comment\":\n        {\n          if (node.raws.content) {\n            return node.raws.content;\n          }\n\n          var text = options.originalText.slice(options.locStart(node), options.locEnd(node));\n          var rawText = node.raws.text || node.text; // Workaround a bug where the location is off.\n          // https://github.com/postcss/postcss-scss/issues/63\n\n          if (text.indexOf(rawText) === -1) {\n            if (node.raws.inline) {\n              return concat$5([\"// \", rawText]);\n            }\n\n            return concat$5([\"/* \", rawText, \" */\"]);\n          }\n\n          return text;\n        }\n\n      case \"css-rule\":\n        {\n          return concat$5([path.call(print, \"selector\"), node.important ? \" !important\" : \"\", node.nodes ? concat$5([\" {\", node.nodes.length > 0 ? indent$2(concat$5([hardline$4, printNodeSequence(path, options, print)])) : \"\", hardline$4, \"}\", isDetachedRulesetDeclarationNode$1(node) ? \";\" : \"\"]) : \";\"]);\n        }\n\n      case \"css-decl\":\n        {\n          var parentNode = path.getParentNode();\n          return concat$5([node.raws.before.replace(/[\\s;]/g, \"\"), insideICSSRuleNode$1(path) ? node.prop : maybeToLowerCase$1(node.prop), node.raws.between.trim() === \":\" ? \":\" : node.raws.between.trim(), node.extend ? \"\" : \" \", hasComposesNode$1(node) ? removeLines$1(path.call(print, \"value\")) : path.call(print, \"value\"), node.raws.important ? node.raws.important.replace(/\\s*!\\s*important/i, \" !important\") : node.important ? \" !important\" : \"\", node.raws.scssDefault ? node.raws.scssDefault.replace(/\\s*!default/i, \" !default\") : node.scssDefault ? \" !default\" : \"\", node.raws.scssGlobal ? node.raws.scssGlobal.replace(/\\s*!global/i, \" !global\") : node.scssGlobal ? \" !global\" : \"\", node.nodes ? concat$5([\" {\", indent$2(concat$5([softline$1, printNodeSequence(path, options, print)])), softline$1, \"}\"]) : isTemplatePropNode$1(node) && !parentNode.raws.semicolon && options.originalText[options.locEnd(node) - 1] !== \";\" ? \"\" : \";\"]);\n        }\n\n      case \"css-atrule\":\n        {\n          var _parentNode = path.getParentNode();\n\n          return concat$5([\"@\", // If a Less file ends up being parsed with the SCSS parser, Less\n          // variable declarations will be parsed as at-rules with names ending\n          // with a colon, so keep the original case then.\n          isDetachedRulesetCallNode$1(node) || node.name.endsWith(\":\") ? node.name : maybeToLowerCase$1(node.name), node.params ? concat$5([isDetachedRulesetCallNode$1(node) ? \"\" : isTemplatePlaceholderNode$1(node) && /^\\s*\\n/.test(node.raws.afterName) ? /^\\s*\\n\\s*\\n/.test(node.raws.afterName) ? concat$5([hardline$4, hardline$4]) : hardline$4 : \" \", path.call(print, \"params\")]) : \"\", node.selector ? indent$2(concat$5([\" \", path.call(print, \"selector\")])) : \"\", node.value ? group$1(concat$5([\" \", path.call(print, \"value\"), isSCSSControlDirectiveNode$1(node) ? hasParensAroundNode$1(node) ? \" \" : line$1 : \"\"])) : node.name === \"else\" ? \" \" : \"\", node.nodes ? concat$5([isSCSSControlDirectiveNode$1(node) ? \"\" : \" \", \"{\", indent$2(concat$5([node.nodes.length > 0 ? softline$1 : \"\", printNodeSequence(path, options, print)])), softline$1, \"}\"]) : isTemplatePlaceholderNode$1(node) && !_parentNode.raws.semicolon && options.originalText[options.locEnd(node) - 1] !== \";\" ? \"\" : \";\"]);\n        }\n      // postcss-media-query-parser\n\n      case \"media-query-list\":\n        {\n          var parts = [];\n          path.each(function (childPath) {\n            var node = childPath.getValue();\n\n            if (node.type === \"media-query\" && node.value === \"\") {\n              return;\n            }\n\n            parts.push(childPath.call(print));\n          }, \"nodes\");\n          return group$1(indent$2(join$2(line$1, parts)));\n        }\n\n      case \"media-query\":\n        {\n          return concat$5([join$2(\" \", path.map(print, \"nodes\")), isLastNode$1(path, node) ? \"\" : \",\"]);\n        }\n\n      case \"media-type\":\n        {\n          return adjustNumbers(adjustStrings(node.value, options));\n        }\n\n      case \"media-feature-expression\":\n        {\n          if (!node.nodes) {\n            return node.value;\n          }\n\n          return concat$5([\"(\", concat$5(path.map(print, \"nodes\")), \")\"]);\n        }\n\n      case \"media-feature\":\n        {\n          return maybeToLowerCase$1(adjustStrings(node.value.replace(/ +/g, \" \"), options));\n        }\n\n      case \"media-colon\":\n        {\n          return concat$5([node.value, \" \"]);\n        }\n\n      case \"media-value\":\n        {\n          return adjustNumbers(adjustStrings(node.value, options));\n        }\n\n      case \"media-keyword\":\n        {\n          return adjustStrings(node.value, options);\n        }\n\n      case \"media-url\":\n        {\n          return adjustStrings(node.value.replace(/^url\\(\\s+/gi, \"url(\").replace(/\\s+\\)$/gi, \")\"), options);\n        }\n\n      case \"media-unknown\":\n        {\n          return node.value;\n        }\n      // postcss-selector-parser\n\n      case \"selector-root\":\n        {\n          return group$1(concat$5([insideAtRuleNode$1(path, \"custom-selector\") ? concat$5([getAncestorNode$1(path, \"css-atrule\").customSelector, line$1]) : \"\", join$2(concat$5([\",\", insideAtRuleNode$1(path, [\"extend\", \"custom-selector\", \"nest\"]) ? line$1 : hardline$4]), path.map(print, \"nodes\"))]));\n        }\n\n      case \"selector-selector\":\n        {\n          return group$1(indent$2(concat$5(path.map(print, \"nodes\"))));\n        }\n\n      case \"selector-comment\":\n        {\n          return node.value;\n        }\n\n      case \"selector-string\":\n        {\n          return adjustStrings(node.value, options);\n        }\n\n      case \"selector-tag\":\n        {\n          var _parentNode2 = path.getParentNode();\n\n          var index = _parentNode2 && _parentNode2.nodes.indexOf(node);\n\n          var prevNode = index && _parentNode2.nodes[index - 1];\n          return concat$5([node.namespace ? concat$5([node.namespace === true ? \"\" : node.namespace.trim(), \"|\"]) : \"\", prevNode.type === \"selector-nesting\" ? node.value : adjustNumbers(isHTMLTag$1(node.value) || isKeyframeAtRuleKeywords$1(path, node.value) ? node.value.toLowerCase() : node.value)]);\n        }\n\n      case \"selector-id\":\n        {\n          return concat$5([\"#\", node.value]);\n        }\n\n      case \"selector-class\":\n        {\n          return concat$5([\".\", adjustNumbers(adjustStrings(node.value, options))]);\n        }\n\n      case \"selector-attribute\":\n        {\n          return concat$5([\"[\", node.namespace ? concat$5([node.namespace === true ? \"\" : node.namespace.trim(), \"|\"]) : \"\", node.attribute.trim(), node.operator ? node.operator : \"\", node.value ? quoteAttributeValue(adjustStrings(node.value.trim(), options), options) : \"\", node.insensitive ? \" i\" : \"\", \"]\"]);\n        }\n\n      case \"selector-combinator\":\n        {\n          if (node.value === \"+\" || node.value === \">\" || node.value === \"~\" || node.value === \">>>\") {\n            var _parentNode3 = path.getParentNode();\n\n            var _leading = _parentNode3.type === \"selector-selector\" && _parentNode3.nodes[0] === node ? \"\" : line$1;\n\n            return concat$5([_leading, node.value, isLastNode$1(path, node) ? \"\" : \" \"]);\n          }\n\n          var leading = node.value.trim().startsWith(\"(\") ? line$1 : \"\";\n          var value = adjustNumbers(adjustStrings(node.value.trim(), options)) || line$1;\n          return concat$5([leading, value]);\n        }\n\n      case \"selector-universal\":\n        {\n          return concat$5([node.namespace ? concat$5([node.namespace === true ? \"\" : node.namespace.trim(), \"|\"]) : \"\", node.value]);\n        }\n\n      case \"selector-pseudo\":\n        {\n          return concat$5([maybeToLowerCase$1(node.value), node.nodes && node.nodes.length > 0 ? concat$5([\"(\", join$2(\", \", path.map(print, \"nodes\")), \")\"]) : \"\"]);\n        }\n\n      case \"selector-nesting\":\n        {\n          return node.value;\n        }\n\n      case \"selector-unknown\":\n        {\n          var ruleAncestorNode = getAncestorNode$1(path, \"css-rule\"); // Nested SCSS property\n\n          if (ruleAncestorNode && ruleAncestorNode.isSCSSNesterProperty) {\n            return adjustNumbers(adjustStrings(maybeToLowerCase$1(node.value), options));\n          }\n\n          return node.value;\n        }\n      // postcss-values-parser\n\n      case \"value-value\":\n      case \"value-root\":\n        {\n          return path.call(print, \"group\");\n        }\n\n      case \"value-comment\":\n        {\n          return concat$5([node.inline ? \"//\" : \"/*\", node.value, node.inline ? \"\" : \"*/\"]);\n        }\n\n      case \"value-comma_group\":\n        {\n          var _parentNode4 = path.getParentNode();\n\n          var parentParentNode = path.getParentNode(1);\n          var declAncestorProp = getPropOfDeclNode$1(path);\n          var isGridValue = declAncestorProp && _parentNode4.type === \"value-value\" && (declAncestorProp === \"grid\" || declAncestorProp.startsWith(\"grid-template\"));\n          var atRuleAncestorNode = getAncestorNode$1(path, \"css-atrule\");\n          var isControlDirective = atRuleAncestorNode && isSCSSControlDirectiveNode$1(atRuleAncestorNode);\n          var printed = path.map(print, \"groups\");\n          var _parts = [];\n          var insideURLFunction = insideValueFunctionNode$1(path, \"url\");\n          var insideSCSSInterpolationInString = false;\n          var didBreak = false;\n\n          for (var i = 0; i < node.groups.length; ++i) {\n            _parts.push(printed[i]); // Ignore value inside `url()`\n\n\n            if (insideURLFunction) {\n              continue;\n            }\n\n            var iPrevNode = node.groups[i - 1];\n            var iNode = node.groups[i];\n            var iNextNode = node.groups[i + 1];\n            var iNextNextNode = node.groups[i + 2]; // Ignore after latest node (i.e. before semicolon)\n\n            if (!iNextNode) {\n              continue;\n            } // Ignore spaces before/after string interpolation (i.e. `\"#{my-fn(\"_\")}\"`)\n\n\n            var isStartSCSSInterpolationInString = iNode.type === \"value-string\" && iNode.value.startsWith(\"#{\");\n            var isEndingSCSSInterpolationInString = insideSCSSInterpolationInString && iNextNode.type === \"value-string\" && iNextNode.value.endsWith(\"}\");\n\n            if (isStartSCSSInterpolationInString || isEndingSCSSInterpolationInString) {\n              insideSCSSInterpolationInString = !insideSCSSInterpolationInString;\n              continue;\n            }\n\n            if (insideSCSSInterpolationInString) {\n              continue;\n            } // Ignore colon (i.e. `:`)\n\n\n            if (isColonNode$1(iNode) || isColonNode$1(iNextNode)) {\n              continue;\n            } // Ignore `@` in Less (i.e. `@@var;`)\n\n\n            if (iNode.type === \"value-atword\" && iNode.value === \"\") {\n              continue;\n            } // Ignore `~` in Less (i.e. `content: ~\"^//* some horrible but needed css hack\";`)\n\n\n            if (iNode.value === \"~\") {\n              continue;\n            } // Ignore escape `\\`\n\n\n            if (iNode.value && iNode.value.indexOf(\"\\\\\") !== -1 && iNextNode && iNextNode.type !== \"value-comment\") {\n              continue;\n            } // Ignore escaped `/`\n\n\n            if (iPrevNode && iPrevNode.value && iPrevNode.value.indexOf(\"\\\\\") === iPrevNode.value.length - 1 && iNode.type === \"value-operator\" && iNode.value === \"/\") {\n              continue;\n            } // Ignore `\\` (i.e. `$variable: \\@small;`)\n\n\n            if (iNode.value === \"\\\\\") {\n              continue;\n            } // Ignore `$$` (i.e. `background-color: $$(style)Color;`)\n\n\n            if (isPostcssSimpleVarNode$1(iNode, iNextNode)) {\n              continue;\n            } // Ignore spaces after `#` and after `{` and before `}` in SCSS interpolation (i.e. `#{variable}`)\n\n\n            if (isHashNode$1(iNode) || isLeftCurlyBraceNode$1(iNode) || isRightCurlyBraceNode$1(iNextNode) || isLeftCurlyBraceNode$1(iNextNode) && hasEmptyRawBefore$1(iNextNode) || isRightCurlyBraceNode$1(iNode) && hasEmptyRawBefore$1(iNextNode)) {\n              continue;\n            } // Ignore css variables and interpolation in SCSS (i.e. `--#{$var}`)\n\n\n            if (iNode.value === \"--\" && isHashNode$1(iNextNode)) {\n              continue;\n            } // Formatting math operations\n\n\n            var isMathOperator = isMathOperatorNode$1(iNode);\n            var isNextMathOperator = isMathOperatorNode$1(iNextNode); // Print spaces before and after math operators beside SCSS interpolation as is\n            // (i.e. `#{$var}+5`, `#{$var} +5`, `#{$var}+ 5`, `#{$var} + 5`)\n            // (i.e. `5+#{$var}`, `5 +#{$var}`, `5+ #{$var}`, `5 + #{$var}`)\n\n            if ((isMathOperator && isHashNode$1(iNextNode) || isNextMathOperator && isRightCurlyBraceNode$1(iNode)) && hasEmptyRawBefore$1(iNextNode)) {\n              continue;\n            } // Print spaces before and after addition and subtraction math operators as is in `calc` function\n            // due to the fact that it is not valid syntax\n            // (i.e. `calc(1px+1px)`, `calc(1px+ 1px)`, `calc(1px +1px)`, `calc(1px + 1px)`)\n\n\n            if (insideValueFunctionNode$1(path, \"calc\") && (isAdditionNode$1(iNode) || isAdditionNode$1(iNextNode) || isSubtractionNode$1(iNode) || isSubtractionNode$1(iNextNode)) && hasEmptyRawBefore$1(iNextNode)) {\n              continue;\n            } // Print spaces after `+` and `-` in color adjuster functions as is (e.g. `color(red l(+ 20%))`)\n            // Adjusters with signed numbers (e.g. `color(red l(+20%))`) output as-is.\n\n\n            var isColorAdjusterNode = (isAdditionNode$1(iNode) || isSubtractionNode$1(iNode)) && i === 0 && (iNextNode.type === \"value-number\" || iNextNode.isHex) && parentParentNode && isColorAdjusterFuncNode$1(parentParentNode) && !hasEmptyRawBefore$1(iNextNode);\n            var requireSpaceBeforeOperator = iNextNextNode && iNextNextNode.type === \"value-func\" || iNextNextNode && isWordNode$1(iNextNextNode) || iNode.type === \"value-func\" || isWordNode$1(iNode);\n            var requireSpaceAfterOperator = iNextNode.type === \"value-func\" || isWordNode$1(iNextNode) || iPrevNode && iPrevNode.type === \"value-func\" || iPrevNode && isWordNode$1(iPrevNode); // Formatting `/`, `+`, `-` sign\n\n            if (!(isMultiplicationNode$1(iNextNode) || isMultiplicationNode$1(iNode)) && !insideValueFunctionNode$1(path, \"calc\") && !isColorAdjusterNode && (isDivisionNode$1(iNextNode) && !requireSpaceBeforeOperator || isDivisionNode$1(iNode) && !requireSpaceAfterOperator || isAdditionNode$1(iNextNode) && !requireSpaceBeforeOperator || isAdditionNode$1(iNode) && !requireSpaceAfterOperator || isSubtractionNode$1(iNextNode) || isSubtractionNode$1(iNode)) && (hasEmptyRawBefore$1(iNextNode) || isMathOperator && (!iPrevNode || iPrevNode && isMathOperatorNode$1(iPrevNode)))) {\n              continue;\n            } // Add `hardline` after inline comment (i.e. `// comment\\n foo: bar;`)\n\n\n            if (isInlineValueCommentNode$1(iNode)) {\n              _parts.push(hardline$4);\n\n              continue;\n            } // Handle keywords in SCSS control directive\n\n\n            if (isControlDirective && (isEqualityOperatorNode$1(iNextNode) || isRelationalOperatorNode$1(iNextNode) || isIfElseKeywordNode$1(iNextNode) || isEachKeywordNode$1(iNode) || isForKeywordNode$1(iNode))) {\n              _parts.push(\" \");\n\n              continue;\n            } // At-rule `namespace` should be in one line\n\n\n            if (atRuleAncestorNode && atRuleAncestorNode.name.toLowerCase() === \"namespace\") {\n              _parts.push(\" \");\n\n              continue;\n            } // Formatting `grid` property\n\n\n            if (isGridValue) {\n              if (iNode.source && iNextNode.source && iNode.source.start.line !== iNextNode.source.start.line) {\n                _parts.push(hardline$4);\n\n                didBreak = true;\n              } else {\n                _parts.push(\" \");\n              }\n\n              continue;\n            } // Add `space` before next math operation\n            // Note: `grip` property have `/` delimiter and it is not math operation, so\n            // `grid` property handles above\n\n\n            if (isNextMathOperator) {\n              _parts.push(\" \");\n\n              continue;\n            } // Be default all values go through `line`\n\n\n            _parts.push(line$1);\n          }\n\n          if (didBreak) {\n            _parts.unshift(hardline$4);\n          }\n\n          if (isControlDirective) {\n            return group$1(indent$2(concat$5(_parts)));\n          } // Indent is not needed for import url when url is very long\n          // and node has two groups\n          // when type is value-comma_group\n          // example @import url(\"verylongurl\") projection,tv\n\n\n          if (insideURLFunctionInImportAtRuleNode$1(path)) {\n            return group$1(fill$2(_parts));\n          }\n\n          return group$1(indent$2(fill$2(_parts)));\n        }\n\n      case \"value-paren_group\":\n        {\n          var _parentNode5 = path.getParentNode();\n\n          if (_parentNode5 && isURLFunctionNode$1(_parentNode5) && (node.groups.length === 1 || node.groups.length > 0 && node.groups[0].type === \"value-comma_group\" && node.groups[0].groups.length > 0 && node.groups[0].groups[0].type === \"value-word\" && node.groups[0].groups[0].value.startsWith(\"data:\"))) {\n            return concat$5([node.open ? path.call(print, \"open\") : \"\", join$2(\",\", path.map(print, \"groups\")), node.close ? path.call(print, \"close\") : \"\"]);\n          }\n\n          if (!node.open) {\n            var _printed = path.map(print, \"groups\");\n\n            var res = [];\n\n            for (var _i = 0; _i < _printed.length; _i++) {\n              if (_i !== 0) {\n                res.push(concat$5([\",\", line$1]));\n              }\n\n              res.push(_printed[_i]);\n            }\n\n            return group$1(indent$2(fill$2(res)));\n          }\n\n          var isSCSSMapItem = isSCSSMapItemNode$1(path);\n          return group$1(concat$5([node.open ? path.call(print, \"open\") : \"\", indent$2(concat$5([softline$1, join$2(concat$5([\",\", line$1]), path.map(function (childPath) {\n            var node = childPath.getValue();\n            var printed = print(childPath); // Key/Value pair in open paren already indented\n\n            if (isKeyValuePairNode$1(node) && node.type === \"value-comma_group\" && node.groups && node.groups[2] && node.groups[2].type === \"value-paren_group\") {\n              printed.contents.contents.parts[1] = group$1(printed.contents.contents.parts[1]);\n              return group$1(dedent$1(printed));\n            }\n\n            return printed;\n          }, \"groups\"))])), ifBreak$1(isSCSS$1(options.parser, options.originalText) && isSCSSMapItem && shouldPrintComma(options) ? \",\" : \"\"), softline$1, node.close ? path.call(print, \"close\") : \"\"]), {\n            shouldBreak: isSCSSMapItem\n          });\n        }\n\n      case \"value-func\":\n        {\n          return concat$5([node.value, insideAtRuleNode$1(path, \"supports\") && isMediaAndSupportsKeywords$1(node) ? \" \" : \"\", path.call(print, \"group\")]);\n        }\n\n      case \"value-paren\":\n        {\n          return node.value;\n        }\n\n      case \"value-number\":\n        {\n          return concat$5([printCssNumber(node.value), maybeToLowerCase$1(node.unit)]);\n        }\n\n      case \"value-operator\":\n        {\n          return node.value;\n        }\n\n      case \"value-word\":\n        {\n          if (node.isColor && node.isHex || isWideKeywords$1(node.value)) {\n            return node.value.toLowerCase();\n          }\n\n          return node.value;\n        }\n\n      case \"value-colon\":\n        {\n          return concat$5([node.value, // Don't add spaces on `:` in `url` function (i.e. `url(fbglyph: cross-outline, fig-white)`)\n          insideValueFunctionNode$1(path, \"url\") ? \"\" : line$1]);\n        }\n\n      case \"value-comma\":\n        {\n          return concat$5([node.value, \" \"]);\n        }\n\n      case \"value-string\":\n        {\n          return printString$1(node.raws.quote + node.value + node.raws.quote, options);\n        }\n\n      case \"value-atword\":\n        {\n          return concat$5([\"@\", node.value]);\n        }\n\n      case \"value-unicode-range\":\n        {\n          return node.value;\n        }\n\n      case \"value-unknown\":\n        {\n          return node.value;\n        }\n\n      default:\n        /* istanbul ignore next */\n        throw new Error(\"Unknown postcss type \".concat(JSON.stringify(node.type)));\n    }\n  }\n\n  function printNodeSequence(path, options, print) {\n    var node = path.getValue();\n    var parts = [];\n    var i = 0;\n    path.map(function (pathChild) {\n      var prevNode = node.nodes[i - 1];\n\n      if (prevNode && prevNode.type === \"css-comment\" && prevNode.text.trim() === \"prettier-ignore\") {\n        var childNode = pathChild.getValue();\n        parts.push(options.originalText.slice(options.locStart(childNode), options.locEnd(childNode)));\n      } else {\n        parts.push(pathChild.call(print));\n      }\n\n      if (i !== node.nodes.length - 1) {\n        if (node.nodes[i + 1].type === \"css-comment\" && !hasNewline$2(options.originalText, options.locStart(node.nodes[i + 1]), {\n          backwards: true\n        }) && node.nodes[i].type !== \"yaml\" && node.nodes[i].type !== \"toml\" || node.nodes[i + 1].type === \"css-atrule\" && node.nodes[i + 1].name === \"else\" && node.nodes[i].type !== \"css-comment\") {\n          parts.push(\" \");\n        } else {\n          parts.push(hardline$4);\n\n          if (isNextLineEmpty$2(options.originalText, pathChild.getValue(), options) && node.nodes[i].type !== \"yaml\" && node.nodes[i].type !== \"toml\") {\n            parts.push(hardline$4);\n          }\n        }\n      }\n\n      i++;\n    }, \"nodes\");\n    return concat$5(parts);\n  }\n\n  var STRING_REGEX$1 = /(['\"])(?:(?!\\1)[^\\\\]|\\\\[\\s\\S])*\\1/g;\n  var NUMBER_REGEX = /(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?/g;\n  var STANDARD_UNIT_REGEX = /[a-zA-Z]+/g;\n  var WORD_PART_REGEX = /[$@]?[a-zA-Z_\\u0080-\\uFFFF][\\w\\-\\u0080-\\uFFFF]*/g;\n  var ADJUST_NUMBERS_REGEX = RegExp(STRING_REGEX$1.source + \"|\" + \"(\".concat(WORD_PART_REGEX.source, \")?\") + \"(\".concat(NUMBER_REGEX.source, \")\") + \"(\".concat(STANDARD_UNIT_REGEX.source, \")?\"), \"g\");\n\n  function adjustStrings(value, options) {\n    return value.replace(STRING_REGEX$1, function (match) {\n      return printString$1(match, options);\n    });\n  }\n\n  function quoteAttributeValue(value, options) {\n    var quote = options.singleQuote ? \"'\" : '\"';\n    return value.includes('\"') || value.includes(\"'\") ? value : quote + value + quote;\n  }\n\n  function adjustNumbers(value) {\n    return value.replace(ADJUST_NUMBERS_REGEX, function (match, quote, wordPart, number, unit) {\n      return !wordPart && number ? (wordPart || \"\") + printCssNumber(number) + maybeToLowerCase$1(unit || \"\") : match;\n    });\n  }\n\n  function printCssNumber(rawNumber) {\n    return printNumber$1(rawNumber) // Remove trailing `.0`.\n    .replace(/\\.0(?=$|e)/, \"\");\n  }\n\n  var printerPostcss = {\n    print: genericPrint,\n    embed: embed_1,\n    insertPragma: insertPragma$2,\n    hasPrettierIgnore: hasIgnoreComment$1,\n    massageAstNode: clean_1\n  };\n\n  var CATEGORY_COMMON = \"Common\"; // format based on https://github.com/prettier/prettier/blob/master/src/main/core-options.js\n\n  var commonOptions = {\n    bracketSpacing: {\n      since: \"0.0.0\",\n      category: CATEGORY_COMMON,\n      type: \"boolean\",\n      default: true,\n      description: \"Print spaces between brackets.\",\n      oppositeDescription: \"Do not print spaces between brackets.\"\n    },\n    singleQuote: {\n      since: \"0.0.0\",\n      category: CATEGORY_COMMON,\n      type: \"boolean\",\n      default: false,\n      description: \"Use single quotes instead of double quotes.\"\n    },\n    proseWrap: {\n      since: \"1.8.2\",\n      category: CATEGORY_COMMON,\n      type: \"choice\",\n      default: [{\n        since: \"1.8.2\",\n        value: true\n      }, {\n        since: \"1.9.0\",\n        value: \"preserve\"\n      }],\n      description: \"How to wrap prose.\",\n      choices: [{\n        since: \"1.9.0\",\n        value: \"always\",\n        description: \"Wrap prose if it exceeds the print width.\"\n      }, {\n        since: \"1.9.0\",\n        value: \"never\",\n        description: \"Do not wrap prose.\"\n      }, {\n        since: \"1.9.0\",\n        value: \"preserve\",\n        description: \"Wrap prose as-is.\"\n      }, {\n        value: false,\n        deprecated: \"1.9.0\",\n        redirect: \"never\"\n      }, {\n        value: true,\n        deprecated: \"1.9.0\",\n        redirect: \"always\"\n      }]\n    }\n  };\n\n  var options$2 = {\n    singleQuote: commonOptions.singleQuote\n  };\n\n  var createLanguage = function createLanguage(linguistData, transform) {\n    var language = {};\n\n    for (var key in linguistData) {\n      var newKey = key === \"languageId\" ? \"linguistLanguageId\" : key;\n      language[newKey] = linguistData[key];\n    }\n\n    return transform(language);\n  };\n\n  var name$1 = \"CSS\";\n  var type = \"markup\";\n  var tmScope = \"source.css\";\n  var aceMode = \"css\";\n  var codemirrorMode = \"css\";\n  var codemirrorMimeType = \"text/css\";\n  var color = \"#563d7c\";\n  var extensions = [\n  \t\".css\"\n  ];\n  var languageId = 50;\n  var CSS = {\n  \tname: name$1,\n  \ttype: type,\n  \ttmScope: tmScope,\n  \taceMode: aceMode,\n  \tcodemirrorMode: codemirrorMode,\n  \tcodemirrorMimeType: codemirrorMimeType,\n  \tcolor: color,\n  \textensions: extensions,\n  \tlanguageId: languageId\n  };\n\n  var CSS$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    name: name$1,\n    type: type,\n    tmScope: tmScope,\n    aceMode: aceMode,\n    codemirrorMode: codemirrorMode,\n    codemirrorMimeType: codemirrorMimeType,\n    color: color,\n    extensions: extensions,\n    languageId: languageId,\n    'default': CSS\n  });\n\n  var name$2 = \"PostCSS\";\n  var type$1 = \"markup\";\n  var tmScope$1 = \"source.postcss\";\n  var group$2 = \"CSS\";\n  var extensions$1 = [\n  \t\".pcss\"\n  ];\n  var aceMode$1 = \"text\";\n  var languageId$1 = 262764437;\n  var PostCSS = {\n  \tname: name$2,\n  \ttype: type$1,\n  \ttmScope: tmScope$1,\n  \tgroup: group$2,\n  \textensions: extensions$1,\n  \taceMode: aceMode$1,\n  \tlanguageId: languageId$1\n  };\n\n  var PostCSS$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    name: name$2,\n    type: type$1,\n    tmScope: tmScope$1,\n    group: group$2,\n    extensions: extensions$1,\n    aceMode: aceMode$1,\n    languageId: languageId$1,\n    'default': PostCSS\n  });\n\n  var name$3 = \"Less\";\n  var type$2 = \"markup\";\n  var group$3 = \"CSS\";\n  var extensions$2 = [\n  \t\".less\"\n  ];\n  var tmScope$2 = \"source.css.less\";\n  var aceMode$2 = \"less\";\n  var codemirrorMode$1 = \"css\";\n  var codemirrorMimeType$1 = \"text/css\";\n  var languageId$2 = 198;\n  var Less = {\n  \tname: name$3,\n  \ttype: type$2,\n  \tgroup: group$3,\n  \textensions: extensions$2,\n  \ttmScope: tmScope$2,\n  \taceMode: aceMode$2,\n  \tcodemirrorMode: codemirrorMode$1,\n  \tcodemirrorMimeType: codemirrorMimeType$1,\n  \tlanguageId: languageId$2\n  };\n\n  var Less$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    name: name$3,\n    type: type$2,\n    group: group$3,\n    extensions: extensions$2,\n    tmScope: tmScope$2,\n    aceMode: aceMode$2,\n    codemirrorMode: codemirrorMode$1,\n    codemirrorMimeType: codemirrorMimeType$1,\n    languageId: languageId$2,\n    'default': Less\n  });\n\n  var name$4 = \"SCSS\";\n  var type$3 = \"markup\";\n  var tmScope$3 = \"source.css.scss\";\n  var group$4 = \"CSS\";\n  var aceMode$3 = \"scss\";\n  var codemirrorMode$2 = \"css\";\n  var codemirrorMimeType$2 = \"text/x-scss\";\n  var extensions$3 = [\n  \t\".scss\"\n  ];\n  var languageId$3 = 329;\n  var SCSS = {\n  \tname: name$4,\n  \ttype: type$3,\n  \ttmScope: tmScope$3,\n  \tgroup: group$4,\n  \taceMode: aceMode$3,\n  \tcodemirrorMode: codemirrorMode$2,\n  \tcodemirrorMimeType: codemirrorMimeType$2,\n  \textensions: extensions$3,\n  \tlanguageId: languageId$3\n  };\n\n  var SCSS$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    name: name$4,\n    type: type$3,\n    tmScope: tmScope$3,\n    group: group$4,\n    aceMode: aceMode$3,\n    codemirrorMode: codemirrorMode$2,\n    codemirrorMimeType: codemirrorMimeType$2,\n    extensions: extensions$3,\n    languageId: languageId$3,\n    'default': SCSS\n  });\n\n  var require$$0$2 = getCjsExportFromNamespace(CSS$1);\n\n  var require$$1 = getCjsExportFromNamespace(PostCSS$1);\n\n  var require$$2 = getCjsExportFromNamespace(Less$1);\n\n  var require$$3 = getCjsExportFromNamespace(SCSS$1);\n\n  var languages = [createLanguage(require$$0$2, function (data) {\n    return Object.assign(data, {\n      since: \"1.4.0\",\n      parsers: [\"css\"],\n      vscodeLanguageIds: [\"css\"]\n    });\n  }), createLanguage(require$$1, function (data) {\n    return Object.assign(data, {\n      since: \"1.4.0\",\n      parsers: [\"css\"],\n      vscodeLanguageIds: [\"postcss\"],\n      extensions: data.extensions.concat(\".postcss\")\n    });\n  }), createLanguage(require$$2, function (data) {\n    return Object.assign(data, {\n      since: \"1.4.0\",\n      parsers: [\"less\"],\n      vscodeLanguageIds: [\"less\"]\n    });\n  }), createLanguage(require$$3, function (data) {\n    return Object.assign(data, {\n      since: \"1.4.0\",\n      parsers: [\"scss\"],\n      vscodeLanguageIds: [\"scss\"]\n    });\n  })];\n  var printers = {\n    postcss: printerPostcss\n  };\n  var languageCss = {\n    languages: languages,\n    options: options$2,\n    printers: printers\n  };\n\n  function hasPragma$2(text) {\n    return /^\\s*#[^\\n\\S]*@(format|prettier)\\s*(\\n|$)/.test(text);\n  }\n\n  function insertPragma$3(text) {\n    return \"# @format\\n\\n\" + text;\n  }\n\n  var pragma$2 = {\n    hasPragma: hasPragma$2,\n    insertPragma: insertPragma$3\n  };\n\n  var _require$$0$builders$2 = doc.builders,\n      concat$6 = _require$$0$builders$2.concat,\n      join$3 = _require$$0$builders$2.join,\n      hardline$5 = _require$$0$builders$2.hardline,\n      line$2 = _require$$0$builders$2.line,\n      softline$2 = _require$$0$builders$2.softline,\n      group$5 = _require$$0$builders$2.group,\n      indent$3 = _require$$0$builders$2.indent,\n      ifBreak$2 = _require$$0$builders$2.ifBreak;\n  var hasIgnoreComment$2 = util.hasIgnoreComment;\n  var isNextLineEmpty$3 = utilShared.isNextLineEmpty;\n  var insertPragma$4 = pragma$2.insertPragma;\n\n  function genericPrint$1(path, options, print) {\n    var n = path.getValue();\n\n    if (!n) {\n      return \"\";\n    }\n\n    if (typeof n === \"string\") {\n      return n;\n    }\n\n    switch (n.kind) {\n      case \"Document\":\n        {\n          var parts = [];\n          path.map(function (pathChild, index) {\n            parts.push(concat$6([pathChild.call(print)]));\n\n            if (index !== n.definitions.length - 1) {\n              parts.push(hardline$5);\n\n              if (isNextLineEmpty$3(options.originalText, pathChild.getValue(), options)) {\n                parts.push(hardline$5);\n              }\n            }\n          }, \"definitions\");\n          return concat$6([concat$6(parts), hardline$5]);\n        }\n\n      case \"OperationDefinition\":\n        {\n          var hasOperation = options.originalText[options.locStart(n)] !== \"{\";\n          var hasName = !!n.name;\n          return concat$6([hasOperation ? n.operation : \"\", hasOperation && hasName ? concat$6([\" \", path.call(print, \"name\")]) : \"\", n.variableDefinitions && n.variableDefinitions.length ? group$5(concat$6([\"(\", indent$3(concat$6([softline$2, join$3(concat$6([ifBreak$2(\"\", \", \"), softline$2]), path.map(print, \"variableDefinitions\"))])), softline$2, \")\"])) : \"\", printDirectives(path, print, n), n.selectionSet ? !hasOperation && !hasName ? \"\" : \" \" : \"\", path.call(print, \"selectionSet\")]);\n        }\n\n      case \"FragmentDefinition\":\n        {\n          return concat$6([\"fragment \", path.call(print, \"name\"), n.variableDefinitions && n.variableDefinitions.length ? group$5(concat$6([\"(\", indent$3(concat$6([softline$2, join$3(concat$6([ifBreak$2(\"\", \", \"), softline$2]), path.map(print, \"variableDefinitions\"))])), softline$2, \")\"])) : \"\", \" on \", path.call(print, \"typeCondition\"), printDirectives(path, print, n), \" \", path.call(print, \"selectionSet\")]);\n        }\n\n      case \"SelectionSet\":\n        {\n          return concat$6([\"{\", indent$3(concat$6([hardline$5, join$3(hardline$5, path.call(function (selectionsPath) {\n            return printSequence(selectionsPath, options, print);\n          }, \"selections\"))])), hardline$5, \"}\"]);\n        }\n\n      case \"Field\":\n        {\n          return group$5(concat$6([n.alias ? concat$6([path.call(print, \"alias\"), \": \"]) : \"\", path.call(print, \"name\"), n.arguments.length > 0 ? group$5(concat$6([\"(\", indent$3(concat$6([softline$2, join$3(concat$6([ifBreak$2(\"\", \", \"), softline$2]), path.call(function (argsPath) {\n            return printSequence(argsPath, options, print);\n          }, \"arguments\"))])), softline$2, \")\"])) : \"\", printDirectives(path, print, n), n.selectionSet ? \" \" : \"\", path.call(print, \"selectionSet\")]));\n        }\n\n      case \"Name\":\n        {\n          return n.value;\n        }\n\n      case \"StringValue\":\n        {\n          if (n.block) {\n            return concat$6(['\"\"\"', hardline$5, join$3(hardline$5, n.value.replace(/\"\"\"/g, \"\\\\$&\").split(\"\\n\")), hardline$5, '\"\"\"']);\n          }\n\n          return concat$6(['\"', n.value.replace(/[\"\\\\]/g, \"\\\\$&\").replace(/\\n/g, \"\\\\n\"), '\"']);\n        }\n\n      case \"IntValue\":\n      case \"FloatValue\":\n      case \"EnumValue\":\n        {\n          return n.value;\n        }\n\n      case \"BooleanValue\":\n        {\n          return n.value ? \"true\" : \"false\";\n        }\n\n      case \"NullValue\":\n        {\n          return \"null\";\n        }\n\n      case \"Variable\":\n        {\n          return concat$6([\"$\", path.call(print, \"name\")]);\n        }\n\n      case \"ListValue\":\n        {\n          return group$5(concat$6([\"[\", indent$3(concat$6([softline$2, join$3(concat$6([ifBreak$2(\"\", \", \"), softline$2]), path.map(print, \"values\"))])), softline$2, \"]\"]));\n        }\n\n      case \"ObjectValue\":\n        {\n          return group$5(concat$6([\"{\", options.bracketSpacing && n.fields.length > 0 ? \" \" : \"\", indent$3(concat$6([softline$2, join$3(concat$6([ifBreak$2(\"\", \", \"), softline$2]), path.map(print, \"fields\"))])), softline$2, ifBreak$2(\"\", options.bracketSpacing && n.fields.length > 0 ? \" \" : \"\"), \"}\"]));\n        }\n\n      case \"ObjectField\":\n      case \"Argument\":\n        {\n          return concat$6([path.call(print, \"name\"), \": \", path.call(print, \"value\")]);\n        }\n\n      case \"Directive\":\n        {\n          return concat$6([\"@\", path.call(print, \"name\"), n.arguments.length > 0 ? group$5(concat$6([\"(\", indent$3(concat$6([softline$2, join$3(concat$6([ifBreak$2(\"\", \", \"), softline$2]), path.call(function (argsPath) {\n            return printSequence(argsPath, options, print);\n          }, \"arguments\"))])), softline$2, \")\"])) : \"\"]);\n        }\n\n      case \"NamedType\":\n        {\n          return path.call(print, \"name\");\n        }\n\n      case \"VariableDefinition\":\n        {\n          return concat$6([path.call(print, \"variable\"), \": \", path.call(print, \"type\"), n.defaultValue ? concat$6([\" = \", path.call(print, \"defaultValue\")]) : \"\", printDirectives(path, print, n)]);\n        }\n\n      case \"TypeExtensionDefinition\":\n        {\n          return concat$6([\"extend \", path.call(print, \"definition\")]);\n        }\n\n      case \"ObjectTypeExtension\":\n      case \"ObjectTypeDefinition\":\n        {\n          return concat$6([path.call(print, \"description\"), n.description ? hardline$5 : \"\", n.kind === \"ObjectTypeExtension\" ? \"extend \" : \"\", \"type \", path.call(print, \"name\"), n.interfaces.length > 0 ? concat$6([\" implements \", join$3(determineInterfaceSeparator(options.originalText.substr(options.locStart(n), options.locEnd(n))), path.map(print, \"interfaces\"))]) : \"\", printDirectives(path, print, n), n.fields.length > 0 ? concat$6([\" {\", indent$3(concat$6([hardline$5, join$3(hardline$5, path.call(function (fieldsPath) {\n            return printSequence(fieldsPath, options, print);\n          }, \"fields\"))])), hardline$5, \"}\"]) : \"\"]);\n        }\n\n      case \"FieldDefinition\":\n        {\n          return concat$6([path.call(print, \"description\"), n.description ? hardline$5 : \"\", path.call(print, \"name\"), n.arguments.length > 0 ? group$5(concat$6([\"(\", indent$3(concat$6([softline$2, join$3(concat$6([ifBreak$2(\"\", \", \"), softline$2]), path.call(function (argsPath) {\n            return printSequence(argsPath, options, print);\n          }, \"arguments\"))])), softline$2, \")\"])) : \"\", \": \", path.call(print, \"type\"), printDirectives(path, print, n)]);\n        }\n\n      case \"DirectiveDefinition\":\n        {\n          return concat$6([path.call(print, \"description\"), n.description ? hardline$5 : \"\", \"directive \", \"@\", path.call(print, \"name\"), n.arguments.length > 0 ? group$5(concat$6([\"(\", indent$3(concat$6([softline$2, join$3(concat$6([ifBreak$2(\"\", \", \"), softline$2]), path.call(function (argsPath) {\n            return printSequence(argsPath, options, print);\n          }, \"arguments\"))])), softline$2, \")\"])) : \"\", concat$6([\" on \", join$3(\" | \", path.map(print, \"locations\"))])]);\n        }\n\n      case \"EnumTypeExtension\":\n      case \"EnumTypeDefinition\":\n        {\n          return concat$6([path.call(print, \"description\"), n.description ? hardline$5 : \"\", n.kind === \"EnumTypeExtension\" ? \"extend \" : \"\", \"enum \", path.call(print, \"name\"), printDirectives(path, print, n), n.values.length > 0 ? concat$6([\" {\", indent$3(concat$6([hardline$5, join$3(hardline$5, path.call(function (valuesPath) {\n            return printSequence(valuesPath, options, print);\n          }, \"values\"))])), hardline$5, \"}\"]) : \"\"]);\n        }\n\n      case \"EnumValueDefinition\":\n        {\n          return concat$6([path.call(print, \"description\"), n.description ? hardline$5 : \"\", path.call(print, \"name\"), printDirectives(path, print, n)]);\n        }\n\n      case \"InputValueDefinition\":\n        {\n          return concat$6([path.call(print, \"description\"), n.description ? n.description.block ? hardline$5 : line$2 : \"\", path.call(print, \"name\"), \": \", path.call(print, \"type\"), n.defaultValue ? concat$6([\" = \", path.call(print, \"defaultValue\")]) : \"\", printDirectives(path, print, n)]);\n        }\n\n      case \"InputObjectTypeExtension\":\n      case \"InputObjectTypeDefinition\":\n        {\n          return concat$6([path.call(print, \"description\"), n.description ? hardline$5 : \"\", n.kind === \"InputObjectTypeExtension\" ? \"extend \" : \"\", \"input \", path.call(print, \"name\"), printDirectives(path, print, n), n.fields.length > 0 ? concat$6([\" {\", indent$3(concat$6([hardline$5, join$3(hardline$5, path.call(function (fieldsPath) {\n            return printSequence(fieldsPath, options, print);\n          }, \"fields\"))])), hardline$5, \"}\"]) : \"\"]);\n        }\n\n      case \"SchemaDefinition\":\n        {\n          return concat$6([\"schema\", printDirectives(path, print, n), \" {\", n.operationTypes.length > 0 ? indent$3(concat$6([hardline$5, join$3(hardline$5, path.call(function (opsPath) {\n            return printSequence(opsPath, options, print);\n          }, \"operationTypes\"))])) : \"\", hardline$5, \"}\"]);\n        }\n\n      case \"OperationTypeDefinition\":\n        {\n          return concat$6([path.call(print, \"operation\"), \": \", path.call(print, \"type\")]);\n        }\n\n      case \"InterfaceTypeExtension\":\n      case \"InterfaceTypeDefinition\":\n        {\n          return concat$6([path.call(print, \"description\"), n.description ? hardline$5 : \"\", n.kind === \"InterfaceTypeExtension\" ? \"extend \" : \"\", \"interface \", path.call(print, \"name\"), printDirectives(path, print, n), n.fields.length > 0 ? concat$6([\" {\", indent$3(concat$6([hardline$5, join$3(hardline$5, path.call(function (fieldsPath) {\n            return printSequence(fieldsPath, options, print);\n          }, \"fields\"))])), hardline$5, \"}\"]) : \"\"]);\n        }\n\n      case \"FragmentSpread\":\n        {\n          return concat$6([\"...\", path.call(print, \"name\"), printDirectives(path, print, n)]);\n        }\n\n      case \"InlineFragment\":\n        {\n          return concat$6([\"...\", n.typeCondition ? concat$6([\" on \", path.call(print, \"typeCondition\")]) : \"\", printDirectives(path, print, n), \" \", path.call(print, \"selectionSet\")]);\n        }\n\n      case \"UnionTypeExtension\":\n      case \"UnionTypeDefinition\":\n        {\n          return group$5(concat$6([path.call(print, \"description\"), n.description ? hardline$5 : \"\", group$5(concat$6([n.kind === \"UnionTypeExtension\" ? \"extend \" : \"\", \"union \", path.call(print, \"name\"), printDirectives(path, print, n), n.types.length > 0 ? concat$6([\" =\", ifBreak$2(\"\", \" \"), indent$3(concat$6([ifBreak$2(concat$6([line$2, \"  \"])), join$3(concat$6([line$2, \"| \"]), path.map(print, \"types\"))]))]) : \"\"]))]));\n        }\n\n      case \"ScalarTypeExtension\":\n      case \"ScalarTypeDefinition\":\n        {\n          return concat$6([path.call(print, \"description\"), n.description ? hardline$5 : \"\", n.kind === \"ScalarTypeExtension\" ? \"extend \" : \"\", \"scalar \", path.call(print, \"name\"), printDirectives(path, print, n)]);\n        }\n\n      case \"NonNullType\":\n        {\n          return concat$6([path.call(print, \"type\"), \"!\"]);\n        }\n\n      case \"ListType\":\n        {\n          return concat$6([\"[\", path.call(print, \"type\"), \"]\"]);\n        }\n\n      default:\n        /* istanbul ignore next */\n        throw new Error(\"unknown graphql type: \" + JSON.stringify(n.kind));\n    }\n  }\n\n  function printDirectives(path, print, n) {\n    if (n.directives.length === 0) {\n      return \"\";\n    }\n\n    return concat$6([\" \", group$5(indent$3(concat$6([softline$2, join$3(concat$6([ifBreak$2(\"\", \" \"), softline$2]), path.map(print, \"directives\"))])))]);\n  }\n\n  function printSequence(sequencePath, options, print) {\n    var count = sequencePath.getValue().length;\n    return sequencePath.map(function (path, i) {\n      var printed = print(path);\n\n      if (isNextLineEmpty$3(options.originalText, path.getValue(), options) && i < count - 1) {\n        return concat$6([printed, hardline$5]);\n      }\n\n      return printed;\n    });\n  }\n\n  function canAttachComment(node) {\n    return node.kind && node.kind !== \"Comment\";\n  }\n\n  function printComment$1(commentPath) {\n    var comment = commentPath.getValue();\n\n    if (comment.kind === \"Comment\") {\n      return \"#\" + comment.value.trimRight();\n    }\n\n    throw new Error(\"Not a comment: \" + JSON.stringify(comment));\n  }\n\n  function determineInterfaceSeparator(originalSource) {\n    var start = originalSource.indexOf(\"implements\");\n\n    if (start === -1) {\n      throw new Error(\"Must implement interfaces: \" + originalSource);\n    }\n\n    var end = originalSource.indexOf(\"{\");\n\n    if (end === -1) {\n      end = originalSource.length;\n    }\n\n    return originalSource.substr(start, end).includes(\"&\") ? \" & \" : \", \";\n  }\n\n  function clean$1(node, newNode\n  /*, parent*/\n  ) {\n    delete newNode.loc;\n    delete newNode.comments;\n  }\n\n  var printerGraphql = {\n    print: genericPrint$1,\n    massageAstNode: clean$1,\n    hasPrettierIgnore: hasIgnoreComment$2,\n    insertPragma: insertPragma$4,\n    printComment: printComment$1,\n    canAttachComment: canAttachComment\n  };\n\n  var options$3 = {\n    bracketSpacing: commonOptions.bracketSpacing\n  };\n\n  var name$5 = \"GraphQL\";\n  var type$4 = \"data\";\n  var extensions$4 = [\n  \t\".graphql\",\n  \t\".gql\",\n  \t\".graphqls\"\n  ];\n  var tmScope$4 = \"source.graphql\";\n  var aceMode$4 = \"text\";\n  var languageId$4 = 139;\n  var GraphQL = {\n  \tname: name$5,\n  \ttype: type$4,\n  \textensions: extensions$4,\n  \ttmScope: tmScope$4,\n  \taceMode: aceMode$4,\n  \tlanguageId: languageId$4\n  };\n\n  var GraphQL$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    name: name$5,\n    type: type$4,\n    extensions: extensions$4,\n    tmScope: tmScope$4,\n    aceMode: aceMode$4,\n    languageId: languageId$4,\n    'default': GraphQL\n  });\n\n  var require$$0$3 = getCjsExportFromNamespace(GraphQL$1);\n\n  var languages$1 = [createLanguage(require$$0$3, function (data) {\n    return Object.assign(data, {\n      since: \"1.5.0\",\n      parsers: [\"graphql\"],\n      vscodeLanguageIds: [\"graphql\"]\n    });\n  })];\n  var printers$1 = {\n    graphql: printerGraphql\n  };\n  var languageGraphql = {\n    languages: languages$1,\n    options: options$3,\n    printers: printers$1\n  };\n\n  var _require$$0$builders$3 = doc.builders,\n      concat$7 = _require$$0$builders$3.concat,\n      join$4 = _require$$0$builders$3.join,\n      softline$3 = _require$$0$builders$3.softline,\n      hardline$6 = _require$$0$builders$3.hardline,\n      line$3 = _require$$0$builders$3.line,\n      group$6 = _require$$0$builders$3.group,\n      indent$4 = _require$$0$builders$3.indent,\n      ifBreak$3 = _require$$0$builders$3.ifBreak; // http://w3c.github.io/html/single-page.html#void-elements\n\n  var voidTags = [\"area\", \"base\", \"br\", \"col\", \"embed\", \"hr\", \"img\", \"input\", \"link\", \"meta\", \"param\", \"source\", \"track\", \"wbr\"]; // Formatter based on @glimmerjs/syntax's built-in test formatter:\n  // https://github.com/glimmerjs/glimmer-vm/blob/master/packages/%40glimmer/syntax/lib/generation/print.ts\n\n  function printChildren(path, options, print) {\n    return concat$7(path.map(function (childPath, childIndex) {\n      var childNode = path.getValue();\n      var isFirstNode = childIndex === 0;\n      var isLastNode = childIndex == path.getParentNode(0).children.length - 1;\n      var isLastNodeInMultiNodeList = isLastNode && !isFirstNode;\n      var isWhitespace = isWhitespaceNode(childNode);\n\n      if (isWhitespace && isLastNodeInMultiNodeList) {\n        return print(childPath, options, print);\n      } else if (isFirstNode) {\n        return concat$7([softline$3, print(childPath, options, print)]);\n      }\n\n      return print(childPath, options, print);\n    }, \"children\"));\n  }\n\n  function print(path, options, print) {\n    var n = path.getValue();\n    /* istanbul ignore if*/\n\n    if (!n) {\n      return \"\";\n    }\n\n    switch (n.type) {\n      case \"Block\":\n      case \"Program\":\n      case \"Template\":\n        {\n          return group$6(concat$7(path.map(print, \"body\").filter(function (text) {\n            return text !== \"\";\n          })));\n        }\n\n      case \"ElementNode\":\n        {\n          var tagFirstChar = n.tag[0];\n          var isLocal = n.tag.indexOf(\".\") !== -1;\n          var isGlimmerComponent = tagFirstChar.toUpperCase() === tagFirstChar || isLocal;\n          var hasChildren = n.children.length > 0;\n          var hasNonWhitespaceChildren = n.children.some(function (n) {\n            return !isWhitespaceNode(n);\n          });\n          var isVoid = isGlimmerComponent && (!hasChildren || !hasNonWhitespaceChildren) || voidTags.indexOf(n.tag) !== -1;\n          var closeTagForNoBreak = isVoid ? concat$7([\" />\", softline$3]) : \">\";\n          var closeTagForBreak = isVoid ? \"/>\" : \">\";\n\n          var _getParams = function _getParams(path, print) {\n            return indent$4(concat$7([n.attributes.length ? line$3 : \"\", join$4(line$3, path.map(print, \"attributes\")), n.modifiers.length ? line$3 : \"\", join$4(line$3, path.map(print, \"modifiers\")), n.comments.length ? line$3 : \"\", join$4(line$3, path.map(print, \"comments\"))]));\n          };\n\n          var nextNode = getNextNode(path);\n          return concat$7([group$6(concat$7([\"<\", n.tag, _getParams(path, print), n.blockParams.length ? \" as |\".concat(n.blockParams.join(\" \"), \"|\") : \"\", ifBreak$3(softline$3, \"\"), ifBreak$3(closeTagForBreak, closeTagForNoBreak)])), !isVoid ? group$6(concat$7([hasNonWhitespaceChildren ? indent$4(printChildren(path, options, print)) : \"\", ifBreak$3(hasChildren ? hardline$6 : \"\", \"\"), concat$7([\"</\", n.tag, \">\"])])) : \"\", nextNode && nextNode.type === \"ElementNode\" ? hardline$6 : \"\"]);\n        }\n\n      case \"BlockStatement\":\n        {\n          var pp = path.getParentNode(1);\n          var isElseIf = pp && pp.inverse && pp.inverse.body.length === 1 && pp.inverse.body[0] === n && pp.inverse.body[0].path.parts[0] === \"if\";\n          var hasElseIf = n.inverse && n.inverse.body.length === 1 && n.inverse.body[0].type === \"BlockStatement\" && n.inverse.body[0].path.parts[0] === \"if\";\n          var indentElse = hasElseIf ? function (a) {\n            return a;\n          } : indent$4;\n\n          if (n.inverse) {\n            return concat$7([isElseIf ? concat$7([\"{{else \", printPathParams(path, print), \"}}\"]) : printOpenBlock(path, print), indent$4(concat$7([hardline$6, path.call(print, \"program\")])), n.inverse && !hasElseIf ? concat$7([hardline$6, \"{{else}}\"]) : \"\", n.inverse ? indentElse(concat$7([hardline$6, path.call(print, \"inverse\")])) : \"\", isElseIf ? \"\" : concat$7([hardline$6, printCloseBlock(path, print)])]);\n          } else if (isElseIf) {\n            return concat$7([concat$7([\"{{else \", printPathParams(path, print), \"}}\"]), indent$4(concat$7([hardline$6, path.call(print, \"program\")]))]);\n          }\n\n          var _hasNonWhitespaceChildren = n.program.body.some(function (n) {\n            return !isWhitespaceNode(n);\n          });\n\n          return concat$7([printOpenBlock(path, print), group$6(concat$7([indent$4(concat$7([softline$3, path.call(print, \"program\")])), _hasNonWhitespaceChildren ? hardline$6 : softline$3, printCloseBlock(path, print)]))]);\n        }\n\n      case \"ElementModifierStatement\":\n      case \"MustacheStatement\":\n        {\n          var _pp = path.getParentNode(1);\n\n          var isConcat = _pp && _pp.type === \"ConcatStatement\";\n          return group$6(concat$7([n.escaped === false ? \"{{{\" : \"{{\", printPathParams(path, print, {\n            group: false\n          }), isConcat ? \"\" : softline$3, n.escaped === false ? \"}}}\" : \"}}\"]));\n        }\n\n      case \"SubExpression\":\n        {\n          var params = getParams(path, print);\n          var printedParams = params.length > 0 ? indent$4(concat$7([line$3, group$6(join$4(line$3, params))])) : \"\";\n          return group$6(concat$7([\"(\", printPath(path, print), printedParams, softline$3, \")\"]));\n        }\n\n      case \"AttrNode\":\n        {\n          var isText = n.value.type === \"TextNode\";\n\n          if (isText && n.value.loc.start.column === n.value.loc.end.column) {\n            return concat$7([n.name]);\n          }\n\n          var value = path.call(print, \"value\");\n          var quotedValue = isText ? printStringLiteral(value.parts.join(), options) : value;\n          return concat$7([n.name, \"=\", quotedValue]);\n        }\n\n      case \"ConcatStatement\":\n        {\n          return concat$7(['\"', group$6(indent$4(join$4(softline$3, path.map(function (partPath) {\n            return print(partPath);\n          }, \"parts\").filter(function (a) {\n            return a !== \"\";\n          })))), '\"']);\n        }\n\n      case \"Hash\":\n        {\n          return concat$7([join$4(line$3, path.map(print, \"pairs\"))]);\n        }\n\n      case \"HashPair\":\n        {\n          return concat$7([n.key, \"=\", path.call(print, \"value\")]);\n        }\n\n      case \"TextNode\":\n        {\n          var maxLineBreaksToPreserve = 2;\n          var isFirstElement = !getPreviousNode(path);\n          var isLastElement = !getNextNode(path);\n          var isWhitespaceOnly = !/\\S/.test(n.chars);\n          var lineBreaksCount = countNewLines(n.chars);\n          var hasBlockParent = path.getParentNode(0).type === \"Block\";\n          var hasElementParent = path.getParentNode(0).type === \"ElementNode\";\n          var hasTemplateParent = path.getParentNode(0).type === \"Template\";\n          var leadingLineBreaksCount = countLeadingNewLines(n.chars);\n          var trailingLineBreaksCount = countTrailingNewLines(n.chars);\n\n          if ((isFirstElement || isLastElement) && isWhitespaceOnly && (hasBlockParent || hasElementParent || hasTemplateParent)) {\n            return \"\";\n          }\n\n          if (isWhitespaceOnly && lineBreaksCount) {\n            leadingLineBreaksCount = Math.min(lineBreaksCount, maxLineBreaksToPreserve);\n            trailingLineBreaksCount = 0;\n          } else {\n            if (isNextNodeOfType(path, \"ElementNode\") || isNextNodeOfType(path, \"BlockStatement\")) {\n              trailingLineBreaksCount = Math.max(trailingLineBreaksCount, 1);\n            }\n\n            if (isPreviousNodeOfSomeType(path, [\"ElementNode\"]) || isPreviousNodeOfSomeType(path, [\"BlockStatement\"])) {\n              leadingLineBreaksCount = Math.max(leadingLineBreaksCount, 1);\n            }\n          }\n\n          var leadingSpace = \"\";\n          var trailingSpace = \"\"; // preserve a space inside of an attribute node where whitespace present,\n          // when next to mustache statement.\n\n          var inAttrNode = path.stack.indexOf(\"attributes\") >= 0;\n\n          if (inAttrNode) {\n            var parentNode = path.getParentNode(0);\n\n            var _isConcat = parentNode.type === \"ConcatStatement\";\n\n            if (_isConcat) {\n              var parts = parentNode.parts;\n              var partIndex = parts.indexOf(n);\n\n              if (partIndex > 0) {\n                var partType = parts[partIndex - 1].type;\n                var isMustache = partType === \"MustacheStatement\";\n\n                if (isMustache) {\n                  leadingSpace = \" \";\n                }\n              }\n\n              if (partIndex < parts.length - 1) {\n                var _partType = parts[partIndex + 1].type;\n\n                var _isMustache = _partType === \"MustacheStatement\";\n\n                if (_isMustache) {\n                  trailingSpace = \" \";\n                }\n              }\n            }\n          } else {\n            if (trailingLineBreaksCount === 0 && isNextNodeOfType(path, \"MustacheStatement\")) {\n              trailingSpace = \" \";\n            }\n\n            if (leadingLineBreaksCount === 0 && isPreviousNodeOfSomeType(path, [\"MustacheStatement\"])) {\n              leadingSpace = \" \";\n            }\n\n            if (isFirstElement) {\n              leadingLineBreaksCount = 0;\n              leadingSpace = \"\";\n            }\n\n            if (isLastElement) {\n              trailingLineBreaksCount = 0;\n              trailingSpace = \"\";\n            }\n          }\n\n          return concat$7([].concat(_toConsumableArray(generateHardlines(leadingLineBreaksCount, maxLineBreaksToPreserve)), [n.chars.replace(/^[\\s ]+/g, leadingSpace).replace(/[\\s ]+$/, trailingSpace)], _toConsumableArray(generateHardlines(trailingLineBreaksCount, maxLineBreaksToPreserve))).filter(Boolean));\n        }\n\n      case \"MustacheCommentStatement\":\n        {\n          var dashes = n.value.indexOf(\"}}\") > -1 ? \"--\" : \"\";\n          return concat$7([\"{{!\", dashes, n.value, dashes, \"}}\"]);\n        }\n\n      case \"PathExpression\":\n        {\n          return n.original;\n        }\n\n      case \"BooleanLiteral\":\n        {\n          return String(n.value);\n        }\n\n      case \"CommentStatement\":\n        {\n          return concat$7([\"<!--\", n.value, \"-->\"]);\n        }\n\n      case \"StringLiteral\":\n        {\n          return printStringLiteral(n.value, options);\n        }\n\n      case \"NumberLiteral\":\n        {\n          return String(n.value);\n        }\n\n      case \"UndefinedLiteral\":\n        {\n          return \"undefined\";\n        }\n\n      case \"NullLiteral\":\n        {\n          return \"null\";\n        }\n\n      /* istanbul ignore next */\n\n      default:\n        throw new Error(\"unknown glimmer type: \" + JSON.stringify(n.type));\n    }\n  }\n  /**\n   * Prints a string literal with the correct surrounding quotes based on\n   * `options.singleQuote` and the number of escaped quotes contained in\n   * the string literal. This function is the glimmer equivalent of `printString`\n   * in `common/util`, but has differences because of the way escaped characters\n   * are treated in hbs string literals.\n   * @param {string} stringLiteral - the string literal value\n   * @param {object} options - the prettier options object\n   */\n\n\n  function printStringLiteral(stringLiteral, options) {\n    var double = {\n      quote: '\"',\n      regex: /\"/g\n    };\n    var single = {\n      quote: \"'\",\n      regex: /'/g\n    };\n    var preferred = options.singleQuote ? single : double;\n    var alternate = preferred === single ? double : single;\n    var shouldUseAlternateQuote = false; // If `stringLiteral` contains at least one of the quote preferred for\n    // enclosing the string, we might want to enclose with the alternate quote\n    // instead, to minimize the number of escaped quotes.\n\n    if (stringLiteral.includes(preferred.quote) || stringLiteral.includes(alternate.quote)) {\n      var numPreferredQuotes = (stringLiteral.match(preferred.regex) || []).length;\n      var numAlternateQuotes = (stringLiteral.match(alternate.regex) || []).length;\n      shouldUseAlternateQuote = numPreferredQuotes > numAlternateQuotes;\n    }\n\n    var enclosingQuote = shouldUseAlternateQuote ? alternate : preferred;\n    var escapedStringLiteral = stringLiteral.replace(enclosingQuote.regex, \"\\\\\".concat(enclosingQuote.quote));\n    return \"\".concat(enclosingQuote.quote).concat(escapedStringLiteral).concat(enclosingQuote.quote);\n  }\n\n  function printPath(path, print) {\n    return path.call(print, \"path\");\n  }\n\n  function getParams(path, print) {\n    var node = path.getValue();\n    var parts = [];\n\n    if (node.params.length > 0) {\n      parts = parts.concat(path.map(print, \"params\"));\n    }\n\n    if (node.hash && node.hash.pairs.length > 0) {\n      parts.push(path.call(print, \"hash\"));\n    }\n\n    return parts;\n  }\n\n  function printPathParams(path, print, options) {\n    var parts = [];\n    options = Object.assign({\n      group: true\n    }, options || {});\n    parts.push(printPath(path, print));\n    parts = parts.concat(getParams(path, print));\n\n    if (!options.group) {\n      return indent$4(join$4(line$3, parts));\n    }\n\n    return indent$4(group$6(join$4(line$3, parts)));\n  }\n\n  function printBlockParams(path) {\n    var block = path.getValue();\n\n    if (!block.program || !block.program.blockParams.length) {\n      return \"\";\n    }\n\n    return concat$7([\" as |\", block.program.blockParams.join(\" \"), \"|\"]);\n  }\n\n  function printOpenBlock(path, print) {\n    return group$6(concat$7([\"{{#\", printPathParams(path, print), printBlockParams(path), softline$3, \"}}\"]));\n  }\n\n  function printCloseBlock(path, print) {\n    return concat$7([\"{{/\", path.call(print, \"path\"), \"}}\"]);\n  }\n\n  function isWhitespaceNode(node) {\n    return node.type === \"TextNode\" && !/\\S/.test(node.chars);\n  }\n\n  function getPreviousNode(path) {\n    var node = path.getValue();\n    var parentNode = path.getParentNode(0);\n    var children = parentNode.children || parentNode.body;\n\n    if (children) {\n      var nodeIndex = children.indexOf(node);\n\n      if (nodeIndex > 0) {\n        var previousNode = children[nodeIndex - 1];\n        return previousNode;\n      }\n    }\n  }\n\n  function getNextNode(path) {\n    var node = path.getValue();\n    var parentNode = path.getParentNode(0);\n    var children = parentNode.children || parentNode.body;\n\n    if (children) {\n      var nodeIndex = children.indexOf(node);\n\n      if (nodeIndex < children.length) {\n        var nextNode = children[nodeIndex + 1];\n        return nextNode;\n      }\n    }\n  }\n\n  function isPreviousNodeOfSomeType(path, types) {\n    var previousNode = getPreviousNode(path);\n\n    if (previousNode) {\n      return types.some(function (type) {\n        return previousNode.type === type;\n      });\n    }\n\n    return false;\n  }\n\n  function isNextNodeOfType(path, type) {\n    var nextNode = getNextNode(path);\n    return nextNode && nextNode.type === type;\n  }\n\n  function clean$2(ast, newObj) {\n    delete newObj.loc;\n    delete newObj.selfClosing; // (Glimmer/HTML) ignore TextNode whitespace\n\n    if (ast.type === \"TextNode\") {\n      if (ast.chars.replace(/\\s+/, \"\") === \"\") {\n        return null;\n      }\n\n      newObj.chars = ast.chars.replace(/^\\s+/, \"\").replace(/\\s+$/, \"\");\n    }\n  }\n\n  function countNewLines(string) {\n    /* istanbul ignore next */\n    string = typeof string === \"string\" ? string : \"\";\n    return string.split(\"\\n\").length - 1;\n  }\n\n  function countLeadingNewLines(string) {\n    /* istanbul ignore next */\n    string = typeof string === \"string\" ? string : \"\";\n    var newLines = (string.match(/^([^\\S\\r\\n]*[\\r\\n])+/g) || [])[0] || \"\";\n    return countNewLines(newLines);\n  }\n\n  function countTrailingNewLines(string) {\n    /* istanbul ignore next */\n    string = typeof string === \"string\" ? string : \"\";\n    var newLines = (string.match(/([\\r\\n][^\\S\\r\\n]*)+$/g) || [])[0] || \"\";\n    return countNewLines(newLines);\n  }\n\n  function generateHardlines() {\n    var number = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return new Array(Math.min(number, max)).fill(hardline$6);\n  }\n\n  var printerGlimmer = {\n    print: print,\n    massageAstNode: clean$2\n  };\n\n  var name$6 = \"Handlebars\";\n  var type$5 = \"markup\";\n  var group$7 = \"HTML\";\n  var aliases = [\n  \t\"hbs\",\n  \t\"htmlbars\"\n  ];\n  var extensions$5 = [\n  \t\".handlebars\",\n  \t\".hbs\"\n  ];\n  var tmScope$5 = \"text.html.handlebars\";\n  var aceMode$5 = \"handlebars\";\n  var languageId$5 = 155;\n  var Handlebars = {\n  \tname: name$6,\n  \ttype: type$5,\n  \tgroup: group$7,\n  \taliases: aliases,\n  \textensions: extensions$5,\n  \ttmScope: tmScope$5,\n  \taceMode: aceMode$5,\n  \tlanguageId: languageId$5\n  };\n\n  var Handlebars$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    name: name$6,\n    type: type$5,\n    group: group$7,\n    aliases: aliases,\n    extensions: extensions$5,\n    tmScope: tmScope$5,\n    aceMode: aceMode$5,\n    languageId: languageId$5,\n    'default': Handlebars\n  });\n\n  var require$$0$4 = getCjsExportFromNamespace(Handlebars$1);\n\n  var languages$2 = [createLanguage(require$$0$4, function (data) {\n    return Object.assign(data, {\n      since: null,\n      // unreleased\n      parsers: [\"glimmer\"],\n      vscodeLanguageIds: [\"handlebars\"]\n    });\n  })];\n  var printers$2 = {\n    glimmer: printerGlimmer\n  };\n  var languageHandlebars = {\n    languages: languages$2,\n    printers: printers$2\n  };\n\n  var clean$3 = function clean(ast, newNode) {\n    delete newNode.sourceSpan;\n    delete newNode.startSourceSpan;\n    delete newNode.endSourceSpan;\n    delete newNode.nameSpan;\n    delete newNode.valueSpan;\n\n    if (ast.type === \"text\" || ast.type === \"comment\") {\n      return null;\n    } // may be formatted by multiparser\n\n\n    if (ast.type === \"yaml\" || ast.type === \"toml\") {\n      return null;\n    }\n\n    if (ast.type === \"attribute\") {\n      delete newNode.value;\n    }\n\n    if (ast.type === \"docType\") {\n      delete newNode.value;\n    }\n  };\n\n  var json = {\n    \"CSS_DISPLAY_TAGS\": {\n      \"area\": \"none\",\n      \"base\": \"none\",\n      \"basefont\": \"none\",\n      \"datalist\": \"none\",\n      \"head\": \"none\",\n      \"link\": \"none\",\n      \"meta\": \"none\",\n      \"noembed\": \"none\",\n      \"noframes\": \"none\",\n      \"param\": \"none\",\n      \"rp\": \"none\",\n      \"script\": \"block\",\n      \"source\": \"block\",\n      \"style\": \"none\",\n      \"template\": \"inline\",\n      \"track\": \"block\",\n      \"title\": \"none\",\n      \"html\": \"block\",\n      \"body\": \"block\",\n      \"address\": \"block\",\n      \"blockquote\": \"block\",\n      \"center\": \"block\",\n      \"div\": \"block\",\n      \"figure\": \"block\",\n      \"figcaption\": \"block\",\n      \"footer\": \"block\",\n      \"form\": \"block\",\n      \"header\": \"block\",\n      \"hr\": \"block\",\n      \"legend\": \"block\",\n      \"listing\": \"block\",\n      \"main\": \"block\",\n      \"p\": \"block\",\n      \"plaintext\": \"block\",\n      \"pre\": \"block\",\n      \"xmp\": \"block\",\n      \"slot\": \"contents\",\n      \"ruby\": \"ruby\",\n      \"rt\": \"ruby-text\",\n      \"article\": \"block\",\n      \"aside\": \"block\",\n      \"h1\": \"block\",\n      \"h2\": \"block\",\n      \"h3\": \"block\",\n      \"h4\": \"block\",\n      \"h5\": \"block\",\n      \"h6\": \"block\",\n      \"hgroup\": \"block\",\n      \"nav\": \"block\",\n      \"section\": \"block\",\n      \"dir\": \"block\",\n      \"dd\": \"block\",\n      \"dl\": \"block\",\n      \"dt\": \"block\",\n      \"ol\": \"block\",\n      \"ul\": \"block\",\n      \"li\": \"list-item\",\n      \"table\": \"table\",\n      \"caption\": \"table-caption\",\n      \"colgroup\": \"table-column-group\",\n      \"col\": \"table-column\",\n      \"thead\": \"table-header-group\",\n      \"tbody\": \"table-row-group\",\n      \"tfoot\": \"table-footer-group\",\n      \"tr\": \"table-row\",\n      \"td\": \"table-cell\",\n      \"th\": \"table-cell\",\n      \"fieldset\": \"block\",\n      \"button\": \"inline-block\",\n      \"video\": \"inline-block\",\n      \"audio\": \"inline-block\"\n    },\n    \"CSS_DISPLAY_DEFAULT\": \"inline\",\n    \"CSS_WHITE_SPACE_TAGS\": {\n      \"listing\": \"pre\",\n      \"plaintext\": \"pre\",\n      \"pre\": \"pre\",\n      \"xmp\": \"pre\",\n      \"nobr\": \"nowrap\",\n      \"table\": \"initial\",\n      \"textarea\": \"pre-wrap\"\n    },\n    \"CSS_WHITE_SPACE_DEFAULT\": \"normal\"\n  };\n\n  var a = [\n  \t\"accesskey\",\n  \t\"charset\",\n  \t\"coords\",\n  \t\"download\",\n  \t\"href\",\n  \t\"hreflang\",\n  \t\"name\",\n  \t\"ping\",\n  \t\"referrerpolicy\",\n  \t\"rel\",\n  \t\"rev\",\n  \t\"shape\",\n  \t\"tabindex\",\n  \t\"target\",\n  \t\"type\"\n  ];\n  var abbr = [\n  \t\"title\"\n  ];\n  var applet = [\n  \t\"align\",\n  \t\"alt\",\n  \t\"archive\",\n  \t\"code\",\n  \t\"codebase\",\n  \t\"height\",\n  \t\"hspace\",\n  \t\"name\",\n  \t\"object\",\n  \t\"vspace\",\n  \t\"width\"\n  ];\n  var area = [\n  \t\"accesskey\",\n  \t\"alt\",\n  \t\"coords\",\n  \t\"download\",\n  \t\"href\",\n  \t\"hreflang\",\n  \t\"nohref\",\n  \t\"ping\",\n  \t\"referrerpolicy\",\n  \t\"rel\",\n  \t\"shape\",\n  \t\"tabindex\",\n  \t\"target\",\n  \t\"type\"\n  ];\n  var audio = [\n  \t\"autoplay\",\n  \t\"controls\",\n  \t\"crossorigin\",\n  \t\"loop\",\n  \t\"muted\",\n  \t\"preload\",\n  \t\"src\"\n  ];\n  var base = [\n  \t\"href\",\n  \t\"target\"\n  ];\n  var basefont = [\n  \t\"color\",\n  \t\"face\",\n  \t\"size\"\n  ];\n  var bdo = [\n  \t\"dir\"\n  ];\n  var blockquote = [\n  \t\"cite\"\n  ];\n  var body = [\n  \t\"alink\",\n  \t\"background\",\n  \t\"bgcolor\",\n  \t\"link\",\n  \t\"text\",\n  \t\"vlink\"\n  ];\n  var br = [\n  \t\"clear\"\n  ];\n  var button = [\n  \t\"accesskey\",\n  \t\"autofocus\",\n  \t\"disabled\",\n  \t\"form\",\n  \t\"formaction\",\n  \t\"formenctype\",\n  \t\"formmethod\",\n  \t\"formnovalidate\",\n  \t\"formtarget\",\n  \t\"name\",\n  \t\"tabindex\",\n  \t\"type\",\n  \t\"value\"\n  ];\n  var canvas = [\n  \t\"height\",\n  \t\"width\"\n  ];\n  var caption = [\n  \t\"align\"\n  ];\n  var col = [\n  \t\"align\",\n  \t\"char\",\n  \t\"charoff\",\n  \t\"span\",\n  \t\"valign\",\n  \t\"width\"\n  ];\n  var colgroup = [\n  \t\"align\",\n  \t\"char\",\n  \t\"charoff\",\n  \t\"span\",\n  \t\"valign\",\n  \t\"width\"\n  ];\n  var data = [\n  \t\"value\"\n  ];\n  var del = [\n  \t\"cite\",\n  \t\"datetime\"\n  ];\n  var details = [\n  \t\"open\"\n  ];\n  var dfn = [\n  \t\"title\"\n  ];\n  var dialog = [\n  \t\"open\"\n  ];\n  var dir = [\n  \t\"compact\"\n  ];\n  var div = [\n  \t\"align\"\n  ];\n  var dl = [\n  \t\"compact\"\n  ];\n  var embed$1 = [\n  \t\"height\",\n  \t\"src\",\n  \t\"type\",\n  \t\"width\"\n  ];\n  var fieldset = [\n  \t\"disabled\",\n  \t\"form\",\n  \t\"name\"\n  ];\n  var font = [\n  \t\"color\",\n  \t\"face\",\n  \t\"size\"\n  ];\n  var form = [\n  \t\"accept\",\n  \t\"accept-charset\",\n  \t\"action\",\n  \t\"autocomplete\",\n  \t\"enctype\",\n  \t\"method\",\n  \t\"name\",\n  \t\"novalidate\",\n  \t\"target\"\n  ];\n  var frame = [\n  \t\"frameborder\",\n  \t\"longdesc\",\n  \t\"marginheight\",\n  \t\"marginwidth\",\n  \t\"name\",\n  \t\"noresize\",\n  \t\"scrolling\",\n  \t\"src\"\n  ];\n  var frameset = [\n  \t\"cols\",\n  \t\"rows\"\n  ];\n  var h1 = [\n  \t\"align\"\n  ];\n  var h2 = [\n  \t\"align\"\n  ];\n  var h3 = [\n  \t\"align\"\n  ];\n  var h4 = [\n  \t\"align\"\n  ];\n  var h5 = [\n  \t\"align\"\n  ];\n  var h6 = [\n  \t\"align\"\n  ];\n  var head = [\n  \t\"profile\"\n  ];\n  var hr = [\n  \t\"align\",\n  \t\"noshade\",\n  \t\"size\",\n  \t\"width\"\n  ];\n  var html = [\n  \t\"manifest\",\n  \t\"version\"\n  ];\n  var iframe = [\n  \t\"align\",\n  \t\"allow\",\n  \t\"allowfullscreen\",\n  \t\"allowpaymentrequest\",\n  \t\"allowusermedia\",\n  \t\"frameborder\",\n  \t\"height\",\n  \t\"longdesc\",\n  \t\"marginheight\",\n  \t\"marginwidth\",\n  \t\"name\",\n  \t\"referrerpolicy\",\n  \t\"sandbox\",\n  \t\"scrolling\",\n  \t\"src\",\n  \t\"srcdoc\",\n  \t\"width\"\n  ];\n  var img = [\n  \t\"align\",\n  \t\"alt\",\n  \t\"border\",\n  \t\"crossorigin\",\n  \t\"decoding\",\n  \t\"height\",\n  \t\"hspace\",\n  \t\"ismap\",\n  \t\"longdesc\",\n  \t\"name\",\n  \t\"referrerpolicy\",\n  \t\"sizes\",\n  \t\"src\",\n  \t\"srcset\",\n  \t\"usemap\",\n  \t\"vspace\",\n  \t\"width\"\n  ];\n  var input = [\n  \t\"accept\",\n  \t\"accesskey\",\n  \t\"align\",\n  \t\"alt\",\n  \t\"autocomplete\",\n  \t\"autofocus\",\n  \t\"checked\",\n  \t\"dirname\",\n  \t\"disabled\",\n  \t\"form\",\n  \t\"formaction\",\n  \t\"formenctype\",\n  \t\"formmethod\",\n  \t\"formnovalidate\",\n  \t\"formtarget\",\n  \t\"height\",\n  \t\"ismap\",\n  \t\"list\",\n  \t\"max\",\n  \t\"maxlength\",\n  \t\"min\",\n  \t\"minlength\",\n  \t\"multiple\",\n  \t\"name\",\n  \t\"pattern\",\n  \t\"placeholder\",\n  \t\"readonly\",\n  \t\"required\",\n  \t\"size\",\n  \t\"src\",\n  \t\"step\",\n  \t\"tabindex\",\n  \t\"title\",\n  \t\"type\",\n  \t\"usemap\",\n  \t\"value\",\n  \t\"width\"\n  ];\n  var ins = [\n  \t\"cite\",\n  \t\"datetime\"\n  ];\n  var isindex = [\n  \t\"prompt\"\n  ];\n  var label = [\n  \t\"accesskey\",\n  \t\"for\",\n  \t\"form\"\n  ];\n  var legend = [\n  \t\"accesskey\",\n  \t\"align\"\n  ];\n  var li = [\n  \t\"type\",\n  \t\"value\"\n  ];\n  var link$1 = [\n  \t\"as\",\n  \t\"charset\",\n  \t\"color\",\n  \t\"crossorigin\",\n  \t\"href\",\n  \t\"hreflang\",\n  \t\"imagesizes\",\n  \t\"imagesrcset\",\n  \t\"integrity\",\n  \t\"media\",\n  \t\"nonce\",\n  \t\"referrerpolicy\",\n  \t\"rel\",\n  \t\"rev\",\n  \t\"sizes\",\n  \t\"target\",\n  \t\"title\",\n  \t\"type\"\n  ];\n  var map = [\n  \t\"name\"\n  ];\n  var menu = [\n  \t\"compact\"\n  ];\n  var meta = [\n  \t\"charset\",\n  \t\"content\",\n  \t\"http-equiv\",\n  \t\"name\",\n  \t\"scheme\"\n  ];\n  var meter = [\n  \t\"high\",\n  \t\"low\",\n  \t\"max\",\n  \t\"min\",\n  \t\"optimum\",\n  \t\"value\"\n  ];\n  var object = [\n  \t\"align\",\n  \t\"archive\",\n  \t\"border\",\n  \t\"classid\",\n  \t\"codebase\",\n  \t\"codetype\",\n  \t\"data\",\n  \t\"declare\",\n  \t\"form\",\n  \t\"height\",\n  \t\"hspace\",\n  \t\"name\",\n  \t\"standby\",\n  \t\"tabindex\",\n  \t\"type\",\n  \t\"typemustmatch\",\n  \t\"usemap\",\n  \t\"vspace\",\n  \t\"width\"\n  ];\n  var ol = [\n  \t\"compact\",\n  \t\"reversed\",\n  \t\"start\",\n  \t\"type\"\n  ];\n  var optgroup = [\n  \t\"disabled\",\n  \t\"label\"\n  ];\n  var option = [\n  \t\"disabled\",\n  \t\"label\",\n  \t\"selected\",\n  \t\"value\"\n  ];\n  var output = [\n  \t\"for\",\n  \t\"form\",\n  \t\"name\"\n  ];\n  var p = [\n  \t\"align\"\n  ];\n  var param = [\n  \t\"name\",\n  \t\"type\",\n  \t\"value\",\n  \t\"valuetype\"\n  ];\n  var pre = [\n  \t\"width\"\n  ];\n  var progress = [\n  \t\"max\",\n  \t\"value\"\n  ];\n  var q = [\n  \t\"cite\"\n  ];\n  var script = [\n  \t\"async\",\n  \t\"charset\",\n  \t\"crossorigin\",\n  \t\"defer\",\n  \t\"integrity\",\n  \t\"language\",\n  \t\"nomodule\",\n  \t\"nonce\",\n  \t\"referrerpolicy\",\n  \t\"src\",\n  \t\"type\"\n  ];\n  var select = [\n  \t\"autocomplete\",\n  \t\"autofocus\",\n  \t\"disabled\",\n  \t\"form\",\n  \t\"multiple\",\n  \t\"name\",\n  \t\"required\",\n  \t\"size\",\n  \t\"tabindex\"\n  ];\n  var slot = [\n  \t\"name\"\n  ];\n  var source = [\n  \t\"media\",\n  \t\"sizes\",\n  \t\"src\",\n  \t\"srcset\",\n  \t\"type\"\n  ];\n  var style = [\n  \t\"media\",\n  \t\"nonce\",\n  \t\"title\",\n  \t\"type\"\n  ];\n  var table = [\n  \t\"align\",\n  \t\"bgcolor\",\n  \t\"border\",\n  \t\"cellpadding\",\n  \t\"cellspacing\",\n  \t\"frame\",\n  \t\"rules\",\n  \t\"summary\",\n  \t\"width\"\n  ];\n  var tbody = [\n  \t\"align\",\n  \t\"char\",\n  \t\"charoff\",\n  \t\"valign\"\n  ];\n  var td = [\n  \t\"abbr\",\n  \t\"align\",\n  \t\"axis\",\n  \t\"bgcolor\",\n  \t\"char\",\n  \t\"charoff\",\n  \t\"colspan\",\n  \t\"headers\",\n  \t\"height\",\n  \t\"nowrap\",\n  \t\"rowspan\",\n  \t\"scope\",\n  \t\"valign\",\n  \t\"width\"\n  ];\n  var textarea = [\n  \t\"accesskey\",\n  \t\"autocomplete\",\n  \t\"autofocus\",\n  \t\"cols\",\n  \t\"dirname\",\n  \t\"disabled\",\n  \t\"form\",\n  \t\"maxlength\",\n  \t\"minlength\",\n  \t\"name\",\n  \t\"placeholder\",\n  \t\"readonly\",\n  \t\"required\",\n  \t\"rows\",\n  \t\"tabindex\",\n  \t\"wrap\"\n  ];\n  var tfoot = [\n  \t\"align\",\n  \t\"char\",\n  \t\"charoff\",\n  \t\"valign\"\n  ];\n  var th = [\n  \t\"abbr\",\n  \t\"align\",\n  \t\"axis\",\n  \t\"bgcolor\",\n  \t\"char\",\n  \t\"charoff\",\n  \t\"colspan\",\n  \t\"headers\",\n  \t\"height\",\n  \t\"nowrap\",\n  \t\"rowspan\",\n  \t\"scope\",\n  \t\"valign\",\n  \t\"width\"\n  ];\n  var thead = [\n  \t\"align\",\n  \t\"char\",\n  \t\"charoff\",\n  \t\"valign\"\n  ];\n  var time = [\n  \t\"datetime\"\n  ];\n  var tr = [\n  \t\"align\",\n  \t\"bgcolor\",\n  \t\"char\",\n  \t\"charoff\",\n  \t\"valign\"\n  ];\n  var track = [\n  \t\"default\",\n  \t\"kind\",\n  \t\"label\",\n  \t\"src\",\n  \t\"srclang\"\n  ];\n  var ul = [\n  \t\"compact\",\n  \t\"type\"\n  ];\n  var video = [\n  \t\"autoplay\",\n  \t\"controls\",\n  \t\"crossorigin\",\n  \t\"height\",\n  \t\"loop\",\n  \t\"muted\",\n  \t\"playsinline\",\n  \t\"poster\",\n  \t\"preload\",\n  \t\"src\",\n  \t\"width\"\n  ];\n  var index$1 = {\n  \t\"*\": [\n  \t\"accesskey\",\n  \t\"autocapitalize\",\n  \t\"autofocus\",\n  \t\"class\",\n  \t\"contenteditable\",\n  \t\"dir\",\n  \t\"draggable\",\n  \t\"enterkeyhint\",\n  \t\"hidden\",\n  \t\"id\",\n  \t\"inputmode\",\n  \t\"is\",\n  \t\"itemid\",\n  \t\"itemprop\",\n  \t\"itemref\",\n  \t\"itemscope\",\n  \t\"itemtype\",\n  \t\"lang\",\n  \t\"nonce\",\n  \t\"slot\",\n  \t\"spellcheck\",\n  \t\"style\",\n  \t\"tabindex\",\n  \t\"title\",\n  \t\"translate\"\n  ],\n  \ta: a,\n  \tabbr: abbr,\n  \tapplet: applet,\n  \tarea: area,\n  \taudio: audio,\n  \tbase: base,\n  \tbasefont: basefont,\n  \tbdo: bdo,\n  \tblockquote: blockquote,\n  \tbody: body,\n  \tbr: br,\n  \tbutton: button,\n  \tcanvas: canvas,\n  \tcaption: caption,\n  \tcol: col,\n  \tcolgroup: colgroup,\n  \tdata: data,\n  \tdel: del,\n  \tdetails: details,\n  \tdfn: dfn,\n  \tdialog: dialog,\n  \tdir: dir,\n  \tdiv: div,\n  \tdl: dl,\n  \tembed: embed$1,\n  \tfieldset: fieldset,\n  \tfont: font,\n  \tform: form,\n  \tframe: frame,\n  \tframeset: frameset,\n  \th1: h1,\n  \th2: h2,\n  \th3: h3,\n  \th4: h4,\n  \th5: h5,\n  \th6: h6,\n  \thead: head,\n  \thr: hr,\n  \thtml: html,\n  \tiframe: iframe,\n  \timg: img,\n  \tinput: input,\n  \tins: ins,\n  \tisindex: isindex,\n  \tlabel: label,\n  \tlegend: legend,\n  \tli: li,\n  \tlink: link$1,\n  \tmap: map,\n  \tmenu: menu,\n  \tmeta: meta,\n  \tmeter: meter,\n  \tobject: object,\n  \tol: ol,\n  \toptgroup: optgroup,\n  \toption: option,\n  \toutput: output,\n  \tp: p,\n  \tparam: param,\n  \tpre: pre,\n  \tprogress: progress,\n  \tq: q,\n  \tscript: script,\n  \tselect: select,\n  \tslot: slot,\n  \tsource: source,\n  \tstyle: style,\n  \ttable: table,\n  \ttbody: tbody,\n  \ttd: td,\n  \ttextarea: textarea,\n  \ttfoot: tfoot,\n  \tth: th,\n  \tthead: thead,\n  \ttime: time,\n  \ttr: tr,\n  \ttrack: track,\n  \tul: ul,\n  \tvideo: video\n  };\n\n  var htmlElementAttributes = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    a: a,\n    abbr: abbr,\n    applet: applet,\n    area: area,\n    audio: audio,\n    base: base,\n    basefont: basefont,\n    bdo: bdo,\n    blockquote: blockquote,\n    body: body,\n    br: br,\n    button: button,\n    canvas: canvas,\n    caption: caption,\n    col: col,\n    colgroup: colgroup,\n    data: data,\n    del: del,\n    details: details,\n    dfn: dfn,\n    dialog: dialog,\n    dir: dir,\n    div: div,\n    dl: dl,\n    embed: embed$1,\n    fieldset: fieldset,\n    font: font,\n    form: form,\n    frame: frame,\n    frameset: frameset,\n    h1: h1,\n    h2: h2,\n    h3: h3,\n    h4: h4,\n    h5: h5,\n    h6: h6,\n    head: head,\n    hr: hr,\n    html: html,\n    iframe: iframe,\n    img: img,\n    input: input,\n    ins: ins,\n    isindex: isindex,\n    label: label,\n    legend: legend,\n    li: li,\n    link: link$1,\n    map: map,\n    menu: menu,\n    meta: meta,\n    meter: meter,\n    object: object,\n    ol: ol,\n    optgroup: optgroup,\n    option: option,\n    output: output,\n    p: p,\n    param: param,\n    pre: pre,\n    progress: progress,\n    q: q,\n    script: script,\n    select: select,\n    slot: slot,\n    source: source,\n    style: style,\n    table: table,\n    tbody: tbody,\n    td: td,\n    textarea: textarea,\n    tfoot: tfoot,\n    th: th,\n    thead: thead,\n    time: time,\n    tr: tr,\n    track: track,\n    ul: ul,\n    video: video,\n    'default': index$1\n  });\n\n  var htmlElementAttributes$1 = getCjsExportFromNamespace(htmlElementAttributes);\n\n  var CSS_DISPLAY_TAGS = json.CSS_DISPLAY_TAGS,\n      CSS_DISPLAY_DEFAULT = json.CSS_DISPLAY_DEFAULT,\n      CSS_WHITE_SPACE_TAGS = json.CSS_WHITE_SPACE_TAGS,\n      CSS_WHITE_SPACE_DEFAULT = json.CSS_WHITE_SPACE_DEFAULT;\n  var HTML_TAGS = arrayToMap(htmlTagNames$1);\n  var HTML_ELEMENT_ATTRIBUTES = mapObject(htmlElementAttributes$1, arrayToMap);\n\n  function arrayToMap(array) {\n    var map = Object.create(null);\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = array[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var value = _step.value;\n        map[value] = true;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return map;\n  }\n\n  function mapObject(object, fn) {\n    var newObject = Object.create(null);\n\n    for (var _i = 0, _Object$keys = Object.keys(object); _i < _Object$keys.length; _i++) {\n      var key = _Object$keys[_i];\n      newObject[key] = fn(object[key], key);\n    }\n\n    return newObject;\n  }\n\n  function shouldPreserveContent(node, options) {\n    if (node.type === \"element\" && node.fullName === \"template\" && node.attrMap.lang && node.attrMap.lang !== \"html\") {\n      return true;\n    } // unterminated node in ie conditional comment\n    // e.g. <!--[if lt IE 9]><html><![endif]-->\n\n\n    if (node.type === \"ieConditionalComment\" && node.lastChild && !node.lastChild.isSelfClosing && !node.lastChild.endSourceSpan) {\n      return true;\n    } // incomplete html in ie conditional comment\n    // e.g. <!--[if lt IE 9]></div><![endif]-->\n\n\n    if (node.type === \"ieConditionalComment\" && !node.complete) {\n      return true;\n    } // top-level elements (excluding <template>, <style> and <script>) in Vue SFC are considered custom block\n    // custom blocks can be written in other languages so we should preserve them to not break the code\n\n\n    if (options.parser === \"vue\" && node.type === \"element\" && node.parent.type === \"root\" && [\"template\", \"style\", \"script\", // vue parser can be used for vue dom template as well, so we should still format top-level <html>\n    \"html\"].indexOf(node.fullName) === -1) {\n      return true;\n    } // TODO: handle non-text children in <pre>\n\n\n    if (isPreLikeNode(node) && node.children.some(function (child) {\n      return child.type !== \"text\" && child.type !== \"interpolation\";\n    })) {\n      return true;\n    }\n\n    return false;\n  }\n\n  function hasPrettierIgnore(node) {\n    if (node.type === \"attribute\" || isTextLikeNode(node)) {\n      return false;\n    }\n\n    if (!node.parent) {\n      return false;\n    }\n\n    if (typeof node.index !== \"number\" || node.index === 0) {\n      return false;\n    }\n\n    var prevNode = node.parent.children[node.index - 1];\n    return isPrettierIgnore(prevNode);\n  }\n\n  function isPrettierIgnore(node) {\n    return node.type === \"comment\" && node.value.trim() === \"prettier-ignore\";\n  }\n\n  function getPrettierIgnoreAttributeCommentData(value) {\n    var match = value.trim().match(/^prettier-ignore-attribute(?:\\s+([^]+))?$/);\n\n    if (!match) {\n      return false;\n    }\n\n    if (!match[1]) {\n      return true;\n    }\n\n    return match[1].split(/\\s+/);\n  }\n  /** there's no opening/closing tag or it's considered not breakable */\n\n\n  function isTextLikeNode(node) {\n    return node.type === \"text\" || node.type === \"comment\";\n  }\n\n  function isScriptLikeTag(node) {\n    return node.type === \"element\" && (node.fullName === \"script\" || node.fullName === \"style\" || node.fullName === \"svg:style\");\n  }\n\n  function isFrontMatterNode(node) {\n    return node.type === \"yaml\" || node.type === \"toml\";\n  }\n\n  function canHaveInterpolation(node) {\n    return node.children && !isScriptLikeTag(node);\n  }\n\n  function isWhitespaceSensitiveNode(node) {\n    return isScriptLikeTag(node) || node.type === \"interpolation\" || isIndentationSensitiveNode(node);\n  }\n\n  function isIndentationSensitiveNode(node) {\n    return getNodeCssStyleWhiteSpace(node).startsWith(\"pre\");\n  }\n\n  function isLeadingSpaceSensitiveNode(node) {\n    var isLeadingSpaceSensitive = _isLeadingSpaceSensitiveNode();\n\n    if (isLeadingSpaceSensitive && !node.prev && node.parent && node.parent.tagDefinition && node.parent.tagDefinition.ignoreFirstLf) {\n      return node.type === \"interpolation\";\n    }\n\n    return isLeadingSpaceSensitive;\n\n    function _isLeadingSpaceSensitiveNode() {\n      if (isFrontMatterNode(node)) {\n        return false;\n      }\n\n      if ((node.type === \"text\" || node.type === \"interpolation\") && node.prev && (node.prev.type === \"text\" || node.prev.type === \"interpolation\")) {\n        return true;\n      }\n\n      if (!node.parent || node.parent.cssDisplay === \"none\") {\n        return false;\n      }\n\n      if (isPreLikeNode(node.parent)) {\n        return true;\n      }\n\n      if (!node.prev && (node.parent.type === \"root\" || isScriptLikeTag(node.parent) || !isFirstChildLeadingSpaceSensitiveCssDisplay(node.parent.cssDisplay))) {\n        return false;\n      }\n\n      if (node.prev && !isNextLeadingSpaceSensitiveCssDisplay(node.prev.cssDisplay)) {\n        return false;\n      }\n\n      return true;\n    }\n  }\n\n  function isTrailingSpaceSensitiveNode(node) {\n    if (isFrontMatterNode(node)) {\n      return false;\n    }\n\n    if ((node.type === \"text\" || node.type === \"interpolation\") && node.next && (node.next.type === \"text\" || node.next.type === \"interpolation\")) {\n      return true;\n    }\n\n    if (!node.parent || node.parent.cssDisplay === \"none\") {\n      return false;\n    }\n\n    if (isPreLikeNode(node.parent)) {\n      return true;\n    }\n\n    if (!node.next && (node.parent.type === \"root\" || isScriptLikeTag(node.parent) || !isLastChildTrailingSpaceSensitiveCssDisplay(node.parent.cssDisplay))) {\n      return false;\n    }\n\n    if (node.next && !isPrevTrailingSpaceSensitiveCssDisplay(node.next.cssDisplay)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  function isDanglingSpaceSensitiveNode(node) {\n    return isDanglingSpaceSensitiveCssDisplay(node.cssDisplay) && !isScriptLikeTag(node);\n  }\n\n  function forceNextEmptyLine(node) {\n    return isFrontMatterNode(node) || node.next && node.sourceSpan.end.line + 1 < node.next.sourceSpan.start.line;\n  }\n  /** firstChild leadingSpaces and lastChild trailingSpaces */\n\n\n  function forceBreakContent(node) {\n    return forceBreakChildren(node) || node.type === \"element\" && node.children.length !== 0 && ([\"body\", \"script\", \"style\"].indexOf(node.name) !== -1 || node.children.some(function (child) {\n      return hasNonTextChild(child);\n    })) || node.firstChild && node.firstChild === node.lastChild && hasLeadingLineBreak(node.firstChild) && (!node.lastChild.isTrailingSpaceSensitive || hasTrailingLineBreak(node.lastChild));\n  }\n  /** spaces between children */\n\n\n  function forceBreakChildren(node) {\n    return node.type === \"element\" && node.children.length !== 0 && ([\"html\", \"head\", \"ul\", \"ol\", \"select\"].indexOf(node.name) !== -1 || node.cssDisplay.startsWith(\"table\") && node.cssDisplay !== \"table-cell\");\n  }\n\n  function preferHardlineAsLeadingSpaces(node) {\n    return preferHardlineAsSurroundingSpaces(node) || node.prev && preferHardlineAsTrailingSpaces(node.prev) || hasSurroundingLineBreak(node);\n  }\n\n  function preferHardlineAsTrailingSpaces(node) {\n    return preferHardlineAsSurroundingSpaces(node) || node.type === \"element\" && node.fullName === \"br\" || hasSurroundingLineBreak(node);\n  }\n\n  function hasSurroundingLineBreak(node) {\n    return hasLeadingLineBreak(node) && hasTrailingLineBreak(node);\n  }\n\n  function hasLeadingLineBreak(node) {\n    return node.hasLeadingSpaces && (node.prev ? node.prev.sourceSpan.end.line < node.sourceSpan.start.line : node.parent.type === \"root\" || node.parent.startSourceSpan.end.line < node.sourceSpan.start.line);\n  }\n\n  function hasTrailingLineBreak(node) {\n    return node.hasTrailingSpaces && (node.next ? node.next.sourceSpan.start.line > node.sourceSpan.end.line : node.parent.type === \"root\" || node.parent.endSourceSpan.start.line > node.sourceSpan.end.line);\n  }\n\n  function preferHardlineAsSurroundingSpaces(node) {\n    switch (node.type) {\n      case \"ieConditionalComment\":\n      case \"comment\":\n      case \"directive\":\n        return true;\n\n      case \"element\":\n        return [\"script\", \"select\"].indexOf(node.name) !== -1;\n    }\n\n    return false;\n  }\n\n  function getLastDescendant(node) {\n    return node.lastChild ? getLastDescendant(node.lastChild) : node;\n  }\n\n  function hasNonTextChild(node) {\n    return node.children && node.children.some(function (child) {\n      return child.type !== \"text\";\n    });\n  }\n\n  function inferScriptParser(node) {\n    if (node.name === \"script\" && !node.attrMap.src) {\n      if (!node.attrMap.lang && !node.attrMap.type || node.attrMap.type === \"module\" || node.attrMap.type === \"text/javascript\" || node.attrMap.type === \"text/babel\" || node.attrMap.type === \"application/javascript\") {\n        return \"babel\";\n      }\n\n      if (node.attrMap.type === \"application/x-typescript\" || node.attrMap.lang === \"ts\" || node.attrMap.lang === \"tsx\") {\n        return \"typescript\";\n      }\n\n      if (node.attrMap.type === \"text/markdown\") {\n        return \"markdown\";\n      }\n\n      if (node.attrMap.type.endsWith(\"json\") || node.attrMap.type.endsWith(\"importmap\")) {\n        return \"json\";\n      }\n    }\n\n    if (node.name === \"style\") {\n      if (!node.attrMap.lang || node.attrMap.lang === \"postcss\" || node.attrMap.lang === \"css\") {\n        return \"css\";\n      }\n\n      if (node.attrMap.lang === \"scss\") {\n        return \"scss\";\n      }\n\n      if (node.attrMap.lang === \"less\") {\n        return \"less\";\n      }\n    }\n\n    return null;\n  }\n\n  function isBlockLikeCssDisplay(cssDisplay) {\n    return cssDisplay === \"block\" || cssDisplay === \"list-item\" || cssDisplay.startsWith(\"table\");\n  }\n\n  function isFirstChildLeadingSpaceSensitiveCssDisplay(cssDisplay) {\n    return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== \"inline-block\";\n  }\n\n  function isLastChildTrailingSpaceSensitiveCssDisplay(cssDisplay) {\n    return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== \"inline-block\";\n  }\n\n  function isPrevTrailingSpaceSensitiveCssDisplay(cssDisplay) {\n    return !isBlockLikeCssDisplay(cssDisplay);\n  }\n\n  function isNextLeadingSpaceSensitiveCssDisplay(cssDisplay) {\n    return !isBlockLikeCssDisplay(cssDisplay);\n  }\n\n  function isDanglingSpaceSensitiveCssDisplay(cssDisplay) {\n    return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== \"inline-block\";\n  }\n\n  function isPreLikeNode(node) {\n    return getNodeCssStyleWhiteSpace(node).startsWith(\"pre\");\n  }\n\n  function countParents(path) {\n    var predicate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n      return true;\n    };\n    var counter = 0;\n\n    for (var i = path.stack.length - 1; i >= 0; i--) {\n      var value = path.stack[i];\n\n      if (value && _typeof(value) === \"object\" && !Array.isArray(value) && predicate(value)) {\n        counter++;\n      }\n    }\n\n    return counter;\n  }\n\n  function hasParent(node, fn) {\n    var current = node;\n\n    while (current) {\n      if (fn(current)) {\n        return true;\n      }\n\n      current = current.parent;\n    }\n\n    return false;\n  }\n\n  function getNodeCssStyleDisplay(node, options) {\n    if (node.prev && node.prev.type === \"comment\") {\n      // <!-- display: block -->\n      var match = node.prev.value.match(/^\\s*display:\\s*([a-z]+)\\s*$/);\n\n      if (match) {\n        return match[1];\n      }\n    }\n\n    var isInSvgForeignObject = false;\n\n    if (node.type === \"element\" && node.namespace === \"svg\") {\n      if (hasParent(node, function (parent) {\n        return parent.fullName === \"svg:foreignObject\";\n      })) {\n        isInSvgForeignObject = true;\n      } else {\n        return node.name === \"svg\" ? \"inline-block\" : \"block\";\n      }\n    }\n\n    switch (options.htmlWhitespaceSensitivity) {\n      case \"strict\":\n        return \"inline\";\n\n      case \"ignore\":\n        return \"block\";\n\n      default:\n        return node.type === \"element\" && (!node.namespace || isInSvgForeignObject) && CSS_DISPLAY_TAGS[node.name] || CSS_DISPLAY_DEFAULT;\n    }\n  }\n\n  function getNodeCssStyleWhiteSpace(node) {\n    return node.type === \"element\" && !node.namespace && CSS_WHITE_SPACE_TAGS[node.name] || CSS_WHITE_SPACE_DEFAULT;\n  }\n\n  function getMinIndentation(text) {\n    var minIndentation = Infinity;\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = text.split(\"\\n\")[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var lineText = _step2.value;\n\n        if (lineText.length === 0) {\n          continue;\n        }\n\n        if (/\\S/.test(lineText[0])) {\n          return 0;\n        }\n\n        var indentation = lineText.match(/^\\s*/)[0].length;\n\n        if (lineText.length === indentation) {\n          continue;\n        }\n\n        if (indentation < minIndentation) {\n          minIndentation = indentation;\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return minIndentation === Infinity ? 0 : minIndentation;\n  }\n\n  function dedentString(text) {\n    var minIndent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getMinIndentation(text);\n    return minIndent === 0 ? text : text.split(\"\\n\").map(function (lineText) {\n      return lineText.slice(minIndent);\n    }).join(\"\\n\");\n  }\n\n  function normalizeParts(parts) {\n    var newParts = [];\n    var restParts = parts.slice();\n\n    while (restParts.length !== 0) {\n      var part = restParts.shift();\n\n      if (!part) {\n        continue;\n      }\n\n      if (part.type === \"concat\") {\n        Array.prototype.unshift.apply(restParts, part.parts);\n        continue;\n      }\n\n      if (newParts.length !== 0 && typeof newParts[newParts.length - 1] === \"string\" && typeof part === \"string\") {\n        newParts.push(newParts.pop() + part);\n        continue;\n      }\n\n      newParts.push(part);\n    }\n\n    return newParts;\n  }\n\n  function identity(x) {\n    return x;\n  }\n\n  function shouldNotPrintClosingTag(node, options) {\n    return !node.isSelfClosing && !node.endSourceSpan && (hasPrettierIgnore(node) || shouldPreserveContent(node.parent, options));\n  }\n\n  function countChars(text, char) {\n    var counter = 0;\n\n    for (var i = 0; i < text.length; i++) {\n      if (text[i] === char) {\n        counter++;\n      }\n    }\n\n    return counter;\n  }\n\n  function unescapeQuoteEntities(text) {\n    return text.replace(/&apos;/g, \"'\").replace(/&quot;/g, '\"');\n  }\n\n  var utils$3 = {\n    HTML_ELEMENT_ATTRIBUTES: HTML_ELEMENT_ATTRIBUTES,\n    HTML_TAGS: HTML_TAGS,\n    canHaveInterpolation: canHaveInterpolation,\n    countChars: countChars,\n    countParents: countParents,\n    dedentString: dedentString,\n    forceBreakChildren: forceBreakChildren,\n    forceBreakContent: forceBreakContent,\n    forceNextEmptyLine: forceNextEmptyLine,\n    getLastDescendant: getLastDescendant,\n    getNodeCssStyleDisplay: getNodeCssStyleDisplay,\n    getNodeCssStyleWhiteSpace: getNodeCssStyleWhiteSpace,\n    getPrettierIgnoreAttributeCommentData: getPrettierIgnoreAttributeCommentData,\n    hasPrettierIgnore: hasPrettierIgnore,\n    identity: identity,\n    inferScriptParser: inferScriptParser,\n    isDanglingSpaceSensitiveNode: isDanglingSpaceSensitiveNode,\n    isFrontMatterNode: isFrontMatterNode,\n    isIndentationSensitiveNode: isIndentationSensitiveNode,\n    isLeadingSpaceSensitiveNode: isLeadingSpaceSensitiveNode,\n    isPreLikeNode: isPreLikeNode,\n    isScriptLikeTag: isScriptLikeTag,\n    isTextLikeNode: isTextLikeNode,\n    isTrailingSpaceSensitiveNode: isTrailingSpaceSensitiveNode,\n    isWhitespaceSensitiveNode: isWhitespaceSensitiveNode,\n    normalizeParts: normalizeParts,\n    preferHardlineAsLeadingSpaces: preferHardlineAsLeadingSpaces,\n    preferHardlineAsTrailingSpaces: preferHardlineAsTrailingSpaces,\n    shouldNotPrintClosingTag: shouldNotPrintClosingTag,\n    shouldPreserveContent: shouldPreserveContent,\n    unescapeQuoteEntities: unescapeQuoteEntities\n  };\n\n  var canHaveInterpolation$1 = utils$3.canHaveInterpolation,\n      getNodeCssStyleDisplay$1 = utils$3.getNodeCssStyleDisplay,\n      isDanglingSpaceSensitiveNode$1 = utils$3.isDanglingSpaceSensitiveNode,\n      isIndentationSensitiveNode$1 = utils$3.isIndentationSensitiveNode,\n      isLeadingSpaceSensitiveNode$1 = utils$3.isLeadingSpaceSensitiveNode,\n      isTrailingSpaceSensitiveNode$1 = utils$3.isTrailingSpaceSensitiveNode,\n      isWhitespaceSensitiveNode$1 = utils$3.isWhitespaceSensitiveNode;\n  var PREPROCESS_PIPELINE = [removeIgnorableFirstLf, mergeIeConditonalStartEndCommentIntoElementOpeningTag, mergeCdataIntoText, extractInterpolation, extractWhitespaces, addCssDisplay, addIsSelfClosing, addHasHtmComponentClosingTag, addIsSpaceSensitive, mergeSimpleElementIntoText];\n\n  function preprocess(ast, options) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = PREPROCESS_PIPELINE[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var fn = _step.value;\n        ast = fn(ast, options);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return ast;\n  }\n\n  function removeIgnorableFirstLf(ast\n  /*, options */\n  ) {\n    return ast.map(function (node) {\n      if (node.type === \"element\" && node.tagDefinition.ignoreFirstLf && node.children.length !== 0 && node.children[0].type === \"text\" && node.children[0].value[0] === \"\\n\") {\n        var text = node.children[0];\n        return node.clone({\n          children: text.value.length === 1 ? node.children.slice(1) : [].concat(text.clone({\n            value: text.value.slice(1)\n          }), node.children.slice(1))\n        });\n      }\n\n      return node;\n    });\n  }\n\n  function mergeIeConditonalStartEndCommentIntoElementOpeningTag(ast\n  /*, options */\n  ) {\n    /**\n     *     <!--[if ...]><!--><target><!--<![endif]-->\n     */\n    var isTarget = function isTarget(node) {\n      return node.type === \"element\" && node.prev && node.prev.type === \"ieConditionalStartComment\" && node.prev.sourceSpan.end.offset === node.startSourceSpan.start.offset && node.firstChild && node.firstChild.type === \"ieConditionalEndComment\" && node.firstChild.sourceSpan.start.offset === node.startSourceSpan.end.offset;\n    };\n\n    return ast.map(function (node) {\n      if (node.children) {\n        var isTargetResults = node.children.map(isTarget);\n\n        if (isTargetResults.some(Boolean)) {\n          var newChildren = [];\n\n          for (var i = 0; i < node.children.length; i++) {\n            var child = node.children[i];\n\n            if (isTargetResults[i + 1]) {\n              // ieConditionalStartComment\n              continue;\n            }\n\n            if (isTargetResults[i]) {\n              var ieConditionalStartComment = child.prev;\n              var ieConditionalEndComment = child.firstChild;\n              var ParseSourceSpan = child.sourceSpan.constructor;\n              var startSourceSpan = new ParseSourceSpan(ieConditionalStartComment.sourceSpan.start, ieConditionalEndComment.sourceSpan.end);\n              var sourceSpan = new ParseSourceSpan(startSourceSpan.start, child.sourceSpan.end);\n              newChildren.push(child.clone({\n                condition: ieConditionalStartComment.condition,\n                sourceSpan: sourceSpan,\n                startSourceSpan: startSourceSpan,\n                children: child.children.slice(1)\n              }));\n              continue;\n            }\n\n            newChildren.push(child);\n          }\n\n          return node.clone({\n            children: newChildren\n          });\n        }\n      }\n\n      return node;\n    });\n  }\n\n  function mergeNodeIntoText(ast, shouldMerge, getValue) {\n    return ast.map(function (node) {\n      if (node.children) {\n        var shouldMergeResults = node.children.map(shouldMerge);\n\n        if (shouldMergeResults.some(Boolean)) {\n          var newChildren = [];\n\n          for (var i = 0; i < node.children.length; i++) {\n            var child = node.children[i];\n\n            if (child.type !== \"text\" && !shouldMergeResults[i]) {\n              newChildren.push(child);\n              continue;\n            }\n\n            var newChild = child.type === \"text\" ? child : child.clone({\n              type: \"text\",\n              value: getValue(child)\n            });\n\n            if (newChildren.length === 0 || newChildren[newChildren.length - 1].type !== \"text\") {\n              newChildren.push(newChild);\n              continue;\n            }\n\n            var lastChild = newChildren.pop();\n            var ParseSourceSpan = lastChild.sourceSpan.constructor;\n            newChildren.push(lastChild.clone({\n              value: lastChild.value + newChild.value,\n              sourceSpan: new ParseSourceSpan(lastChild.sourceSpan.start, newChild.sourceSpan.end)\n            }));\n          }\n\n          return node.clone({\n            children: newChildren\n          });\n        }\n      }\n\n      return node;\n    });\n  }\n\n  function mergeCdataIntoText(ast\n  /*, options */\n  ) {\n    return mergeNodeIntoText(ast, function (node) {\n      return node.type === \"cdata\";\n    }, function (node) {\n      return \"<![CDATA[\".concat(node.value, \"]]>\");\n    });\n  }\n\n  function mergeSimpleElementIntoText(ast\n  /*, options */\n  ) {\n    var isSimpleElement = function isSimpleElement(node) {\n      return node.type === \"element\" && node.attrs.length === 0 && node.children.length === 1 && node.firstChild.type === \"text\" && // \\xA0: non-breaking whitespace\n      !/[^\\S\\xA0]/.test(node.children[0].value) && !node.firstChild.hasLeadingSpaces && !node.firstChild.hasTrailingSpaces && node.isLeadingSpaceSensitive && !node.hasLeadingSpaces && node.isTrailingSpaceSensitive && !node.hasTrailingSpaces && node.prev && node.prev.type === \"text\" && node.next && node.next.type === \"text\";\n    };\n\n    return ast.map(function (node) {\n      if (node.children) {\n        var isSimpleElementResults = node.children.map(isSimpleElement);\n\n        if (isSimpleElementResults.some(Boolean)) {\n          var newChildren = [];\n\n          for (var i = 0; i < node.children.length; i++) {\n            var child = node.children[i];\n\n            if (isSimpleElementResults[i]) {\n              var lastChild = newChildren.pop();\n              var nextChild = node.children[++i];\n              var ParseSourceSpan = node.sourceSpan.constructor;\n              var isTrailingSpaceSensitive = nextChild.isTrailingSpaceSensitive,\n                  hasTrailingSpaces = nextChild.hasTrailingSpaces;\n              newChildren.push(lastChild.clone({\n                value: lastChild.value + \"<\".concat(child.rawName, \">\") + child.firstChild.value + \"</\".concat(child.rawName, \">\") + nextChild.value,\n                sourceSpan: new ParseSourceSpan(lastChild.sourceSpan.start, nextChild.sourceSpan.end),\n                isTrailingSpaceSensitive: isTrailingSpaceSensitive,\n                hasTrailingSpaces: hasTrailingSpaces\n              }));\n            } else {\n              newChildren.push(child);\n            }\n          }\n\n          return node.clone({\n            children: newChildren\n          });\n        }\n      }\n\n      return node;\n    });\n  }\n\n  function extractInterpolation(ast, options) {\n    if (options.parser === \"html\") {\n      return ast;\n    }\n\n    var interpolationRegex = /\\{\\{([\\s\\S]+?)\\}\\}/g;\n    return ast.map(function (node) {\n      if (!canHaveInterpolation$1(node)) {\n        return node;\n      }\n\n      var newChildren = [];\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = node.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var child = _step2.value;\n\n          if (child.type !== \"text\") {\n            newChildren.push(child);\n            continue;\n          }\n\n          var ParseSourceSpan = child.sourceSpan.constructor;\n          var startSourceSpan = child.sourceSpan.start;\n          var endSourceSpan = null;\n          var components = child.value.split(interpolationRegex);\n\n          for (var i = 0; i < components.length; i++, startSourceSpan = endSourceSpan) {\n            var value = components[i];\n\n            if (i % 2 === 0) {\n              endSourceSpan = startSourceSpan.moveBy(value.length);\n\n              if (value.length !== 0) {\n                newChildren.push({\n                  type: \"text\",\n                  value: value,\n                  sourceSpan: new ParseSourceSpan(startSourceSpan, endSourceSpan)\n                });\n              }\n\n              continue;\n            }\n\n            endSourceSpan = startSourceSpan.moveBy(value.length + 4); // `{{` + `}}`\n\n            newChildren.push({\n              type: \"interpolation\",\n              sourceSpan: new ParseSourceSpan(startSourceSpan, endSourceSpan),\n              children: value.length === 0 ? [] : [{\n                type: \"text\",\n                value: value,\n                sourceSpan: new ParseSourceSpan(startSourceSpan.moveBy(2), endSourceSpan.moveBy(-2))\n              }]\n            });\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return node.clone({\n        children: newChildren\n      });\n    });\n  }\n  /**\n   * - add `hasLeadingSpaces` field\n   * - add `hasTrailingSpaces` field\n   * - add `hasDanglingSpaces` field for parent nodes\n   * - add `isWhitespaceSensitive`, `isIndentationSensitive` field for text nodes\n   * - remove insensitive whitespaces\n   */\n\n\n  function extractWhitespaces(ast\n  /*, options*/\n  ) {\n    var TYPE_WHITESPACE = \"whitespace\";\n    return ast.map(function (node) {\n      if (!node.children) {\n        return node;\n      }\n\n      if (node.children.length === 0 || node.children.length === 1 && node.children[0].type === \"text\" && node.children[0].value.trim().length === 0) {\n        return node.clone({\n          children: [],\n          hasDanglingSpaces: node.children.length !== 0\n        });\n      }\n\n      var isWhitespaceSensitive = isWhitespaceSensitiveNode$1(node);\n      var isIndentationSensitive = isIndentationSensitiveNode$1(node);\n      return node.clone({\n        isWhitespaceSensitive: isWhitespaceSensitive,\n        isIndentationSensitive: isIndentationSensitive,\n        children: node.children // extract whitespace nodes\n        .reduce(function (newChildren, child) {\n          if (child.type !== \"text\" || isWhitespaceSensitive) {\n            return newChildren.concat(child);\n          }\n\n          var localChildren = [];\n\n          var _child$value$match = child.value.match(/^(\\s*)([\\s\\S]*?)(\\s*)$/),\n              _child$value$match2 = _slicedToArray(_child$value$match, 4),\n              leadingSpaces = _child$value$match2[1],\n              text = _child$value$match2[2],\n              trailingSpaces = _child$value$match2[3];\n\n          if (leadingSpaces) {\n            localChildren.push({\n              type: TYPE_WHITESPACE\n            });\n          }\n\n          var ParseSourceSpan = child.sourceSpan.constructor;\n\n          if (text) {\n            localChildren.push({\n              type: \"text\",\n              value: text,\n              sourceSpan: new ParseSourceSpan(child.sourceSpan.start.moveBy(leadingSpaces.length), child.sourceSpan.end.moveBy(-trailingSpaces.length))\n            });\n          }\n\n          if (trailingSpaces) {\n            localChildren.push({\n              type: TYPE_WHITESPACE\n            });\n          }\n\n          return newChildren.concat(localChildren);\n        }, []) // set hasLeadingSpaces/hasTrailingSpaces and filter whitespace nodes\n        .reduce(function (newChildren, child, i, children) {\n          if (child.type === TYPE_WHITESPACE) {\n            return newChildren;\n          }\n\n          var hasLeadingSpaces = i !== 0 && children[i - 1].type === TYPE_WHITESPACE;\n          var hasTrailingSpaces = i !== children.length - 1 && children[i + 1].type === TYPE_WHITESPACE;\n          return newChildren.concat(Object.assign({}, child, {\n            hasLeadingSpaces: hasLeadingSpaces,\n            hasTrailingSpaces: hasTrailingSpaces\n          }));\n        }, [])\n      });\n    });\n  }\n\n  function addIsSelfClosing(ast\n  /*, options */\n  ) {\n    return ast.map(function (node) {\n      return Object.assign(node, {\n        isSelfClosing: !node.children || node.type === \"element\" && (node.tagDefinition.isVoid || // self-closing\n        node.startSourceSpan === node.endSourceSpan)\n      });\n    });\n  }\n\n  function addHasHtmComponentClosingTag(ast, options) {\n    return ast.map(function (node) {\n      return node.type !== \"element\" ? node : Object.assign(node, {\n        hasHtmComponentClosingTag: node.endSourceSpan && /^<\\s*\\/\\s*\\/\\s*>$/.test(options.originalText.slice(node.endSourceSpan.start.offset, node.endSourceSpan.end.offset))\n      });\n    });\n  }\n\n  function addCssDisplay(ast, options) {\n    return ast.map(function (node) {\n      return Object.assign(node, {\n        cssDisplay: getNodeCssStyleDisplay$1(node, options)\n      });\n    });\n  }\n  /**\n   * - add `isLeadingSpaceSensitive` field\n   * - add `isTrailingSpaceSensitive` field\n   * - add `isDanglingSpaceSensitive` field for parent nodes\n   */\n\n\n  function addIsSpaceSensitive(ast\n  /*, options */\n  ) {\n    return ast.map(function (node) {\n      if (!node.children) {\n        return node;\n      }\n\n      if (node.children.length === 0) {\n        return node.clone({\n          isDanglingSpaceSensitive: isDanglingSpaceSensitiveNode$1(node)\n        });\n      }\n\n      return node.clone({\n        children: node.children.map(function (child) {\n          return Object.assign({}, child, {\n            isLeadingSpaceSensitive: isLeadingSpaceSensitiveNode$1(child),\n            isTrailingSpaceSensitive: isTrailingSpaceSensitiveNode$1(child)\n          });\n        }).map(function (child, index, children) {\n          return Object.assign({}, child, {\n            isLeadingSpaceSensitive: index === 0 ? child.isLeadingSpaceSensitive : children[index - 1].isTrailingSpaceSensitive && child.isLeadingSpaceSensitive,\n            isTrailingSpaceSensitive: index === children.length - 1 ? child.isTrailingSpaceSensitive : children[index + 1].isLeadingSpaceSensitive && child.isTrailingSpaceSensitive\n          });\n        })\n      });\n    });\n  }\n\n  var preprocess_1 = preprocess;\n\n  function hasPragma$3(text) {\n    return /^\\s*<!--\\s*@(format|prettier)\\s*-->/.test(text);\n  }\n\n  function insertPragma$5(text) {\n    return \"<!-- @format -->\\n\\n\" + text.replace(/^\\s*\\n/, \"\");\n  }\n\n  var pragma$3 = {\n    hasPragma: hasPragma$3,\n    insertPragma: insertPragma$5\n  };\n\n  var _require$$0$builders$4 = doc.builders,\n      concat$8 = _require$$0$builders$4.concat,\n      group$8 = _require$$0$builders$4.group;\n  /**\n   *     v-for=\"... in ...\"\n   *     v-for=\"... of ...\"\n   *     v-for=\"(..., ...) in ...\"\n   *     v-for=\"(..., ...) of ...\"\n   */\n\n  function printVueFor(value, textToDoc) {\n    var _parseVueFor = parseVueFor(value),\n        left = _parseVueFor.left,\n        operator = _parseVueFor.operator,\n        right = _parseVueFor.right;\n\n    return concat$8([group$8(textToDoc(\"function _(\".concat(left, \") {}\"), {\n      parser: \"babel\",\n      __isVueForBindingLeft: true\n    })), \" \", operator, \" \", textToDoc(right, {\n      parser: \"__js_expression\"\n    })]);\n  } // modified from https://github.com/vuejs/vue/blob/v2.5.17/src/compiler/parser/index.js#L370-L387\n\n\n  function parseVueFor(value) {\n    var forAliasRE = /([^]*?)\\s+(in|of)\\s+([^]*)/;\n    var forIteratorRE = /,([^,}\\]]*)(?:,([^,}\\]]*))?$/;\n    var stripParensRE = /^\\(|\\)$/g;\n    var inMatch = value.match(forAliasRE);\n\n    if (!inMatch) {\n      return;\n    }\n\n    var res = {};\n    res.for = inMatch[3].trim();\n    var alias = inMatch[1].trim().replace(stripParensRE, \"\");\n    var iteratorMatch = alias.match(forIteratorRE);\n\n    if (iteratorMatch) {\n      res.alias = alias.replace(forIteratorRE, \"\");\n      res.iterator1 = iteratorMatch[1].trim();\n\n      if (iteratorMatch[2]) {\n        res.iterator2 = iteratorMatch[2].trim();\n      }\n    } else {\n      res.alias = alias;\n    }\n\n    return {\n      left: \"\".concat([res.alias, res.iterator1, res.iterator2].filter(Boolean).join(\",\")),\n      operator: inMatch[2],\n      right: res.for\n    };\n  }\n\n  function printVueSlotScope(value, textToDoc) {\n    return textToDoc(\"function _(\".concat(value, \") {}\"), {\n      parser: \"babel\",\n      __isVueSlotScope: true\n    });\n  }\n\n  function isVueEventBindingExpression(eventBindingValue) {\n    // https://github.com/vuejs/vue/blob/v2.5.17/src/compiler/codegen/events.js#L3-L4\n    // arrow function or anonymous function\n    var fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/; // simple member expression chain (a, a.b, a['b'], a[\"b\"], a[0], a[b])\n\n    var simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/; // https://github.com/vuejs/vue/blob/v2.5.17/src/compiler/helpers.js#L104\n\n    var value = eventBindingValue.trim();\n    return fnExpRE.test(value) || simplePathRE.test(value);\n  }\n\n  var syntaxVue = {\n    isVueEventBindingExpression: isVueEventBindingExpression,\n    printVueFor: printVueFor,\n    printVueSlotScope: printVueSlotScope\n  };\n\n  var parseSrcset = createCommonjsModule(function (module) {\n    /**\n     * Srcset Parser\n     *\n     * By Alex Bell |  MIT License\n     *\n     * JS Parser for the string value that appears in markup <img srcset=\"here\">\n     *\n     * @returns Array [{url: _, d: _, w: _, h:_}, ...]\n     *\n     * Based super duper closely on the reference algorithm at:\n     * https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-srcset-attribute\n     *\n     * Most comments are copied in directly from the spec\n     * (except for comments in parens).\n     */\n    (function (root, factory) {\n      if ( module.exports) {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory();\n      } else {\n        // Browser globals (root is window)\n        root.parseSrcset = factory();\n      }\n    })(commonjsGlobal, function () {\n      // 1. Let input be the value passed to this algorithm.\n      return function (input, options) {\n        var logger = options && options.logger || console; // UTILITY FUNCTIONS\n        // Manual is faster than RegEx\n        // http://bjorn.tipling.com/state-and-regular-expressions-in-javascript\n        // http://jsperf.com/whitespace-character/5\n\n        function isSpace(c) {\n          return c === \" \" || // space\n          c === \"\\t\" || // horizontal tab\n          c === \"\\n\" || // new line\n          c === \"\\f\" || // form feed\n          c === \"\\r\"; // carriage return\n        }\n\n        function collectCharacters(regEx) {\n          var chars,\n              match = regEx.exec(input.substring(pos));\n\n          if (match) {\n            chars = match[0];\n            pos += chars.length;\n            return chars;\n          }\n        }\n\n        var inputLength = input.length,\n            // (Don't use \\s, to avoid matching non-breaking space)\n        regexLeadingSpaces = /^[ \\t\\n\\r\\u000c]+/,\n            regexLeadingCommasOrSpaces = /^[, \\t\\n\\r\\u000c]+/,\n            regexLeadingNotSpaces = /^[^ \\t\\n\\r\\u000c]+/,\n            regexTrailingCommas = /[,]+$/,\n            regexNonNegativeInteger = /^\\d+$/,\n            // ( Positive or negative or unsigned integers or decimals, without or without exponents.\n        // Must include at least one digit.\n        // According to spec tests any decimal point must be followed by a digit.\n        // No leading plus sign is allowed.)\n        // https://html.spec.whatwg.org/multipage/infrastructure.html#valid-floating-point-number\n        regexFloatingPoint = /^-?(?:[0-9]+|[0-9]*\\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/,\n            url,\n            descriptors,\n            currentDescriptor,\n            state,\n            c,\n            // 2. Let position be a pointer into input, initially pointing at the start\n        //    of the string.\n        pos = 0,\n            // 3. Let candidates be an initially empty source set.\n        candidates = []; // 4. Splitting loop: Collect a sequence of characters that are space\n        //    characters or U+002C COMMA characters. If any U+002C COMMA characters\n        //    were collected, that is a parse error.\n\n        while (true) {\n          collectCharacters(regexLeadingCommasOrSpaces); // 5. If position is past the end of input, return candidates and abort these steps.\n\n          if (pos >= inputLength) {\n            return candidates; // (we're done, this is the sole return path)\n          } // 6. Collect a sequence of characters that are not space characters,\n          //    and let that be url.\n\n\n          url = collectCharacters(regexLeadingNotSpaces); // 7. Let descriptors be a new empty list.\n\n          descriptors = []; // 8. If url ends with a U+002C COMMA character (,), follow these substeps:\n          //\t\t(1). Remove all trailing U+002C COMMA characters from url. If this removed\n          //         more than one character, that is a parse error.\n\n          if (url.slice(-1) === \",\") {\n            url = url.replace(regexTrailingCommas, \"\"); // (Jump ahead to step 9 to skip tokenization and just push the candidate).\n\n            parseDescriptors(); //\tOtherwise, follow these substeps:\n          } else {\n            tokenize();\n          } // (close else of step 8)\n          // 16. Return to the step labeled splitting loop.\n\n        } // (Close of big while loop.)\n\n        /**\n         * Tokenizes descriptor properties prior to parsing\n         * Returns undefined.\n         */\n\n\n        function tokenize() {\n          // 8.1. Descriptor tokeniser: Skip whitespace\n          collectCharacters(regexLeadingSpaces); // 8.2. Let current descriptor be the empty string.\n\n          currentDescriptor = \"\"; // 8.3. Let state be in descriptor.\n\n          state = \"in descriptor\";\n\n          while (true) {\n            // 8.4. Let c be the character at position.\n            c = input.charAt(pos); //  Do the following depending on the value of state.\n            //  For the purpose of this step, \"EOF\" is a special character representing\n            //  that position is past the end of input.\n            // In descriptor\n\n            if (state === \"in descriptor\") {\n              // Do the following, depending on the value of c:\n              // Space character\n              // If current descriptor is not empty, append current descriptor to\n              // descriptors and let current descriptor be the empty string.\n              // Set state to after descriptor.\n              if (isSpace(c)) {\n                if (currentDescriptor) {\n                  descriptors.push(currentDescriptor);\n                  currentDescriptor = \"\";\n                  state = \"after descriptor\";\n                } // U+002C COMMA (,)\n                // Advance position to the next character in input. If current descriptor\n                // is not empty, append current descriptor to descriptors. Jump to the step\n                // labeled descriptor parser.\n\n              } else if (c === \",\") {\n                pos += 1;\n\n                if (currentDescriptor) {\n                  descriptors.push(currentDescriptor);\n                }\n\n                parseDescriptors();\n                return; // U+0028 LEFT PARENTHESIS (()\n                // Append c to current descriptor. Set state to in parens.\n              } else if (c === \"(\") {\n                currentDescriptor = currentDescriptor + c;\n                state = \"in parens\"; // EOF\n                // If current descriptor is not empty, append current descriptor to\n                // descriptors. Jump to the step labeled descriptor parser.\n              } else if (c === \"\") {\n                if (currentDescriptor) {\n                  descriptors.push(currentDescriptor);\n                }\n\n                parseDescriptors();\n                return; // Anything else\n                // Append c to current descriptor.\n              } else {\n                currentDescriptor = currentDescriptor + c;\n              } // (end \"in descriptor\"\n              // In parens\n\n            } else if (state === \"in parens\") {\n              // U+0029 RIGHT PARENTHESIS ())\n              // Append c to current descriptor. Set state to in descriptor.\n              if (c === \")\") {\n                currentDescriptor = currentDescriptor + c;\n                state = \"in descriptor\"; // EOF\n                // Append current descriptor to descriptors. Jump to the step labeled\n                // descriptor parser.\n              } else if (c === \"\") {\n                descriptors.push(currentDescriptor);\n                parseDescriptors();\n                return; // Anything else\n                // Append c to current descriptor.\n              } else {\n                currentDescriptor = currentDescriptor + c;\n              } // After descriptor\n\n            } else if (state === \"after descriptor\") {\n              // Do the following, depending on the value of c:\n              // Space character: Stay in this state.\n              if (isSpace(c)) ; else if (c === \"\") {\n                parseDescriptors();\n                return; // Anything else\n                // Set state to in descriptor. Set position to the previous character in input.\n              } else {\n                state = \"in descriptor\";\n                pos -= 1;\n              }\n            } // Advance position to the next character in input.\n\n\n            pos += 1; // Repeat this step.\n          } // (close while true loop)\n\n        }\n        /**\n         * Adds descriptor properties to a candidate, pushes to the candidates array\n         * @return undefined\n         */\n        // Declared outside of the while loop so that it's only created once.\n\n\n        function parseDescriptors() {\n          // 9. Descriptor parser: Let error be no.\n          var pError = false,\n              // 10. Let width be absent.\n          // 11. Let density be absent.\n          // 12. Let future-compat-h be absent. (We're implementing it now as h)\n          w,\n              d,\n              h,\n              i,\n              candidate = {},\n              desc,\n              lastChar,\n              value,\n              intVal,\n              floatVal; // 13. For each descriptor in descriptors, run the appropriate set of steps\n          // from the following list:\n\n          for (i = 0; i < descriptors.length; i++) {\n            desc = descriptors[i];\n            lastChar = desc[desc.length - 1];\n            value = desc.substring(0, desc.length - 1);\n            intVal = parseInt(value, 10);\n            floatVal = parseFloat(value); // If the descriptor consists of a valid non-negative integer followed by\n            // a U+0077 LATIN SMALL LETTER W character\n\n            if (regexNonNegativeInteger.test(value) && lastChar === \"w\") {\n              // If width and density are not both absent, then let error be yes.\n              if (w || d) {\n                pError = true;\n              } // Apply the rules for parsing non-negative integers to the descriptor.\n              // If the result is zero, let error be yes.\n              // Otherwise, let width be the result.\n\n\n              if (intVal === 0) {\n                pError = true;\n              } else {\n                w = intVal;\n              } // If the descriptor consists of a valid floating-point number followed by\n              // a U+0078 LATIN SMALL LETTER X character\n\n            } else if (regexFloatingPoint.test(value) && lastChar === \"x\") {\n              // If width, density and future-compat-h are not all absent, then let error\n              // be yes.\n              if (w || d || h) {\n                pError = true;\n              } // Apply the rules for parsing floating-point number values to the descriptor.\n              // If the result is less than zero, let error be yes. Otherwise, let density\n              // be the result.\n\n\n              if (floatVal < 0) {\n                pError = true;\n              } else {\n                d = floatVal;\n              } // If the descriptor consists of a valid non-negative integer followed by\n              // a U+0068 LATIN SMALL LETTER H character\n\n            } else if (regexNonNegativeInteger.test(value) && lastChar === \"h\") {\n              // If height and density are not both absent, then let error be yes.\n              if (h || d) {\n                pError = true;\n              } // Apply the rules for parsing non-negative integers to the descriptor.\n              // If the result is zero, let error be yes. Otherwise, let future-compat-h\n              // be the result.\n\n\n              if (intVal === 0) {\n                pError = true;\n              } else {\n                h = intVal;\n              } // Anything else, Let error be yes.\n\n            } else {\n              pError = true;\n            }\n          } // (close step 13 for loop)\n          // 15. If error is still no, then append a new image source to candidates whose\n          // URL is url, associated with a width width if not absent and a pixel\n          // density density if not absent. Otherwise, there is a parse error.\n\n\n          if (!pError) {\n            candidate.url = url;\n\n            if (w) {\n              candidate.w = w;\n            }\n\n            if (d) {\n              candidate.d = d;\n            }\n\n            if (h) {\n              candidate.h = h;\n            }\n\n            candidates.push(candidate);\n          } else if (logger && logger.error) {\n            logger.error(\"Invalid srcset descriptor found in '\" + input + \"' at '\" + desc + \"'.\");\n          }\n        } // (close parseDescriptors fn)\n\n      };\n    });\n  });\n\n  var _require$$0$builders$5 = doc.builders,\n      concat$9 = _require$$0$builders$5.concat,\n      ifBreak$4 = _require$$0$builders$5.ifBreak,\n      join$5 = _require$$0$builders$5.join,\n      line$4 = _require$$0$builders$5.line;\n\n  function printImgSrcset(value) {\n    var srcset = parseSrcset(value, {\n      logger: {\n        error: function error(message) {\n          throw new Error(message);\n        }\n      }\n    });\n    var hasW = srcset.some(function (src) {\n      return src.w;\n    });\n    var hasH = srcset.some(function (src) {\n      return src.h;\n    });\n    var hasX = srcset.some(function (src) {\n      return src.d;\n    });\n\n    if (hasW + hasH + hasX !== 1) {\n      throw new Error(\"Mixed descriptor in srcset is not supported\");\n    }\n\n    var key = hasW ? \"w\" : hasH ? \"h\" : \"d\";\n    var unit = hasW ? \"w\" : hasH ? \"h\" : \"x\";\n\n    var getMax = function getMax(values) {\n      return Math.max.apply(Math, values);\n    };\n\n    var urls = srcset.map(function (src) {\n      return src.url;\n    });\n    var maxUrlLength = getMax(urls.map(function (url) {\n      return url.length;\n    }));\n    var descriptors = srcset.map(function (src) {\n      return src[key];\n    }).map(function (descriptor) {\n      return descriptor ? descriptor.toString() : \"\";\n    });\n    var descriptorLeftLengths = descriptors.map(function (descriptor) {\n      var index = descriptor.indexOf(\".\");\n      return index === -1 ? descriptor.length : index;\n    });\n    var maxDescriptorLeftLength = getMax(descriptorLeftLengths);\n    return join$5(concat$9([\",\", line$4]), urls.map(function (url, index) {\n      var parts = [url];\n      var descriptor = descriptors[index];\n\n      if (descriptor) {\n        var urlPadding = maxUrlLength - url.length + 1;\n        var descriptorPadding = maxDescriptorLeftLength - descriptorLeftLengths[index];\n        var alignment = \" \".repeat(urlPadding + descriptorPadding);\n        parts.push(ifBreak$4(alignment, \" \"), descriptor + unit);\n      }\n\n      return concat$9(parts);\n    }));\n  }\n\n  var syntaxAttribute = {\n    printImgSrcset: printImgSrcset\n  };\n\n  var builders = doc.builders,\n      _require$$0$utils = doc.utils,\n      stripTrailingHardline$1 = _require$$0$utils.stripTrailingHardline,\n      mapDoc$4 = _require$$0$utils.mapDoc;\n  var breakParent$2 = builders.breakParent,\n      dedentToRoot$1 = builders.dedentToRoot,\n      fill$3 = builders.fill,\n      group$9 = builders.group,\n      hardline$7 = builders.hardline,\n      ifBreak$5 = builders.ifBreak,\n      indent$5 = builders.indent,\n      join$6 = builders.join,\n      line$5 = builders.line,\n      literalline$2 = builders.literalline,\n      markAsRoot$2 = builders.markAsRoot,\n      softline$4 = builders.softline;\n  var countChars$1 = utils$3.countChars,\n      countParents$1 = utils$3.countParents,\n      dedentString$1 = utils$3.dedentString,\n      forceBreakChildren$1 = utils$3.forceBreakChildren,\n      forceBreakContent$1 = utils$3.forceBreakContent,\n      forceNextEmptyLine$1 = utils$3.forceNextEmptyLine,\n      getLastDescendant$1 = utils$3.getLastDescendant,\n      getPrettierIgnoreAttributeCommentData$1 = utils$3.getPrettierIgnoreAttributeCommentData,\n      hasPrettierIgnore$1 = utils$3.hasPrettierIgnore,\n      inferScriptParser$1 = utils$3.inferScriptParser,\n      isScriptLikeTag$1 = utils$3.isScriptLikeTag,\n      isTextLikeNode$1 = utils$3.isTextLikeNode,\n      normalizeParts$1 = utils$3.normalizeParts,\n      preferHardlineAsLeadingSpaces$1 = utils$3.preferHardlineAsLeadingSpaces,\n      shouldNotPrintClosingTag$1 = utils$3.shouldNotPrintClosingTag,\n      shouldPreserveContent$1 = utils$3.shouldPreserveContent,\n      unescapeQuoteEntities$1 = utils$3.unescapeQuoteEntities;\n  var replaceEndOfLineWith$1 = util.replaceEndOfLineWith;\n  var insertPragma$6 = pragma$3.insertPragma;\n  var printVueFor$1 = syntaxVue.printVueFor,\n      printVueSlotScope$1 = syntaxVue.printVueSlotScope,\n      isVueEventBindingExpression$1 = syntaxVue.isVueEventBindingExpression;\n  var printImgSrcset$1 = syntaxAttribute.printImgSrcset;\n\n  function concat$a(parts) {\n    var newParts = normalizeParts$1(parts);\n    return newParts.length === 0 ? \"\" : newParts.length === 1 ? newParts[0] : builders.concat(newParts);\n  }\n\n  function embed$2(path, print, textToDoc, options) {\n    var node = path.getValue();\n\n    switch (node.type) {\n      case \"text\":\n        {\n          if (isScriptLikeTag$1(node.parent)) {\n            var parser = inferScriptParser$1(node.parent);\n\n            if (parser) {\n              var value = parser === \"markdown\" ? dedentString$1(node.value.replace(/^[^\\S\\n]*?\\n/, \"\")) : node.value;\n              return builders.concat([concat$a([breakParent$2, printOpeningTagPrefix(node, options), stripTrailingHardline$1(textToDoc(value, {\n                parser: parser\n              })), printClosingTagSuffix(node, options)])]);\n            }\n          } else if (node.parent.type === \"interpolation\") {\n            return concat$a([indent$5(concat$a([line$5, textToDoc(node.value, Object.assign({\n              __isInHtmlInterpolation: true // to avoid unexpected `}}`\n\n            }, options.parser === \"angular\" ? {\n              parser: \"__ng_interpolation\",\n              trailingComma: \"none\"\n            } : options.parser === \"vue\" ? {\n              parser: \"__vue_expression\"\n            } : {\n              parser: \"__js_expression\"\n            }))])), node.parent.next && needsToBorrowPrevClosingTagEndMarker(node.parent.next) ? \" \" : line$5]);\n          }\n\n          break;\n        }\n\n      case \"attribute\":\n        {\n          if (!node.value) {\n            break;\n          } // lit-html: html`<my-element obj=${obj}></my-element>`\n\n\n          if (/^PRETTIER_HTML_PLACEHOLDER_\\d+_\\d+_IN_JS$/.test(options.originalText.slice(node.valueSpan.start.offset, node.valueSpan.end.offset))) {\n            return concat$a([node.rawName, \"=\", node.value]);\n          } // lwc: html`<my-element data-for={value}></my-element>`\n\n\n          if (options.parser === \"lwc\") {\n            var interpolationRegex = /^\\{[\\s\\S]*\\}$/;\n\n            if (interpolationRegex.test(options.originalText.slice(node.valueSpan.start.offset, node.valueSpan.end.offset))) {\n              return concat$a([node.rawName, \"=\", node.value]);\n            }\n          }\n\n          var embeddedAttributeValueDoc = printEmbeddedAttributeValue(node, function (code, opts) {\n            return (// strictly prefer single quote to avoid unnecessary html entity escape\n              textToDoc(code, Object.assign({\n                __isInHtmlAttribute: true\n              }, opts))\n            );\n          }, options);\n\n          if (embeddedAttributeValueDoc) {\n            return concat$a([node.rawName, '=\"', group$9(mapDoc$4(embeddedAttributeValueDoc, function (doc) {\n              return typeof doc === \"string\" ? doc.replace(/\"/g, \"&quot;\") : doc;\n            })), '\"']);\n          }\n\n          break;\n        }\n\n      case \"yaml\":\n        return markAsRoot$2(concat$a([\"---\", hardline$7, node.value.trim().length === 0 ? \"\" : textToDoc(node.value, {\n          parser: \"yaml\"\n        }), \"---\"]));\n    }\n  }\n\n  function genericPrint$2(path, options, print) {\n    var node = path.getValue();\n\n    switch (node.type) {\n      case \"root\":\n        // use original concat to not break stripTrailingHardline\n        return builders.concat([group$9(printChildren$1(path, options, print)), hardline$7]);\n\n      case \"element\":\n      case \"ieConditionalComment\":\n        {\n          /**\n           * do not break:\n           *\n           *     <div>{{\n           *         ~\n           *       interpolation\n           *     }}</div>\n           *            ~\n           *\n           * exception: break if the opening tag breaks\n           *\n           *     <div\n           *       long\n           *           ~\n           *       >{{\n           *         interpolation\n           *       }}</div\n           *              ~\n           *     >\n           */\n          var shouldHugContent = node.children.length === 1 && node.firstChild.type === \"interpolation\" && node.firstChild.isLeadingSpaceSensitive && !node.firstChild.hasLeadingSpaces && node.lastChild.isTrailingSpaceSensitive && !node.lastChild.hasTrailingSpaces;\n          var attrGroupId = Symbol(\"element-attr-group-id\");\n          return concat$a([group$9(concat$a([group$9(printOpeningTag(path, options, print), {\n            id: attrGroupId\n          }), node.children.length === 0 ? node.hasDanglingSpaces && node.isDanglingSpaceSensitive ? line$5 : \"\" : concat$a([forceBreakContent$1(node) ? breakParent$2 : \"\", function (childrenDoc) {\n            return shouldHugContent ? ifBreak$5(indent$5(childrenDoc), childrenDoc, {\n              groupId: attrGroupId\n            }) : isScriptLikeTag$1(node) && node.parent.type === \"root\" && options.parser === \"vue\" && !options.vueIndentScriptAndStyle ? childrenDoc : indent$5(childrenDoc);\n          }(concat$a([shouldHugContent ? ifBreak$5(softline$4, \"\", {\n            groupId: attrGroupId\n          }) : node.firstChild.hasLeadingSpaces && node.firstChild.isLeadingSpaceSensitive ? line$5 : node.firstChild.type === \"text\" && node.isWhitespaceSensitive && node.isIndentationSensitive ? dedentToRoot$1(softline$4) : softline$4, printChildren$1(path, options, print)])), (node.next ? needsToBorrowPrevClosingTagEndMarker(node.next) : needsToBorrowLastChildClosingTagEndMarker(node.parent)) ? node.lastChild.hasTrailingSpaces && node.lastChild.isTrailingSpaceSensitive ? \" \" : \"\" : shouldHugContent ? ifBreak$5(softline$4, \"\", {\n            groupId: attrGroupId\n          }) : node.lastChild.hasTrailingSpaces && node.lastChild.isTrailingSpaceSensitive ? line$5 : (node.lastChild.type === \"comment\" || node.lastChild.type === \"text\" && node.isWhitespaceSensitive && node.isIndentationSensitive) && new RegExp(\"\\\\n\\\\s{\".concat(options.tabWidth * countParents$1(path, function (n) {\n            return n.parent && n.parent.type !== \"root\";\n          }), \"}$\")).test(node.lastChild.value) ?\n          /**\n           *     <div>\n           *       <pre>\n           *         something\n           *       </pre>\n           *            ~\n           *     </div>\n           */\n          \"\" : softline$4])])), printClosingTag(node, options)]);\n        }\n\n      case \"ieConditionalStartComment\":\n      case \"ieConditionalEndComment\":\n        return concat$a([printOpeningTagStart(node), printClosingTagEnd(node)]);\n\n      case \"interpolation\":\n        return concat$a([printOpeningTagStart(node, options), concat$a(path.map(print, \"children\")), printClosingTagEnd(node, options)]);\n\n      case \"text\":\n        {\n          if (node.parent.type === \"interpolation\") {\n            // replace the trailing literalline with hardline for better readability\n            var trailingNewlineRegex = /\\n[^\\S\\n]*?$/;\n            var hasTrailingNewline = trailingNewlineRegex.test(node.value);\n            var value = hasTrailingNewline ? node.value.replace(trailingNewlineRegex, \"\") : node.value;\n            return concat$a([concat$a(replaceEndOfLineWith$1(value, literalline$2)), hasTrailingNewline ? hardline$7 : \"\"]);\n          }\n\n          return fill$3(normalizeParts$1([].concat(printOpeningTagPrefix(node, options), getTextValueParts(node), printClosingTagSuffix(node, options))));\n        }\n\n      case \"docType\":\n        return concat$a([group$9(concat$a([printOpeningTagStart(node, options), \" \", node.value.replace(/^html\\b/i, \"html\").replace(/\\s+/g, \" \")])), printClosingTagEnd(node, options)]);\n\n      case \"comment\":\n        {\n          return concat$a([printOpeningTagPrefix(node, options), concat$a(replaceEndOfLineWith$1(options.originalText.slice(options.locStart(node), options.locEnd(node)), literalline$2)), printClosingTagSuffix(node, options)]);\n        }\n\n      case \"attribute\":\n        {\n          if (node.value === null) {\n            return node.rawName;\n          }\n\n          var _value = unescapeQuoteEntities$1(node.value);\n\n          var singleQuoteCount = countChars$1(_value, \"'\");\n          var doubleQuoteCount = countChars$1(_value, '\"');\n          var quote = singleQuoteCount < doubleQuoteCount ? \"'\" : '\"';\n          return concat$a([node.rawName, concat$a([\"=\", quote, concat$a(replaceEndOfLineWith$1(quote === '\"' ? _value.replace(/\"/g, \"&quot;\") : _value.replace(/'/g, \"&apos;\"), literalline$2)), quote])]);\n        }\n\n      case \"yaml\":\n      case \"toml\":\n        return concat$a(replaceEndOfLineWith$1(node.raw, literalline$2));\n\n      default:\n        throw new Error(\"Unexpected node type \".concat(node.type));\n    }\n  }\n\n  function printChildren$1(path, options, print) {\n    var node = path.getValue();\n\n    if (forceBreakChildren$1(node)) {\n      return concat$a([breakParent$2, concat$a(path.map(function (childPath) {\n        var childNode = childPath.getValue();\n        var prevBetweenLine = !childNode.prev ? \"\" : printBetweenLine(childNode.prev, childNode);\n        return concat$a([!prevBetweenLine ? \"\" : concat$a([prevBetweenLine, forceNextEmptyLine$1(childNode.prev) ? hardline$7 : \"\"]), printChild(childPath)]);\n      }, \"children\"))]);\n    }\n\n    var groupIds = node.children.map(function () {\n      return Symbol(\"\");\n    });\n    return concat$a(path.map(function (childPath, childIndex) {\n      var childNode = childPath.getValue();\n\n      if (isTextLikeNode$1(childNode)) {\n        if (childNode.prev && isTextLikeNode$1(childNode.prev)) {\n          var _prevBetweenLine = printBetweenLine(childNode.prev, childNode);\n\n          if (_prevBetweenLine) {\n            if (forceNextEmptyLine$1(childNode.prev)) {\n              return concat$a([hardline$7, hardline$7, printChild(childPath)]);\n            }\n\n            return concat$a([_prevBetweenLine, printChild(childPath)]);\n          }\n        }\n\n        return printChild(childPath);\n      }\n\n      var prevParts = [];\n      var leadingParts = [];\n      var trailingParts = [];\n      var nextParts = [];\n      var prevBetweenLine = childNode.prev ? printBetweenLine(childNode.prev, childNode) : \"\";\n      var nextBetweenLine = childNode.next ? printBetweenLine(childNode, childNode.next) : \"\";\n\n      if (prevBetweenLine) {\n        if (forceNextEmptyLine$1(childNode.prev)) {\n          prevParts.push(hardline$7, hardline$7);\n        } else if (prevBetweenLine === hardline$7) {\n          prevParts.push(hardline$7);\n        } else {\n          if (isTextLikeNode$1(childNode.prev)) {\n            leadingParts.push(prevBetweenLine);\n          } else {\n            leadingParts.push(ifBreak$5(\"\", softline$4, {\n              groupId: groupIds[childIndex - 1]\n            }));\n          }\n        }\n      }\n\n      if (nextBetweenLine) {\n        if (forceNextEmptyLine$1(childNode)) {\n          if (isTextLikeNode$1(childNode.next)) {\n            nextParts.push(hardline$7, hardline$7);\n          }\n        } else if (nextBetweenLine === hardline$7) {\n          if (isTextLikeNode$1(childNode.next)) {\n            nextParts.push(hardline$7);\n          }\n        } else {\n          trailingParts.push(nextBetweenLine);\n        }\n      }\n\n      return concat$a([].concat(prevParts, group$9(concat$a([concat$a(leadingParts), group$9(concat$a([printChild(childPath), concat$a(trailingParts)]), {\n        id: groupIds[childIndex]\n      })])), nextParts));\n    }, \"children\"));\n\n    function printChild(childPath) {\n      var child = childPath.getValue();\n\n      if (hasPrettierIgnore$1(child)) {\n        return concat$a([].concat(printOpeningTagPrefix(child, options), replaceEndOfLineWith$1(options.originalText.slice(options.locStart(child) + (child.prev && needsToBorrowNextOpeningTagStartMarker(child.prev) ? printOpeningTagStartMarker(child).length : 0), options.locEnd(child) - (child.next && needsToBorrowPrevClosingTagEndMarker(child.next) ? printClosingTagEndMarker(child, options).length : 0)), literalline$2), printClosingTagSuffix(child, options)));\n      }\n\n      if (shouldPreserveContent$1(child, options)) {\n        return concat$a([].concat(printOpeningTagPrefix(child, options), group$9(printOpeningTag(childPath, options, print)), replaceEndOfLineWith$1(options.originalText.slice(child.startSourceSpan.end.offset + (child.firstChild && needsToBorrowParentOpeningTagEndMarker(child.firstChild) ? -printOpeningTagEndMarker(child).length : 0), child.endSourceSpan.start.offset + (child.lastChild && needsToBorrowParentClosingTagStartMarker(child.lastChild) ? printClosingTagStartMarker(child, options).length : needsToBorrowLastChildClosingTagEndMarker(child) ? -printClosingTagEndMarker(child.lastChild, options).length : 0)), literalline$2), printClosingTag(child, options), printClosingTagSuffix(child, options)));\n      }\n\n      return print(childPath);\n    }\n\n    function printBetweenLine(prevNode, nextNode) {\n      return isTextLikeNode$1(prevNode) && isTextLikeNode$1(nextNode) ? prevNode.isTrailingSpaceSensitive ? prevNode.hasTrailingSpaces ? preferHardlineAsLeadingSpaces$1(nextNode) ? hardline$7 : line$5 : \"\" : preferHardlineAsLeadingSpaces$1(nextNode) ? hardline$7 : softline$4 : needsToBorrowNextOpeningTagStartMarker(prevNode) && (\n      /**\n       *     123<a\n       *          ~\n       *       ><b>\n       */\n      nextNode.firstChild ||\n      /**\n       *     123<!--\n       *            ~\n       *     -->\n       */\n      nextNode.isSelfClosing ||\n      /**\n       *     123<span\n       *             ~\n       *       attr\n       */\n      nextNode.type === \"element\" && nextNode.attrs.length !== 0) ||\n      /**\n       *     <img\n       *       src=\"long\"\n       *                 ~\n       *     />123\n       */\n      prevNode.type === \"element\" && prevNode.isSelfClosing && needsToBorrowPrevClosingTagEndMarker(nextNode) ? \"\" : !nextNode.isLeadingSpaceSensitive || preferHardlineAsLeadingSpaces$1(nextNode) ||\n      /**\n       *       Want to write us a letter? Use our<a\n       *         ><b><a>mailing address</a></b></a\n       *                                          ~\n       *       >.\n       */\n      needsToBorrowPrevClosingTagEndMarker(nextNode) && prevNode.lastChild && needsToBorrowParentClosingTagStartMarker(prevNode.lastChild) && prevNode.lastChild.lastChild && needsToBorrowParentClosingTagStartMarker(prevNode.lastChild.lastChild) ? hardline$7 : nextNode.hasLeadingSpaces ? line$5 : softline$4;\n    }\n  }\n\n  function printOpeningTag(path, options, print) {\n    var node = path.getValue();\n    var forceNotToBreakAttrContent = node.type === \"element\" && node.fullName === \"script\" && node.attrs.length === 1 && node.attrs[0].fullName === \"src\" && node.children.length === 0;\n    return concat$a([printOpeningTagStart(node, options), !node.attrs || node.attrs.length === 0 ? node.isSelfClosing ?\n    /**\n     *     <br />\n     *        ^\n     */\n    \" \" : \"\" : concat$a([indent$5(concat$a([forceNotToBreakAttrContent ? \" \" : line$5, join$6(line$5, function (ignoreAttributeData) {\n      var hasPrettierIgnoreAttribute = typeof ignoreAttributeData === \"boolean\" ? function () {\n        return ignoreAttributeData;\n      } : Array.isArray(ignoreAttributeData) ? function (attr) {\n        return ignoreAttributeData.indexOf(attr.rawName) !== -1;\n      } : function () {\n        return false;\n      };\n      return path.map(function (attrPath) {\n        var attr = attrPath.getValue();\n        return hasPrettierIgnoreAttribute(attr) ? concat$a(replaceEndOfLineWith$1(options.originalText.slice(options.locStart(attr), options.locEnd(attr)), literalline$2)) : print(attrPath);\n      }, \"attrs\");\n    }(node.prev && node.prev.type === \"comment\" && getPrettierIgnoreAttributeCommentData$1(node.prev.value)))])),\n    /**\n     *     123<a\n     *       attr\n     *           ~\n     *       >456\n     */\n    node.firstChild && needsToBorrowParentOpeningTagEndMarker(node.firstChild) ||\n    /**\n     *     <span\n     *       >123<meta\n     *                ~\n     *     /></span>\n     */\n    node.isSelfClosing && needsToBorrowLastChildClosingTagEndMarker(node.parent) ? \"\" : node.isSelfClosing ? forceNotToBreakAttrContent ? \" \" : line$5 : forceNotToBreakAttrContent ? \"\" : softline$4]), node.isSelfClosing ? \"\" : printOpeningTagEnd(node)]);\n  }\n\n  function printOpeningTagStart(node, options) {\n    return node.prev && needsToBorrowNextOpeningTagStartMarker(node.prev) ? \"\" : concat$a([printOpeningTagPrefix(node, options), printOpeningTagStartMarker(node)]);\n  }\n\n  function printOpeningTagEnd(node) {\n    return node.firstChild && needsToBorrowParentOpeningTagEndMarker(node.firstChild) ? \"\" : printOpeningTagEndMarker(node);\n  }\n\n  function printClosingTag(node, options) {\n    return concat$a([node.isSelfClosing ? \"\" : printClosingTagStart(node, options), printClosingTagEnd(node, options)]);\n  }\n\n  function printClosingTagStart(node, options) {\n    return node.lastChild && needsToBorrowParentClosingTagStartMarker(node.lastChild) ? \"\" : concat$a([printClosingTagPrefix(node, options), printClosingTagStartMarker(node, options)]);\n  }\n\n  function printClosingTagEnd(node, options) {\n    return (node.next ? needsToBorrowPrevClosingTagEndMarker(node.next) : needsToBorrowLastChildClosingTagEndMarker(node.parent)) ? \"\" : concat$a([printClosingTagEndMarker(node, options), printClosingTagSuffix(node, options)]);\n  }\n\n  function needsToBorrowNextOpeningTagStartMarker(node) {\n    /**\n     *     123<p\n     *        ^^\n     *     >\n     */\n    return node.next && !isTextLikeNode$1(node.next) && isTextLikeNode$1(node) && node.isTrailingSpaceSensitive && !node.hasTrailingSpaces;\n  }\n\n  function needsToBorrowParentOpeningTagEndMarker(node) {\n    /**\n     *     <p\n     *       >123\n     *       ^\n     *\n     *     <p\n     *       ><a\n     *       ^\n     */\n    return !node.prev && node.isLeadingSpaceSensitive && !node.hasLeadingSpaces;\n  }\n\n  function needsToBorrowPrevClosingTagEndMarker(node) {\n    /**\n     *     <p></p\n     *     >123\n     *     ^\n     *\n     *     <p></p\n     *     ><a\n     *     ^\n     */\n    return node.prev && !isTextLikeNode$1(node.prev) && node.isLeadingSpaceSensitive && !node.hasLeadingSpaces;\n  }\n\n  function needsToBorrowLastChildClosingTagEndMarker(node) {\n    /**\n     *     <p\n     *       ><a></a\n     *       ></p\n     *       ^\n     *     >\n     */\n    return node.lastChild && node.lastChild.isTrailingSpaceSensitive && !node.lastChild.hasTrailingSpaces && !isTextLikeNode$1(getLastDescendant$1(node.lastChild));\n  }\n\n  function needsToBorrowParentClosingTagStartMarker(node) {\n    /**\n     *     <p>\n     *       123</p\n     *          ^^^\n     *     >\n     *\n     *         123</b\n     *       ></a\n     *        ^^^\n     *     >\n     */\n    return !node.next && !node.hasTrailingSpaces && node.isTrailingSpaceSensitive && isTextLikeNode$1(getLastDescendant$1(node));\n  }\n\n  function printOpeningTagPrefix(node, options) {\n    return needsToBorrowParentOpeningTagEndMarker(node) ? printOpeningTagEndMarker(node.parent) : needsToBorrowPrevClosingTagEndMarker(node) ? printClosingTagEndMarker(node.prev, options) : \"\";\n  }\n\n  function printClosingTagPrefix(node, options) {\n    return needsToBorrowLastChildClosingTagEndMarker(node) ? printClosingTagEndMarker(node.lastChild, options) : \"\";\n  }\n\n  function printClosingTagSuffix(node, options) {\n    return needsToBorrowParentClosingTagStartMarker(node) ? printClosingTagStartMarker(node.parent, options) : needsToBorrowNextOpeningTagStartMarker(node) ? printOpeningTagStartMarker(node.next) : \"\";\n  }\n\n  function printOpeningTagStartMarker(node) {\n    switch (node.type) {\n      case \"ieConditionalComment\":\n      case \"ieConditionalStartComment\":\n        return \"<!--[if \".concat(node.condition);\n\n      case \"ieConditionalEndComment\":\n        return \"<!--<!\";\n\n      case \"interpolation\":\n        return \"{{\";\n\n      case \"docType\":\n        return \"<!DOCTYPE\";\n\n      case \"element\":\n        if (node.condition) {\n          return \"<!--[if \".concat(node.condition, \"]><!--><\").concat(node.rawName);\n        }\n\n      // fall through\n\n      default:\n        return \"<\".concat(node.rawName);\n    }\n  }\n\n  function printOpeningTagEndMarker(node) {\n    assert(!node.isSelfClosing);\n\n    switch (node.type) {\n      case \"ieConditionalComment\":\n        return \"]>\";\n\n      case \"element\":\n        if (node.condition) {\n          return \"><!--<![endif]-->\";\n        }\n\n      // fall through\n\n      default:\n        return \">\";\n    }\n  }\n\n  function printClosingTagStartMarker(node, options) {\n    assert(!node.isSelfClosing);\n\n    if (shouldNotPrintClosingTag$1(node, options)) {\n      return \"\";\n    }\n\n    switch (node.type) {\n      case \"ieConditionalComment\":\n        return \"<!\";\n\n      case \"element\":\n        if (node.hasHtmComponentClosingTag) {\n          return \"<//\";\n        }\n\n      // fall through\n\n      default:\n        return \"</\".concat(node.rawName);\n    }\n  }\n\n  function printClosingTagEndMarker(node, options) {\n    if (shouldNotPrintClosingTag$1(node, options)) {\n      return \"\";\n    }\n\n    switch (node.type) {\n      case \"ieConditionalComment\":\n      case \"ieConditionalEndComment\":\n        return \"[endif]-->\";\n\n      case \"ieConditionalStartComment\":\n        return \"]><!-->\";\n\n      case \"interpolation\":\n        return \"}}\";\n\n      case \"element\":\n        if (node.isSelfClosing) {\n          return \"/>\";\n        }\n\n      // fall through\n\n      default:\n        return \">\";\n    }\n  }\n\n  function getTextValueParts(node) {\n    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node.value;\n    return node.parent.isWhitespaceSensitive ? node.parent.isIndentationSensitive ? replaceEndOfLineWith$1(value, literalline$2) : replaceEndOfLineWith$1(dedentString$1(value.replace(/^\\s*?\\n|\\n\\s*?$/g, \"\")), hardline$7) : // https://infra.spec.whatwg.org/#ascii-whitespace\n    join$6(line$5, value.split(/[\\t\\n\\f\\r ]+/)).parts;\n  }\n\n  function printEmbeddedAttributeValue(node, originalTextToDoc, options) {\n    var isKeyMatched = function isKeyMatched(patterns) {\n      return new RegExp(patterns.join(\"|\")).test(node.fullName);\n    };\n\n    var getValue = function getValue() {\n      return unescapeQuoteEntities$1(node.value);\n    };\n\n    var shouldHug = false;\n\n    var __onHtmlBindingRoot = function __onHtmlBindingRoot(root) {\n      var rootNode = root.type === \"NGRoot\" ? root.node.type === \"NGMicrosyntax\" && root.node.body.length === 1 && root.node.body[0].type === \"NGMicrosyntaxExpression\" ? root.node.body[0].expression : root.node : root.type === \"JsExpressionRoot\" ? root.node : root;\n\n      if (rootNode && (rootNode.type === \"ObjectExpression\" || rootNode.type === \"ArrayExpression\")) {\n        shouldHug = true;\n      }\n    };\n\n    var printHug = function printHug(doc) {\n      return group$9(doc);\n    };\n\n    var printExpand = function printExpand(doc) {\n      return group$9(concat$a([indent$5(concat$a([softline$4, doc])), softline$4]));\n    };\n\n    var printMaybeHug = function printMaybeHug(doc) {\n      return shouldHug ? printHug(doc) : printExpand(doc);\n    };\n\n    var textToDoc = function textToDoc(code, opts) {\n      return originalTextToDoc(code, Object.assign({\n        __onHtmlBindingRoot: __onHtmlBindingRoot\n      }, opts));\n    };\n\n    if (node.fullName === \"srcset\" && (node.parent.fullName === \"img\" || node.parent.fullName === \"source\")) {\n      return printExpand(printImgSrcset$1(getValue()));\n    }\n\n    if (options.parser === \"vue\") {\n      if (node.fullName === \"v-for\") {\n        return printVueFor$1(getValue(), textToDoc);\n      }\n\n      if (node.fullName === \"slot-scope\") {\n        return printVueSlotScope$1(getValue(), textToDoc);\n      }\n      /**\n       *     @click=\"jsStatement\"\n       *     @click=\"jsExpression\"\n       *     v-on:click=\"jsStatement\"\n       *     v-on:click=\"jsExpression\"\n       */\n\n\n      var vueEventBindingPatterns = [\"^@\", \"^v-on:\"];\n      /**\n       *     :class=\"vueExpression\"\n       *     v-bind:id=\"vueExpression\"\n       */\n\n      var vueExpressionBindingPatterns = [\"^:\", \"^v-bind:\"];\n      /**\n       *     v-if=\"jsExpression\"\n       */\n\n      var jsExpressionBindingPatterns = [\"^v-\"];\n\n      if (isKeyMatched(vueEventBindingPatterns)) {\n        var value = getValue();\n        return printMaybeHug(isVueEventBindingExpression$1(value) ? textToDoc(value, {\n          parser: \"__js_expression\"\n        }) : stripTrailingHardline$1(textToDoc(value, {\n          parser: \"__vue_event_binding\"\n        })));\n      }\n\n      if (isKeyMatched(vueExpressionBindingPatterns)) {\n        return printMaybeHug(textToDoc(getValue(), {\n          parser: \"__vue_expression\"\n        }));\n      }\n\n      if (isKeyMatched(jsExpressionBindingPatterns)) {\n        return printMaybeHug(textToDoc(getValue(), {\n          parser: \"__js_expression\"\n        }));\n      }\n    }\n\n    if (options.parser === \"angular\") {\n      var ngTextToDoc = function ngTextToDoc(code, opts) {\n        return (// angular does not allow trailing comma\n          textToDoc(code, Object.assign({\n            trailingComma: \"none\"\n          }, opts))\n        );\n      };\n      /**\n       *     *directive=\"angularDirective\"\n       */\n\n\n      var ngDirectiveBindingPatterns = [\"^\\\\*\"];\n      /**\n       *     (click)=\"angularStatement\"\n       *     on-click=\"angularStatement\"\n       */\n\n      var ngStatementBindingPatterns = [\"^\\\\(.+\\\\)$\", \"^on-\"];\n      /**\n       *     [target]=\"angularExpression\"\n       *     bind-target=\"angularExpression\"\n       *     [(target)]=\"angularExpression\"\n       *     bindon-target=\"angularExpression\"\n       */\n\n      var ngExpressionBindingPatterns = [\"^\\\\[.+\\\\]$\", \"^bind(on)?-\"];\n      /**\n       *     i18n=\"longDescription\"\n       *     i18n-attr=\"longDescription\"\n       */\n\n      var ngI18nPatterns = [\"^i18n(-.+)?$\"];\n\n      if (isKeyMatched(ngStatementBindingPatterns)) {\n        return printMaybeHug(ngTextToDoc(getValue(), {\n          parser: \"__ng_action\"\n        }));\n      }\n\n      if (isKeyMatched(ngExpressionBindingPatterns)) {\n        return printMaybeHug(ngTextToDoc(getValue(), {\n          parser: \"__ng_binding\"\n        }));\n      }\n\n      if (isKeyMatched(ngI18nPatterns)) {\n        return printExpand(fill$3(getTextValueParts(node, getValue())));\n      }\n\n      if (isKeyMatched(ngDirectiveBindingPatterns)) {\n        return printMaybeHug(ngTextToDoc(getValue(), {\n          parser: \"__ng_directive\"\n        }));\n      }\n\n      var interpolationRegex = /\\{\\{([\\s\\S]+?)\\}\\}/g;\n\n      var _value2 = getValue();\n\n      if (interpolationRegex.test(_value2)) {\n        var parts = [];\n\n        _value2.split(interpolationRegex).forEach(function (part, index) {\n          if (index % 2 === 0) {\n            parts.push(concat$a(replaceEndOfLineWith$1(part, literalline$2)));\n          } else {\n            try {\n              parts.push(group$9(concat$a([\"{{\", indent$5(concat$a([line$5, ngTextToDoc(part, {\n                parser: \"__ng_interpolation\",\n                __isInHtmlInterpolation: true // to avoid unexpected `}}`\n\n              })])), line$5, \"}}\"])));\n            } catch (e) {\n              parts.push(\"{{\", concat$a(replaceEndOfLineWith$1(part, literalline$2)), \"}}\");\n            }\n          }\n        });\n\n        return group$9(concat$a(parts));\n      }\n    }\n\n    return null;\n  }\n\n  var printerHtml = {\n    preprocess: preprocess_1,\n    print: genericPrint$2,\n    insertPragma: insertPragma$6,\n    massageAstNode: clean$3,\n    embed: embed$2\n  };\n\n  var CATEGORY_HTML = \"HTML\"; // format based on https://github.com/prettier/prettier/blob/master/src/main/core-options.js\n\n  var options$4 = {\n    htmlWhitespaceSensitivity: {\n      since: \"1.15.0\",\n      category: CATEGORY_HTML,\n      type: \"choice\",\n      default: \"css\",\n      description: \"How to handle whitespaces in HTML.\",\n      choices: [{\n        value: \"css\",\n        description: \"Respect the default value of CSS display property.\"\n      }, {\n        value: \"strict\",\n        description: \"Whitespaces are considered sensitive.\"\n      }, {\n        value: \"ignore\",\n        description: \"Whitespaces are considered insensitive.\"\n      }]\n    },\n    vueIndentScriptAndStyle: {\n      since: \"1.19.0\",\n      category: CATEGORY_HTML,\n      type: \"boolean\",\n      default: false,\n      description: \"Indent script and style tags in Vue files.\"\n    }\n  };\n\n  var name$7 = \"HTML\";\n  var type$6 = \"markup\";\n  var tmScope$6 = \"text.html.basic\";\n  var aceMode$6 = \"html\";\n  var codemirrorMode$3 = \"htmlmixed\";\n  var codemirrorMimeType$3 = \"text/html\";\n  var color$1 = \"#e34c26\";\n  var aliases$1 = [\n  \t\"xhtml\"\n  ];\n  var extensions$6 = [\n  \t\".html\",\n  \t\".htm\",\n  \t\".html.hl\",\n  \t\".inc\",\n  \t\".st\",\n  \t\".xht\",\n  \t\".xhtml\"\n  ];\n  var languageId$6 = 146;\n  var HTML = {\n  \tname: name$7,\n  \ttype: type$6,\n  \ttmScope: tmScope$6,\n  \taceMode: aceMode$6,\n  \tcodemirrorMode: codemirrorMode$3,\n  \tcodemirrorMimeType: codemirrorMimeType$3,\n  \tcolor: color$1,\n  \taliases: aliases$1,\n  \textensions: extensions$6,\n  \tlanguageId: languageId$6\n  };\n\n  var HTML$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    name: name$7,\n    type: type$6,\n    tmScope: tmScope$6,\n    aceMode: aceMode$6,\n    codemirrorMode: codemirrorMode$3,\n    codemirrorMimeType: codemirrorMimeType$3,\n    color: color$1,\n    aliases: aliases$1,\n    extensions: extensions$6,\n    languageId: languageId$6,\n    'default': HTML\n  });\n\n  var name$8 = \"Vue\";\n  var type$7 = \"markup\";\n  var color$2 = \"#2c3e50\";\n  var extensions$7 = [\n  \t\".vue\"\n  ];\n  var tmScope$7 = \"text.html.vue\";\n  var aceMode$7 = \"html\";\n  var languageId$7 = 391;\n  var Vue = {\n  \tname: name$8,\n  \ttype: type$7,\n  \tcolor: color$2,\n  \textensions: extensions$7,\n  \ttmScope: tmScope$7,\n  \taceMode: aceMode$7,\n  \tlanguageId: languageId$7\n  };\n\n  var Vue$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    name: name$8,\n    type: type$7,\n    color: color$2,\n    extensions: extensions$7,\n    tmScope: tmScope$7,\n    aceMode: aceMode$7,\n    languageId: languageId$7,\n    'default': Vue\n  });\n\n  var require$$0$5 = getCjsExportFromNamespace(HTML$1);\n\n  var require$$1$1 = getCjsExportFromNamespace(Vue$1);\n\n  var languages$3 = [createLanguage(require$$0$5, function (data) {\n    return Object.assign(data, {\n      name: \"Angular\",\n      since: \"1.15.0\",\n      parsers: [\"angular\"],\n      vscodeLanguageIds: [\"html\"],\n      extensions: [\".component.html\"],\n      filenames: []\n    });\n  }), createLanguage(require$$0$5, function (data) {\n    return Object.assign(data, {\n      since: \"1.15.0\",\n      parsers: [\"html\"],\n      vscodeLanguageIds: [\"html\"],\n      extensions: data.extensions.concat([\".mjml\" // MJML is considered XML in Linguist but it should be formatted as HTML\n      ])\n    });\n  }), createLanguage(require$$0$5, function (data) {\n    return Object.assign(data, {\n      name: \"Lightning Web Components\",\n      since: \"1.17.0\",\n      parsers: [\"lwc\"],\n      vscodeLanguageIds: [\"html\"],\n      extensions: [],\n      filenames: []\n    });\n  }), createLanguage(require$$1$1, function (data) {\n    return Object.assign(data, {\n      since: \"1.10.0\",\n      parsers: [\"vue\"],\n      vscodeLanguageIds: [\"vue\"]\n    });\n  })];\n  var printers$3 = {\n    html: printerHtml\n  };\n  var languageHtml = {\n    languages: languages$3,\n    printers: printers$3,\n    options: options$4\n  };\n\n  var addLeadingComment$2 = utilShared.addLeadingComment,\n      addTrailingComment$2 = utilShared.addTrailingComment,\n      addDanglingComment$2 = utilShared.addDanglingComment;\n\n  function handleOwnLineComment(comment, text, options, ast, isLastComment) {\n    var precedingNode = comment.precedingNode,\n        enclosingNode = comment.enclosingNode,\n        followingNode = comment.followingNode;\n\n    if (handleLastFunctionArgComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleMemberExpressionComments(enclosingNode, followingNode, comment) || handleIfStatementComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleWhileComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleTryStatementComments(enclosingNode, precedingNode, followingNode, comment) || handleClassComments(enclosingNode, precedingNode, followingNode, comment) || handleImportSpecifierComments(enclosingNode, comment) || handleForComments(enclosingNode, precedingNode, comment) || handleUnionTypeComments(precedingNode, enclosingNode, followingNode, comment) || handleOnlyComments(enclosingNode, ast, comment, isLastComment) || handleImportDeclarationComments(text, enclosingNode, precedingNode, comment, options) || handleAssignmentPatternComments(enclosingNode, comment) || handleMethodNameComments(text, enclosingNode, precedingNode, comment, options)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  function handleEndOfLineComment(comment, text, options, ast, isLastComment) {\n    var precedingNode = comment.precedingNode,\n        enclosingNode = comment.enclosingNode,\n        followingNode = comment.followingNode;\n\n    if (handleLastFunctionArgComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleConditionalExpressionComments(enclosingNode, precedingNode, followingNode, comment, text, options) || handleImportSpecifierComments(enclosingNode, comment) || handleIfStatementComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleWhileComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleTryStatementComments(enclosingNode, precedingNode, followingNode, comment) || handleClassComments(enclosingNode, precedingNode, followingNode, comment) || handleLabeledStatementComments(enclosingNode, comment) || handleCallExpressionComments(precedingNode, enclosingNode, comment) || handlePropertyComments(enclosingNode, comment) || handleOnlyComments(enclosingNode, ast, comment, isLastComment) || handleTypeAliasComments(enclosingNode, followingNode, comment) || handleVariableDeclaratorComments(enclosingNode, followingNode, comment)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  function handleRemainingComment(comment, text, options, ast, isLastComment) {\n    var precedingNode = comment.precedingNode,\n        enclosingNode = comment.enclosingNode,\n        followingNode = comment.followingNode;\n\n    if (handleIfStatementComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleWhileComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleObjectPropertyAssignment(enclosingNode, precedingNode, comment) || handleCommentInEmptyParens(text, enclosingNode, comment, options) || handleMethodNameComments(text, enclosingNode, precedingNode, comment, options) || handleOnlyComments(enclosingNode, ast, comment, isLastComment) || handleCommentAfterArrowParams(text, enclosingNode, comment, options) || handleFunctionNameComments(text, enclosingNode, precedingNode, comment, options) || handleTSMappedTypeComments(text, enclosingNode, precedingNode, followingNode, comment) || handleBreakAndContinueStatementComments(enclosingNode, comment)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  function addBlockStatementFirstComment(node, comment) {\n    var body = node.body.filter(function (n) {\n      return n.type !== \"EmptyStatement\";\n    });\n\n    if (body.length === 0) {\n      addDanglingComment$2(node, comment);\n    } else {\n      addLeadingComment$2(body[0], comment);\n    }\n  }\n\n  function addBlockOrNotComment(node, comment) {\n    if (node.type === \"BlockStatement\") {\n      addBlockStatementFirstComment(node, comment);\n    } else {\n      addLeadingComment$2(node, comment);\n    }\n  } // There are often comments before the else clause of if statements like\n  //\n  //   if (1) { ... }\n  //   // comment\n  //   else { ... }\n  //\n  // They are being attached as leading comments of the BlockExpression which\n  // is not well printed. What we want is to instead move the comment inside\n  // of the block and make it leadingComment of the first element of the block\n  // or dangling comment of the block if there is nothing inside\n  //\n  //   if (1) { ... }\n  //   else {\n  //     // comment\n  //     ...\n  //   }\n\n\n  function handleIfStatementComments(text, precedingNode, enclosingNode, followingNode, comment, options) {\n    if (!enclosingNode || enclosingNode.type !== \"IfStatement\" || !followingNode) {\n      return false;\n    } // We unfortunately have no way using the AST or location of nodes to know\n    // if the comment is positioned before the condition parenthesis:\n    //   if (a /* comment */) {}\n    // The only workaround I found is to look at the next character to see if\n    // it is a ).\n\n\n    var nextCharacter = util.getNextNonSpaceNonCommentCharacter(text, comment, options.locEnd);\n\n    if (nextCharacter === \")\") {\n      addTrailingComment$2(precedingNode, comment);\n      return true;\n    } // Comments before `else`:\n    // - treat as trailing comments of the consequent, if it's a BlockStatement\n    // - treat as a dangling comment otherwise\n\n\n    if (precedingNode === enclosingNode.consequent && followingNode === enclosingNode.alternate) {\n      if (precedingNode.type === \"BlockStatement\") {\n        addTrailingComment$2(precedingNode, comment);\n      } else {\n        addDanglingComment$2(enclosingNode, comment);\n      }\n\n      return true;\n    }\n\n    if (followingNode.type === \"BlockStatement\") {\n      addBlockStatementFirstComment(followingNode, comment);\n      return true;\n    }\n\n    if (followingNode.type === \"IfStatement\") {\n      addBlockOrNotComment(followingNode.consequent, comment);\n      return true;\n    } // For comments positioned after the condition parenthesis in an if statement\n    // before the consequent without brackets on, such as\n    // if (a) /* comment */ true,\n    // we look at the next character to see if the following node\n    // is the consequent for the if statement\n\n\n    if (enclosingNode.consequent === followingNode) {\n      addLeadingComment$2(followingNode, comment);\n      return true;\n    }\n\n    return false;\n  }\n\n  function handleWhileComments(text, precedingNode, enclosingNode, followingNode, comment, options) {\n    if (!enclosingNode || enclosingNode.type !== \"WhileStatement\" || !followingNode) {\n      return false;\n    } // We unfortunately have no way using the AST or location of nodes to know\n    // if the comment is positioned before the condition parenthesis:\n    //   while (a /* comment */) {}\n    // The only workaround I found is to look at the next character to see if\n    // it is a ).\n\n\n    var nextCharacter = util.getNextNonSpaceNonCommentCharacter(text, comment, options.locEnd);\n\n    if (nextCharacter === \")\") {\n      addTrailingComment$2(precedingNode, comment);\n      return true;\n    }\n\n    if (followingNode.type === \"BlockStatement\") {\n      addBlockStatementFirstComment(followingNode, comment);\n      return true;\n    }\n\n    return false;\n  } // Same as IfStatement but for TryStatement\n\n\n  function handleTryStatementComments(enclosingNode, precedingNode, followingNode, comment) {\n    if (!enclosingNode || enclosingNode.type !== \"TryStatement\" && enclosingNode.type !== \"CatchClause\" || !followingNode) {\n      return false;\n    }\n\n    if (enclosingNode.type === \"CatchClause\" && precedingNode) {\n      addTrailingComment$2(precedingNode, comment);\n      return true;\n    }\n\n    if (followingNode.type === \"BlockStatement\") {\n      addBlockStatementFirstComment(followingNode, comment);\n      return true;\n    }\n\n    if (followingNode.type === \"TryStatement\") {\n      addBlockOrNotComment(followingNode.finalizer, comment);\n      return true;\n    }\n\n    if (followingNode.type === \"CatchClause\") {\n      addBlockOrNotComment(followingNode.body, comment);\n      return true;\n    }\n\n    return false;\n  }\n\n  function handleMemberExpressionComments(enclosingNode, followingNode, comment) {\n    if (enclosingNode && (enclosingNode.type === \"MemberExpression\" || enclosingNode.type === \"OptionalMemberExpression\") && followingNode && followingNode.type === \"Identifier\") {\n      addLeadingComment$2(enclosingNode, comment);\n      return true;\n    }\n\n    return false;\n  }\n\n  function handleConditionalExpressionComments(enclosingNode, precedingNode, followingNode, comment, text, options) {\n    var isSameLineAsPrecedingNode = precedingNode && !util.hasNewlineInRange(text, options.locEnd(precedingNode), options.locStart(comment));\n\n    if ((!precedingNode || !isSameLineAsPrecedingNode) && enclosingNode && enclosingNode.type === \"ConditionalExpression\" && followingNode) {\n      addLeadingComment$2(followingNode, comment);\n      return true;\n    }\n\n    return false;\n  }\n\n  function handleObjectPropertyAssignment(enclosingNode, precedingNode, comment) {\n    if (enclosingNode && (enclosingNode.type === \"ObjectProperty\" || enclosingNode.type === \"Property\") && enclosingNode.shorthand && enclosingNode.key === precedingNode && enclosingNode.value.type === \"AssignmentPattern\") {\n      addTrailingComment$2(enclosingNode.value.left, comment);\n      return true;\n    }\n\n    return false;\n  }\n\n  function handleClassComments(enclosingNode, precedingNode, followingNode, comment) {\n    if (enclosingNode && (enclosingNode.type === \"ClassDeclaration\" || enclosingNode.type === \"ClassExpression\") && enclosingNode.decorators && enclosingNode.decorators.length > 0 && !(followingNode && followingNode.type === \"Decorator\")) {\n      if (!enclosingNode.decorators || enclosingNode.decorators.length === 0) {\n        addLeadingComment$2(enclosingNode, comment);\n      } else {\n        addTrailingComment$2(enclosingNode.decorators[enclosingNode.decorators.length - 1], comment);\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  function handleMethodNameComments(text, enclosingNode, precedingNode, comment, options) {\n    // This is only needed for estree parsers (flow, typescript) to attach\n    // after a method name:\n    // obj = { fn /*comment*/() {} };\n    if (enclosingNode && precedingNode && (enclosingNode.type === \"Property\" || enclosingNode.type === \"MethodDefinition\") && precedingNode.type === \"Identifier\" && enclosingNode.key === precedingNode && // special Property case: { key: /*comment*/(value) };\n    // comment should be attached to value instead of key\n    util.getNextNonSpaceNonCommentCharacter(text, precedingNode, options.locEnd) !== \":\") {\n      addTrailingComment$2(precedingNode, comment);\n      return true;\n    } // Print comments between decorators and class methods as a trailing comment\n    // on the decorator node instead of the method node\n\n\n    if (precedingNode && enclosingNode && precedingNode.type === \"Decorator\" && (enclosingNode.type === \"ClassMethod\" || enclosingNode.type === \"ClassProperty\" || enclosingNode.type === \"TSAbstractClassProperty\" || enclosingNode.type === \"TSAbstractMethodDefinition\" || enclosingNode.type === \"MethodDefinition\")) {\n      addTrailingComment$2(precedingNode, comment);\n      return true;\n    }\n\n    return false;\n  }\n\n  function handleFunctionNameComments(text, enclosingNode, precedingNode, comment, options) {\n    if (util.getNextNonSpaceNonCommentCharacter(text, comment, options.locEnd) !== \"(\") {\n      return false;\n    }\n\n    if (precedingNode && enclosingNode && (enclosingNode.type === \"FunctionDeclaration\" || enclosingNode.type === \"FunctionExpression\" || enclosingNode.type === \"ClassMethod\" || enclosingNode.type === \"MethodDefinition\" || enclosingNode.type === \"ObjectMethod\")) {\n      addTrailingComment$2(precedingNode, comment);\n      return true;\n    }\n\n    return false;\n  }\n\n  function handleCommentAfterArrowParams(text, enclosingNode, comment, options) {\n    if (!(enclosingNode && enclosingNode.type === \"ArrowFunctionExpression\")) {\n      return false;\n    }\n\n    var index = utilShared.getNextNonSpaceNonCommentCharacterIndex(text, comment, options);\n\n    if (text.substr(index, 2) === \"=>\") {\n      addDanglingComment$2(enclosingNode, comment);\n      return true;\n    }\n\n    return false;\n  }\n\n  function handleCommentInEmptyParens(text, enclosingNode, comment, options) {\n    if (util.getNextNonSpaceNonCommentCharacter(text, comment, options.locEnd) !== \")\") {\n      return false;\n    } // Only add dangling comments to fix the case when no params are present,\n    // i.e. a function without any argument.\n\n\n    if (enclosingNode && ((enclosingNode.type === \"FunctionDeclaration\" || enclosingNode.type === \"FunctionExpression\" || enclosingNode.type === \"ArrowFunctionExpression\" || enclosingNode.type === \"ClassMethod\" || enclosingNode.type === \"ObjectMethod\") && enclosingNode.params.length === 0 || (enclosingNode.type === \"CallExpression\" || enclosingNode.type === \"OptionalCallExpression\" || enclosingNode.type === \"NewExpression\") && enclosingNode.arguments.length === 0)) {\n      addDanglingComment$2(enclosingNode, comment);\n      return true;\n    }\n\n    if (enclosingNode && enclosingNode.type === \"MethodDefinition\" && enclosingNode.value.params.length === 0) {\n      addDanglingComment$2(enclosingNode.value, comment);\n      return true;\n    }\n\n    return false;\n  }\n\n  function handleLastFunctionArgComments(text, precedingNode, enclosingNode, followingNode, comment, options) {\n    // Type definitions functions\n    if (precedingNode && precedingNode.type === \"FunctionTypeParam\" && enclosingNode && enclosingNode.type === \"FunctionTypeAnnotation\" && followingNode && followingNode.type !== \"FunctionTypeParam\") {\n      addTrailingComment$2(precedingNode, comment);\n      return true;\n    } // Real functions\n\n\n    if (precedingNode && (precedingNode.type === \"Identifier\" || precedingNode.type === \"AssignmentPattern\") && enclosingNode && (enclosingNode.type === \"ArrowFunctionExpression\" || enclosingNode.type === \"FunctionExpression\" || enclosingNode.type === \"FunctionDeclaration\" || enclosingNode.type === \"ObjectMethod\" || enclosingNode.type === \"ClassMethod\") && util.getNextNonSpaceNonCommentCharacter(text, comment, options.locEnd) === \")\") {\n      addTrailingComment$2(precedingNode, comment);\n      return true;\n    }\n\n    if (enclosingNode && enclosingNode.type === \"FunctionDeclaration\" && followingNode && followingNode.type === \"BlockStatement\") {\n      var functionParamRightParenIndex = function () {\n        if (enclosingNode.params.length !== 0) {\n          return util.getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, options.locEnd(util.getLast(enclosingNode.params)));\n        }\n\n        var functionParamLeftParenIndex = util.getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, options.locEnd(enclosingNode.id));\n        return util.getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, functionParamLeftParenIndex + 1);\n      }();\n\n      if (options.locStart(comment) > functionParamRightParenIndex) {\n        addBlockStatementFirstComment(followingNode, comment);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function handleImportSpecifierComments(enclosingNode, comment) {\n    if (enclosingNode && enclosingNode.type === \"ImportSpecifier\") {\n      addLeadingComment$2(enclosingNode, comment);\n      return true;\n    }\n\n    return false;\n  }\n\n  function handleLabeledStatementComments(enclosingNode, comment) {\n    if (enclosingNode && enclosingNode.type === \"LabeledStatement\") {\n      addLeadingComment$2(enclosingNode, comment);\n      return true;\n    }\n\n    return false;\n  }\n\n  function handleBreakAndContinueStatementComments(enclosingNode, comment) {\n    if (enclosingNode && (enclosingNode.type === \"ContinueStatement\" || enclosingNode.type === \"BreakStatement\") && !enclosingNode.label) {\n      addTrailingComment$2(enclosingNode, comment);\n      return true;\n    }\n\n    return false;\n  }\n\n  function handleCallExpressionComments(precedingNode, enclosingNode, comment) {\n    if (enclosingNode && (enclosingNode.type === \"CallExpression\" || enclosingNode.type === \"OptionalCallExpression\") && precedingNode && enclosingNode.callee === precedingNode && enclosingNode.arguments.length > 0) {\n      addLeadingComment$2(enclosingNode.arguments[0], comment);\n      return true;\n    }\n\n    return false;\n  }\n\n  function handleUnionTypeComments(precedingNode, enclosingNode, followingNode, comment) {\n    if (enclosingNode && (enclosingNode.type === \"UnionTypeAnnotation\" || enclosingNode.type === \"TSUnionType\")) {\n      addTrailingComment$2(precedingNode, comment);\n      return true;\n    }\n\n    return false;\n  }\n\n  function handlePropertyComments(enclosingNode, comment) {\n    if (enclosingNode && (enclosingNode.type === \"Property\" || enclosingNode.type === \"ObjectProperty\")) {\n      addLeadingComment$2(enclosingNode, comment);\n      return true;\n    }\n\n    return false;\n  }\n\n  function handleOnlyComments(enclosingNode, ast, comment, isLastComment) {\n    // With Flow the enclosingNode is undefined so use the AST instead.\n    if (ast && ast.body && ast.body.length === 0) {\n      if (isLastComment) {\n        addDanglingComment$2(ast, comment);\n      } else {\n        addLeadingComment$2(ast, comment);\n      }\n\n      return true;\n    } else if (enclosingNode && enclosingNode.type === \"Program\" && enclosingNode.body.length === 0 && enclosingNode.directives && enclosingNode.directives.length === 0) {\n      if (isLastComment) {\n        addDanglingComment$2(enclosingNode, comment);\n      } else {\n        addLeadingComment$2(enclosingNode, comment);\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  function handleForComments(enclosingNode, precedingNode, comment) {\n    if (enclosingNode && (enclosingNode.type === \"ForInStatement\" || enclosingNode.type === \"ForOfStatement\")) {\n      addLeadingComment$2(enclosingNode, comment);\n      return true;\n    }\n\n    return false;\n  }\n\n  function handleImportDeclarationComments(text, enclosingNode, precedingNode, comment, options) {\n    if (precedingNode && precedingNode.type === \"ImportSpecifier\" && enclosingNode && enclosingNode.type === \"ImportDeclaration\" && util.hasNewline(text, options.locEnd(comment))) {\n      addTrailingComment$2(precedingNode, comment);\n      return true;\n    }\n\n    return false;\n  }\n\n  function handleAssignmentPatternComments(enclosingNode, comment) {\n    if (enclosingNode && enclosingNode.type === \"AssignmentPattern\") {\n      addLeadingComment$2(enclosingNode, comment);\n      return true;\n    }\n\n    return false;\n  }\n\n  function handleTypeAliasComments(enclosingNode, followingNode, comment) {\n    if (enclosingNode && enclosingNode.type === \"TypeAlias\") {\n      addLeadingComment$2(enclosingNode, comment);\n      return true;\n    }\n\n    return false;\n  }\n\n  function handleVariableDeclaratorComments(enclosingNode, followingNode, comment) {\n    if (enclosingNode && (enclosingNode.type === \"VariableDeclarator\" || enclosingNode.type === \"AssignmentExpression\") && followingNode && (followingNode.type === \"ObjectExpression\" || followingNode.type === \"ArrayExpression\" || followingNode.type === \"TemplateLiteral\" || followingNode.type === \"TaggedTemplateExpression\")) {\n      addLeadingComment$2(followingNode, comment);\n      return true;\n    }\n\n    return false;\n  }\n\n  function handleTSMappedTypeComments(text, enclosingNode, precedingNode, followingNode, comment) {\n    if (!enclosingNode || enclosingNode.type !== \"TSMappedType\") {\n      return false;\n    }\n\n    if (followingNode && followingNode.type === \"TSTypeParameter\" && followingNode.name) {\n      addLeadingComment$2(followingNode.name, comment);\n      return true;\n    }\n\n    if (precedingNode && precedingNode.type === \"TSTypeParameter\" && precedingNode.constraint) {\n      addTrailingComment$2(precedingNode.constraint, comment);\n      return true;\n    }\n\n    return false;\n  }\n\n  function isBlockComment(comment) {\n    return comment.type === \"Block\" || comment.type === \"CommentBlock\";\n  }\n\n  function hasLeadingComment(node) {\n    var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n      return true;\n    };\n\n    if (node.leadingComments) {\n      return node.leadingComments.some(fn);\n    }\n\n    if (node.comments) {\n      return node.comments.some(function (comment) {\n        return comment.leading && fn(comment);\n      });\n    }\n\n    return false;\n  }\n\n  var comments$1 = {\n    handleOwnLineComment: handleOwnLineComment,\n    handleEndOfLineComment: handleEndOfLineComment,\n    handleRemainingComment: handleRemainingComment,\n    hasLeadingComment: hasLeadingComment,\n    isBlockComment: isBlockComment\n  };\n\n  var isBlockComment$1 = comments$1.isBlockComment,\n      hasLeadingComment$1 = comments$1.hasLeadingComment;\n  var _require$$1$builders = doc.builders,\n      indent$6 = _require$$1$builders.indent,\n      join$7 = _require$$1$builders.join,\n      hardline$8 = _require$$1$builders.hardline,\n      softline$5 = _require$$1$builders.softline,\n      literalline$3 = _require$$1$builders.literalline,\n      concat$b = _require$$1$builders.concat,\n      group$a = _require$$1$builders.group,\n      dedentToRoot$2 = _require$$1$builders.dedentToRoot,\n      _require$$1$utils = doc.utils,\n      mapDoc$5 = _require$$1$utils.mapDoc,\n      stripTrailingHardline$2 = _require$$1$utils.stripTrailingHardline;\n\n  function embed$3(path, print, textToDoc, options) {\n    var node = path.getValue();\n    var parent = path.getParentNode();\n    var parentParent = path.getParentNode(1);\n\n    switch (node.type) {\n      case \"TemplateLiteral\":\n        {\n          var isCss = [isStyledJsx, isStyledComponents, isCssProp, isAngularComponentStyles].some(function (isIt) {\n            return isIt(path);\n          });\n\n          if (isCss) {\n            // Get full template literal with expressions replaced by placeholders\n            var rawQuasis = node.quasis.map(function (q) {\n              return q.value.raw;\n            });\n            var placeholderID = 0;\n            var text = rawQuasis.reduce(function (prevVal, currVal, idx) {\n              return idx == 0 ? currVal : prevVal + \"@prettier-placeholder-\" + placeholderID++ + \"-id\" + currVal;\n            }, \"\");\n            var doc = textToDoc(text, {\n              parser: \"css\"\n            });\n            return transformCssDoc(doc, path, print);\n          }\n          /*\n           * react-relay and graphql-tag\n           * graphql`...`\n           * graphql.experimental`...`\n           * gql`...`\n           *\n           * This intentionally excludes Relay Classic tags, as Prettier does not\n           * support Relay Classic formatting.\n           */\n\n\n          if (isGraphQL(path)) {\n            var expressionDocs = node.expressions ? path.map(print, \"expressions\") : [];\n            var numQuasis = node.quasis.length;\n\n            if (numQuasis === 1 && node.quasis[0].value.raw.trim() === \"\") {\n              return \"``\";\n            }\n\n            var parts = [];\n\n            for (var i = 0; i < numQuasis; i++) {\n              var templateElement = node.quasis[i];\n              var isFirst = i === 0;\n              var isLast = i === numQuasis - 1;\n              var _text = templateElement.value.cooked; // Bail out if any of the quasis have an invalid escape sequence\n              // (which would make the `cooked` value be `null` or `undefined`)\n\n              if (typeof _text !== \"string\") {\n                return null;\n              }\n\n              var lines = _text.split(\"\\n\");\n\n              var numLines = lines.length;\n              var expressionDoc = expressionDocs[i];\n              var startsWithBlankLine = numLines > 2 && lines[0].trim() === \"\" && lines[1].trim() === \"\";\n              var endsWithBlankLine = numLines > 2 && lines[numLines - 1].trim() === \"\" && lines[numLines - 2].trim() === \"\";\n              var commentsAndWhitespaceOnly = lines.every(function (line) {\n                return /^\\s*(?:#[^\\r\\n]*)?$/.test(line);\n              }); // Bail out if an interpolation occurs within a comment.\n\n              if (!isLast && /#[^\\r\\n]*$/.test(lines[numLines - 1])) {\n                return null;\n              }\n\n              var _doc = null;\n\n              if (commentsAndWhitespaceOnly) {\n                _doc = printGraphqlComments(lines);\n              } else {\n                _doc = stripTrailingHardline$2(textToDoc(_text, {\n                  parser: \"graphql\"\n                }));\n              }\n\n              if (_doc) {\n                _doc = escapeTemplateCharacters(_doc, false);\n\n                if (!isFirst && startsWithBlankLine) {\n                  parts.push(\"\");\n                }\n\n                parts.push(_doc);\n\n                if (!isLast && endsWithBlankLine) {\n                  parts.push(\"\");\n                }\n              } else if (!isFirst && !isLast && startsWithBlankLine) {\n                parts.push(\"\");\n              }\n\n              if (expressionDoc) {\n                parts.push(concat$b([\"${\", expressionDoc, \"}\"]));\n              }\n            }\n\n            return concat$b([\"`\", indent$6(concat$b([hardline$8, join$7(hardline$8, parts)])), hardline$8, \"`\"]);\n          }\n\n          var htmlParser = isHtml(path) ? \"html\" : isAngularComponentTemplate(path) ? \"angular\" : undefined;\n\n          if (htmlParser) {\n            return printHtmlTemplateLiteral(path, print, textToDoc, htmlParser, options.embeddedInHtml);\n          }\n\n          break;\n        }\n\n      case \"TemplateElement\":\n        {\n          /**\n           * md`...`\n           * markdown`...`\n           */\n          if (parentParent && parentParent.type === \"TaggedTemplateExpression\" && parent.quasis.length === 1 && parentParent.tag.type === \"Identifier\" && (parentParent.tag.name === \"md\" || parentParent.tag.name === \"markdown\")) {\n            var _text2 = parent.quasis[0].value.raw.replace(/((?:\\\\\\\\)*)\\\\`/g, function (_, backslashes) {\n              return \"\\\\\".repeat(backslashes.length / 2) + \"`\";\n            });\n\n            var indentation = getIndentation(_text2);\n            var hasIndent = indentation !== \"\";\n            return concat$b([hasIndent ? indent$6(concat$b([softline$5, printMarkdown(_text2.replace(new RegExp(\"^\".concat(indentation), \"gm\"), \"\"))])) : concat$b([literalline$3, dedentToRoot$2(printMarkdown(_text2))]), softline$5]);\n          }\n\n          break;\n        }\n    }\n\n    function printMarkdown(text) {\n      var doc = textToDoc(text, {\n        parser: \"markdown\",\n        __inJsTemplate: true\n      });\n      return stripTrailingHardline$2(escapeTemplateCharacters(doc, true));\n    }\n  }\n\n  function getIndentation(str) {\n    var firstMatchedIndent = str.match(/^([^\\S\\n]*)\\S/m);\n    return firstMatchedIndent === null ? \"\" : firstMatchedIndent[1];\n  }\n\n  function uncook(cookedValue) {\n    return cookedValue.replace(/([\\\\`]|\\$\\{)/g, \"\\\\$1\");\n  }\n\n  function escapeTemplateCharacters(doc, raw) {\n    return mapDoc$5(doc, function (currentDoc) {\n      if (!currentDoc.parts) {\n        return currentDoc;\n      }\n\n      var parts = [];\n      currentDoc.parts.forEach(function (part) {\n        if (typeof part === \"string\") {\n          parts.push(raw ? part.replace(/(\\\\*)`/g, \"$1$1\\\\`\") : uncook(part));\n        } else {\n          parts.push(part);\n        }\n      });\n      return Object.assign({}, currentDoc, {\n        parts: parts\n      });\n    });\n  }\n\n  function transformCssDoc(quasisDoc, path, print) {\n    var parentNode = path.getValue();\n    var isEmpty = parentNode.quasis.length === 1 && !parentNode.quasis[0].value.raw.trim();\n\n    if (isEmpty) {\n      return \"``\";\n    }\n\n    var expressionDocs = parentNode.expressions ? path.map(print, \"expressions\") : [];\n    var newDoc = replacePlaceholders(quasisDoc, expressionDocs);\n    /* istanbul ignore if */\n\n    if (!newDoc) {\n      throw new Error(\"Couldn't insert all the expressions\");\n    }\n\n    return concat$b([\"`\", indent$6(concat$b([hardline$8, stripTrailingHardline$2(newDoc)])), softline$5, \"`\"]);\n  } // Search all the placeholders in the quasisDoc tree\n  // and replace them with the expression docs one by one\n  // returns a new doc with all the placeholders replaced,\n  // or null if it couldn't replace any expression\n\n\n  function replacePlaceholders(quasisDoc, expressionDocs) {\n    if (!expressionDocs || !expressionDocs.length) {\n      return quasisDoc;\n    }\n\n    var expressions = expressionDocs.slice();\n    var replaceCounter = 0;\n    var newDoc = mapDoc$5(quasisDoc, function (doc) {\n      if (!doc || !doc.parts || !doc.parts.length) {\n        return doc;\n      }\n\n      var parts = doc.parts;\n      var atIndex = parts.indexOf(\"@\");\n      var placeholderIndex = atIndex + 1;\n\n      if (atIndex > -1 && typeof parts[placeholderIndex] === \"string\" && parts[placeholderIndex].startsWith(\"prettier-placeholder\")) {\n        // If placeholder is split, join it\n        var at = parts[atIndex];\n        var placeholder = parts[placeholderIndex];\n        var rest = parts.slice(placeholderIndex + 1);\n        parts = parts.slice(0, atIndex).concat([at + placeholder]).concat(rest);\n      }\n\n      var atPlaceholderIndex = parts.findIndex(function (part) {\n        return typeof part === \"string\" && part.startsWith(\"@prettier-placeholder\");\n      });\n\n      if (atPlaceholderIndex > -1) {\n        var _placeholder = parts[atPlaceholderIndex];\n\n        var _rest = parts.slice(atPlaceholderIndex + 1);\n\n        var placeholderMatch = _placeholder.match(/@prettier-placeholder-(.+)-id([\\s\\S]*)/);\n\n        var placeholderID = placeholderMatch[1]; // When the expression has a suffix appended, like:\n        // animation: linear ${time}s ease-out;\n\n        var suffix = placeholderMatch[2];\n        var expression = expressions[placeholderID];\n        replaceCounter++;\n        parts = parts.slice(0, atPlaceholderIndex).concat([\"${\", expression, \"}\" + suffix]).concat(_rest);\n      }\n\n      return Object.assign({}, doc, {\n        parts: parts\n      });\n    });\n    return expressions.length === replaceCounter ? newDoc : null;\n  }\n\n  function printGraphqlComments(lines) {\n    var parts = [];\n    var seenComment = false;\n    lines.map(function (textLine) {\n      return textLine.trim();\n    }).forEach(function (textLine, i, array) {\n      // Lines are either whitespace only, or a comment (with potential whitespace\n      // around it). Drop whitespace-only lines.\n      if (textLine === \"\") {\n        return;\n      }\n\n      if (array[i - 1] === \"\" && seenComment) {\n        // If a non-first comment is preceded by a blank (whitespace only) line,\n        // add in a blank line.\n        parts.push(concat$b([hardline$8, textLine]));\n      } else {\n        parts.push(textLine);\n      }\n\n      seenComment = true;\n    }); // If `lines` was whitespace only, return `null`.\n\n    return parts.length === 0 ? null : join$7(hardline$8, parts);\n  }\n  /**\n   * Template literal in these contexts:\n   * <style jsx>{`div{color:red}`}</style>\n   * css``\n   * css.global``\n   * css.resolve``\n   */\n\n\n  function isStyledJsx(path) {\n    var node = path.getValue();\n    var parent = path.getParentNode();\n    var parentParent = path.getParentNode(1);\n    return parentParent && node.quasis && parent.type === \"JSXExpressionContainer\" && parentParent.type === \"JSXElement\" && parentParent.openingElement.name.name === \"style\" && parentParent.openingElement.attributes.some(function (attribute) {\n      return attribute.name.name === \"jsx\";\n    }) || parent && parent.type === \"TaggedTemplateExpression\" && parent.tag.type === \"Identifier\" && parent.tag.name === \"css\" || parent && parent.type === \"TaggedTemplateExpression\" && parent.tag.type === \"MemberExpression\" && parent.tag.object.name === \"css\" && (parent.tag.property.name === \"global\" || parent.tag.property.name === \"resolve\");\n  }\n  /**\n   * Angular Components can have:\n   * - Inline HTML template\n   * - Inline CSS styles\n   *\n   * ...which are both within template literals somewhere\n   * inside of the Component decorator factory.\n   *\n   * E.g.\n   * @Component({\n   *  template: `<div>...</div>`,\n   *  styles: [`h1 { color: blue; }`]\n   * })\n   */\n\n\n  function isAngularComponentStyles(path) {\n    return isPathMatch(path, [function (node) {\n      return node.type === \"TemplateLiteral\";\n    }, function (node, name) {\n      return node.type === \"ArrayExpression\" && name === \"elements\";\n    }, function (node, name) {\n      return node.type === \"Property\" && node.key.type === \"Identifier\" && node.key.name === \"styles\" && name === \"value\";\n    }].concat(getAngularComponentObjectExpressionPredicates()));\n  }\n\n  function isAngularComponentTemplate(path) {\n    return isPathMatch(path, [function (node) {\n      return node.type === \"TemplateLiteral\";\n    }, function (node, name) {\n      return node.type === \"Property\" && node.key.type === \"Identifier\" && node.key.name === \"template\" && name === \"value\";\n    }].concat(getAngularComponentObjectExpressionPredicates()));\n  }\n\n  function getAngularComponentObjectExpressionPredicates() {\n    return [function (node, name) {\n      return node.type === \"ObjectExpression\" && name === \"properties\";\n    }, function (node, name) {\n      return node.type === \"CallExpression\" && node.callee.type === \"Identifier\" && node.callee.name === \"Component\" && name === \"arguments\";\n    }, function (node, name) {\n      return node.type === \"Decorator\" && name === \"expression\";\n    }];\n  }\n  /**\n   * styled-components template literals\n   */\n\n\n  function isStyledComponents(path) {\n    var parent = path.getParentNode();\n\n    if (!parent || parent.type !== \"TaggedTemplateExpression\") {\n      return false;\n    }\n\n    var tag = parent.tag;\n\n    switch (tag.type) {\n      case \"MemberExpression\":\n        return (// styled.foo``\n          isStyledIdentifier(tag.object) || // Component.extend``\n          isStyledExtend(tag)\n        );\n\n      case \"CallExpression\":\n        return (// styled(Component)``\n          isStyledIdentifier(tag.callee) || tag.callee.type === \"MemberExpression\" && (tag.callee.object.type === \"MemberExpression\" && ( // styled.foo.attrs({})``\n          isStyledIdentifier(tag.callee.object.object) || // Component.extend.attrs({})``\n          isStyledExtend(tag.callee.object)) || // styled(Component).attrs({})``\n          tag.callee.object.type === \"CallExpression\" && isStyledIdentifier(tag.callee.object.callee))\n        );\n\n      case \"Identifier\":\n        // css``\n        return tag.name === \"css\";\n\n      default:\n        return false;\n    }\n  }\n  /**\n   * JSX element with CSS prop\n   */\n\n\n  function isCssProp(path) {\n    var parent = path.getParentNode();\n    var parentParent = path.getParentNode(1);\n    return parentParent && parent.type === \"JSXExpressionContainer\" && parentParent.type === \"JSXAttribute\" && parentParent.name.type === \"JSXIdentifier\" && parentParent.name.name === \"css\";\n  }\n\n  function isStyledIdentifier(node) {\n    return node.type === \"Identifier\" && node.name === \"styled\";\n  }\n\n  function isStyledExtend(node) {\n    return /^[A-Z]/.test(node.object.name) && node.property.name === \"extend\";\n  }\n  /*\n   * react-relay and graphql-tag\n   * graphql`...`\n   * graphql.experimental`...`\n   * gql`...`\n   * GraphQL comment block\n   *\n   * This intentionally excludes Relay Classic tags, as Prettier does not\n   * support Relay Classic formatting.\n   */\n\n\n  function isGraphQL(path) {\n    var node = path.getValue();\n    var parent = path.getParentNode();\n    return hasLanguageComment(node, \"GraphQL\") || parent && (parent.type === \"TaggedTemplateExpression\" && (parent.tag.type === \"MemberExpression\" && parent.tag.object.name === \"graphql\" && parent.tag.property.name === \"experimental\" || parent.tag.type === \"Identifier\" && (parent.tag.name === \"gql\" || parent.tag.name === \"graphql\")) || parent.type === \"CallExpression\" && parent.callee.type === \"Identifier\" && parent.callee.name === \"graphql\");\n  }\n\n  function hasLanguageComment(node, languageName) {\n    // This checks for a leading comment that is exactly `/* GraphQL */`\n    // In order to be in line with other implementations of this comment tag\n    // we will not trim the comment value and we will expect exactly one space on\n    // either side of the GraphQL string\n    // Also see ./clean.js\n    return hasLeadingComment$1(node, function (comment) {\n      return isBlockComment$1(comment) && comment.value === \" \".concat(languageName, \" \");\n    });\n  }\n\n  function isPathMatch(path, predicateStack) {\n    var stack = path.stack.slice();\n    var name = null;\n    var node = stack.pop();\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = predicateStack[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var predicate = _step.value;\n\n        if (node === undefined) {\n          return false;\n        } // skip index/array\n\n\n        if (typeof name === \"number\") {\n          name = stack.pop();\n          node = stack.pop();\n        }\n\n        if (!predicate(node, name)) {\n          return false;\n        }\n\n        name = stack.pop();\n        node = stack.pop();\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return true;\n  }\n  /**\n   *     - html`...`\n   *     - HTML comment block\n   */\n\n\n  function isHtml(path) {\n    var node = path.getValue();\n    return hasLanguageComment(node, \"HTML\") || isPathMatch(path, [function (node) {\n      return node.type === \"TemplateLiteral\";\n    }, function (node, name) {\n      return node.type === \"TaggedTemplateExpression\" && node.tag.type === \"Identifier\" && node.tag.name === \"html\" && name === \"quasi\";\n    }]);\n  } // The counter is needed to distinguish nested embeds.\n\n\n  var htmlTemplateLiteralCounter = 0;\n\n  function printHtmlTemplateLiteral(path, print, textToDoc, parser, escapeClosingScriptTag) {\n    var node = path.getValue();\n    var counter = htmlTemplateLiteralCounter;\n    htmlTemplateLiteralCounter = htmlTemplateLiteralCounter + 1 >>> 0;\n\n    var composePlaceholder = function composePlaceholder(index) {\n      return \"PRETTIER_HTML_PLACEHOLDER_\".concat(index, \"_\").concat(counter, \"_IN_JS\");\n    };\n\n    var text = node.quasis.map(function (quasi, index, quasis) {\n      return index === quasis.length - 1 ? quasi.value.cooked : quasi.value.cooked + composePlaceholder(index);\n    }).join(\"\");\n    var expressionDocs = path.map(print, \"expressions\");\n\n    if (expressionDocs.length === 0 && text.trim().length === 0) {\n      return \"``\";\n    }\n\n    var placeholderRegex = RegExp(composePlaceholder(\"(\\\\d+)\"), \"g\");\n    var contentDoc = mapDoc$5(stripTrailingHardline$2(textToDoc(text, {\n      parser: parser\n    })), function (doc) {\n      if (typeof doc !== \"string\") {\n        return doc;\n      }\n\n      var parts = [];\n      var components = doc.split(placeholderRegex);\n\n      for (var i = 0; i < components.length; i++) {\n        var component = components[i];\n\n        if (i % 2 === 0) {\n          if (component) {\n            component = uncook(component);\n\n            if (escapeClosingScriptTag) {\n              component = component.replace(/<\\/(script)\\b/gi, \"<\\\\/$1\");\n            }\n\n            parts.push(component);\n          }\n\n          continue;\n        }\n\n        var placeholderIndex = +component;\n        parts.push(concat$b([\"${\", group$a(expressionDocs[placeholderIndex]), \"}\"]));\n      }\n\n      return concat$b(parts);\n    });\n    return group$a(concat$b([\"`\", indent$6(concat$b([hardline$8, group$a(contentDoc)])), softline$5, \"`\"]));\n  }\n\n  var embed_1$1 = embed$3;\n\n  function clean$4(ast, newObj, parent) {\n    [\"range\", \"raw\", \"comments\", \"leadingComments\", \"trailingComments\", \"extra\", \"start\", \"end\", \"flags\", \"errors\"].forEach(function (name) {\n      delete newObj[name];\n    });\n\n    if (ast.type === \"BigIntLiteral\") {\n      newObj.value = newObj.value.toLowerCase();\n    } // We remove extra `;` and add them when needed\n\n\n    if (ast.type === \"EmptyStatement\") {\n      return null;\n    } // We move text around, including whitespaces and add {\" \"}\n\n\n    if (ast.type === \"JSXText\") {\n      return null;\n    }\n\n    if (ast.type === \"JSXExpressionContainer\" && ast.expression.type === \"Literal\" && ast.expression.value === \" \") {\n      return null;\n    } // We remove unneeded parens around same-operator LogicalExpressions\n\n\n    if (isUnbalancedLogicalTree(newObj)) {\n      return rebalanceLogicalTree(newObj);\n    } // (TypeScript) Ignore `static` in `constructor(static p) {}`\n    // and `export` in `constructor(export p) {}`\n\n\n    if (ast.type === \"TSParameterProperty\" && ast.accessibility === null && !ast.readonly) {\n      return {\n        type: \"Identifier\",\n        name: ast.parameter.name,\n        typeAnnotation: newObj.parameter.typeAnnotation,\n        decorators: newObj.decorators\n      };\n    } // (TypeScript) ignore empty `specifiers` array\n\n\n    if (ast.type === \"TSNamespaceExportDeclaration\" && ast.specifiers && ast.specifiers.length === 0) {\n      delete newObj.specifiers;\n    } // We convert <div></div> to <div />\n\n\n    if (ast.type === \"JSXOpeningElement\") {\n      delete newObj.selfClosing;\n    }\n\n    if (ast.type === \"JSXElement\") {\n      delete newObj.closingElement;\n    } // We change {'key': value} into {key: value}\n\n\n    if ((ast.type === \"Property\" || ast.type === \"ObjectProperty\" || ast.type === \"MethodDefinition\" || ast.type === \"ClassProperty\" || ast.type === \"TSPropertySignature\" || ast.type === \"ObjectTypeProperty\") && _typeof(ast.key) === \"object\" && ast.key && (ast.key.type === \"Literal\" || ast.key.type === \"StringLiteral\" || ast.key.type === \"Identifier\")) {\n      delete newObj.key;\n    }\n\n    if (ast.type === \"OptionalMemberExpression\" && ast.optional === false) {\n      newObj.type = \"MemberExpression\";\n      delete newObj.optional;\n    } // Remove raw and cooked values from TemplateElement when it's CSS\n    // styled-jsx\n\n\n    if (ast.type === \"JSXElement\" && ast.openingElement.name.name === \"style\" && ast.openingElement.attributes.some(function (attr) {\n      return attr.name.name === \"jsx\";\n    })) {\n      var templateLiterals = newObj.children.filter(function (child) {\n        return child.type === \"JSXExpressionContainer\" && child.expression.type === \"TemplateLiteral\";\n      }).map(function (container) {\n        return container.expression;\n      });\n      var quasis = templateLiterals.reduce(function (quasis, templateLiteral) {\n        return quasis.concat(templateLiteral.quasis);\n      }, []);\n      quasis.forEach(function (q) {\n        return delete q.value;\n      });\n    } // CSS template literals in css prop\n\n\n    if (ast.type === \"JSXAttribute\" && ast.name.name === \"css\" && ast.value.type === \"JSXExpressionContainer\" && ast.value.expression.type === \"TemplateLiteral\") {\n      newObj.value.expression.quasis.forEach(function (q) {\n        return delete q.value;\n      });\n    } // Angular Components: Inline HTML template and Inline CSS styles\n\n\n    var expression = ast.expression || ast.callee;\n\n    if (ast.type === \"Decorator\" && expression.type === \"CallExpression\" && expression.callee.name === \"Component\" && expression.arguments.length === 1) {\n      var astProps = ast.expression.arguments[0].properties;\n      newObj.expression.arguments[0].properties.forEach(function (prop, index) {\n        var templateLiteral = null;\n\n        switch (astProps[index].key.name) {\n          case \"styles\":\n            if (prop.value.type === \"ArrayExpression\") {\n              templateLiteral = prop.value.elements[0];\n            }\n\n            break;\n\n          case \"template\":\n            if (prop.value.type === \"TemplateLiteral\") {\n              templateLiteral = prop.value;\n            }\n\n            break;\n        }\n\n        if (templateLiteral) {\n          templateLiteral.quasis.forEach(function (q) {\n            return delete q.value;\n          });\n        }\n      });\n    } // styled-components, graphql, markdown\n\n\n    if (ast.type === \"TaggedTemplateExpression\" && (ast.tag.type === \"MemberExpression\" || ast.tag.type === \"Identifier\" && (ast.tag.name === \"gql\" || ast.tag.name === \"graphql\" || ast.tag.name === \"css\" || ast.tag.name === \"md\" || ast.tag.name === \"markdown\" || ast.tag.name === \"html\") || ast.tag.type === \"CallExpression\")) {\n      newObj.quasi.quasis.forEach(function (quasi) {\n        return delete quasi.value;\n      });\n    }\n\n    if (ast.type === \"TemplateLiteral\") {\n      // This checks for a leading comment that is exactly `/* GraphQL */`\n      // In order to be in line with other implementations of this comment tag\n      // we will not trim the comment value and we will expect exactly one space on\n      // either side of the GraphQL string\n      // Also see ./embed.js\n      var hasLanguageComment = ast.leadingComments && ast.leadingComments.some(function (comment) {\n        return comment.type === \"CommentBlock\" && [\"GraphQL\", \"HTML\"].some(function (languageName) {\n          return comment.value === \" \".concat(languageName, \" \");\n        });\n      });\n\n      if (hasLanguageComment || parent.type === \"CallExpression\" && parent.callee.name === \"graphql\") {\n        newObj.quasis.forEach(function (quasi) {\n          return delete quasi.value;\n        });\n      }\n    }\n  }\n\n  function isUnbalancedLogicalTree(newObj) {\n    return newObj.type === \"LogicalExpression\" && newObj.right.type === \"LogicalExpression\" && newObj.operator === newObj.right.operator;\n  }\n\n  function rebalanceLogicalTree(newObj) {\n    if (isUnbalancedLogicalTree(newObj)) {\n      return rebalanceLogicalTree({\n        type: \"LogicalExpression\",\n        operator: newObj.operator,\n        left: rebalanceLogicalTree({\n          type: \"LogicalExpression\",\n          operator: newObj.operator,\n          left: newObj.left,\n          right: newObj.right.left,\n          loc: {}\n        }),\n        right: newObj.right.right,\n        loc: {}\n      });\n    }\n\n    return newObj;\n  }\n\n  var clean_1$1 = clean$4;\n\n  var getLast$1 = util.getLast,\n      hasNewline$3 = util.hasNewline,\n      hasNewlineInRange$1 = util.hasNewlineInRange,\n      hasIgnoreComment$3 = util.hasIgnoreComment,\n      hasNodeIgnoreComment$1 = util.hasNodeIgnoreComment,\n      skipWhitespace$1 = util.skipWhitespace;\n  var isIdentifierName = utils$1.keyword.isIdentifierNameES5; // We match any whitespace except line terminators because\n  // Flow annotation comments cannot be split across lines. For example:\n  //\n  // (this /*\n  // : any */).foo = 5;\n  //\n  // is not picked up by Flow (see https://github.com/facebook/flow/issues/7050), so\n  // removing the newline would create a type annotation that the user did not intend\n  // to create.\n\n  var NON_LINE_TERMINATING_WHITE_SPACE = \"(?:(?=.)\\\\s)\";\n  var FLOW_SHORTHAND_ANNOTATION = new RegExp(\"^\".concat(NON_LINE_TERMINATING_WHITE_SPACE, \"*:\"));\n  var FLOW_ANNOTATION = new RegExp(\"^\".concat(NON_LINE_TERMINATING_WHITE_SPACE, \"*::\"));\n\n  function hasFlowShorthandAnnotationComment(node) {\n    // https://flow.org/en/docs/types/comments/\n    // Syntax example: const r = new (window.Request /*: Class<Request> */)(\"\");\n    return node.extra && node.extra.parenthesized && node.trailingComments && node.trailingComments[0].value.match(FLOW_SHORTHAND_ANNOTATION);\n  }\n\n  function hasFlowAnnotationComment(comments) {\n    return comments && comments[0].value.match(FLOW_ANNOTATION);\n  }\n\n  function hasNode(node, fn) {\n    if (!node || _typeof(node) !== \"object\") {\n      return false;\n    }\n\n    if (Array.isArray(node)) {\n      return node.some(function (value) {\n        return hasNode(value, fn);\n      });\n    }\n\n    var result = fn(node);\n    return typeof result === \"boolean\" ? result : Object.keys(node).some(function (key) {\n      return hasNode(node[key], fn);\n    });\n  }\n\n  function hasNakedLeftSide(node) {\n    return node.type === \"AssignmentExpression\" || node.type === \"BinaryExpression\" || node.type === \"LogicalExpression\" || node.type === \"NGPipeExpression\" || node.type === \"ConditionalExpression\" || node.type === \"CallExpression\" || node.type === \"OptionalCallExpression\" || node.type === \"MemberExpression\" || node.type === \"OptionalMemberExpression\" || node.type === \"SequenceExpression\" || node.type === \"TaggedTemplateExpression\" || node.type === \"BindExpression\" || node.type === \"UpdateExpression\" && !node.prefix || node.type === \"TSAsExpression\" || node.type === \"TSNonNullExpression\";\n  }\n\n  function getLeftSide(node) {\n    if (node.expressions) {\n      return node.expressions[0];\n    }\n\n    return node.left || node.test || node.callee || node.object || node.tag || node.argument || node.expression;\n  }\n\n  function getLeftSidePathName(path, node) {\n    if (node.expressions) {\n      return [\"expressions\", 0];\n    }\n\n    if (node.left) {\n      return [\"left\"];\n    }\n\n    if (node.test) {\n      return [\"test\"];\n    }\n\n    if (node.object) {\n      return [\"object\"];\n    }\n\n    if (node.callee) {\n      return [\"callee\"];\n    }\n\n    if (node.tag) {\n      return [\"tag\"];\n    }\n\n    if (node.argument) {\n      return [\"argument\"];\n    }\n\n    if (node.expression) {\n      return [\"expression\"];\n    }\n\n    throw new Error(\"Unexpected node has no left side\", node);\n  }\n\n  function isLiteral(node) {\n    return node.type === \"BooleanLiteral\" || node.type === \"DirectiveLiteral\" || node.type === \"Literal\" || node.type === \"NullLiteral\" || node.type === \"NumericLiteral\" || node.type === \"RegExpLiteral\" || node.type === \"StringLiteral\" || node.type === \"TemplateLiteral\" || node.type === \"TSTypeLiteral\" || node.type === \"JSXText\";\n  }\n\n  function isNumericLiteral(node) {\n    return node.type === \"NumericLiteral\" || node.type === \"Literal\" && typeof node.value === \"number\";\n  }\n\n  function isStringLiteral(node) {\n    return node.type === \"StringLiteral\" || node.type === \"Literal\" && typeof node.value === \"string\";\n  }\n\n  function isObjectType(n) {\n    return n.type === \"ObjectTypeAnnotation\" || n.type === \"TSTypeLiteral\";\n  }\n\n  function isFunctionOrArrowExpression(node) {\n    return node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\";\n  }\n\n  function isFunctionOrArrowExpressionWithBody(node) {\n    return node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\" && node.body.type === \"BlockStatement\";\n  }\n\n  function isTemplateLiteral(node) {\n    return node.type === \"TemplateLiteral\";\n  } // `inject` is used in AngularJS 1.x, `async` in Angular 2+\n  // example: https://docs.angularjs.org/guide/unit-testing#using-beforeall-\n\n\n  function isAngularTestWrapper(node) {\n    return (node.type === \"CallExpression\" || node.type === \"OptionalCallExpression\") && node.callee.type === \"Identifier\" && (node.callee.name === \"async\" || node.callee.name === \"inject\" || node.callee.name === \"fakeAsync\");\n  }\n\n  function isJSXNode(node) {\n    return node.type === \"JSXElement\" || node.type === \"JSXFragment\";\n  }\n\n  function isTheOnlyJSXElementInMarkdown(options, path) {\n    if (options.parentParser !== \"markdown\" && options.parentParser !== \"mdx\") {\n      return false;\n    }\n\n    var node = path.getNode();\n\n    if (!node.expression || !isJSXNode(node.expression)) {\n      return false;\n    }\n\n    var parent = path.getParentNode();\n    return parent.type === \"Program\" && parent.body.length == 1;\n  } // Detect an expression node representing `{\" \"}`\n\n\n  function isJSXWhitespaceExpression(node) {\n    return node.type === \"JSXExpressionContainer\" && isLiteral(node.expression) && node.expression.value === \" \" && !node.expression.comments;\n  }\n\n  function isMemberExpressionChain(node) {\n    if (node.type !== \"MemberExpression\" && node.type !== \"OptionalMemberExpression\") {\n      return false;\n    }\n\n    if (node.object.type === \"Identifier\") {\n      return true;\n    }\n\n    return isMemberExpressionChain(node.object);\n  }\n\n  function isGetterOrSetter(node) {\n    return node.kind === \"get\" || node.kind === \"set\";\n  }\n\n  function sameLocStart(nodeA, nodeB, options) {\n    return options.locStart(nodeA) === options.locStart(nodeB);\n  } // TODO: This is a bad hack and we need a better way to distinguish between\n  // arrow functions and otherwise\n\n\n  function isFunctionNotation(node, options) {\n    return isGetterOrSetter(node) || sameLocStart(node, node.value, options);\n  } // Hack to differentiate between the following two which have the same ast\n  // type T = { method: () => void };\n  // type T = { method(): void };\n\n\n  function isObjectTypePropertyAFunction(node, options) {\n    return (node.type === \"ObjectTypeProperty\" || node.type === \"ObjectTypeInternalSlot\") && node.value.type === \"FunctionTypeAnnotation\" && !node.static && !isFunctionNotation(node, options);\n  } // Hack to differentiate between the following two which have the same ast\n  // declare function f(a): void;\n  // var f: (a) => void;\n\n\n  function isTypeAnnotationAFunction(node, options) {\n    return (node.type === \"TypeAnnotation\" || node.type === \"TSTypeAnnotation\") && node.typeAnnotation.type === \"FunctionTypeAnnotation\" && !node.static && !sameLocStart(node, node.typeAnnotation, options);\n  }\n\n  function isBinaryish(node) {\n    return node.type === \"BinaryExpression\" || node.type === \"LogicalExpression\" || node.type === \"NGPipeExpression\";\n  }\n\n  function isMemberish(node) {\n    return node.type === \"MemberExpression\" || node.type === \"OptionalMemberExpression\" || node.type === \"BindExpression\" && node.object;\n  }\n\n  function isSimpleFlowType(node) {\n    var flowTypeAnnotations = [\"AnyTypeAnnotation\", \"NullLiteralTypeAnnotation\", \"GenericTypeAnnotation\", \"ThisTypeAnnotation\", \"NumberTypeAnnotation\", \"VoidTypeAnnotation\", \"EmptyTypeAnnotation\", \"MixedTypeAnnotation\", \"BooleanTypeAnnotation\", \"BooleanLiteralTypeAnnotation\", \"StringTypeAnnotation\"];\n    return node && flowTypeAnnotations.indexOf(node.type) !== -1 && !(node.type === \"GenericTypeAnnotation\" && node.typeParameters);\n  }\n\n  var unitTestRe = /^(skip|[fx]?(it|describe|test))$/;\n\n  function isSkipOrOnlyBlock(node) {\n    return (node.callee.type === \"MemberExpression\" || node.callee.type === \"OptionalMemberExpression\") && node.callee.object.type === \"Identifier\" && node.callee.property.type === \"Identifier\" && unitTestRe.test(node.callee.object.name) && (node.callee.property.name === \"only\" || node.callee.property.name === \"skip\");\n  }\n\n  function isUnitTestSetUp(n) {\n    var unitTestSetUpRe = /^(before|after)(Each|All)$/;\n    return n.callee.type === \"Identifier\" && unitTestSetUpRe.test(n.callee.name) && n.arguments.length === 1;\n  } // eg; `describe(\"some string\", (done) => {})`\n\n\n  function isTestCall(n, parent) {\n    if (n.type !== \"CallExpression\") {\n      return false;\n    }\n\n    if (n.arguments.length === 1) {\n      if (isAngularTestWrapper(n) && parent && isTestCall(parent)) {\n        return isFunctionOrArrowExpression(n.arguments[0]);\n      }\n\n      if (isUnitTestSetUp(n)) {\n        return isAngularTestWrapper(n.arguments[0]);\n      }\n    } else if (n.arguments.length === 2 || n.arguments.length === 3) {\n      if ((n.callee.type === \"Identifier\" && unitTestRe.test(n.callee.name) || isSkipOrOnlyBlock(n)) && (isTemplateLiteral(n.arguments[0]) || isStringLiteral(n.arguments[0]))) {\n        // it(\"name\", () => { ... }, 2500)\n        if (n.arguments[2] && !isNumericLiteral(n.arguments[2])) {\n          return false;\n        }\n\n        return (n.arguments.length === 2 ? isFunctionOrArrowExpression(n.arguments[1]) : isFunctionOrArrowExpressionWithBody(n.arguments[1]) && n.arguments[1].params.length <= 1) || isAngularTestWrapper(n.arguments[1]);\n      }\n    }\n\n    return false;\n  }\n\n  function hasLeadingComment$2(node) {\n    return node.comments && node.comments.some(function (comment) {\n      return comment.leading;\n    });\n  }\n\n  function hasTrailingComment(node) {\n    return node.comments && node.comments.some(function (comment) {\n      return comment.trailing;\n    });\n  }\n\n  function isCallOrOptionalCallExpression(node) {\n    return node.type === \"CallExpression\" || node.type === \"OptionalCallExpression\";\n  }\n\n  function hasDanglingComments(node) {\n    return node.comments && node.comments.some(function (comment) {\n      return !comment.leading && !comment.trailing;\n    });\n  }\n  /** identify if an angular expression seems to have side effects */\n\n\n  function hasNgSideEffect(path) {\n    return hasNode(path.getValue(), function (node) {\n      switch (node.type) {\n        case undefined:\n          return false;\n\n        case \"CallExpression\":\n        case \"OptionalCallExpression\":\n        case \"AssignmentExpression\":\n          return true;\n      }\n    });\n  }\n\n  function isNgForOf(node, index, parentNode) {\n    return node.type === \"NGMicrosyntaxKeyedExpression\" && node.key.name === \"of\" && index === 1 && parentNode.body[0].type === \"NGMicrosyntaxLet\" && parentNode.body[0].value === null;\n  }\n  /** @param node {import(\"estree\").TemplateLiteral} */\n\n\n  function isSimpleTemplateLiteral(node) {\n    if (node.expressions.length === 0) {\n      return false;\n    }\n\n    return node.expressions.every(function (expr) {\n      // Disallow comments since printDocToString can't print them here\n      if (expr.comments) {\n        return false;\n      } // Allow `x` and `this`\n\n\n      if (expr.type === \"Identifier\" || expr.type === \"ThisExpression\") {\n        return true;\n      } // Allow `a.b.c`, `a.b[c]`, and `this.x.y`\n\n\n      if (expr.type === \"MemberExpression\" || expr.type === \"OptionalMemberExpression\") {\n        var head = expr;\n\n        while (head.type === \"MemberExpression\" || head.type === \"OptionalMemberExpression\") {\n          if (head.property.type !== \"Identifier\" && head.property.type !== \"Literal\" && head.property.type !== \"StringLiteral\" && head.property.type !== \"NumericLiteral\") {\n            return false;\n          }\n\n          head = head.object;\n\n          if (head.comments) {\n            return false;\n          }\n        }\n\n        if (head.type === \"Identifier\" || head.type === \"ThisExpression\") {\n          return true;\n        }\n\n        return false;\n      }\n\n      return false;\n    });\n  }\n\n  function getFlowVariance(path) {\n    if (!path.variance) {\n      return null;\n    } // Babel 7.0 currently uses variance node type, and flow should\n    // follow suit soon:\n    // https://github.com/babel/babel/issues/4722\n\n\n    var variance = path.variance.kind || path.variance;\n\n    switch (variance) {\n      case \"plus\":\n        return \"+\";\n\n      case \"minus\":\n        return \"-\";\n\n      default:\n        /* istanbul ignore next */\n        return variance;\n    }\n  }\n\n  function classPropMayCauseASIProblems(path) {\n    var node = path.getNode();\n\n    if (node.type !== \"ClassProperty\") {\n      return false;\n    }\n\n    var name = node.key && node.key.name; // this isn't actually possible yet with most parsers available today\n    // so isn't properly tested yet.\n\n    if ((name === \"static\" || name === \"get\" || name === \"set\") && !node.value && !node.typeAnnotation) {\n      return true;\n    }\n  }\n\n  function classChildNeedsASIProtection(node) {\n    if (!node) {\n      return;\n    }\n\n    if (node.static || node.accessibility // TypeScript\n    ) {\n        return false;\n      }\n\n    if (!node.computed) {\n      var name = node.key && node.key.name;\n\n      if (name === \"in\" || name === \"instanceof\") {\n        return true;\n      }\n    }\n\n    switch (node.type) {\n      case \"ClassProperty\":\n      case \"TSAbstractClassProperty\":\n        return node.computed;\n\n      case \"MethodDefinition\": // Flow\n\n      case \"TSAbstractMethodDefinition\": // TypeScript\n\n      case \"ClassMethod\":\n      case \"ClassPrivateMethod\":\n        {\n          // Babel\n          var isAsync = node.value ? node.value.async : node.async;\n          var isGenerator = node.value ? node.value.generator : node.generator;\n\n          if (isAsync || node.kind === \"get\" || node.kind === \"set\") {\n            return false;\n          }\n\n          if (node.computed || isGenerator) {\n            return true;\n          }\n\n          return false;\n        }\n\n      case \"TSIndexSignature\":\n        return true;\n\n      default:\n        /* istanbul ignore next */\n        return false;\n    }\n  }\n\n  function getTypeScriptMappedTypeModifier(tokenNode, keyword) {\n    if (tokenNode === \"+\") {\n      return \"+\" + keyword;\n    } else if (tokenNode === \"-\") {\n      return \"-\" + keyword;\n    }\n\n    return keyword;\n  }\n\n  function hasNewlineBetweenOrAfterDecorators(node, options) {\n    return hasNewlineInRange$1(options.originalText, options.locStart(node.decorators[0]), options.locEnd(getLast$1(node.decorators))) || hasNewline$3(options.originalText, options.locEnd(getLast$1(node.decorators)));\n  } // Only space, newline, carriage return, and tab are treated as whitespace\n  // inside JSX.\n\n\n  var jsxWhitespaceChars = \" \\n\\r\\t\";\n  var matchJsxWhitespaceRegex = new RegExp(\"([\" + jsxWhitespaceChars + \"]+)\");\n  var containsNonJsxWhitespaceRegex = new RegExp(\"[^\" + jsxWhitespaceChars + \"]\"); // Meaningful if it contains non-whitespace characters,\n  // or it contains whitespace without a new line.\n\n  function isMeaningfulJSXText(node) {\n    return isLiteral(node) && (containsNonJsxWhitespaceRegex.test(rawText(node)) || !/\\n/.test(rawText(node)));\n  }\n\n  function hasJsxIgnoreComment(path) {\n    var node = path.getValue();\n    var parent = path.getParentNode();\n\n    if (!parent || !node || !isJSXNode(node) || !isJSXNode(parent)) {\n      return false;\n    } // Lookup the previous sibling, ignoring any empty JSXText elements\n\n\n    var index = parent.children.indexOf(node);\n    var prevSibling = null;\n\n    for (var i = index; i > 0; i--) {\n      var candidate = parent.children[i - 1];\n\n      if (candidate.type === \"JSXText\" && !isMeaningfulJSXText(candidate)) {\n        continue;\n      }\n\n      prevSibling = candidate;\n      break;\n    }\n\n    return prevSibling && prevSibling.type === \"JSXExpressionContainer\" && prevSibling.expression.type === \"JSXEmptyExpression\" && prevSibling.expression.comments && prevSibling.expression.comments.find(function (comment) {\n      return comment.value.trim() === \"prettier-ignore\";\n    });\n  }\n\n  function isEmptyJSXElement(node) {\n    if (node.children.length === 0) {\n      return true;\n    }\n\n    if (node.children.length > 1) {\n      return false;\n    } // if there is one text child and does not contain any meaningful text\n    // we can treat the element as empty.\n\n\n    var child = node.children[0];\n    return isLiteral(child) && !isMeaningfulJSXText(child);\n  }\n\n  function hasPrettierIgnore$2(path) {\n    return hasIgnoreComment$3(path) || hasJsxIgnoreComment(path);\n  }\n\n  function isLastStatement(path) {\n    var parent = path.getParentNode();\n\n    if (!parent) {\n      return true;\n    }\n\n    var node = path.getValue();\n    var body = (parent.body || parent.consequent).filter(function (stmt) {\n      return stmt.type !== \"EmptyStatement\";\n    });\n    return body && body[body.length - 1] === node;\n  }\n\n  function isFlowAnnotationComment(text, typeAnnotation, options) {\n    var start = options.locStart(typeAnnotation);\n    var end = skipWhitespace$1(text, options.locEnd(typeAnnotation));\n    return text.substr(start, 2) === \"/*\" && text.substr(end, 2) === \"*/\";\n  }\n\n  function hasLeadingOwnLineComment(text, node, options) {\n    if (isJSXNode(node)) {\n      return hasNodeIgnoreComment$1(node);\n    }\n\n    var res = node.comments && node.comments.some(function (comment) {\n      return comment.leading && hasNewline$3(text, options.locEnd(comment));\n    });\n    return res;\n  } // This recurses the return argument, looking for the first token\n  // (the leftmost leaf node) and, if it (or its parents) has any\n  // leadingComments, returns true (so it can be wrapped in parens).\n\n\n  function returnArgumentHasLeadingComment(options, argument) {\n    if (hasLeadingOwnLineComment(options.originalText, argument, options)) {\n      return true;\n    }\n\n    if (hasNakedLeftSide(argument)) {\n      var leftMost = argument;\n      var newLeftMost;\n\n      while (newLeftMost = getLeftSide(leftMost)) {\n        leftMost = newLeftMost;\n\n        if (hasLeadingOwnLineComment(options.originalText, leftMost, options)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  function isStringPropSafeToCoerceToIdentifier(node, options) {\n    return isStringLiteral(node.key) && isIdentifierName(node.key.value) && options.parser !== \"json\" && !(options.parser === \"typescript\" && node.type === \"ClassProperty\");\n  }\n\n  function isJestEachTemplateLiteral(node, parentNode) {\n    /**\n     * describe.each`table`(name, fn)\n     * describe.only.each`table`(name, fn)\n     * describe.skip.each`table`(name, fn)\n     * test.each`table`(name, fn)\n     * test.only.each`table`(name, fn)\n     * test.skip.each`table`(name, fn)\n     *\n     * Ref: https://github.com/facebook/jest/pull/6102\n     */\n    var jestEachTriggerRegex = /^[xf]?(describe|it|test)$/;\n    return parentNode.type === \"TaggedTemplateExpression\" && parentNode.quasi === node && parentNode.tag.type === \"MemberExpression\" && parentNode.tag.property.type === \"Identifier\" && parentNode.tag.property.name === \"each\" && (parentNode.tag.object.type === \"Identifier\" && jestEachTriggerRegex.test(parentNode.tag.object.name) || parentNode.tag.object.type === \"MemberExpression\" && parentNode.tag.object.property.type === \"Identifier\" && (parentNode.tag.object.property.name === \"only\" || parentNode.tag.object.property.name === \"skip\") && parentNode.tag.object.object.type === \"Identifier\" && jestEachTriggerRegex.test(parentNode.tag.object.object.name));\n  }\n\n  function templateLiteralHasNewLines(template) {\n    return template.quasis.some(function (quasi) {\n      return quasi.value.raw.includes(\"\\n\");\n    });\n  }\n\n  function isTemplateOnItsOwnLine(n, text, options) {\n    return (n.type === \"TemplateLiteral\" && templateLiteralHasNewLines(n) || n.type === \"TaggedTemplateExpression\" && templateLiteralHasNewLines(n.quasi)) && !hasNewline$3(text, options.locStart(n), {\n      backwards: true\n    });\n  }\n\n  function needsHardlineAfterDanglingComment(node) {\n    if (!node.comments) {\n      return false;\n    }\n\n    var lastDanglingComment = getLast$1(node.comments.filter(function (comment) {\n      return !comment.leading && !comment.trailing;\n    }));\n    return lastDanglingComment && !comments$1.isBlockComment(lastDanglingComment);\n  } // If we have nested conditional expressions, we want to print them in JSX mode\n  // if there's at least one JSXElement somewhere in the tree.\n  //\n  // A conditional expression chain like this should be printed in normal mode,\n  // because there aren't JSXElements anywhere in it:\n  //\n  // isA ? \"A\" : isB ? \"B\" : isC ? \"C\" : \"Unknown\";\n  //\n  // But a conditional expression chain like this should be printed in JSX mode,\n  // because there is a JSXElement in the last ConditionalExpression:\n  //\n  // isA ? \"A\" : isB ? \"B\" : isC ? \"C\" : <span className=\"warning\">Unknown</span>;\n  //\n  // This type of ConditionalExpression chain is structured like this in the AST:\n  //\n  // ConditionalExpression {\n  //   test: ...,\n  //   consequent: ...,\n  //   alternate: ConditionalExpression {\n  //     test: ...,\n  //     consequent: ...,\n  //     alternate: ConditionalExpression {\n  //       test: ...,\n  //       consequent: ...,\n  //       alternate: ...,\n  //     }\n  //   }\n  // }\n  //\n  // We want to traverse over that shape and convert it into a flat structure so\n  // that we can find if there's a JSXElement somewhere inside.\n\n\n  function getConditionalChainContents(node) {\n    // Given this code:\n    //\n    // // Using a ConditionalExpression as the consequent is uncommon, but should\n    // // be handled.\n    // A ? B : C ? D : E ? F ? G : H : I\n    //\n    // which has this AST:\n    //\n    // ConditionalExpression {\n    //   test: Identifier(A),\n    //   consequent: Identifier(B),\n    //   alternate: ConditionalExpression {\n    //     test: Identifier(C),\n    //     consequent: Identifier(D),\n    //     alternate: ConditionalExpression {\n    //       test: Identifier(E),\n    //       consequent: ConditionalExpression {\n    //         test: Identifier(F),\n    //         consequent: Identifier(G),\n    //         alternate: Identifier(H),\n    //       },\n    //       alternate: Identifier(I),\n    //     }\n    //   }\n    // }\n    //\n    // we should return this Array:\n    //\n    // [\n    //   Identifier(A),\n    //   Identifier(B),\n    //   Identifier(C),\n    //   Identifier(D),\n    //   Identifier(E),\n    //   Identifier(F),\n    //   Identifier(G),\n    //   Identifier(H),\n    //   Identifier(I)\n    // ];\n    //\n    // This loses the information about whether each node was the test,\n    // consequent, or alternate, but we don't care about that here- we are only\n    // flattening this structure to find if there's any JSXElements inside.\n    var nonConditionalExpressions = [];\n\n    function recurse(node) {\n      if (node.type === \"ConditionalExpression\") {\n        recurse(node.test);\n        recurse(node.consequent);\n        recurse(node.alternate);\n      } else {\n        nonConditionalExpressions.push(node);\n      }\n    }\n\n    recurse(node);\n    return nonConditionalExpressions;\n  }\n\n  function conditionalExpressionChainContainsJSX(node) {\n    return Boolean(getConditionalChainContents(node).find(isJSXNode));\n  } // Logic to check for args with multiple anonymous functions. For instance,\n  // the following call should be split on multiple lines for readability:\n  // source.pipe(map((x) => x + x), filter((x) => x % 2 === 0))\n\n\n  function isFunctionCompositionArgs(args) {\n    if (args.length <= 1) {\n      return false;\n    }\n\n    var count = 0;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = args[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var arg = _step.value;\n\n        if (isFunctionOrArrowExpression(arg)) {\n          count += 1;\n\n          if (count > 1) {\n            return true;\n          }\n        } else if (isCallOrOptionalCallExpression(arg)) {\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = arg.arguments[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var childArg = _step2.value;\n\n              if (isFunctionOrArrowExpression(childArg)) {\n                return true;\n              }\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return false;\n  } // Logic to determine if a call is a “long curried function call”.\n  // See https://github.com/prettier/prettier/issues/1420.\n  //\n  // `connect(a, b, c)(d)`\n  // In the above call expression, the second call is the parent node and the\n  // first call is the current node.\n\n\n  function isLongCurriedCallExpression(path) {\n    var node = path.getValue();\n    var parent = path.getParentNode();\n    return isCallOrOptionalCallExpression(node) && isCallOrOptionalCallExpression(parent) && parent.callee === node && node.arguments.length > parent.arguments.length && parent.arguments.length > 0;\n  }\n\n  function rawText(node) {\n    return node.extra ? node.extra.raw : node.raw;\n  }\n\n  function identity$1(x) {\n    return x;\n  }\n\n  function isTSXFile(options) {\n    return options.filepath && /\\.tsx$/i.test(options.filepath);\n  }\n\n  var utils$4 = {\n    classChildNeedsASIProtection: classChildNeedsASIProtection,\n    classPropMayCauseASIProblems: classPropMayCauseASIProblems,\n    conditionalExpressionChainContainsJSX: conditionalExpressionChainContainsJSX,\n    getFlowVariance: getFlowVariance,\n    getLeftSidePathName: getLeftSidePathName,\n    getTypeScriptMappedTypeModifier: getTypeScriptMappedTypeModifier,\n    hasDanglingComments: hasDanglingComments,\n    hasFlowAnnotationComment: hasFlowAnnotationComment,\n    hasFlowShorthandAnnotationComment: hasFlowShorthandAnnotationComment,\n    hasLeadingComment: hasLeadingComment$2,\n    hasLeadingOwnLineComment: hasLeadingOwnLineComment,\n    hasNakedLeftSide: hasNakedLeftSide,\n    hasNewlineBetweenOrAfterDecorators: hasNewlineBetweenOrAfterDecorators,\n    hasNgSideEffect: hasNgSideEffect,\n    hasNode: hasNode,\n    hasPrettierIgnore: hasPrettierIgnore$2,\n    hasTrailingComment: hasTrailingComment,\n    identity: identity$1,\n    isBinaryish: isBinaryish,\n    isCallOrOptionalCallExpression: isCallOrOptionalCallExpression,\n    isEmptyJSXElement: isEmptyJSXElement,\n    isFlowAnnotationComment: isFlowAnnotationComment,\n    isFunctionCompositionArgs: isFunctionCompositionArgs,\n    isFunctionNotation: isFunctionNotation,\n    isFunctionOrArrowExpression: isFunctionOrArrowExpression,\n    isGetterOrSetter: isGetterOrSetter,\n    isJestEachTemplateLiteral: isJestEachTemplateLiteral,\n    isJSXNode: isJSXNode,\n    isJSXWhitespaceExpression: isJSXWhitespaceExpression,\n    isLastStatement: isLastStatement,\n    isLiteral: isLiteral,\n    isLongCurriedCallExpression: isLongCurriedCallExpression,\n    isMeaningfulJSXText: isMeaningfulJSXText,\n    isMemberExpressionChain: isMemberExpressionChain,\n    isMemberish: isMemberish,\n    isNgForOf: isNgForOf,\n    isNumericLiteral: isNumericLiteral,\n    isObjectType: isObjectType,\n    isObjectTypePropertyAFunction: isObjectTypePropertyAFunction,\n    isSimpleFlowType: isSimpleFlowType,\n    isSimpleTemplateLiteral: isSimpleTemplateLiteral,\n    isStringLiteral: isStringLiteral,\n    isStringPropSafeToCoerceToIdentifier: isStringPropSafeToCoerceToIdentifier,\n    isTemplateOnItsOwnLine: isTemplateOnItsOwnLine,\n    isTestCall: isTestCall,\n    isTheOnlyJSXElementInMarkdown: isTheOnlyJSXElementInMarkdown,\n    isTSXFile: isTSXFile,\n    isTypeAnnotationAFunction: isTypeAnnotationAFunction,\n    matchJsxWhitespaceRegex: matchJsxWhitespaceRegex,\n    needsHardlineAfterDanglingComment: needsHardlineAfterDanglingComment,\n    rawText: rawText,\n    returnArgumentHasLeadingComment: returnArgumentHasLeadingComment\n  };\n\n  var getLeftSidePathName$1 = utils$4.getLeftSidePathName,\n      hasFlowShorthandAnnotationComment$1 = utils$4.hasFlowShorthandAnnotationComment,\n      hasNakedLeftSide$1 = utils$4.hasNakedLeftSide,\n      hasNode$1 = utils$4.hasNode;\n\n  function hasClosureCompilerTypeCastComment(text, path) {\n    // https://github.com/google/closure-compiler/wiki/Annotating-Types#type-casts\n    // Syntax example: var x = /** @type {string} */ (fruit);\n    var n = path.getValue();\n    return isParenthesized(n) && (hasTypeCastComment(n) || hasAncestorTypeCastComment(0)); // for sub-item: /** @type {array} */ (numberOrString).map(x => x);\n\n    function hasAncestorTypeCastComment(index) {\n      var ancestor = path.getParentNode(index);\n      return ancestor && !isParenthesized(ancestor) ? hasTypeCastComment(ancestor) || hasAncestorTypeCastComment(index + 1) : false;\n    }\n\n    function hasTypeCastComment(node) {\n      return node.comments && node.comments.some(function (comment) {\n        return comment.leading && comments$1.isBlockComment(comment) && isTypeCastComment(comment.value);\n      });\n    }\n\n    function isParenthesized(node) {\n      // Closure typecast comments only really make sense when _not_ using\n      // typescript or flow parsers, so we take advantage of the babel parser's\n      // parenthesized expressions.\n      return node.extra && node.extra.parenthesized;\n    }\n\n    function isTypeCastComment(comment) {\n      var cleaned = comment.trim().split(\"\\n\").map(function (line) {\n        return line.replace(/^[\\s*]+/, \"\");\n      }).join(\" \").trim();\n\n      if (!/^@type\\s*\\{[^]+\\}$/.test(cleaned)) {\n        return false;\n      }\n\n      var isCompletelyClosed = false;\n      var unpairedBracketCount = 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = cleaned[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var char = _step.value;\n\n          if (char === \"{\") {\n            if (isCompletelyClosed) {\n              return false;\n            }\n\n            unpairedBracketCount++;\n          } else if (char === \"}\") {\n            if (unpairedBracketCount === 0) {\n              return false;\n            }\n\n            unpairedBracketCount--;\n\n            if (unpairedBracketCount === 0) {\n              isCompletelyClosed = true;\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return unpairedBracketCount === 0;\n    }\n  }\n\n  function needsParens(path, options) {\n    var parent = path.getParentNode();\n\n    if (!parent) {\n      return false;\n    }\n\n    var name = path.getName();\n    var node = path.getNode(); // If the value of this path is some child of a Node and not a Node\n    // itself, then it doesn't need parentheses. Only Node objects (in\n    // fact, only Expression nodes) need parentheses.\n\n    if (path.getValue() !== node) {\n      return false;\n    } // to avoid unexpected `}}` in HTML interpolations\n\n\n    if (options.__isInHtmlInterpolation && !options.bracketSpacing && endsWithRightBracket(node) && isFollowedByRightBracket(path)) {\n      return true;\n    } // Only statements don't need parentheses.\n\n\n    if (isStatement(node)) {\n      return false;\n    } // Closure compiler requires that type casted expressions to be surrounded by\n    // parentheses.\n\n\n    if (hasClosureCompilerTypeCastComment(options.originalText, path)) {\n      return true;\n    }\n\n    if ( // Preserve parens if we have a Flow annotation comment, unless we're using the Flow\n    // parser. The Flow parser turns Flow comments into type annotation nodes in its\n    // AST, which we handle separately.\n    options.parser !== \"flow\" && hasFlowShorthandAnnotationComment$1(path.getValue())) {\n      return true;\n    } // Identifiers never need parentheses.\n\n\n    if (node.type === \"Identifier\") {\n      // ...unless those identifiers are embed placeholders. They might be substituted by complex\n      // expressions, so the parens around them should not be dropped. Example (JS-in-HTML-in-JS):\n      //     let tpl = html`<script> f((${expr}) / 2); </script>`;\n      // If the inner JS formatter removes the parens, the expression might change its meaning:\n      //     f((a + b) / 2)  vs  f(a + b / 2)\n      if (node.extra && node.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\\d+_\\d+_IN_JS$/.test(node.name)) {\n        return true;\n      }\n\n      return false;\n    }\n\n    if (parent.type === \"ParenthesizedExpression\") {\n      return false;\n    } // Add parens around the extends clause of a class. It is needed for almost\n    // all expressions.\n\n\n    if ((parent.type === \"ClassDeclaration\" || parent.type === \"ClassExpression\") && parent.superClass === node && (node.type === \"ArrowFunctionExpression\" || node.type === \"AssignmentExpression\" || node.type === \"AwaitExpression\" || node.type === \"BinaryExpression\" || node.type === \"ConditionalExpression\" || node.type === \"LogicalExpression\" || node.type === \"NewExpression\" || node.type === \"ObjectExpression\" || node.type === \"ParenthesizedExpression\" || node.type === \"SequenceExpression\" || node.type === \"TaggedTemplateExpression\" || node.type === \"UnaryExpression\" || node.type === \"UpdateExpression\" || node.type === \"YieldExpression\")) {\n      return true;\n    } // `export default function` or `export default class` can't be followed by\n    // anything after. So an expression like `export default (function(){}).toString()`\n    // needs to be followed by a parentheses\n\n\n    if (parent.type === \"ExportDefaultDeclaration\") {\n      return shouldWrapFunctionForExportDefault(path, options);\n    }\n\n    if (parent.type === \"Decorator\" && parent.expression === node) {\n      var hasCallExpression = false;\n      var hasMemberExpression = false;\n      var current = node;\n\n      while (current) {\n        switch (current.type) {\n          case \"MemberExpression\":\n            hasMemberExpression = true;\n            current = current.object;\n            break;\n\n          case \"CallExpression\":\n            if (\n            /** @(x().y) */\n            hasMemberExpression ||\n            /** @(x().y()) */\n            hasCallExpression) {\n              return true;\n            }\n\n            hasCallExpression = true;\n            current = current.callee;\n            break;\n\n          case \"Identifier\":\n            return false;\n\n          default:\n            return true;\n        }\n      }\n\n      return true;\n    }\n\n    if (parent.type === \"ArrowFunctionExpression\" && parent.body === node && node.type !== \"SequenceExpression\" && // these have parens added anyway\n    util.startsWithNoLookaheadToken(node,\n    /* forbidFunctionClassAndDoExpr */\n    false) || parent.type === \"ExpressionStatement\" && util.startsWithNoLookaheadToken(node,\n    /* forbidFunctionClassAndDoExpr */\n    true)) {\n      return true;\n    }\n\n    switch (node.type) {\n      case \"SpreadElement\":\n      case \"SpreadProperty\":\n        return parent.type === \"MemberExpression\" && name === \"object\" && parent.object === node;\n\n      case \"UpdateExpression\":\n        if (parent.type === \"UnaryExpression\") {\n          return node.prefix && (node.operator === \"++\" && parent.operator === \"+\" || node.operator === \"--\" && parent.operator === \"-\");\n        }\n\n      // else fallthrough\n\n      case \"UnaryExpression\":\n        switch (parent.type) {\n          case \"UnaryExpression\":\n            return node.operator === parent.operator && (node.operator === \"+\" || node.operator === \"-\");\n\n          case \"BindExpression\":\n            return true;\n\n          case \"MemberExpression\":\n          case \"OptionalMemberExpression\":\n            return name === \"object\";\n\n          case \"TaggedTemplateExpression\":\n            return true;\n\n          case \"NewExpression\":\n          case \"CallExpression\":\n          case \"OptionalCallExpression\":\n            return name === \"callee\";\n\n          case \"BinaryExpression\":\n            return parent.operator === \"**\" && name === \"left\";\n\n          case \"TSNonNullExpression\":\n            return true;\n\n          default:\n            return false;\n        }\n\n      case \"BinaryExpression\":\n        {\n          if (parent.type === \"UpdateExpression\") {\n            return true;\n          }\n\n          var isLeftOfAForStatement = function isLeftOfAForStatement(node) {\n            var i = 0;\n\n            while (node) {\n              var _parent = path.getParentNode(i++);\n\n              if (!_parent) {\n                return false;\n              }\n\n              if (_parent.type === \"ForStatement\" && _parent.init === node) {\n                return true;\n              }\n\n              node = _parent;\n            }\n\n            return false;\n          };\n\n          if (node.operator === \"in\" && isLeftOfAForStatement(node)) {\n            return true;\n          }\n        }\n      // fallthrough\n\n      case \"TSTypeAssertion\":\n      case \"TSAsExpression\":\n      case \"LogicalExpression\":\n        switch (parent.type) {\n          case \"ConditionalExpression\":\n            return node.type === \"TSAsExpression\";\n\n          case \"CallExpression\":\n          case \"NewExpression\":\n          case \"OptionalCallExpression\":\n            return name === \"callee\";\n\n          case \"ClassExpression\":\n          case \"ClassDeclaration\":\n            return name === \"superClass\" && parent.superClass === node;\n\n          case \"TSTypeAssertion\":\n          case \"TaggedTemplateExpression\":\n          case \"UnaryExpression\":\n          case \"JSXSpreadAttribute\":\n          case \"SpreadElement\":\n          case \"SpreadProperty\":\n          case \"BindExpression\":\n          case \"AwaitExpression\":\n          case \"TSAsExpression\":\n          case \"TSNonNullExpression\":\n          case \"UpdateExpression\":\n            return true;\n\n          case \"MemberExpression\":\n          case \"OptionalMemberExpression\":\n            return name === \"object\";\n\n          case \"AssignmentExpression\":\n            return parent.left === node && (node.type === \"TSTypeAssertion\" || node.type === \"TSAsExpression\");\n\n          case \"LogicalExpression\":\n            if (node.type === \"LogicalExpression\") {\n              return parent.operator !== node.operator;\n            }\n\n          // else fallthrough\n\n          case \"BinaryExpression\":\n            {\n              if (!node.operator && node.type !== \"TSTypeAssertion\") {\n                return true;\n              }\n\n              var po = parent.operator;\n              var pp = util.getPrecedence(po);\n              var no = node.operator;\n              var np = util.getPrecedence(no);\n\n              if (pp > np) {\n                return true;\n              }\n\n              if (pp === np && name === \"right\") {\n                assert.strictEqual(parent.right, node);\n                return true;\n              }\n\n              if (pp === np && !util.shouldFlatten(po, no)) {\n                return true;\n              }\n\n              if (pp < np && no === \"%\") {\n                return po === \"+\" || po === \"-\";\n              } // Add parenthesis when working with bitwise operators\n              // It's not strictly needed but helps with code understanding\n\n\n              if (util.isBitwiseOperator(po)) {\n                return true;\n              }\n\n              return false;\n            }\n\n          default:\n            return false;\n        }\n\n      case \"SequenceExpression\":\n        switch (parent.type) {\n          case \"ReturnStatement\":\n            return false;\n\n          case \"ForStatement\":\n            // Although parentheses wouldn't hurt around sequence\n            // expressions in the head of for loops, traditional style\n            // dictates that e.g. i++, j++ should not be wrapped with\n            // parentheses.\n            return false;\n\n          case \"ExpressionStatement\":\n            return name !== \"expression\";\n\n          case \"ArrowFunctionExpression\":\n            // We do need parentheses, but SequenceExpressions are handled\n            // specially when printing bodies of arrow functions.\n            return name !== \"body\";\n\n          default:\n            // Otherwise err on the side of overparenthesization, adding\n            // explicit exceptions above if this proves overzealous.\n            return true;\n        }\n\n      case \"YieldExpression\":\n        if (parent.type === \"UnaryExpression\" || parent.type === \"AwaitExpression\" || parent.type === \"TSAsExpression\" || parent.type === \"TSNonNullExpression\") {\n          return true;\n        }\n\n      // else fallthrough\n\n      case \"AwaitExpression\":\n        switch (parent.type) {\n          case \"TaggedTemplateExpression\":\n          case \"UnaryExpression\":\n          case \"BinaryExpression\":\n          case \"LogicalExpression\":\n          case \"SpreadElement\":\n          case \"SpreadProperty\":\n          case \"TSAsExpression\":\n          case \"TSNonNullExpression\":\n          case \"BindExpression\":\n            return true;\n\n          case \"MemberExpression\":\n          case \"OptionalMemberExpression\":\n            return name === \"object\";\n\n          case \"NewExpression\":\n          case \"CallExpression\":\n          case \"OptionalCallExpression\":\n            return name === \"callee\";\n\n          case \"ConditionalExpression\":\n            return parent.test === node;\n\n          default:\n            return false;\n        }\n\n      case \"TSConditionalType\":\n        if (parent.type === \"TSConditionalType\" && node === parent.extendsType) {\n          return true;\n        }\n\n      // fallthrough\n\n      case \"TSFunctionType\":\n      case \"TSConstructorType\":\n        if (parent.type === \"TSConditionalType\" && node === parent.checkType) {\n          return true;\n        }\n\n      // fallthrough\n\n      case \"TSUnionType\":\n      case \"TSIntersectionType\":\n        if (parent.type === \"TSUnionType\" || parent.type === \"TSIntersectionType\") {\n          return true;\n        }\n\n      // fallthrough\n\n      case \"TSTypeOperator\":\n      case \"TSInferType\":\n        return parent.type === \"TSArrayType\" || parent.type === \"TSOptionalType\" || parent.type === \"TSRestType\" || parent.type === \"TSIndexedAccessType\" && node === parent.objectType || parent.type === \"TSTypeOperator\";\n\n      case \"ArrayTypeAnnotation\":\n        return parent.type === \"NullableTypeAnnotation\";\n\n      case \"IntersectionTypeAnnotation\":\n      case \"UnionTypeAnnotation\":\n        return parent.type === \"ArrayTypeAnnotation\" || parent.type === \"NullableTypeAnnotation\" || parent.type === \"IntersectionTypeAnnotation\" || parent.type === \"UnionTypeAnnotation\";\n\n      case \"NullableTypeAnnotation\":\n        return parent.type === \"ArrayTypeAnnotation\";\n\n      case \"FunctionTypeAnnotation\":\n        {\n          var ancestor = parent.type === \"NullableTypeAnnotation\" ? path.getParentNode(1) : parent;\n          return ancestor.type === \"UnionTypeAnnotation\" || ancestor.type === \"IntersectionTypeAnnotation\" || ancestor.type === \"ArrayTypeAnnotation\" || // We should check ancestor's parent to know whether the parentheses\n          // are really needed, but since ??T doesn't make sense this check\n          // will almost never be true.\n          ancestor.type === \"NullableTypeAnnotation\";\n        }\n\n      case \"StringLiteral\":\n      case \"NumericLiteral\":\n      case \"Literal\":\n        if (typeof node.value === \"string\" && parent.type === \"ExpressionStatement\" && ( // TypeScript workaround for https://github.com/JamesHenry/typescript-estree/issues/2\n        // See corresponding workaround in printer.js case: \"Literal\"\n        options.parser !== \"typescript\" && !parent.directive || options.parser === \"typescript\" && options.originalText.substr(options.locStart(node) - 1, 1) === \"(\")) {\n          // To avoid becoming a directive\n          var grandParent = path.getParentNode(1);\n          return grandParent.type === \"Program\" || grandParent.type === \"BlockStatement\";\n        }\n\n        return parent.type === \"MemberExpression\" && typeof node.value === \"number\" && name === \"object\" && parent.object === node;\n\n      case \"AssignmentExpression\":\n        {\n          var _grandParent = path.getParentNode(1);\n\n          if (parent.type === \"ArrowFunctionExpression\" && parent.body === node) {\n            return true;\n          } else if (parent.type === \"ClassProperty\" && parent.key === node && parent.computed) {\n            return false;\n          } else if (parent.type === \"TSPropertySignature\" && parent.name === node) {\n            return false;\n          } else if (parent.type === \"ForStatement\" && (parent.init === node || parent.update === node)) {\n            return false;\n          } else if (parent.type === \"ExpressionStatement\") {\n            return node.left.type === \"ObjectPattern\";\n          } else if (parent.type === \"TSPropertySignature\" && parent.key === node) {\n            return false;\n          } else if (parent.type === \"AssignmentExpression\") {\n            return false;\n          } else if (parent.type === \"SequenceExpression\" && _grandParent && _grandParent.type === \"ForStatement\" && (_grandParent.init === parent || _grandParent.update === parent)) {\n            return false;\n          } else if (parent.type === \"Property\" && parent.value === node) {\n            return false;\n          } else if (parent.type === \"NGChainedExpression\") {\n            return false;\n          }\n\n          return true;\n        }\n\n      case \"ConditionalExpression\":\n        switch (parent.type) {\n          case \"TaggedTemplateExpression\":\n          case \"UnaryExpression\":\n          case \"SpreadElement\":\n          case \"SpreadProperty\":\n          case \"BinaryExpression\":\n          case \"LogicalExpression\":\n          case \"NGPipeExpression\":\n          case \"ExportDefaultDeclaration\":\n          case \"AwaitExpression\":\n          case \"JSXSpreadAttribute\":\n          case \"TSTypeAssertion\":\n          case \"TypeCastExpression\":\n          case \"TSAsExpression\":\n          case \"TSNonNullExpression\":\n            return true;\n\n          case \"NewExpression\":\n          case \"CallExpression\":\n          case \"OptionalCallExpression\":\n            return name === \"callee\";\n\n          case \"ConditionalExpression\":\n            return name === \"test\" && parent.test === node;\n\n          case \"MemberExpression\":\n          case \"OptionalMemberExpression\":\n            return name === \"object\";\n\n          default:\n            return false;\n        }\n\n      case \"FunctionExpression\":\n        switch (parent.type) {\n          case \"NewExpression\":\n          case \"CallExpression\":\n          case \"OptionalCallExpression\":\n            // Not always necessary, but it's clearer to the reader if IIFEs are wrapped in parentheses.\n            // Is necessary if it is `expression` of `ExpressionStatement`.\n            return name === \"callee\";\n\n          case \"TaggedTemplateExpression\":\n            return true;\n          // This is basically a kind of IIFE.\n\n          default:\n            return false;\n        }\n\n      case \"ArrowFunctionExpression\":\n        switch (parent.type) {\n          case \"NewExpression\":\n          case \"CallExpression\":\n          case \"OptionalCallExpression\":\n            return name === \"callee\";\n\n          case \"MemberExpression\":\n          case \"OptionalMemberExpression\":\n            return name === \"object\";\n\n          case \"TSAsExpression\":\n          case \"BindExpression\":\n          case \"TaggedTemplateExpression\":\n          case \"UnaryExpression\":\n          case \"LogicalExpression\":\n          case \"BinaryExpression\":\n          case \"AwaitExpression\":\n          case \"TSTypeAssertion\":\n            return true;\n\n          case \"ConditionalExpression\":\n            return name === \"test\";\n\n          default:\n            return false;\n        }\n\n      case \"ClassExpression\":\n        switch (parent.type) {\n          case \"NewExpression\":\n            return name === \"callee\" && parent.callee === node;\n\n          default:\n            return false;\n        }\n\n      case \"OptionalMemberExpression\":\n      case \"OptionalCallExpression\":\n        if ((parent.type === \"MemberExpression\" && name === \"object\" || parent.type === \"CallExpression\" && name === \"callee\") && // workaround for https://github.com/facebook/flow/issues/8159\n        !(options.parser === \"flow\" && parent.range[0] === node.range[0])) {\n          return true;\n        }\n\n      // fallthrough\n\n      case \"CallExpression\":\n      case \"MemberExpression\":\n      case \"TaggedTemplateExpression\":\n      case \"TSNonNullExpression\":\n        if ((parent.type === \"BindExpression\" || parent.type === \"NewExpression\") && name === \"callee\") {\n          var object = node;\n\n          while (object) {\n            switch (object.type) {\n              case \"CallExpression\":\n              case \"OptionalCallExpression\":\n                return true;\n\n              case \"MemberExpression\":\n              case \"OptionalMemberExpression\":\n              case \"BindExpression\":\n                object = object.object;\n                break;\n              // tagged templates are basically member expressions from a grammar perspective\n              // see https://tc39.github.io/ecma262/#prod-MemberExpression\n\n              case \"TaggedTemplateExpression\":\n                object = object.tag;\n                break;\n\n              case \"TSNonNullExpression\":\n                object = object.expression;\n                break;\n\n              default:\n                return false;\n            }\n          }\n        }\n\n        return false;\n\n      case \"BindExpression\":\n        return (parent.type === \"BindExpression\" || parent.type === \"NewExpression\") && name === \"callee\" || (parent.type === \"MemberExpression\" || parent.type === \"OptionalMemberExpression\") && name === \"object\";\n\n      case \"NGPipeExpression\":\n        if (parent.type === \"NGRoot\" || parent.type === \"NGMicrosyntaxExpression\" || parent.type === \"ObjectProperty\" || parent.type === \"ArrayExpression\" || (parent.type === \"CallExpression\" || parent.type === \"OptionalCallExpression\") && parent.arguments[name] === node || parent.type === \"NGPipeExpression\" && name === \"right\" || parent.type === \"MemberExpression\" && name === \"property\" || parent.type === \"AssignmentExpression\") {\n          return false;\n        }\n\n        return true;\n\n      case \"JSXFragment\":\n      case \"JSXElement\":\n        return name === \"callee\" || parent.type !== \"ArrayExpression\" && parent.type !== \"ArrowFunctionExpression\" && parent.type !== \"AssignmentExpression\" && parent.type !== \"AssignmentPattern\" && parent.type !== \"BinaryExpression\" && parent.type !== \"CallExpression\" && parent.type !== \"ConditionalExpression\" && parent.type !== \"ExpressionStatement\" && parent.type !== \"JsExpressionRoot\" && parent.type !== \"JSXAttribute\" && parent.type !== \"JSXElement\" && parent.type !== \"JSXExpressionContainer\" && parent.type !== \"JSXFragment\" && parent.type !== \"LogicalExpression\" && parent.type !== \"ObjectProperty\" && parent.type !== \"OptionalCallExpression\" && parent.type !== \"Property\" && parent.type !== \"ReturnStatement\" && parent.type !== \"TypeCastExpression\" && parent.type !== \"VariableDeclarator\";\n\n      case \"TypeAnnotation\":\n        return name === \"returnType\" && parent.type === \"ArrowFunctionExpression\" && includesFunctionTypeInObjectType(node);\n    }\n\n    return false;\n  }\n\n  function isStatement(node) {\n    return node.type === \"BlockStatement\" || node.type === \"BreakStatement\" || node.type === \"ClassBody\" || node.type === \"ClassDeclaration\" || node.type === \"ClassMethod\" || node.type === \"ClassProperty\" || node.type === \"ClassPrivateProperty\" || node.type === \"ContinueStatement\" || node.type === \"DebuggerStatement\" || node.type === \"DeclareClass\" || node.type === \"DeclareExportAllDeclaration\" || node.type === \"DeclareExportDeclaration\" || node.type === \"DeclareFunction\" || node.type === \"DeclareInterface\" || node.type === \"DeclareModule\" || node.type === \"DeclareModuleExports\" || node.type === \"DeclareVariable\" || node.type === \"DoWhileStatement\" || node.type === \"EnumDeclaration\" || node.type === \"ExportAllDeclaration\" || node.type === \"ExportDefaultDeclaration\" || node.type === \"ExportNamedDeclaration\" || node.type === \"ExpressionStatement\" || node.type === \"ForAwaitStatement\" || node.type === \"ForInStatement\" || node.type === \"ForOfStatement\" || node.type === \"ForStatement\" || node.type === \"FunctionDeclaration\" || node.type === \"IfStatement\" || node.type === \"ImportDeclaration\" || node.type === \"InterfaceDeclaration\" || node.type === \"LabeledStatement\" || node.type === \"MethodDefinition\" || node.type === \"ReturnStatement\" || node.type === \"SwitchStatement\" || node.type === \"ThrowStatement\" || node.type === \"TryStatement\" || node.type === \"TSDeclareFunction\" || node.type === \"TSEnumDeclaration\" || node.type === \"TSImportEqualsDeclaration\" || node.type === \"TSInterfaceDeclaration\" || node.type === \"TSModuleDeclaration\" || node.type === \"TSNamespaceExportDeclaration\" || node.type === \"TypeAlias\" || node.type === \"VariableDeclaration\" || node.type === \"WhileStatement\" || node.type === \"WithStatement\";\n  }\n\n  function includesFunctionTypeInObjectType(node) {\n    return hasNode$1(node, function (n1) {\n      return n1.type === \"ObjectTypeAnnotation\" && hasNode$1(n1, function (n2) {\n        return n2.type === \"FunctionTypeAnnotation\" || undefined;\n      }) || undefined;\n    });\n  }\n\n  function endsWithRightBracket(node) {\n    switch (node.type) {\n      case \"ObjectExpression\":\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  function isFollowedByRightBracket(path) {\n    var node = path.getValue();\n    var parent = path.getParentNode();\n    var name = path.getName();\n\n    switch (parent.type) {\n      case \"NGPipeExpression\":\n        if (typeof name === \"number\" && parent.arguments[name] === node && parent.arguments.length - 1 === name) {\n          return path.callParent(isFollowedByRightBracket);\n        }\n\n        break;\n\n      case \"ObjectProperty\":\n        if (name === \"value\") {\n          var parentParent = path.getParentNode(1);\n          return parentParent.properties[parentParent.properties.length - 1] === parent;\n        }\n\n        break;\n\n      case \"BinaryExpression\":\n      case \"LogicalExpression\":\n        if (name === \"right\") {\n          return path.callParent(isFollowedByRightBracket);\n        }\n\n        break;\n\n      case \"ConditionalExpression\":\n        if (name === \"alternate\") {\n          return path.callParent(isFollowedByRightBracket);\n        }\n\n        break;\n\n      case \"UnaryExpression\":\n        if (parent.prefix) {\n          return path.callParent(isFollowedByRightBracket);\n        }\n\n        break;\n    }\n\n    return false;\n  }\n\n  function shouldWrapFunctionForExportDefault(path, options) {\n    var node = path.getValue();\n    var parent = path.getParentNode();\n\n    if (node.type === \"FunctionExpression\" || node.type === \"ClassExpression\") {\n      return parent.type === \"ExportDefaultDeclaration\" || // in some cases the function is already wrapped\n      // (e.g. `export default (function() {})();`)\n      // in this case we don't need to add extra parens\n      !needsParens(path, options);\n    }\n\n    if (!hasNakedLeftSide$1(node) || parent.type !== \"ExportDefaultDeclaration\" && needsParens(path, options)) {\n      return false;\n    }\n\n    return path.call.apply(path, [function (childPath) {\n      return shouldWrapFunctionForExportDefault(childPath, options);\n    }].concat(getLeftSidePathName$1(path, node)));\n  }\n\n  var needsParens_1 = needsParens;\n\n  var _require$$0$builders$6 = doc.builders,\n      concat$c = _require$$0$builders$6.concat,\n      join$8 = _require$$0$builders$6.join,\n      line$6 = _require$$0$builders$6.line;\n\n  function printHtmlBinding(path, options, print) {\n    var node = path.getValue();\n\n    if (options.__onHtmlBindingRoot && path.getName() === null) {\n      options.__onHtmlBindingRoot(node);\n    }\n\n    if (node.type !== \"File\") {\n      return;\n    }\n\n    if (options.__isVueForBindingLeft) {\n      return path.call(function (functionDeclarationPath) {\n        var _functionDeclarationP = functionDeclarationPath.getValue(),\n            params = _functionDeclarationP.params;\n\n        return concat$c([params.length > 1 ? \"(\" : \"\", join$8(concat$c([\",\", line$6]), functionDeclarationPath.map(print, \"params\")), params.length > 1 ? \")\" : \"\"]);\n      }, \"program\", \"body\", 0);\n    }\n\n    if (options.__isVueSlotScope) {\n      return path.call(function (functionDeclarationPath) {\n        return join$8(concat$c([\",\", line$6]), functionDeclarationPath.map(print, \"params\"));\n      }, \"program\", \"body\", 0);\n    }\n  } // based on https://github.com/prettier/prettier/blob/master/src/language-html/syntax-vue.js isVueEventBindingExpression()\n\n\n  function isVueEventBindingExpression$2(node) {\n    switch (node.type) {\n      case \"MemberExpression\":\n        switch (node.property.type) {\n          case \"Identifier\":\n          case \"NumericLiteral\":\n          case \"StringLiteral\":\n            return isVueEventBindingExpression$2(node.object);\n        }\n\n        return false;\n\n      case \"Identifier\":\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  var htmlBinding = {\n    isVueEventBindingExpression: isVueEventBindingExpression$2,\n    printHtmlBinding: printHtmlBinding\n  };\n\n  function preprocess$1(ast, options) {\n    switch (options.parser) {\n      case \"json\":\n      case \"json5\":\n      case \"json-stringify\":\n      case \"__js_expression\":\n      case \"__vue_expression\":\n        return Object.assign({}, ast, {\n          type: options.parser.startsWith(\"__\") ? \"JsExpressionRoot\" : \"JsonRoot\",\n          node: ast,\n          comments: []\n        });\n\n      default:\n        return ast;\n    }\n  }\n\n  var preprocess_1$1 = preprocess$1;\n\n  var getParentExportDeclaration$1 = util.getParentExportDeclaration,\n      isExportDeclaration$1 = util.isExportDeclaration,\n      shouldFlatten$1 = util.shouldFlatten,\n      getNextNonSpaceNonCommentCharacter$1 = util.getNextNonSpaceNonCommentCharacter,\n      hasNewline$4 = util.hasNewline,\n      hasNewlineInRange$2 = util.hasNewlineInRange,\n      getLast$2 = util.getLast,\n      getStringWidth$2 = util.getStringWidth,\n      printString$2 = util.printString,\n      printNumber$2 = util.printNumber,\n      hasIgnoreComment$4 = util.hasIgnoreComment,\n      hasNodeIgnoreComment$2 = util.hasNodeIgnoreComment,\n      getPenultimate$1 = util.getPenultimate,\n      startsWithNoLookaheadToken$1 = util.startsWithNoLookaheadToken,\n      getIndentSize$1 = util.getIndentSize,\n      matchAncestorTypes$1 = util.matchAncestorTypes,\n      getPreferredQuote$1 = util.getPreferredQuote;\n  var isNextLineEmpty$4 = utilShared.isNextLineEmpty,\n      isNextLineEmptyAfterIndex$1 = utilShared.isNextLineEmptyAfterIndex,\n      getNextNonSpaceNonCommentCharacterIndex$2 = utilShared.getNextNonSpaceNonCommentCharacterIndex;\n  var insertPragma$7 = pragma.insertPragma;\n  var printHtmlBinding$1 = htmlBinding.printHtmlBinding,\n      isVueEventBindingExpression$3 = htmlBinding.isVueEventBindingExpression;\n  var classChildNeedsASIProtection$1 = utils$4.classChildNeedsASIProtection,\n      classPropMayCauseASIProblems$1 = utils$4.classPropMayCauseASIProblems,\n      conditionalExpressionChainContainsJSX$1 = utils$4.conditionalExpressionChainContainsJSX,\n      getFlowVariance$1 = utils$4.getFlowVariance,\n      getLeftSidePathName$2 = utils$4.getLeftSidePathName,\n      getTypeScriptMappedTypeModifier$1 = utils$4.getTypeScriptMappedTypeModifier,\n      hasDanglingComments$1 = utils$4.hasDanglingComments,\n      hasFlowAnnotationComment$1 = utils$4.hasFlowAnnotationComment,\n      hasFlowShorthandAnnotationComment$2 = utils$4.hasFlowShorthandAnnotationComment,\n      hasLeadingComment$3 = utils$4.hasLeadingComment,\n      hasLeadingOwnLineComment$1 = utils$4.hasLeadingOwnLineComment,\n      hasNakedLeftSide$2 = utils$4.hasNakedLeftSide,\n      hasNewlineBetweenOrAfterDecorators$1 = utils$4.hasNewlineBetweenOrAfterDecorators,\n      hasNgSideEffect$1 = utils$4.hasNgSideEffect,\n      hasPrettierIgnore$3 = utils$4.hasPrettierIgnore,\n      hasTrailingComment$1 = utils$4.hasTrailingComment,\n      identity$2 = utils$4.identity,\n      isBinaryish$1 = utils$4.isBinaryish,\n      isCallOrOptionalCallExpression$1 = utils$4.isCallOrOptionalCallExpression,\n      isEmptyJSXElement$1 = utils$4.isEmptyJSXElement,\n      isFlowAnnotationComment$1 = utils$4.isFlowAnnotationComment,\n      isFunctionCompositionArgs$1 = utils$4.isFunctionCompositionArgs,\n      isFunctionNotation$1 = utils$4.isFunctionNotation,\n      isFunctionOrArrowExpression$1 = utils$4.isFunctionOrArrowExpression,\n      isGetterOrSetter$1 = utils$4.isGetterOrSetter,\n      isJestEachTemplateLiteral$1 = utils$4.isJestEachTemplateLiteral,\n      isJSXNode$1 = utils$4.isJSXNode,\n      isJSXWhitespaceExpression$1 = utils$4.isJSXWhitespaceExpression,\n      isLastStatement$1 = utils$4.isLastStatement,\n      isLiteral$1 = utils$4.isLiteral,\n      isLongCurriedCallExpression$1 = utils$4.isLongCurriedCallExpression,\n      isMeaningfulJSXText$1 = utils$4.isMeaningfulJSXText,\n      isMemberExpressionChain$1 = utils$4.isMemberExpressionChain,\n      isMemberish$1 = utils$4.isMemberish,\n      isNgForOf$1 = utils$4.isNgForOf,\n      isNumericLiteral$1 = utils$4.isNumericLiteral,\n      isObjectType$1 = utils$4.isObjectType,\n      isObjectTypePropertyAFunction$1 = utils$4.isObjectTypePropertyAFunction,\n      isSimpleFlowType$1 = utils$4.isSimpleFlowType,\n      isSimpleTemplateLiteral$1 = utils$4.isSimpleTemplateLiteral,\n      isStringLiteral$1 = utils$4.isStringLiteral,\n      isStringPropSafeToCoerceToIdentifier$1 = utils$4.isStringPropSafeToCoerceToIdentifier,\n      isTemplateOnItsOwnLine$1 = utils$4.isTemplateOnItsOwnLine,\n      isTestCall$1 = utils$4.isTestCall,\n      isTheOnlyJSXElementInMarkdown$1 = utils$4.isTheOnlyJSXElementInMarkdown,\n      isTSXFile$1 = utils$4.isTSXFile,\n      isTypeAnnotationAFunction$1 = utils$4.isTypeAnnotationAFunction,\n      matchJsxWhitespaceRegex$1 = utils$4.matchJsxWhitespaceRegex,\n      needsHardlineAfterDanglingComment$1 = utils$4.needsHardlineAfterDanglingComment,\n      rawText$1 = utils$4.rawText,\n      returnArgumentHasLeadingComment$1 = utils$4.returnArgumentHasLeadingComment;\n  var needsQuoteProps = new WeakMap();\n  var _require$$5$builders = doc.builders,\n      concat$d = _require$$5$builders.concat,\n      join$9 = _require$$5$builders.join,\n      line$7 = _require$$5$builders.line,\n      hardline$9 = _require$$5$builders.hardline,\n      softline$6 = _require$$5$builders.softline,\n      literalline$4 = _require$$5$builders.literalline,\n      group$b = _require$$5$builders.group,\n      indent$7 = _require$$5$builders.indent,\n      align$1 = _require$$5$builders.align,\n      conditionalGroup$1 = _require$$5$builders.conditionalGroup,\n      fill$4 = _require$$5$builders.fill,\n      ifBreak$6 = _require$$5$builders.ifBreak,\n      breakParent$3 = _require$$5$builders.breakParent,\n      lineSuffixBoundary$1 = _require$$5$builders.lineSuffixBoundary,\n      addAlignmentToDoc$2 = _require$$5$builders.addAlignmentToDoc,\n      dedent$2 = _require$$5$builders.dedent,\n      _require$$5$utils = doc.utils,\n      willBreak$1 = _require$$5$utils.willBreak,\n      isLineNext$1 = _require$$5$utils.isLineNext,\n      isEmpty$1 = _require$$5$utils.isEmpty,\n      removeLines$2 = _require$$5$utils.removeLines,\n      printDocToString$1 = doc.printer.printDocToString;\n  var uid = 0;\n\n  function shouldPrintComma$1(options, level) {\n    level = level || \"es5\";\n\n    switch (options.trailingComma) {\n      case \"all\":\n        if (level === \"all\") {\n          return true;\n        }\n\n      // fallthrough\n\n      case \"es5\":\n        if (level === \"es5\") {\n          return true;\n        }\n\n      // fallthrough\n\n      case \"none\":\n      default:\n        return false;\n    }\n  }\n\n  function genericPrint$3(path, options, printPath, args) {\n    var node = path.getValue();\n    var needsParens = false;\n    var linesWithoutParens = printPathNoParens(path, options, printPath, args);\n\n    if (!node || isEmpty$1(linesWithoutParens)) {\n      return linesWithoutParens;\n    }\n\n    var parentExportDecl = getParentExportDeclaration$1(path);\n    var decorators = [];\n\n    if (node.type === \"ClassMethod\" || node.type === \"ClassPrivateMethod\" || node.type === \"ClassProperty\" || node.type === \"TSAbstractClassProperty\" || node.type === \"ClassPrivateProperty\" || node.type === \"MethodDefinition\" || node.type === \"TSAbstractMethodDefinition\") ; else if (node.decorators && node.decorators.length > 0 && // If the parent node is an export declaration and the decorator\n    // was written before the export, the export will be responsible\n    // for printing the decorators.\n    !(parentExportDecl && options.locStart(parentExportDecl, {\n      ignoreDecorators: true\n    }) > options.locStart(node.decorators[0]))) {\n      var shouldBreak = node.type === \"ClassExpression\" || node.type === \"ClassDeclaration\" || hasNewlineBetweenOrAfterDecorators$1(node, options);\n      var separator = shouldBreak ? hardline$9 : line$7;\n      path.each(function (decoratorPath) {\n        var decorator = decoratorPath.getValue();\n\n        if (decorator.expression) {\n          decorator = decorator.expression;\n        } else {\n          decorator = decorator.callee;\n        }\n\n        decorators.push(printPath(decoratorPath), separator);\n      }, \"decorators\");\n\n      if (parentExportDecl) {\n        decorators.unshift(hardline$9);\n      }\n    } else if (isExportDeclaration$1(node) && node.declaration && node.declaration.decorators && node.declaration.decorators.length > 0 && // Only print decorators here if they were written before the export,\n    // otherwise they are printed by the node.declaration\n    options.locStart(node, {\n      ignoreDecorators: true\n    }) > options.locStart(node.declaration.decorators[0])) {\n      // Export declarations are responsible for printing any decorators\n      // that logically apply to node.declaration.\n      path.each(function (decoratorPath) {\n        var decorator = decoratorPath.getValue();\n        var prefix = decorator.type === \"Decorator\" ? \"\" : \"@\";\n        decorators.push(prefix, printPath(decoratorPath), hardline$9);\n      }, \"declaration\", \"decorators\");\n    } else {\n      // Nodes with decorators can't have parentheses, so we can avoid\n      // computing pathNeedsParens() except in this case.\n      needsParens = needsParens_1(path, options);\n    }\n\n    var parts = [];\n\n    if (needsParens) {\n      parts.unshift(\"(\");\n    }\n\n    parts.push(linesWithoutParens);\n\n    if (needsParens) {\n      var _node = path.getValue();\n\n      if (hasFlowShorthandAnnotationComment$2(_node)) {\n        parts.push(\" /*\");\n        parts.push(_node.trailingComments[0].value.trimLeft());\n        parts.push(\"*/\");\n        _node.trailingComments[0].printed = true;\n      }\n\n      parts.push(\")\");\n    }\n\n    if (decorators.length > 0) {\n      return group$b(concat$d(decorators.concat(parts)));\n    }\n\n    return concat$d(parts);\n  }\n\n  function printDecorators(path, options, print) {\n    var node = path.getValue();\n    return group$b(concat$d([join$9(line$7, path.map(print, \"decorators\")), hasNewlineBetweenOrAfterDecorators$1(node, options) ? hardline$9 : line$7]));\n  }\n  /**\n   * The following is the shared logic for\n   * ternary operators, namely ConditionalExpression\n   * and TSConditionalType\n   * @typedef {Object} OperatorOptions\n   * @property {() => Array<string | Doc>} beforeParts - Parts to print before the `?`.\n   * @property {(breakClosingParen: boolean) => Array<string | Doc>} afterParts - Parts to print after the conditional expression.\n   * @property {boolean} shouldCheckJsx - Whether to check for and print in JSX mode.\n   * @property {string} conditionalNodeType - The type of the conditional expression node, ie \"ConditionalExpression\" or \"TSConditionalType\".\n   * @property {string} consequentNodePropertyName - The property at which the consequent node can be found on the main node, eg \"consequent\".\n   * @property {string} alternateNodePropertyName - The property at which the alternate node can be found on the main node, eg \"alternate\".\n   * @property {string} testNodePropertyName - The property at which the test node can be found on the main node, eg \"test\".\n   * @property {boolean} breakNested - Whether to break all nested ternaries when one breaks.\n   * @param {FastPath} path - The path to the ConditionalExpression/TSConditionalType node.\n   * @param {Options} options - Prettier options\n   * @param {Function} print - Print function to call recursively\n   * @param {OperatorOptions} operatorOptions\n   * @returns Doc\n   */\n\n\n  function printTernaryOperator(path, options, print, operatorOptions) {\n    var node = path.getValue();\n    var testNode = node[operatorOptions.testNodePropertyName];\n    var consequentNode = node[operatorOptions.consequentNodePropertyName];\n    var alternateNode = node[operatorOptions.alternateNodePropertyName];\n    var parts = []; // We print a ConditionalExpression in either \"JSX mode\" or \"normal mode\".\n    // See tests/jsx/conditional-expression.js for more info.\n\n    var jsxMode = false;\n    var parent = path.getParentNode();\n    var forceNoIndent = parent.type === operatorOptions.conditionalNodeType; // Find the outermost non-ConditionalExpression parent, and the outermost\n    // ConditionalExpression parent. We'll use these to determine if we should\n    // print in JSX mode.\n\n    var currentParent;\n    var previousParent;\n    var i = 0;\n\n    do {\n      previousParent = currentParent || node;\n      currentParent = path.getParentNode(i);\n      i++;\n    } while (currentParent && currentParent.type === operatorOptions.conditionalNodeType);\n\n    var firstNonConditionalParent = currentParent || parent;\n    var lastConditionalParent = previousParent;\n\n    if (operatorOptions.shouldCheckJsx && (isJSXNode$1(testNode) || isJSXNode$1(consequentNode) || isJSXNode$1(alternateNode) || conditionalExpressionChainContainsJSX$1(lastConditionalParent))) {\n      jsxMode = true;\n      forceNoIndent = true; // Even though they don't need parens, we wrap (almost) everything in\n      // parens when using ?: within JSX, because the parens are analogous to\n      // curly braces in an if statement.\n\n      var wrap = function wrap(doc) {\n        return concat$d([ifBreak$6(\"(\", \"\"), indent$7(concat$d([softline$6, doc])), softline$6, ifBreak$6(\")\", \"\")]);\n      }; // The only things we don't wrap are:\n      // * Nested conditional expressions in alternates\n      // * null\n\n\n      var isNull = function isNull(node) {\n        return node.type === \"NullLiteral\" || node.type === \"Literal\" && node.value === null;\n      };\n\n      parts.push(\" ? \", isNull(consequentNode) ? path.call(print, operatorOptions.consequentNodePropertyName) : wrap(path.call(print, operatorOptions.consequentNodePropertyName)), \" : \", alternateNode.type === operatorOptions.conditionalNodeType || isNull(alternateNode) ? path.call(print, operatorOptions.alternateNodePropertyName) : wrap(path.call(print, operatorOptions.alternateNodePropertyName)));\n    } else {\n      // normal mode\n      var part = concat$d([line$7, \"? \", consequentNode.type === operatorOptions.conditionalNodeType ? ifBreak$6(\"\", \"(\") : \"\", align$1(2, path.call(print, operatorOptions.consequentNodePropertyName)), consequentNode.type === operatorOptions.conditionalNodeType ? ifBreak$6(\"\", \")\") : \"\", line$7, \": \", alternateNode.type === operatorOptions.conditionalNodeType ? path.call(print, operatorOptions.alternateNodePropertyName) : align$1(2, path.call(print, operatorOptions.alternateNodePropertyName))]);\n      parts.push(parent.type !== operatorOptions.conditionalNodeType || parent[operatorOptions.alternateNodePropertyName] === node ? part : options.useTabs ? dedent$2(indent$7(part)) : align$1(Math.max(0, options.tabWidth - 2), part));\n    } // We want a whole chain of ConditionalExpressions to all\n    // break if any of them break. That means we should only group around the\n    // outer-most ConditionalExpression.\n\n\n    var maybeGroup = function maybeGroup(doc) {\n      return operatorOptions.breakNested ? parent === firstNonConditionalParent ? group$b(doc) : doc : group$b(doc);\n    }; // Break the closing paren to keep the chain right after it:\n    // (a\n    //   ? b\n    //   : c\n    // ).call()\n\n\n    var breakClosingParen = !jsxMode && (parent.type === \"MemberExpression\" || parent.type === \"OptionalMemberExpression\" || parent.type === \"NGPipeExpression\" && parent.left === node && operatorOptions.breakNested) && !parent.computed;\n    return maybeGroup(concat$d([].concat(function (testDoc) {\n      return (\n        /**\n         *     a\n         *       ? b\n         *       : multiline\n         *         test\n         *         node\n         *       ^^ align(2)\n         *       ? d\n         *       : e\n         */\n        parent.type === operatorOptions.conditionalNodeType && parent[operatorOptions.alternateNodePropertyName] === node ? align$1(2, testDoc) : testDoc\n      );\n    }(concat$d(operatorOptions.beforeParts())), forceNoIndent ? concat$d(parts) : indent$7(concat$d(parts)), operatorOptions.afterParts(breakClosingParen))));\n  }\n\n  function printPathNoParens(path, options, print, args) {\n    var n = path.getValue();\n    var semi = options.semi ? \";\" : \"\";\n\n    if (!n) {\n      return \"\";\n    }\n\n    if (typeof n === \"string\") {\n      return n;\n    }\n\n    var htmlBinding = printHtmlBinding$1(path, options, print);\n\n    if (htmlBinding) {\n      return htmlBinding;\n    }\n\n    var parts = [];\n\n    switch (n.type) {\n      case \"JsExpressionRoot\":\n        return path.call(print, \"node\");\n\n      case \"JsonRoot\":\n        return concat$d([path.call(print, \"node\"), hardline$9]);\n\n      case \"File\":\n        // Print @babel/parser's InterpreterDirective here so that\n        // leading comments on the `Program` node get printed after the hashbang.\n        if (n.program && n.program.interpreter) {\n          parts.push(path.call(function (programPath) {\n            return programPath.call(print, \"interpreter\");\n          }, \"program\"));\n        }\n\n        parts.push(path.call(print, \"program\"));\n        return concat$d(parts);\n\n      case \"Program\":\n        // Babel 6\n        if (n.directives) {\n          path.each(function (childPath) {\n            parts.push(print(childPath), semi, hardline$9);\n\n            if (isNextLineEmpty$4(options.originalText, childPath.getValue(), options)) {\n              parts.push(hardline$9);\n            }\n          }, \"directives\");\n        }\n\n        parts.push(path.call(function (bodyPath) {\n          return printStatementSequence(bodyPath, options, print);\n        }, \"body\"));\n        parts.push(comments.printDanglingComments(path, options,\n        /* sameIndent */\n        true)); // Only force a trailing newline if there were any contents.\n\n        if (n.body.length || n.comments) {\n          parts.push(hardline$9);\n        }\n\n        return concat$d(parts);\n      // Babel extension.\n\n      case \"EmptyStatement\":\n        return \"\";\n\n      case \"ExpressionStatement\":\n        // Detect Flow-parsed directives\n        if (n.directive) {\n          return concat$d([nodeStr(n.expression, options, true), semi]);\n        }\n\n        if (options.parser === \"__vue_event_binding\") {\n          var parent = path.getParentNode();\n\n          if (parent.type === \"Program\" && parent.body.length === 1 && parent.body[0] === n) {\n            return concat$d([path.call(print, \"expression\"), isVueEventBindingExpression$3(n.expression) ? \";\" : \"\"]);\n          }\n        } // Do not append semicolon after the only JSX element in a program\n\n\n        return concat$d([path.call(print, \"expression\"), isTheOnlyJSXElementInMarkdown$1(options, path) ? \"\" : semi]);\n      // Babel extension.\n\n      case \"ParenthesizedExpression\":\n        return concat$d([\"(\", path.call(print, \"expression\"), \")\"]);\n\n      case \"AssignmentExpression\":\n        return printAssignment(n.left, path.call(print, \"left\"), concat$d([\" \", n.operator]), n.right, path.call(print, \"right\"), options);\n\n      case \"BinaryExpression\":\n      case \"LogicalExpression\":\n      case \"NGPipeExpression\":\n        {\n          var _parent = path.getParentNode();\n\n          var parentParent = path.getParentNode(1);\n          var isInsideParenthesis = n !== _parent.body && (_parent.type === \"IfStatement\" || _parent.type === \"WhileStatement\" || _parent.type === \"SwitchStatement\" || _parent.type === \"DoWhileStatement\");\n\n          var _parts = printBinaryishExpressions(path, print, options,\n          /* isNested */\n          false, isInsideParenthesis); //   if (\n          //     this.hasPlugin(\"dynamicImports\") && this.lookahead().type === tt.parenLeft\n          //   ) {\n          //\n          // looks super weird, we want to break the children if the parent breaks\n          //\n          //   if (\n          //     this.hasPlugin(\"dynamicImports\") &&\n          //     this.lookahead().type === tt.parenLeft\n          //   ) {\n\n\n          if (isInsideParenthesis) {\n            return concat$d(_parts);\n          } // Break between the parens in\n          // unaries or in a member or specific call expression, i.e.\n          //\n          //   (\n          //     a &&\n          //     b &&\n          //     c\n          //   ).call()\n\n\n          if ((_parent.type === \"CallExpression\" || _parent.type === \"OptionalCallExpression\") && _parent.callee === n || _parent.type === \"UnaryExpression\" || (_parent.type === \"MemberExpression\" || _parent.type === \"OptionalMemberExpression\") && !_parent.computed) {\n            return group$b(concat$d([indent$7(concat$d([softline$6, concat$d(_parts)])), softline$6]));\n          } // Avoid indenting sub-expressions in some cases where the first sub-expression is already\n          // indented accordingly. We should indent sub-expressions where the first case isn't indented.\n\n\n          var shouldNotIndent = _parent.type === \"ReturnStatement\" || _parent.type === \"JSXExpressionContainer\" && parentParent.type === \"JSXAttribute\" || n.type !== \"NGPipeExpression\" && (_parent.type === \"NGRoot\" && options.parser === \"__ng_binding\" || _parent.type === \"NGMicrosyntaxExpression\" && parentParent.type === \"NGMicrosyntax\" && parentParent.body.length === 1) || n === _parent.body && _parent.type === \"ArrowFunctionExpression\" || n !== _parent.body && _parent.type === \"ForStatement\" || _parent.type === \"ConditionalExpression\" && parentParent.type !== \"ReturnStatement\" && parentParent.type !== \"CallExpression\" && parentParent.type !== \"OptionalCallExpression\";\n          var shouldIndentIfInlining = _parent.type === \"AssignmentExpression\" || _parent.type === \"VariableDeclarator\" || _parent.type === \"ClassProperty\" || _parent.type === \"TSAbstractClassProperty\" || _parent.type === \"ClassPrivateProperty\" || _parent.type === \"ObjectProperty\" || _parent.type === \"Property\";\n          var samePrecedenceSubExpression = isBinaryish$1(n.left) && shouldFlatten$1(n.operator, n.left.operator);\n\n          if (shouldNotIndent || shouldInlineLogicalExpression(n) && !samePrecedenceSubExpression || !shouldInlineLogicalExpression(n) && shouldIndentIfInlining) {\n            return group$b(concat$d(_parts));\n          }\n\n          if (_parts.length === 0) {\n            return \"\";\n          } // If the right part is a JSX node, we include it in a separate group to\n          // prevent it breaking the whole chain, so we can print the expression like:\n          //\n          //   foo && bar && (\n          //     <Foo>\n          //       <Bar />\n          //     </Foo>\n          //   )\n\n\n          var hasJSX = isJSXNode$1(n.right);\n          var rest = concat$d(hasJSX ? _parts.slice(1, -1) : _parts.slice(1));\n          var groupId = Symbol(\"logicalChain-\" + ++uid);\n          var chain = group$b(concat$d([// Don't include the initial expression in the indentation\n          // level. The first item is guaranteed to be the first\n          // left-most expression.\n          _parts.length > 0 ? _parts[0] : \"\", indent$7(rest)]), {\n            id: groupId\n          });\n\n          if (!hasJSX) {\n            return chain;\n          }\n\n          var jsxPart = getLast$2(_parts);\n          return group$b(concat$d([chain, ifBreak$6(indent$7(jsxPart), jsxPart, {\n            groupId: groupId\n          })]));\n        }\n\n      case \"AssignmentPattern\":\n        return concat$d([path.call(print, \"left\"), \" = \", path.call(print, \"right\")]);\n\n      case \"TSTypeAssertion\":\n        {\n          var shouldBreakAfterCast = !(n.expression.type === \"ArrayExpression\" || n.expression.type === \"ObjectExpression\");\n          var castGroup = group$b(concat$d([\"<\", indent$7(concat$d([softline$6, path.call(print, \"typeAnnotation\")])), softline$6, \">\"]));\n          var exprContents = concat$d([ifBreak$6(\"(\"), indent$7(concat$d([softline$6, path.call(print, \"expression\")])), softline$6, ifBreak$6(\")\")]);\n\n          if (shouldBreakAfterCast) {\n            return conditionalGroup$1([concat$d([castGroup, path.call(print, \"expression\")]), concat$d([castGroup, group$b(exprContents, {\n              shouldBreak: true\n            })]), concat$d([castGroup, path.call(print, \"expression\")])]);\n          }\n\n          return group$b(concat$d([castGroup, path.call(print, \"expression\")]));\n        }\n\n      case \"OptionalMemberExpression\":\n      case \"MemberExpression\":\n        {\n          var _parent2 = path.getParentNode();\n\n          var firstNonMemberParent;\n          var i = 0;\n\n          do {\n            firstNonMemberParent = path.getParentNode(i);\n            i++;\n          } while (firstNonMemberParent && (firstNonMemberParent.type === \"MemberExpression\" || firstNonMemberParent.type === \"OptionalMemberExpression\" || firstNonMemberParent.type === \"TSNonNullExpression\"));\n\n          var shouldInline = firstNonMemberParent && (firstNonMemberParent.type === \"NewExpression\" || firstNonMemberParent.type === \"BindExpression\" || firstNonMemberParent.type === \"VariableDeclarator\" && firstNonMemberParent.id.type !== \"Identifier\" || firstNonMemberParent.type === \"AssignmentExpression\" && firstNonMemberParent.left.type !== \"Identifier\") || n.computed || n.object.type === \"Identifier\" && n.property.type === \"Identifier\" && _parent2.type !== \"MemberExpression\" && _parent2.type !== \"OptionalMemberExpression\";\n          return concat$d([path.call(print, \"object\"), shouldInline ? printMemberLookup(path, options, print) : group$b(indent$7(concat$d([softline$6, printMemberLookup(path, options, print)])))]);\n        }\n\n      case \"MetaProperty\":\n        return concat$d([path.call(print, \"meta\"), \".\", path.call(print, \"property\")]);\n\n      case \"BindExpression\":\n        if (n.object) {\n          parts.push(path.call(print, \"object\"));\n        }\n\n        parts.push(group$b(indent$7(concat$d([softline$6, printBindExpressionCallee(path, options, print)]))));\n        return concat$d(parts);\n\n      case \"Identifier\":\n        {\n          return concat$d([n.name, printOptionalToken(path), printTypeAnnotation(path, options, print)]);\n        }\n\n      case \"V8IntrinsicIdentifier\":\n        return concat$d([\"%\", n.name]);\n\n      case \"SpreadElement\":\n      case \"SpreadElementPattern\":\n      case \"RestProperty\":\n      case \"SpreadProperty\":\n      case \"SpreadPropertyPattern\":\n      case \"RestElement\":\n      case \"ObjectTypeSpreadProperty\":\n        return concat$d([\"...\", path.call(print, \"argument\"), printTypeAnnotation(path, options, print)]);\n\n      case \"FunctionDeclaration\":\n      case \"FunctionExpression\":\n        parts.push(printFunctionDeclaration(path, print, options));\n\n        if (!n.body) {\n          parts.push(semi);\n        }\n\n        return concat$d(parts);\n\n      case \"ArrowFunctionExpression\":\n        {\n          if (n.async) {\n            parts.push(\"async \");\n          }\n\n          if (shouldPrintParamsWithoutParens(path, options)) {\n            parts.push(path.call(print, \"params\", 0));\n          } else {\n            parts.push(group$b(concat$d([printFunctionParams(path, print, options,\n            /* expandLast */\n            args && (args.expandLastArg || args.expandFirstArg),\n            /* printTypeParams */\n            true), printReturnType(path, print, options)])));\n          }\n\n          var dangling = comments.printDanglingComments(path, options,\n          /* sameIndent */\n          true, function (comment) {\n            var nextCharacter = getNextNonSpaceNonCommentCharacterIndex$2(options.originalText, comment, options);\n            return options.originalText.substr(nextCharacter, 2) === \"=>\";\n          });\n\n          if (dangling) {\n            parts.push(\" \", dangling);\n          }\n\n          parts.push(\" =>\");\n          var body = path.call(function (bodyPath) {\n            return print(bodyPath, args);\n          }, \"body\"); // We want to always keep these types of nodes on the same line\n          // as the arrow.\n\n          if (!hasLeadingOwnLineComment$1(options.originalText, n.body, options) && (n.body.type === \"ArrayExpression\" || n.body.type === \"ObjectExpression\" || n.body.type === \"BlockStatement\" || isJSXNode$1(n.body) || isTemplateOnItsOwnLine$1(n.body, options.originalText, options) || n.body.type === \"ArrowFunctionExpression\" || n.body.type === \"DoExpression\")) {\n            return group$b(concat$d([concat$d(parts), \" \", body]));\n          } // We handle sequence expressions as the body of arrows specially,\n          // so that the required parentheses end up on their own lines.\n\n\n          if (n.body.type === \"SequenceExpression\") {\n            return group$b(concat$d([concat$d(parts), group$b(concat$d([\" (\", indent$7(concat$d([softline$6, body])), softline$6, \")\"]))]));\n          } // if the arrow function is expanded as last argument, we are adding a\n          // level of indentation and need to add a softline to align the closing )\n          // with the opening (, or if it's inside a JSXExpression (e.g. an attribute)\n          // we should align the expression's closing } with the line with the opening {.\n\n\n          var shouldAddSoftLine = (args && args.expandLastArg || path.getParentNode().type === \"JSXExpressionContainer\") && !(n.comments && n.comments.length);\n          var printTrailingComma = args && args.expandLastArg && shouldPrintComma$1(options, \"all\"); // In order to avoid confusion between\n          // a => a ? a : a\n          // a <= a ? a : a\n\n          var shouldAddParens = n.body.type === \"ConditionalExpression\" && !startsWithNoLookaheadToken$1(n.body,\n          /* forbidFunctionAndClass */\n          false);\n          return group$b(concat$d([concat$d(parts), group$b(concat$d([indent$7(concat$d([line$7, shouldAddParens ? ifBreak$6(\"\", \"(\") : \"\", body, shouldAddParens ? ifBreak$6(\"\", \")\") : \"\"])), shouldAddSoftLine ? concat$d([ifBreak$6(printTrailingComma ? \",\" : \"\"), softline$6]) : \"\"]))]));\n        }\n\n      case \"YieldExpression\":\n        parts.push(\"yield\");\n\n        if (n.delegate) {\n          parts.push(\"*\");\n        }\n\n        if (n.argument) {\n          parts.push(\" \", path.call(print, \"argument\"));\n        }\n\n        return concat$d(parts);\n\n      case \"AwaitExpression\":\n        {\n          parts.push(\"await \", path.call(print, \"argument\"));\n\n          var _parent3 = path.getParentNode();\n\n          if ((_parent3.type === \"CallExpression\" || _parent3.type === \"OptionalCallExpression\") && _parent3.callee === n || (_parent3.type === \"MemberExpression\" || _parent3.type === \"OptionalMemberExpression\") && _parent3.object === n) {\n            return group$b(concat$d([indent$7(concat$d([softline$6, concat$d(parts)])), softline$6]));\n          }\n\n          return concat$d(parts);\n        }\n\n      case \"ImportSpecifier\":\n        if (n.importKind) {\n          parts.push(path.call(print, \"importKind\"), \" \");\n        }\n\n        parts.push(path.call(print, \"imported\"));\n\n        if (n.local && n.local.name !== n.imported.name) {\n          parts.push(\" as \", path.call(print, \"local\"));\n        }\n\n        return concat$d(parts);\n\n      case \"ExportSpecifier\":\n        parts.push(path.call(print, \"local\"));\n\n        if (n.exported && n.exported.name !== n.local.name) {\n          parts.push(\" as \", path.call(print, \"exported\"));\n        }\n\n        return concat$d(parts);\n\n      case \"ImportNamespaceSpecifier\":\n        parts.push(\"* as \");\n        parts.push(path.call(print, \"local\"));\n        return concat$d(parts);\n\n      case \"ImportDefaultSpecifier\":\n        return path.call(print, \"local\");\n\n      case \"TSExportAssignment\":\n        return concat$d([\"export = \", path.call(print, \"expression\"), semi]);\n\n      case \"ExportDefaultDeclaration\":\n      case \"ExportNamedDeclaration\":\n        return printExportDeclaration(path, options, print);\n\n      case \"ExportAllDeclaration\":\n        parts.push(\"export \");\n\n        if (n.exportKind === \"type\") {\n          parts.push(\"type \");\n        }\n\n        parts.push(\"* from \", path.call(print, \"source\"), semi);\n        return concat$d(parts);\n\n      case \"ExportNamespaceSpecifier\":\n      case \"ExportDefaultSpecifier\":\n        return path.call(print, \"exported\");\n\n      case \"ImportDeclaration\":\n        {\n          parts.push(\"import \");\n\n          if (n.importKind && n.importKind !== \"value\") {\n            parts.push(n.importKind + \" \");\n          }\n\n          var standalones = [];\n          var grouped = [];\n\n          if (n.specifiers && n.specifiers.length > 0) {\n            path.each(function (specifierPath) {\n              var value = specifierPath.getValue();\n\n              if (value.type === \"ImportDefaultSpecifier\" || value.type === \"ImportNamespaceSpecifier\") {\n                standalones.push(print(specifierPath));\n              } else {\n                grouped.push(print(specifierPath));\n              }\n            }, \"specifiers\");\n\n            if (standalones.length > 0) {\n              parts.push(join$9(\", \", standalones));\n            }\n\n            if (standalones.length > 0 && grouped.length > 0) {\n              parts.push(\", \");\n            }\n\n            if (grouped.length === 1 && standalones.length === 0 && n.specifiers && !n.specifiers.some(function (node) {\n              return node.comments;\n            })) {\n              parts.push(concat$d([\"{\", options.bracketSpacing ? \" \" : \"\", concat$d(grouped), options.bracketSpacing ? \" \" : \"\", \"}\"]));\n            } else if (grouped.length >= 1) {\n              parts.push(group$b(concat$d([\"{\", indent$7(concat$d([options.bracketSpacing ? line$7 : softline$6, join$9(concat$d([\",\", line$7]), grouped)])), ifBreak$6(shouldPrintComma$1(options) ? \",\" : \"\"), options.bracketSpacing ? line$7 : softline$6, \"}\"])));\n            }\n\n            parts.push(\" from \");\n          } else if (n.importKind && n.importKind === \"type\" || // import {} from 'x'\n          /{\\s*}/.test(options.originalText.slice(options.locStart(n), options.locStart(n.source)))) {\n            parts.push(\"{} from \");\n          }\n\n          parts.push(path.call(print, \"source\"), semi);\n          return concat$d(parts);\n        }\n\n      case \"Import\":\n        return \"import\";\n\n      case \"TSModuleBlock\":\n      case \"BlockStatement\":\n        {\n          var naked = path.call(function (bodyPath) {\n            return printStatementSequence(bodyPath, options, print);\n          }, \"body\");\n          var hasContent = n.body.find(function (node) {\n            return node.type !== \"EmptyStatement\";\n          });\n          var hasDirectives = n.directives && n.directives.length > 0;\n\n          var _parent4 = path.getParentNode();\n\n          var _parentParent = path.getParentNode(1);\n\n          if (!hasContent && !hasDirectives && !hasDanglingComments$1(n) && (_parent4.type === \"ArrowFunctionExpression\" || _parent4.type === \"FunctionExpression\" || _parent4.type === \"FunctionDeclaration\" || _parent4.type === \"ObjectMethod\" || _parent4.type === \"ClassMethod\" || _parent4.type === \"ClassPrivateMethod\" || _parent4.type === \"ForStatement\" || _parent4.type === \"WhileStatement\" || _parent4.type === \"DoWhileStatement\" || _parent4.type === \"DoExpression\" || _parent4.type === \"CatchClause\" && !_parentParent.finalizer || _parent4.type === \"TSModuleDeclaration\")) {\n            return \"{}\";\n          }\n\n          parts.push(\"{\"); // Babel 6\n\n          if (hasDirectives) {\n            path.each(function (childPath) {\n              parts.push(indent$7(concat$d([hardline$9, print(childPath), semi])));\n\n              if (isNextLineEmpty$4(options.originalText, childPath.getValue(), options)) {\n                parts.push(hardline$9);\n              }\n            }, \"directives\");\n          }\n\n          if (hasContent) {\n            parts.push(indent$7(concat$d([hardline$9, naked])));\n          }\n\n          parts.push(comments.printDanglingComments(path, options));\n          parts.push(hardline$9, \"}\");\n          return concat$d(parts);\n        }\n\n      case \"ReturnStatement\":\n        parts.push(\"return\");\n\n        if (n.argument) {\n          if (returnArgumentHasLeadingComment$1(options, n.argument)) {\n            parts.push(concat$d([\" (\", indent$7(concat$d([hardline$9, path.call(print, \"argument\")])), hardline$9, \")\"]));\n          } else if (n.argument.type === \"LogicalExpression\" || n.argument.type === \"BinaryExpression\" || n.argument.type === \"SequenceExpression\") {\n            parts.push(group$b(concat$d([ifBreak$6(\" (\", \" \"), indent$7(concat$d([softline$6, path.call(print, \"argument\")])), softline$6, ifBreak$6(\")\")])));\n          } else {\n            parts.push(\" \", path.call(print, \"argument\"));\n          }\n        }\n\n        if (hasDanglingComments$1(n)) {\n          parts.push(\" \", comments.printDanglingComments(path, options,\n          /* sameIndent */\n          true));\n        }\n\n        parts.push(semi);\n        return concat$d(parts);\n\n      case \"NewExpression\":\n      case \"OptionalCallExpression\":\n      case \"CallExpression\":\n        {\n          var isNew = n.type === \"NewExpression\";\n          var optional = printOptionalToken(path);\n\n          if ( // We want to keep CommonJS- and AMD-style require calls, and AMD-style\n          // define calls, as a unit.\n          // e.g. `define([\"some/lib\", (lib) => {`\n          !isNew && n.callee.type === \"Identifier\" && (n.callee.name === \"require\" || n.callee.name === \"define\") || // Template literals as single arguments\n          n.arguments.length === 1 && isTemplateOnItsOwnLine$1(n.arguments[0], options.originalText, options) || // Keep test declarations on a single line\n          // e.g. `it('long name', () => {`\n          !isNew && isTestCall$1(n, path.getParentNode())) {\n            return concat$d([isNew ? \"new \" : \"\", path.call(print, \"callee\"), optional, printFunctionTypeParameters(path, options, print), concat$d([\"(\", join$9(\", \", path.map(print, \"arguments\")), \")\"])]);\n          } // Inline Flow annotation comments following Identifiers in Call nodes need to\n          // stay with the Identifier. For example:\n          //\n          // foo /*:: <SomeGeneric> */(bar);\n          //\n          // Here, we ensure that such comments stay between the Identifier and the Callee.\n\n\n          var isIdentifierWithFlowAnnotation = n.callee.type === \"Identifier\" && hasFlowAnnotationComment$1(n.callee.trailingComments);\n\n          if (isIdentifierWithFlowAnnotation) {\n            n.callee.trailingComments[0].printed = true;\n          } // We detect calls on member lookups and possibly print them in a\n          // special chain format. See `printMemberChain` for more info.\n\n\n          if (!isNew && isMemberish$1(n.callee)) {\n            return printMemberChain(path, options, print);\n          }\n\n          var contents = concat$d([isNew ? \"new \" : \"\", path.call(print, \"callee\"), optional, isIdentifierWithFlowAnnotation ? \"/*:: \".concat(n.callee.trailingComments[0].value.substring(2).trim(), \" */\") : \"\", printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)]); // We group here when the callee is itself a call expression.\n          // See `isLongCurriedCallExpression` for more info.\n\n          if (isCallOrOptionalCallExpression$1(n.callee)) {\n            return group$b(contents);\n          }\n\n          return contents;\n        }\n\n      case \"TSInterfaceDeclaration\":\n        if (n.declare) {\n          parts.push(\"declare \");\n        }\n\n        parts.push(n.abstract ? \"abstract \" : \"\", printTypeScriptModifiers(path, options, print), \"interface \", path.call(print, \"id\"), n.typeParameters ? path.call(print, \"typeParameters\") : \"\", \" \");\n\n        if (n.extends && n.extends.length) {\n          parts.push(group$b(indent$7(concat$d([softline$6, \"extends \", (n.extends.length === 1 ? identity$2 : indent$7)(join$9(concat$d([\",\", line$7]), path.map(print, \"extends\"))), \" \"]))));\n        }\n\n        parts.push(path.call(print, \"body\"));\n        return concat$d(parts);\n\n      case \"ObjectTypeInternalSlot\":\n        return concat$d([n.static ? \"static \" : \"\", \"[[\", path.call(print, \"id\"), \"]]\", printOptionalToken(path), n.method ? \"\" : \": \", path.call(print, \"value\")]);\n\n      case \"ObjectExpression\":\n      case \"ObjectPattern\":\n      case \"ObjectTypeAnnotation\":\n      case \"TSInterfaceBody\":\n      case \"TSTypeLiteral\":\n        {\n          var propertiesField;\n\n          if (n.type === \"TSTypeLiteral\") {\n            propertiesField = \"members\";\n          } else if (n.type === \"TSInterfaceBody\") {\n            propertiesField = \"body\";\n          } else {\n            propertiesField = \"properties\";\n          }\n\n          var isTypeAnnotation = n.type === \"ObjectTypeAnnotation\";\n          var fields = [];\n\n          if (isTypeAnnotation) {\n            fields.push(\"indexers\", \"callProperties\", \"internalSlots\");\n          }\n\n          fields.push(propertiesField);\n          var firstProperty = fields.map(function (field) {\n            return n[field][0];\n          }).sort(function (a, b) {\n            return options.locStart(a) - options.locStart(b);\n          })[0];\n\n          var _parent5 = path.getParentNode(0);\n\n          var isFlowInterfaceLikeBody = isTypeAnnotation && _parent5 && (_parent5.type === \"InterfaceDeclaration\" || _parent5.type === \"DeclareInterface\" || _parent5.type === \"DeclareClass\") && path.getName() === \"body\";\n          var shouldBreak = n.type === \"TSInterfaceBody\" || isFlowInterfaceLikeBody || n.type === \"ObjectPattern\" && _parent5.type !== \"FunctionDeclaration\" && _parent5.type !== \"FunctionExpression\" && _parent5.type !== \"ArrowFunctionExpression\" && _parent5.type !== \"ObjectMethod\" && _parent5.type !== \"ClassMethod\" && _parent5.type !== \"ClassPrivateMethod\" && _parent5.type !== \"AssignmentPattern\" && _parent5.type !== \"CatchClause\" && n.properties.some(function (property) {\n            return property.value && (property.value.type === \"ObjectPattern\" || property.value.type === \"ArrayPattern\");\n          }) || n.type !== \"ObjectPattern\" && firstProperty && hasNewlineInRange$2(options.originalText, options.locStart(n), options.locStart(firstProperty));\n          var separator = isFlowInterfaceLikeBody ? \";\" : n.type === \"TSInterfaceBody\" || n.type === \"TSTypeLiteral\" ? ifBreak$6(semi, \";\") : \",\";\n          var leftBrace = n.exact ? \"{|\" : \"{\";\n          var rightBrace = n.exact ? \"|}\" : \"}\"; // Unfortunately, things are grouped together in the ast can be\n          // interleaved in the source code. So we need to reorder them before\n          // printing them.\n\n          var propsAndLoc = [];\n          fields.forEach(function (field) {\n            path.each(function (childPath) {\n              var node = childPath.getValue();\n              propsAndLoc.push({\n                node: node,\n                printed: print(childPath),\n                loc: options.locStart(node)\n              });\n            }, field);\n          });\n          var separatorParts = [];\n          var props = propsAndLoc.sort(function (a, b) {\n            return a.loc - b.loc;\n          }).map(function (prop) {\n            var result = concat$d(separatorParts.concat(group$b(prop.printed)));\n            separatorParts = [separator, line$7];\n\n            if ((prop.node.type === \"TSPropertySignature\" || prop.node.type === \"TSMethodSignature\" || prop.node.type === \"TSConstructSignatureDeclaration\") && hasNodeIgnoreComment$2(prop.node)) {\n              separatorParts.shift();\n            }\n\n            if (isNextLineEmpty$4(options.originalText, prop.node, options)) {\n              separatorParts.push(hardline$9);\n            }\n\n            return result;\n          });\n\n          if (n.inexact) {\n            props.push(concat$d(separatorParts.concat(group$b(\"...\"))));\n          }\n\n          var lastElem = getLast$2(n[propertiesField]);\n          var canHaveTrailingSeparator = !(lastElem && (lastElem.type === \"RestProperty\" || lastElem.type === \"RestElement\" || hasNodeIgnoreComment$2(lastElem) || n.inexact));\n          var content;\n\n          if (props.length === 0) {\n            if (!hasDanglingComments$1(n)) {\n              return concat$d([leftBrace, rightBrace, printTypeAnnotation(path, options, print)]);\n            }\n\n            content = group$b(concat$d([leftBrace, comments.printDanglingComments(path, options), softline$6, rightBrace, printOptionalToken(path), printTypeAnnotation(path, options, print)]));\n          } else {\n            content = concat$d([leftBrace, indent$7(concat$d([options.bracketSpacing ? line$7 : softline$6, concat$d(props)])), ifBreak$6(canHaveTrailingSeparator && (separator !== \",\" || shouldPrintComma$1(options)) ? separator : \"\"), concat$d([options.bracketSpacing ? line$7 : softline$6, rightBrace]), printOptionalToken(path), printTypeAnnotation(path, options, print)]);\n          } // If we inline the object as first argument of the parent, we don't want\n          // to create another group so that the object breaks before the return\n          // type\n\n\n          var parentParentParent = path.getParentNode(2);\n\n          if (n.type === \"ObjectPattern\" && _parent5 && shouldHugArguments(_parent5) && !n.decorators && _parent5.params[0] === n || shouldHugType(n) && parentParentParent && shouldHugArguments(parentParentParent) && parentParentParent.params[0].typeAnnotation && parentParentParent.params[0].typeAnnotation.typeAnnotation === n) {\n            return content;\n          }\n\n          return group$b(content, {\n            shouldBreak: shouldBreak\n          });\n        }\n      // Babel 6\n\n      case \"ObjectProperty\": // Non-standard AST node type.\n\n      case \"Property\":\n        if (n.method || n.kind === \"get\" || n.kind === \"set\") {\n          return printMethod(path, options, print);\n        }\n\n        if (n.shorthand) {\n          parts.push(path.call(print, \"value\"));\n        } else {\n          parts.push(printAssignment(n.key, printPropertyKey(path, options, print), \":\", n.value, path.call(print, \"value\"), options));\n        }\n\n        return concat$d(parts);\n      // Babel 6\n\n      case \"ClassMethod\":\n      case \"ClassPrivateMethod\":\n      case \"MethodDefinition\":\n      case \"TSAbstractMethodDefinition\":\n        if (n.decorators && n.decorators.length !== 0) {\n          parts.push(printDecorators(path, options, print));\n        }\n\n        if (n.accessibility) {\n          parts.push(n.accessibility + \" \");\n        }\n\n        if (n.static) {\n          parts.push(\"static \");\n        }\n\n        if (n.type === \"TSAbstractMethodDefinition\") {\n          parts.push(\"abstract \");\n        }\n\n        parts.push(printMethod(path, options, print));\n        return concat$d(parts);\n\n      case \"ObjectMethod\":\n        return printMethod(path, options, print);\n\n      case \"Decorator\":\n        return concat$d([\"@\", path.call(print, \"expression\"), path.call(print, \"callee\")]);\n\n      case \"ArrayExpression\":\n      case \"ArrayPattern\":\n        if (n.elements.length === 0) {\n          if (!hasDanglingComments$1(n)) {\n            parts.push(\"[]\");\n          } else {\n            parts.push(group$b(concat$d([\"[\", comments.printDanglingComments(path, options), softline$6, \"]\"])));\n          }\n        } else {\n          var _lastElem = getLast$2(n.elements);\n\n          var canHaveTrailingComma = !(_lastElem && _lastElem.type === \"RestElement\"); // JavaScript allows you to have empty elements in an array which\n          // changes its length based on the number of commas. The algorithm\n          // is that if the last argument is null, we need to force insert\n          // a comma to ensure JavaScript recognizes it.\n          //   [,].length === 1\n          //   [1,].length === 1\n          //   [1,,].length === 2\n          //\n          // Note that getLast returns null if the array is empty, but\n          // we already check for an empty array just above so we are safe\n\n          var needsForcedTrailingComma = canHaveTrailingComma && _lastElem === null;\n\n          var _shouldBreak = n.elements.length > 1 && n.elements.every(function (element, i, elements) {\n            var elementType = element && element.type;\n\n            if (elementType !== \"ArrayExpression\" && elementType !== \"ObjectExpression\") {\n              return false;\n            }\n\n            var nextElement = elements[i + 1];\n\n            if (nextElement && elementType !== nextElement.type) {\n              return false;\n            }\n\n            var itemsKey = elementType === \"ArrayExpression\" ? \"elements\" : \"properties\";\n            return element[itemsKey] && element[itemsKey].length > 1;\n          });\n\n          parts.push(group$b(concat$d([\"[\", indent$7(concat$d([softline$6, printArrayItems(path, options, \"elements\", print)])), needsForcedTrailingComma ? \",\" : \"\", ifBreak$6(canHaveTrailingComma && !needsForcedTrailingComma && shouldPrintComma$1(options) ? \",\" : \"\"), comments.printDanglingComments(path, options,\n          /* sameIndent */\n          true), softline$6, \"]\"]), {\n            shouldBreak: _shouldBreak\n          }));\n        }\n\n        parts.push(printOptionalToken(path), printTypeAnnotation(path, options, print));\n        return concat$d(parts);\n\n      case \"SequenceExpression\":\n        {\n          var _parent6 = path.getParentNode(0);\n\n          if (_parent6.type === \"ExpressionStatement\" || _parent6.type === \"ForStatement\") {\n            // For ExpressionStatements and for-loop heads, which are among\n            // the few places a SequenceExpression appears unparenthesized, we want\n            // to indent expressions after the first.\n            var _parts2 = [];\n            path.each(function (p) {\n              if (p.getName() === 0) {\n                _parts2.push(print(p));\n              } else {\n                _parts2.push(\",\", indent$7(concat$d([line$7, print(p)])));\n              }\n            }, \"expressions\");\n            return group$b(concat$d(_parts2));\n          }\n\n          return group$b(concat$d([join$9(concat$d([\",\", line$7]), path.map(print, \"expressions\"))]));\n        }\n\n      case \"ThisExpression\":\n        return \"this\";\n\n      case \"Super\":\n        return \"super\";\n\n      case \"NullLiteral\":\n        // Babel 6 Literal split\n        return \"null\";\n\n      case \"RegExpLiteral\":\n        // Babel 6 Literal split\n        return printRegex(n);\n\n      case \"NumericLiteral\":\n        // Babel 6 Literal split\n        return printNumber$2(n.extra.raw);\n\n      case \"BigIntLiteral\":\n        // babel: n.extra.raw, typescript: n.raw, flow: n.bigint\n        return (n.bigint || (n.extra ? n.extra.raw : n.raw)).toLowerCase();\n\n      case \"BooleanLiteral\": // Babel 6 Literal split\n\n      case \"StringLiteral\": // Babel 6 Literal split\n\n      case \"Literal\":\n        {\n          if (n.regex) {\n            return printRegex(n.regex);\n          }\n\n          if (typeof n.value === \"number\") {\n            return printNumber$2(n.raw);\n          }\n\n          if (typeof n.value !== \"string\") {\n            return \"\" + n.value;\n          } // TypeScript workaround for https://github.com/JamesHenry/typescript-estree/issues/2\n          // See corresponding workaround in needs-parens.js\n\n\n          var grandParent = path.getParentNode(1);\n          var isTypeScriptDirective = options.parser === \"typescript\" && typeof n.value === \"string\" && grandParent && (grandParent.type === \"Program\" || grandParent.type === \"BlockStatement\");\n          return nodeStr(n, options, isTypeScriptDirective);\n        }\n\n      case \"Directive\":\n        return path.call(print, \"value\");\n      // Babel 6\n\n      case \"DirectiveLiteral\":\n        return nodeStr(n, options);\n\n      case \"UnaryExpression\":\n        parts.push(n.operator);\n\n        if (/[a-z]$/.test(n.operator)) {\n          parts.push(\" \");\n        }\n\n        if (n.argument.comments && n.argument.comments.length > 0) {\n          parts.push(group$b(concat$d([\"(\", indent$7(concat$d([softline$6, path.call(print, \"argument\")])), softline$6, \")\"])));\n        } else {\n          parts.push(path.call(print, \"argument\"));\n        }\n\n        return concat$d(parts);\n\n      case \"UpdateExpression\":\n        parts.push(path.call(print, \"argument\"), n.operator);\n\n        if (n.prefix) {\n          parts.reverse();\n        }\n\n        return concat$d(parts);\n\n      case \"ConditionalExpression\":\n        return printTernaryOperator(path, options, print, {\n          beforeParts: function beforeParts() {\n            return [path.call(print, \"test\")];\n          },\n          afterParts: function afterParts(breakClosingParen) {\n            return [breakClosingParen ? softline$6 : \"\"];\n          },\n          shouldCheckJsx: true,\n          conditionalNodeType: \"ConditionalExpression\",\n          consequentNodePropertyName: \"consequent\",\n          alternateNodePropertyName: \"alternate\",\n          testNodePropertyName: \"test\",\n          breakNested: true\n        });\n\n      case \"VariableDeclaration\":\n        {\n          var printed = path.map(function (childPath) {\n            return print(childPath);\n          }, \"declarations\"); // We generally want to terminate all variable declarations with a\n          // semicolon, except when they in the () part of for loops.\n\n          var parentNode = path.getParentNode();\n          var isParentForLoop = parentNode.type === \"ForStatement\" || parentNode.type === \"ForInStatement\" || parentNode.type === \"ForOfStatement\" || parentNode.type === \"ForAwaitStatement\";\n          var hasValue = n.declarations.some(function (decl) {\n            return decl.init;\n          });\n          var firstVariable;\n\n          if (printed.length === 1 && !n.declarations[0].comments) {\n            firstVariable = printed[0];\n          } else if (printed.length > 0) {\n            // Indent first var to comply with eslint one-var rule\n            firstVariable = indent$7(printed[0]);\n          }\n\n          parts = [n.declare ? \"declare \" : \"\", n.kind, firstVariable ? concat$d([\" \", firstVariable]) : \"\", indent$7(concat$d(printed.slice(1).map(function (p) {\n            return concat$d([\",\", hasValue && !isParentForLoop ? hardline$9 : line$7, p]);\n          })))];\n\n          if (!(isParentForLoop && parentNode.body !== n)) {\n            parts.push(semi);\n          }\n\n          return group$b(concat$d(parts));\n        }\n\n      case \"TSTypeAliasDeclaration\":\n        {\n          if (n.declare) {\n            parts.push(\"declare \");\n          }\n\n          var _printed = printAssignmentRight(n.id, n.typeAnnotation, n.typeAnnotation && path.call(print, \"typeAnnotation\"), options);\n\n          parts.push(\"type \", path.call(print, \"id\"), path.call(print, \"typeParameters\"), \" =\", _printed, semi);\n          return group$b(concat$d(parts));\n        }\n\n      case \"VariableDeclarator\":\n        return printAssignment(n.id, path.call(print, \"id\"), \" =\", n.init, n.init && path.call(print, \"init\"), options);\n\n      case \"WithStatement\":\n        return group$b(concat$d([\"with (\", path.call(print, \"object\"), \")\", adjustClause(n.body, path.call(print, \"body\"))]));\n\n      case \"IfStatement\":\n        {\n          var con = adjustClause(n.consequent, path.call(print, \"consequent\"));\n          var opening = group$b(concat$d([\"if (\", group$b(concat$d([indent$7(concat$d([softline$6, path.call(print, \"test\")])), softline$6])), \")\", con]));\n          parts.push(opening);\n\n          if (n.alternate) {\n            var commentOnOwnLine = hasTrailingComment$1(n.consequent) && n.consequent.comments.some(function (comment) {\n              return comment.trailing && !comments$1.isBlockComment(comment);\n            }) || needsHardlineAfterDanglingComment$1(n);\n            var elseOnSameLine = n.consequent.type === \"BlockStatement\" && !commentOnOwnLine;\n            parts.push(elseOnSameLine ? \" \" : hardline$9);\n\n            if (hasDanglingComments$1(n)) {\n              parts.push(comments.printDanglingComments(path, options, true), commentOnOwnLine ? hardline$9 : \" \");\n            }\n\n            parts.push(\"else\", group$b(adjustClause(n.alternate, path.call(print, \"alternate\"), n.alternate.type === \"IfStatement\")));\n          }\n\n          return concat$d(parts);\n        }\n\n      case \"ForStatement\":\n        {\n          var _body = adjustClause(n.body, path.call(print, \"body\")); // We want to keep dangling comments above the loop to stay consistent.\n          // Any comment positioned between the for statement and the parentheses\n          // is going to be printed before the statement.\n\n\n          var _dangling = comments.printDanglingComments(path, options,\n          /* sameLine */\n          true);\n\n          var printedComments = _dangling ? concat$d([_dangling, softline$6]) : \"\";\n\n          if (!n.init && !n.test && !n.update) {\n            return concat$d([printedComments, group$b(concat$d([\"for (;;)\", _body]))]);\n          }\n\n          return concat$d([printedComments, group$b(concat$d([\"for (\", group$b(concat$d([indent$7(concat$d([softline$6, path.call(print, \"init\"), \";\", line$7, path.call(print, \"test\"), \";\", line$7, path.call(print, \"update\")])), softline$6])), \")\", _body]))]);\n        }\n\n      case \"WhileStatement\":\n        return group$b(concat$d([\"while (\", group$b(concat$d([indent$7(concat$d([softline$6, path.call(print, \"test\")])), softline$6])), \")\", adjustClause(n.body, path.call(print, \"body\"))]));\n\n      case \"ForInStatement\":\n        // Note: esprima can't actually parse \"for each (\".\n        return group$b(concat$d([n.each ? \"for each (\" : \"for (\", path.call(print, \"left\"), \" in \", path.call(print, \"right\"), \")\", adjustClause(n.body, path.call(print, \"body\"))]));\n\n      case \"ForOfStatement\":\n      case \"ForAwaitStatement\":\n        {\n          // Babel 7 removed ForAwaitStatement in favor of ForOfStatement\n          // with `\"await\": true`:\n          // https://github.com/estree/estree/pull/138\n          var isAwait = n.type === \"ForAwaitStatement\" || n.await;\n          return group$b(concat$d([\"for\", isAwait ? \" await\" : \"\", \" (\", path.call(print, \"left\"), \" of \", path.call(print, \"right\"), \")\", adjustClause(n.body, path.call(print, \"body\"))]));\n        }\n\n      case \"DoWhileStatement\":\n        {\n          var clause = adjustClause(n.body, path.call(print, \"body\"));\n          var doBody = group$b(concat$d([\"do\", clause]));\n          parts = [doBody];\n\n          if (n.body.type === \"BlockStatement\") {\n            parts.push(\" \");\n          } else {\n            parts.push(hardline$9);\n          }\n\n          parts.push(\"while (\");\n          parts.push(group$b(concat$d([indent$7(concat$d([softline$6, path.call(print, \"test\")])), softline$6])), \")\", semi);\n          return concat$d(parts);\n        }\n\n      case \"DoExpression\":\n        return concat$d([\"do \", path.call(print, \"body\")]);\n\n      case \"BreakStatement\":\n        parts.push(\"break\");\n\n        if (n.label) {\n          parts.push(\" \", path.call(print, \"label\"));\n        }\n\n        parts.push(semi);\n        return concat$d(parts);\n\n      case \"ContinueStatement\":\n        parts.push(\"continue\");\n\n        if (n.label) {\n          parts.push(\" \", path.call(print, \"label\"));\n        }\n\n        parts.push(semi);\n        return concat$d(parts);\n\n      case \"LabeledStatement\":\n        if (n.body.type === \"EmptyStatement\") {\n          return concat$d([path.call(print, \"label\"), \":;\"]);\n        }\n\n        return concat$d([path.call(print, \"label\"), \": \", path.call(print, \"body\")]);\n\n      case \"TryStatement\":\n        return concat$d([\"try \", path.call(print, \"block\"), n.handler ? concat$d([\" \", path.call(print, \"handler\")]) : \"\", n.finalizer ? concat$d([\" finally \", path.call(print, \"finalizer\")]) : \"\"]);\n\n      case \"CatchClause\":\n        if (n.param) {\n          var hasComments = n.param.comments && n.param.comments.some(function (comment) {\n            return !comments$1.isBlockComment(comment) || comment.leading && hasNewline$4(options.originalText, options.locEnd(comment)) || comment.trailing && hasNewline$4(options.originalText, options.locStart(comment), {\n              backwards: true\n            });\n          });\n          var param = path.call(print, \"param\");\n          return concat$d([\"catch \", hasComments ? concat$d([\"(\", indent$7(concat$d([softline$6, param])), softline$6, \") \"]) : concat$d([\"(\", param, \") \"]), path.call(print, \"body\")]);\n        }\n\n        return concat$d([\"catch \", path.call(print, \"body\")]);\n\n      case \"ThrowStatement\":\n        return concat$d([\"throw \", path.call(print, \"argument\"), semi]);\n      // Note: ignoring n.lexical because it has no printing consequences.\n\n      case \"SwitchStatement\":\n        return concat$d([group$b(concat$d([\"switch (\", indent$7(concat$d([softline$6, path.call(print, \"discriminant\")])), softline$6, \")\"])), \" {\", n.cases.length > 0 ? indent$7(concat$d([hardline$9, join$9(hardline$9, path.map(function (casePath) {\n          var caseNode = casePath.getValue();\n          return concat$d([casePath.call(print), n.cases.indexOf(caseNode) !== n.cases.length - 1 && isNextLineEmpty$4(options.originalText, caseNode, options) ? hardline$9 : \"\"]);\n        }, \"cases\"))])) : \"\", hardline$9, \"}\"]);\n\n      case \"SwitchCase\":\n        {\n          if (n.test) {\n            parts.push(\"case \", path.call(print, \"test\"), \":\");\n          } else {\n            parts.push(\"default:\");\n          }\n\n          var consequent = n.consequent.filter(function (node) {\n            return node.type !== \"EmptyStatement\";\n          });\n\n          if (consequent.length > 0) {\n            var cons = path.call(function (consequentPath) {\n              return printStatementSequence(consequentPath, options, print);\n            }, \"consequent\");\n            parts.push(consequent.length === 1 && consequent[0].type === \"BlockStatement\" ? concat$d([\" \", cons]) : indent$7(concat$d([hardline$9, cons])));\n          }\n\n          return concat$d(parts);\n        }\n      // JSX extensions below.\n\n      case \"DebuggerStatement\":\n        return concat$d([\"debugger\", semi]);\n\n      case \"JSXAttribute\":\n        parts.push(path.call(print, \"name\"));\n\n        if (n.value) {\n          var res;\n\n          if (isStringLiteral$1(n.value)) {\n            var raw = rawText$1(n.value); // Unescape all quotes so we get an accurate preferred quote\n\n            var final = raw.replace(/&apos;/g, \"'\").replace(/&quot;/g, '\"');\n            var quote = getPreferredQuote$1(final, options.jsxSingleQuote ? \"'\" : '\"');\n\n            var _escape = quote === \"'\" ? \"&apos;\" : \"&quot;\";\n\n            final = final.slice(1, -1).replace(new RegExp(quote, \"g\"), _escape);\n            res = concat$d([quote, final, quote]);\n          } else {\n            res = path.call(print, \"value\");\n          }\n\n          parts.push(\"=\", res);\n        }\n\n        return concat$d(parts);\n\n      case \"JSXIdentifier\":\n        return \"\" + n.name;\n\n      case \"JSXNamespacedName\":\n        return join$9(\":\", [path.call(print, \"namespace\"), path.call(print, \"name\")]);\n\n      case \"JSXMemberExpression\":\n        return join$9(\".\", [path.call(print, \"object\"), path.call(print, \"property\")]);\n\n      case \"TSQualifiedName\":\n        return join$9(\".\", [path.call(print, \"left\"), path.call(print, \"right\")]);\n\n      case \"JSXSpreadAttribute\":\n      case \"JSXSpreadChild\":\n        {\n          return concat$d([\"{\", path.call(function (p) {\n            var printed = concat$d([\"...\", print(p)]);\n            var n = p.getValue();\n\n            if (!n.comments || !n.comments.length) {\n              return printed;\n            }\n\n            return concat$d([indent$7(concat$d([softline$6, comments.printComments(p, function () {\n              return printed;\n            }, options)])), softline$6]);\n          }, n.type === \"JSXSpreadAttribute\" ? \"argument\" : \"expression\"), \"}\"]);\n        }\n\n      case \"JSXExpressionContainer\":\n        {\n          var _parent7 = path.getParentNode(0);\n\n          var preventInline = _parent7.type === \"JSXAttribute\" && n.expression.comments && n.expression.comments.length > 0;\n\n          var _shouldInline = !preventInline && (n.expression.type === \"ArrayExpression\" || n.expression.type === \"ObjectExpression\" || n.expression.type === \"ArrowFunctionExpression\" || n.expression.type === \"CallExpression\" || n.expression.type === \"OptionalCallExpression\" || n.expression.type === \"FunctionExpression\" || n.expression.type === \"JSXEmptyExpression\" || n.expression.type === \"TemplateLiteral\" || n.expression.type === \"TaggedTemplateExpression\" || n.expression.type === \"DoExpression\" || isJSXNode$1(_parent7) && (n.expression.type === \"ConditionalExpression\" || isBinaryish$1(n.expression)));\n\n          if (_shouldInline) {\n            return group$b(concat$d([\"{\", path.call(print, \"expression\"), lineSuffixBoundary$1, \"}\"]));\n          }\n\n          return group$b(concat$d([\"{\", indent$7(concat$d([softline$6, path.call(print, \"expression\")])), softline$6, lineSuffixBoundary$1, \"}\"]));\n        }\n\n      case \"JSXFragment\":\n      case \"JSXElement\":\n        {\n          var elem = comments.printComments(path, function () {\n            return printJSXElement(path, options, print);\n          }, options);\n          return maybeWrapJSXElementInParens(path, elem, options);\n        }\n\n      case \"JSXOpeningElement\":\n        {\n          var _n = path.getValue();\n\n          var nameHasComments = _n.name && _n.name.comments && _n.name.comments.length > 0 || _n.typeParameters && _n.typeParameters.comments && _n.typeParameters.comments.length > 0; // Don't break self-closing elements with no attributes and no comments\n\n          if (_n.selfClosing && !_n.attributes.length && !nameHasComments) {\n            return concat$d([\"<\", path.call(print, \"name\"), path.call(print, \"typeParameters\"), \" />\"]);\n          } // don't break up opening elements with a single long text attribute\n\n\n          if (_n.attributes && _n.attributes.length === 1 && _n.attributes[0].value && isStringLiteral$1(_n.attributes[0].value) && !_n.attributes[0].value.value.includes(\"\\n\") && // We should break for the following cases:\n          // <div\n          //   // comment\n          //   attr=\"value\"\n          // >\n          // <div\n          //   attr=\"value\"\n          //   // comment\n          // >\n          !nameHasComments && (!_n.attributes[0].comments || !_n.attributes[0].comments.length)) {\n            return group$b(concat$d([\"<\", path.call(print, \"name\"), path.call(print, \"typeParameters\"), \" \", concat$d(path.map(print, \"attributes\")), _n.selfClosing ? \" />\" : \">\"]));\n          }\n\n          var lastAttrHasTrailingComments = _n.attributes.length && hasTrailingComment$1(getLast$2(_n.attributes));\n          var bracketSameLine = // Simple tags (no attributes and no comment in tag name) should be\n          // kept unbroken regardless of `jsxBracketSameLine`\n          !_n.attributes.length && !nameHasComments || options.jsxBracketSameLine && ( // We should print the bracket in a new line for the following cases:\n          // <div\n          //   // comment\n          // >\n          // <div\n          //   attr // comment\n          // >\n          !nameHasComments || _n.attributes.length) && !lastAttrHasTrailingComments; // We should print the opening element expanded if any prop value is a\n          // string literal with newlines\n\n          var _shouldBreak2 = _n.attributes && _n.attributes.some(function (attr) {\n            return attr.value && isStringLiteral$1(attr.value) && attr.value.value.includes(\"\\n\");\n          });\n\n          return group$b(concat$d([\"<\", path.call(print, \"name\"), path.call(print, \"typeParameters\"), concat$d([indent$7(concat$d(path.map(function (attr) {\n            return concat$d([line$7, print(attr)]);\n          }, \"attributes\"))), _n.selfClosing ? line$7 : bracketSameLine ? \">\" : softline$6]), _n.selfClosing ? \"/>\" : bracketSameLine ? \"\" : \">\"]), {\n            shouldBreak: _shouldBreak2\n          });\n        }\n\n      case \"JSXClosingElement\":\n        return concat$d([\"</\", path.call(print, \"name\"), \">\"]);\n\n      case \"JSXOpeningFragment\":\n      case \"JSXClosingFragment\":\n        {\n          var hasComment = n.comments && n.comments.length;\n          var hasOwnLineComment = hasComment && !n.comments.every(comments$1.isBlockComment);\n          var isOpeningFragment = n.type === \"JSXOpeningFragment\";\n          return concat$d([isOpeningFragment ? \"<\" : \"</\", indent$7(concat$d([hasOwnLineComment ? hardline$9 : hasComment && !isOpeningFragment ? \" \" : \"\", comments.printDanglingComments(path, options, true)])), hasOwnLineComment ? hardline$9 : \"\", \">\"]);\n        }\n\n      case \"JSXText\":\n        /* istanbul ignore next */\n        throw new Error(\"JSXTest should be handled by JSXElement\");\n\n      case \"JSXEmptyExpression\":\n        {\n          var requiresHardline = n.comments && !n.comments.every(comments$1.isBlockComment);\n          return concat$d([comments.printDanglingComments(path, options,\n          /* sameIndent */\n          !requiresHardline), requiresHardline ? hardline$9 : \"\"]);\n        }\n\n      case \"ClassBody\":\n        if (!n.comments && n.body.length === 0) {\n          return \"{}\";\n        }\n\n        return concat$d([\"{\", n.body.length > 0 ? indent$7(concat$d([hardline$9, path.call(function (bodyPath) {\n          return printStatementSequence(bodyPath, options, print);\n        }, \"body\")])) : comments.printDanglingComments(path, options), hardline$9, \"}\"]);\n\n      case \"ClassProperty\":\n      case \"TSAbstractClassProperty\":\n      case \"ClassPrivateProperty\":\n        {\n          if (n.decorators && n.decorators.length !== 0) {\n            parts.push(printDecorators(path, options, print));\n          }\n\n          if (n.accessibility) {\n            parts.push(n.accessibility + \" \");\n          }\n\n          if (n.declare) {\n            parts.push(\"declare \");\n          }\n\n          if (n.static) {\n            parts.push(\"static \");\n          }\n\n          if (n.type === \"TSAbstractClassProperty\") {\n            parts.push(\"abstract \");\n          }\n\n          if (n.readonly) {\n            parts.push(\"readonly \");\n          }\n\n          var variance = getFlowVariance$1(n);\n\n          if (variance) {\n            parts.push(variance);\n          }\n\n          parts.push(printPropertyKey(path, options, print), printOptionalToken(path), printTypeAnnotation(path, options, print));\n\n          if (n.value) {\n            parts.push(\" =\", printAssignmentRight(n.key, n.value, path.call(print, \"value\"), options));\n          }\n\n          parts.push(semi);\n          return group$b(concat$d(parts));\n        }\n\n      case \"ClassDeclaration\":\n      case \"ClassExpression\":\n        if (n.declare) {\n          parts.push(\"declare \");\n        }\n\n        parts.push(concat$d(printClass(path, options, print)));\n        return concat$d(parts);\n\n      case \"TSInterfaceHeritage\":\n        parts.push(path.call(print, \"expression\"));\n\n        if (n.typeParameters) {\n          parts.push(path.call(print, \"typeParameters\"));\n        }\n\n        return concat$d(parts);\n\n      case \"TemplateElement\":\n        return join$9(literalline$4, n.value.raw.split(/\\r?\\n/g));\n\n      case \"TemplateLiteral\":\n        {\n          var expressions = path.map(print, \"expressions\");\n\n          var _parentNode = path.getParentNode();\n\n          if (isJestEachTemplateLiteral$1(n, _parentNode)) {\n            var _printed2 = printJestEachTemplateLiteral(n, expressions, options);\n\n            if (_printed2) {\n              return _printed2;\n            }\n          }\n\n          var isSimple = isSimpleTemplateLiteral$1(n);\n\n          if (isSimple) {\n            expressions = expressions.map(function (doc) {\n              return printDocToString$1(doc, Object.assign({}, options, {\n                printWidth: Infinity\n              })).formatted;\n            });\n          }\n\n          parts.push(lineSuffixBoundary$1, \"`\");\n          path.each(function (childPath) {\n            var i = childPath.getName();\n            parts.push(print(childPath));\n\n            if (i < expressions.length) {\n              // For a template literal of the following form:\n              //   `someQuery {\n              //     ${call({\n              //       a,\n              //       b,\n              //     })}\n              //   }`\n              // the expression is on its own line (there is a \\n in the previous\n              // quasi literal), therefore we want to indent the JavaScript\n              // expression inside at the beginning of ${ instead of the beginning\n              // of the `.\n              var tabWidth = options.tabWidth;\n              var quasi = childPath.getValue();\n              var indentSize = getIndentSize$1(quasi.value.raw, tabWidth);\n              var _printed3 = expressions[i];\n\n              if (!isSimple) {\n                // Breaks at the template element boundaries (${ and }) are preferred to breaking\n                // in the middle of a MemberExpression\n                if (n.expressions[i].comments && n.expressions[i].comments.length || n.expressions[i].type === \"MemberExpression\" || n.expressions[i].type === \"OptionalMemberExpression\" || n.expressions[i].type === \"ConditionalExpression\") {\n                  _printed3 = concat$d([indent$7(concat$d([softline$6, _printed3])), softline$6]);\n                }\n              }\n\n              var aligned = indentSize === 0 && quasi.value.raw.endsWith(\"\\n\") ? align$1(-Infinity, _printed3) : addAlignmentToDoc$2(_printed3, indentSize, tabWidth);\n              parts.push(group$b(concat$d([\"${\", aligned, lineSuffixBoundary$1, \"}\"])));\n            }\n          }, \"quasis\");\n          parts.push(\"`\");\n          return concat$d(parts);\n        }\n      // These types are unprintable because they serve as abstract\n      // supertypes for other (printable) types.\n\n      case \"TaggedTemplateExpression\":\n        return concat$d([path.call(print, \"tag\"), path.call(print, \"typeParameters\"), path.call(print, \"quasi\")]);\n\n      case \"Node\":\n      case \"Printable\":\n      case \"SourceLocation\":\n      case \"Position\":\n      case \"Statement\":\n      case \"Function\":\n      case \"Pattern\":\n      case \"Expression\":\n      case \"Declaration\":\n      case \"Specifier\":\n      case \"NamedSpecifier\":\n      case \"Comment\":\n      case \"MemberTypeAnnotation\": // Flow\n\n      case \"Type\":\n        /* istanbul ignore next */\n        throw new Error(\"unprintable type: \" + JSON.stringify(n.type));\n      // Type Annotations for Facebook Flow, typically stripped out or\n      // transformed away before printing.\n\n      case \"TypeAnnotation\":\n      case \"TSTypeAnnotation\":\n        if (n.typeAnnotation) {\n          return path.call(print, \"typeAnnotation\");\n        }\n        /* istanbul ignore next */\n\n\n        return \"\";\n\n      case \"TSTupleType\":\n      case \"TupleTypeAnnotation\":\n        {\n          var typesField = n.type === \"TSTupleType\" ? \"elementTypes\" : \"types\";\n          return group$b(concat$d([\"[\", indent$7(concat$d([softline$6, printArrayItems(path, options, typesField, print)])), ifBreak$6(shouldPrintComma$1(options, \"all\") ? \",\" : \"\"), comments.printDanglingComments(path, options,\n          /* sameIndent */\n          true), softline$6, \"]\"]));\n        }\n\n      case \"ExistsTypeAnnotation\":\n        return \"*\";\n\n      case \"EmptyTypeAnnotation\":\n        return \"empty\";\n\n      case \"AnyTypeAnnotation\":\n        return \"any\";\n\n      case \"MixedTypeAnnotation\":\n        return \"mixed\";\n\n      case \"ArrayTypeAnnotation\":\n        return concat$d([path.call(print, \"elementType\"), \"[]\"]);\n\n      case \"BooleanTypeAnnotation\":\n        return \"boolean\";\n\n      case \"BooleanLiteralTypeAnnotation\":\n        return \"\" + n.value;\n\n      case \"DeclareClass\":\n        return printFlowDeclaration(path, printClass(path, options, print));\n\n      case \"TSDeclareFunction\":\n        // For TypeScript the TSDeclareFunction node shares the AST\n        // structure with FunctionDeclaration\n        return concat$d([n.declare ? \"declare \" : \"\", printFunctionDeclaration(path, print, options), semi]);\n\n      case \"DeclareFunction\":\n        return printFlowDeclaration(path, [\"function \", path.call(print, \"id\"), n.predicate ? \" \" : \"\", path.call(print, \"predicate\"), semi]);\n\n      case \"DeclareModule\":\n        return printFlowDeclaration(path, [\"module \", path.call(print, \"id\"), \" \", path.call(print, \"body\")]);\n\n      case \"DeclareModuleExports\":\n        return printFlowDeclaration(path, [\"module.exports\", \": \", path.call(print, \"typeAnnotation\"), semi]);\n\n      case \"DeclareVariable\":\n        return printFlowDeclaration(path, [\"var \", path.call(print, \"id\"), semi]);\n\n      case \"DeclareExportAllDeclaration\":\n        return concat$d([\"declare export * from \", path.call(print, \"source\")]);\n\n      case \"DeclareExportDeclaration\":\n        return concat$d([\"declare \", printExportDeclaration(path, options, print)]);\n\n      case \"DeclareOpaqueType\":\n      case \"OpaqueType\":\n        {\n          parts.push(\"opaque type \", path.call(print, \"id\"), path.call(print, \"typeParameters\"));\n\n          if (n.supertype) {\n            parts.push(\": \", path.call(print, \"supertype\"));\n          }\n\n          if (n.impltype) {\n            parts.push(\" = \", path.call(print, \"impltype\"));\n          }\n\n          parts.push(semi);\n\n          if (n.type === \"DeclareOpaqueType\") {\n            return printFlowDeclaration(path, parts);\n          }\n\n          return concat$d(parts);\n        }\n\n      case \"EnumDeclaration\":\n        return concat$d([\"enum \", path.call(print, \"id\"), \" \", path.call(print, \"body\")]);\n\n      case \"EnumBooleanBody\":\n      case \"EnumNumberBody\":\n      case \"EnumStringBody\":\n      case \"EnumSymbolBody\":\n        {\n          if (n.type === \"EnumSymbolBody\" || n.explicitType) {\n            var type = null;\n\n            switch (n.type) {\n              case \"EnumBooleanBody\":\n                type = \"boolean\";\n                break;\n\n              case \"EnumNumberBody\":\n                type = \"number\";\n                break;\n\n              case \"EnumStringBody\":\n                type = \"string\";\n                break;\n\n              case \"EnumSymbolBody\":\n                type = \"symbol\";\n                break;\n            }\n\n            parts.push(\"of \", type, \" \");\n          }\n\n          if (n.members.length === 0) {\n            parts.push(group$b(concat$d([\"{\", comments.printDanglingComments(path, options), softline$6, \"}\"])));\n          } else {\n            parts.push(group$b(concat$d([\"{\", indent$7(concat$d([hardline$9, printArrayItems(path, options, \"members\", print), shouldPrintComma$1(options) ? \",\" : \"\"])), comments.printDanglingComments(path, options,\n            /* sameIndent */\n            true), hardline$9, \"}\"])));\n          }\n\n          return concat$d(parts);\n        }\n\n      case \"EnumBooleanMember\":\n      case \"EnumNumberMember\":\n      case \"EnumStringMember\":\n        return concat$d([path.call(print, \"id\"), \" = \", _typeof(n.init) === \"object\" ? path.call(print, \"init\") : String(n.init)]);\n\n      case \"EnumDefaultedMember\":\n        return path.call(print, \"id\");\n\n      case \"FunctionTypeAnnotation\":\n      case \"TSFunctionType\":\n        {\n          // FunctionTypeAnnotation is ambiguous:\n          // declare function foo(a: B): void; OR\n          // var A: (a: B) => void;\n          var _parent8 = path.getParentNode(0);\n\n          var _parentParent2 = path.getParentNode(1);\n\n          var _parentParentParent = path.getParentNode(2);\n\n          var isArrowFunctionTypeAnnotation = n.type === \"TSFunctionType\" || !((_parent8.type === \"ObjectTypeProperty\" || _parent8.type === \"ObjectTypeInternalSlot\") && !getFlowVariance$1(_parent8) && !_parent8.optional && options.locStart(_parent8) === options.locStart(n) || _parent8.type === \"ObjectTypeCallProperty\" || _parentParentParent && _parentParentParent.type === \"DeclareFunction\");\n          var needsColon = isArrowFunctionTypeAnnotation && (_parent8.type === \"TypeAnnotation\" || _parent8.type === \"TSTypeAnnotation\"); // Sadly we can't put it inside of FastPath::needsColon because we are\n          // printing \":\" as part of the expression and it would put parenthesis\n          // around :(\n\n          var needsParens = needsColon && isArrowFunctionTypeAnnotation && (_parent8.type === \"TypeAnnotation\" || _parent8.type === \"TSTypeAnnotation\") && _parentParent2.type === \"ArrowFunctionExpression\";\n\n          if (isObjectTypePropertyAFunction$1(_parent8, options)) {\n            isArrowFunctionTypeAnnotation = true;\n            needsColon = true;\n          }\n\n          if (needsParens) {\n            parts.push(\"(\");\n          }\n\n          parts.push(printFunctionParams(path, print, options,\n          /* expandArg */\n          false,\n          /* printTypeParams */\n          true)); // The returnType is not wrapped in a TypeAnnotation, so the colon\n          // needs to be added separately.\n\n          if (n.returnType || n.predicate || n.typeAnnotation) {\n            parts.push(isArrowFunctionTypeAnnotation ? \" => \" : \": \", path.call(print, \"returnType\"), path.call(print, \"predicate\"), path.call(print, \"typeAnnotation\"));\n          }\n\n          if (needsParens) {\n            parts.push(\")\");\n          }\n\n          return group$b(concat$d(parts));\n        }\n\n      case \"TSRestType\":\n        return concat$d([\"...\", path.call(print, \"typeAnnotation\")]);\n\n      case \"TSOptionalType\":\n        return concat$d([path.call(print, \"typeAnnotation\"), \"?\"]);\n\n      case \"FunctionTypeParam\":\n        return concat$d([path.call(print, \"name\"), printOptionalToken(path), n.name ? \": \" : \"\", path.call(print, \"typeAnnotation\")]);\n\n      case \"GenericTypeAnnotation\":\n        return concat$d([path.call(print, \"id\"), path.call(print, \"typeParameters\")]);\n\n      case \"DeclareInterface\":\n      case \"InterfaceDeclaration\":\n      case \"InterfaceTypeAnnotation\":\n        {\n          if (n.type === \"DeclareInterface\" || n.declare) {\n            parts.push(\"declare \");\n          }\n\n          parts.push(\"interface\");\n\n          if (n.type === \"DeclareInterface\" || n.type === \"InterfaceDeclaration\") {\n            parts.push(\" \", path.call(print, \"id\"), path.call(print, \"typeParameters\"));\n          }\n\n          if (n[\"extends\"].length > 0) {\n            parts.push(group$b(indent$7(concat$d([line$7, \"extends \", (n.extends.length === 1 ? identity$2 : indent$7)(join$9(concat$d([\",\", line$7]), path.map(print, \"extends\")))]))));\n          }\n\n          parts.push(\" \", path.call(print, \"body\"));\n          return group$b(concat$d(parts));\n        }\n\n      case \"ClassImplements\":\n      case \"InterfaceExtends\":\n        return concat$d([path.call(print, \"id\"), path.call(print, \"typeParameters\")]);\n\n      case \"TSClassImplements\":\n        return concat$d([path.call(print, \"expression\"), path.call(print, \"typeParameters\")]);\n\n      case \"TSIntersectionType\":\n      case \"IntersectionTypeAnnotation\":\n        {\n          var types = path.map(print, \"types\");\n          var result = [];\n          var wasIndented = false;\n\n          for (var _i = 0; _i < types.length; ++_i) {\n            if (_i === 0) {\n              result.push(types[_i]);\n            } else if (isObjectType$1(n.types[_i - 1]) && isObjectType$1(n.types[_i])) {\n              // If both are objects, don't indent\n              result.push(concat$d([\" & \", wasIndented ? indent$7(types[_i]) : types[_i]]));\n            } else if (!isObjectType$1(n.types[_i - 1]) && !isObjectType$1(n.types[_i])) {\n              // If no object is involved, go to the next line if it breaks\n              result.push(indent$7(concat$d([\" &\", line$7, types[_i]])));\n            } else {\n              // If you go from object to non-object or vis-versa, then inline it\n              if (_i > 1) {\n                wasIndented = true;\n              }\n\n              result.push(\" & \", _i > 1 ? indent$7(types[_i]) : types[_i]);\n            }\n          }\n\n          return group$b(concat$d(result));\n        }\n\n      case \"TSUnionType\":\n      case \"UnionTypeAnnotation\":\n        {\n          // single-line variation\n          // A | B | C\n          // multi-line variation\n          // | A\n          // | B\n          // | C\n          var _parent9 = path.getParentNode(); // If there's a leading comment, the parent is doing the indentation\n\n\n          var shouldIndent = _parent9.type !== \"TypeParameterInstantiation\" && _parent9.type !== \"TSTypeParameterInstantiation\" && _parent9.type !== \"GenericTypeAnnotation\" && _parent9.type !== \"TSTypeReference\" && _parent9.type !== \"TSTypeAssertion\" && _parent9.type !== \"TupleTypeAnnotation\" && _parent9.type !== \"TSTupleType\" && !(_parent9.type === \"FunctionTypeParam\" && !_parent9.name) && !((_parent9.type === \"TypeAlias\" || _parent9.type === \"VariableDeclarator\" || _parent9.type === \"TSTypeAliasDeclaration\") && hasLeadingOwnLineComment$1(options.originalText, n, options)); // {\n          //   a: string\n          // } | null | void\n          // should be inlined and not be printed in the multi-line variant\n\n          var shouldHug = shouldHugType(n); // We want to align the children but without its comment, so it looks like\n          // | child1\n          // // comment\n          // | child2\n\n          var _printed4 = path.map(function (typePath) {\n            var printedType = typePath.call(print);\n\n            if (!shouldHug) {\n              printedType = align$1(2, printedType);\n            }\n\n            return comments.printComments(typePath, function () {\n              return printedType;\n            }, options);\n          }, \"types\");\n\n          if (shouldHug) {\n            return join$9(\" | \", _printed4);\n          }\n\n          var shouldAddStartLine = shouldIndent && !hasLeadingOwnLineComment$1(options.originalText, n, options);\n          var code = concat$d([ifBreak$6(concat$d([shouldAddStartLine ? line$7 : \"\", \"| \"])), join$9(concat$d([line$7, \"| \"]), _printed4)]);\n\n          if (needsParens_1(path, options)) {\n            return group$b(concat$d([indent$7(code), softline$6]));\n          }\n\n          if (_parent9.type === \"TupleTypeAnnotation\" && _parent9.types.length > 1 || _parent9.type === \"TSTupleType\" && _parent9.elementTypes.length > 1) {\n            return group$b(concat$d([indent$7(concat$d([ifBreak$6(concat$d([\"(\", softline$6])), code])), softline$6, ifBreak$6(\")\")]));\n          }\n\n          return group$b(shouldIndent ? indent$7(code) : code);\n        }\n\n      case \"NullableTypeAnnotation\":\n        return concat$d([\"?\", path.call(print, \"typeAnnotation\")]);\n\n      case \"TSNullKeyword\":\n      case \"NullLiteralTypeAnnotation\":\n        return \"null\";\n\n      case \"ThisTypeAnnotation\":\n        return \"this\";\n\n      case \"NumberTypeAnnotation\":\n        return \"number\";\n\n      case \"ObjectTypeCallProperty\":\n        if (n.static) {\n          parts.push(\"static \");\n        }\n\n        parts.push(path.call(print, \"value\"));\n        return concat$d(parts);\n\n      case \"ObjectTypeIndexer\":\n        {\n          var _variance = getFlowVariance$1(n);\n\n          return concat$d([_variance || \"\", \"[\", path.call(print, \"id\"), n.id ? \": \" : \"\", path.call(print, \"key\"), \"]: \", path.call(print, \"value\")]);\n        }\n\n      case \"ObjectTypeProperty\":\n        {\n          var _variance2 = getFlowVariance$1(n);\n\n          var modifier = \"\";\n\n          if (n.proto) {\n            modifier = \"proto \";\n          } else if (n.static) {\n            modifier = \"static \";\n          }\n\n          return concat$d([modifier, isGetterOrSetter$1(n) ? n.kind + \" \" : \"\", _variance2 || \"\", printPropertyKey(path, options, print), printOptionalToken(path), isFunctionNotation$1(n, options) ? \"\" : \": \", path.call(print, \"value\")]);\n        }\n\n      case \"QualifiedTypeIdentifier\":\n        return concat$d([path.call(print, \"qualification\"), \".\", path.call(print, \"id\")]);\n\n      case \"StringLiteralTypeAnnotation\":\n        return nodeStr(n, options);\n\n      case \"NumberLiteralTypeAnnotation\":\n        assert.strictEqual(_typeof(n.value), \"number\");\n\n        if (n.extra != null) {\n          return printNumber$2(n.extra.raw);\n        }\n\n        return printNumber$2(n.raw);\n\n      case \"StringTypeAnnotation\":\n        return \"string\";\n\n      case \"DeclareTypeAlias\":\n      case \"TypeAlias\":\n        {\n          if (n.type === \"DeclareTypeAlias\" || n.declare) {\n            parts.push(\"declare \");\n          }\n\n          var _printed5 = printAssignmentRight(n.id, n.right, path.call(print, \"right\"), options);\n\n          parts.push(\"type \", path.call(print, \"id\"), path.call(print, \"typeParameters\"), \" =\", _printed5, semi);\n          return group$b(concat$d(parts));\n        }\n\n      case \"TypeCastExpression\":\n        {\n          var value = path.getValue(); // Flow supports a comment syntax for specifying type annotations: https://flow.org/en/docs/types/comments/.\n          // Unfortunately, its parser doesn't differentiate between comment annotations and regular\n          // annotations when producing an AST. So to preserve parentheses around type casts that use\n          // the comment syntax, we need to hackily read the source itself to see if the code contains\n          // a type annotation comment.\n          //\n          // Note that we're able to use the normal whitespace regex here because the Flow parser has\n          // already deemed this AST node to be a type cast. Only the Babel parser needs the\n          // non-line-break whitespace regex, which is why hasFlowShorthandAnnotationComment() is\n          // implemented differently.\n\n          var commentSyntax = value && value.typeAnnotation && value.typeAnnotation.range && options.originalText.substring(value.typeAnnotation.range[0]).match(/^\\/\\*\\s*:/);\n          return concat$d([\"(\", path.call(print, \"expression\"), commentSyntax ? \" /*\" : \"\", \": \", path.call(print, \"typeAnnotation\"), commentSyntax ? \" */\" : \"\", \")\"]);\n        }\n\n      case \"TypeParameterDeclaration\":\n      case \"TypeParameterInstantiation\":\n        {\n          var _value = path.getValue();\n\n          var commentStart = _value.range ? options.originalText.substring(0, _value.range[0]).lastIndexOf(\"/*\") : -1; // As noted in the TypeCastExpression comments above, we're able to use a normal whitespace regex here\n          // because we know for sure that this is a type definition.\n\n          var _commentSyntax = commentStart >= 0 && options.originalText.substring(commentStart).match(/^\\/\\*\\s*::/);\n\n          if (_commentSyntax) {\n            return concat$d([\"/*:: \", printTypeParameters(path, options, print, \"params\"), \" */\"]);\n          }\n\n          return printTypeParameters(path, options, print, \"params\");\n        }\n\n      case \"TSTypeParameterDeclaration\":\n      case \"TSTypeParameterInstantiation\":\n        return printTypeParameters(path, options, print, \"params\");\n\n      case \"TSTypeParameter\":\n      case \"TypeParameter\":\n        {\n          var _parent10 = path.getParentNode();\n\n          if (_parent10.type === \"TSMappedType\") {\n            parts.push(\"[\", path.call(print, \"name\"));\n\n            if (n.constraint) {\n              parts.push(\" in \", path.call(print, \"constraint\"));\n            }\n\n            parts.push(\"]\");\n            return concat$d(parts);\n          }\n\n          var _variance3 = getFlowVariance$1(n);\n\n          if (_variance3) {\n            parts.push(_variance3);\n          }\n\n          parts.push(path.call(print, \"name\"));\n\n          if (n.bound) {\n            parts.push(\": \");\n            parts.push(path.call(print, \"bound\"));\n          }\n\n          if (n.constraint) {\n            parts.push(\" extends \", path.call(print, \"constraint\"));\n          }\n\n          if (n[\"default\"]) {\n            parts.push(\" = \", path.call(print, \"default\"));\n          } // Keep comma if the file extension is .tsx and\n          // has one type parameter that isn't extend with any types.\n          // Because, otherwise formatted result will be invalid as tsx.\n\n\n          var _grandParent = path.getNode(2);\n\n          if (_parent10.params && _parent10.params.length === 1 && isTSXFile$1(options) && !n.constraint && _grandParent.type === \"ArrowFunctionExpression\") {\n            parts.push(\",\");\n          }\n\n          return concat$d(parts);\n        }\n\n      case \"TypeofTypeAnnotation\":\n        return concat$d([\"typeof \", path.call(print, \"argument\")]);\n\n      case \"VoidTypeAnnotation\":\n        return \"void\";\n\n      case \"InferredPredicate\":\n        return \"%checks\";\n      // Unhandled types below. If encountered, nodes of these types should\n      // be either left alone or desugared into AST types that are fully\n      // supported by the pretty-printer.\n\n      case \"DeclaredPredicate\":\n        return concat$d([\"%checks(\", path.call(print, \"value\"), \")\"]);\n\n      case \"TSAbstractKeyword\":\n        return \"abstract\";\n\n      case \"TSAnyKeyword\":\n        return \"any\";\n\n      case \"TSAsyncKeyword\":\n        return \"async\";\n\n      case \"TSBooleanKeyword\":\n        return \"boolean\";\n\n      case \"TSBigIntKeyword\":\n        return \"bigint\";\n\n      case \"TSConstKeyword\":\n        return \"const\";\n\n      case \"TSDeclareKeyword\":\n        return \"declare\";\n\n      case \"TSExportKeyword\":\n        return \"export\";\n\n      case \"TSNeverKeyword\":\n        return \"never\";\n\n      case \"TSNumberKeyword\":\n        return \"number\";\n\n      case \"TSObjectKeyword\":\n        return \"object\";\n\n      case \"TSProtectedKeyword\":\n        return \"protected\";\n\n      case \"TSPrivateKeyword\":\n        return \"private\";\n\n      case \"TSPublicKeyword\":\n        return \"public\";\n\n      case \"TSReadonlyKeyword\":\n        return \"readonly\";\n\n      case \"TSSymbolKeyword\":\n        return \"symbol\";\n\n      case \"TSStaticKeyword\":\n        return \"static\";\n\n      case \"TSStringKeyword\":\n        return \"string\";\n\n      case \"TSUndefinedKeyword\":\n        return \"undefined\";\n\n      case \"TSUnknownKeyword\":\n        return \"unknown\";\n\n      case \"TSVoidKeyword\":\n        return \"void\";\n\n      case \"TSAsExpression\":\n        return concat$d([path.call(print, \"expression\"), \" as \", path.call(print, \"typeAnnotation\")]);\n\n      case \"TSArrayType\":\n        return concat$d([path.call(print, \"elementType\"), \"[]\"]);\n\n      case \"TSPropertySignature\":\n        {\n          if (n.export) {\n            parts.push(\"export \");\n          }\n\n          if (n.accessibility) {\n            parts.push(n.accessibility + \" \");\n          }\n\n          if (n.static) {\n            parts.push(\"static \");\n          }\n\n          if (n.readonly) {\n            parts.push(\"readonly \");\n          }\n\n          parts.push(printPropertyKey(path, options, print), printOptionalToken(path));\n\n          if (n.typeAnnotation) {\n            parts.push(\": \");\n            parts.push(path.call(print, \"typeAnnotation\"));\n          } // This isn't valid semantically, but it's in the AST so we can print it.\n\n\n          if (n.initializer) {\n            parts.push(\" = \", path.call(print, \"initializer\"));\n          }\n\n          return concat$d(parts);\n        }\n\n      case \"TSParameterProperty\":\n        if (n.accessibility) {\n          parts.push(n.accessibility + \" \");\n        }\n\n        if (n.export) {\n          parts.push(\"export \");\n        }\n\n        if (n.static) {\n          parts.push(\"static \");\n        }\n\n        if (n.readonly) {\n          parts.push(\"readonly \");\n        }\n\n        parts.push(path.call(print, \"parameter\"));\n        return concat$d(parts);\n\n      case \"TSTypeReference\":\n        return concat$d([path.call(print, \"typeName\"), printTypeParameters(path, options, print, \"typeParameters\")]);\n\n      case \"TSTypeQuery\":\n        return concat$d([\"typeof \", path.call(print, \"exprName\")]);\n\n      case \"TSIndexSignature\":\n        {\n          var _parent11 = path.getParentNode();\n\n          return concat$d([n.export ? \"export \" : \"\", n.accessibility ? concat$d([n.accessibility, \" \"]) : \"\", n.static ? \"static \" : \"\", n.readonly ? \"readonly \" : \"\", \"[\", n.parameters ? concat$d(path.map(print, \"parameters\")) : \"\", \"]: \", path.call(print, \"typeAnnotation\"), _parent11.type === \"ClassBody\" ? semi : \"\"]);\n        }\n\n      case \"TSTypePredicate\":\n        return concat$d([n.asserts ? \"asserts \" : \"\", path.call(print, \"parameterName\"), n.typeAnnotation ? concat$d([\" is \", path.call(print, \"typeAnnotation\")]) : \"\"]);\n\n      case \"TSNonNullExpression\":\n        return concat$d([path.call(print, \"expression\"), \"!\"]);\n\n      case \"TSThisType\":\n        return \"this\";\n\n      case \"TSImportType\":\n        return concat$d([!n.isTypeOf ? \"\" : \"typeof \", \"import(\", path.call(print, \"parameter\"), \")\", !n.qualifier ? \"\" : concat$d([\".\", path.call(print, \"qualifier\")]), printTypeParameters(path, options, print, \"typeParameters\")]);\n\n      case \"TSLiteralType\":\n        return path.call(print, \"literal\");\n\n      case \"TSIndexedAccessType\":\n        return concat$d([path.call(print, \"objectType\"), \"[\", path.call(print, \"indexType\"), \"]\"]);\n\n      case \"TSConstructSignatureDeclaration\":\n      case \"TSCallSignatureDeclaration\":\n      case \"TSConstructorType\":\n        {\n          if (n.type !== \"TSCallSignatureDeclaration\") {\n            parts.push(\"new \");\n          }\n\n          parts.push(group$b(printFunctionParams(path, print, options,\n          /* expandArg */\n          false,\n          /* printTypeParams */\n          true)));\n\n          if (n.returnType) {\n            var isType = n.type === \"TSConstructorType\";\n            parts.push(isType ? \" => \" : \": \", path.call(print, \"returnType\"));\n          }\n\n          return concat$d(parts);\n        }\n\n      case \"TSTypeOperator\":\n        return concat$d([n.operator, \" \", path.call(print, \"typeAnnotation\")]);\n\n      case \"TSMappedType\":\n        {\n          var _shouldBreak3 = hasNewlineInRange$2(options.originalText, options.locStart(n), options.locEnd(n));\n\n          return group$b(concat$d([\"{\", indent$7(concat$d([options.bracketSpacing ? line$7 : softline$6, n.readonly ? concat$d([getTypeScriptMappedTypeModifier$1(n.readonly, \"readonly\"), \" \"]) : \"\", printTypeScriptModifiers(path, options, print), path.call(print, \"typeParameter\"), n.optional ? getTypeScriptMappedTypeModifier$1(n.optional, \"?\") : \"\", \": \", path.call(print, \"typeAnnotation\"), ifBreak$6(semi, \"\")])), comments.printDanglingComments(path, options,\n          /* sameIndent */\n          true), options.bracketSpacing ? line$7 : softline$6, \"}\"]), {\n            shouldBreak: _shouldBreak3\n          });\n        }\n\n      case \"TSMethodSignature\":\n        parts.push(n.accessibility ? concat$d([n.accessibility, \" \"]) : \"\", n.export ? \"export \" : \"\", n.static ? \"static \" : \"\", n.readonly ? \"readonly \" : \"\", n.computed ? \"[\" : \"\", path.call(print, \"key\"), n.computed ? \"]\" : \"\", printOptionalToken(path), printFunctionParams(path, print, options,\n        /* expandArg */\n        false,\n        /* printTypeParams */\n        true));\n\n        if (n.returnType) {\n          parts.push(\": \", path.call(print, \"returnType\"));\n        }\n\n        return group$b(concat$d(parts));\n\n      case \"TSNamespaceExportDeclaration\":\n        parts.push(\"export as namespace \", path.call(print, \"id\"));\n\n        if (options.semi) {\n          parts.push(\";\");\n        }\n\n        return group$b(concat$d(parts));\n\n      case \"TSEnumDeclaration\":\n        if (n.declare) {\n          parts.push(\"declare \");\n        }\n\n        if (n.modifiers) {\n          parts.push(printTypeScriptModifiers(path, options, print));\n        }\n\n        if (n.const) {\n          parts.push(\"const \");\n        }\n\n        parts.push(\"enum \", path.call(print, \"id\"), \" \");\n\n        if (n.members.length === 0) {\n          parts.push(group$b(concat$d([\"{\", comments.printDanglingComments(path, options), softline$6, \"}\"])));\n        } else {\n          parts.push(group$b(concat$d([\"{\", indent$7(concat$d([hardline$9, printArrayItems(path, options, \"members\", print), shouldPrintComma$1(options, \"es5\") ? \",\" : \"\"])), comments.printDanglingComments(path, options,\n          /* sameIndent */\n          true), hardline$9, \"}\"])));\n        }\n\n        return concat$d(parts);\n\n      case \"TSEnumMember\":\n        parts.push(path.call(print, \"id\"));\n\n        if (n.initializer) {\n          parts.push(\" = \", path.call(print, \"initializer\"));\n        }\n\n        return concat$d(parts);\n\n      case \"TSImportEqualsDeclaration\":\n        if (n.isExport) {\n          parts.push(\"export \");\n        }\n\n        parts.push(\"import \", path.call(print, \"id\"), \" = \", path.call(print, \"moduleReference\"));\n\n        if (options.semi) {\n          parts.push(\";\");\n        }\n\n        return group$b(concat$d(parts));\n\n      case \"TSExternalModuleReference\":\n        return concat$d([\"require(\", path.call(print, \"expression\"), \")\"]);\n\n      case \"TSModuleDeclaration\":\n        {\n          var _parent12 = path.getParentNode();\n\n          var isExternalModule = isLiteral$1(n.id);\n          var parentIsDeclaration = _parent12.type === \"TSModuleDeclaration\";\n          var bodyIsDeclaration = n.body && n.body.type === \"TSModuleDeclaration\";\n\n          if (parentIsDeclaration) {\n            parts.push(\".\");\n          } else {\n            if (n.declare) {\n              parts.push(\"declare \");\n            }\n\n            parts.push(printTypeScriptModifiers(path, options, print));\n            var textBetweenNodeAndItsId = options.originalText.slice(options.locStart(n), options.locStart(n.id)); // Global declaration looks like this:\n            // (declare)? global { ... }\n\n            var isGlobalDeclaration = n.id.type === \"Identifier\" && n.id.name === \"global\" && !/namespace|module/.test(textBetweenNodeAndItsId);\n\n            if (!isGlobalDeclaration) {\n              parts.push(isExternalModule || /(^|\\s)module(\\s|$)/.test(textBetweenNodeAndItsId) ? \"module \" : \"namespace \");\n            }\n          }\n\n          parts.push(path.call(print, \"id\"));\n\n          if (bodyIsDeclaration) {\n            parts.push(path.call(print, \"body\"));\n          } else if (n.body) {\n            parts.push(\" \", group$b(path.call(print, \"body\")));\n          } else {\n            parts.push(semi);\n          }\n\n          return concat$d(parts);\n        }\n\n      case \"PrivateName\":\n        return concat$d([\"#\", path.call(print, \"id\")]);\n\n      case \"TSConditionalType\":\n        return printTernaryOperator(path, options, print, {\n          beforeParts: function beforeParts() {\n            return [path.call(print, \"checkType\"), \" \", \"extends\", \" \", path.call(print, \"extendsType\")];\n          },\n          afterParts: function afterParts() {\n            return [];\n          },\n          shouldCheckJsx: false,\n          conditionalNodeType: \"TSConditionalType\",\n          consequentNodePropertyName: \"trueType\",\n          alternateNodePropertyName: \"falseType\",\n          testNodePropertyName: \"checkType\",\n          breakNested: true\n        });\n\n      case \"TSInferType\":\n        return concat$d([\"infer\", \" \", path.call(print, \"typeParameter\")]);\n\n      case \"InterpreterDirective\":\n        parts.push(\"#!\", n.value, hardline$9);\n\n        if (isNextLineEmpty$4(options.originalText, n, options)) {\n          parts.push(hardline$9);\n        }\n\n        return concat$d(parts);\n\n      case \"NGRoot\":\n        return concat$d([].concat(path.call(print, \"node\"), !n.node.comments || n.node.comments.length === 0 ? [] : concat$d([\" //\", n.node.comments[0].value.trimRight()])));\n\n      case \"NGChainedExpression\":\n        return group$b(join$9(concat$d([\";\", line$7]), path.map(function (childPath) {\n          return hasNgSideEffect$1(childPath) ? print(childPath) : concat$d([\"(\", print(childPath), \")\"]);\n        }, \"expressions\")));\n\n      case \"NGEmptyExpression\":\n        return \"\";\n\n      case \"NGQuotedExpression\":\n        return concat$d([n.prefix, \":\", n.value]);\n\n      case \"NGMicrosyntax\":\n        return concat$d(path.map(function (childPath, index) {\n          return concat$d([index === 0 ? \"\" : isNgForOf$1(childPath.getValue(), index, n) ? \" \" : concat$d([\";\", line$7]), print(childPath)]);\n        }, \"body\"));\n\n      case \"NGMicrosyntaxKey\":\n        return /^[a-z_$][a-z0-9_$]*(-[a-z_$][a-z0-9_$])*$/i.test(n.name) ? n.name : JSON.stringify(n.name);\n\n      case \"NGMicrosyntaxExpression\":\n        return concat$d([path.call(print, \"expression\"), n.alias === null ? \"\" : concat$d([\" as \", path.call(print, \"alias\")])]);\n\n      case \"NGMicrosyntaxKeyedExpression\":\n        {\n          var index = path.getName();\n\n          var _parentNode2 = path.getParentNode();\n\n          var shouldNotPrintColon = isNgForOf$1(n, index, _parentNode2) || (index === 1 && (n.key.name === \"then\" || n.key.name === \"else\") || index === 2 && n.key.name === \"else\" && _parentNode2.body[index - 1].type === \"NGMicrosyntaxKeyedExpression\" && _parentNode2.body[index - 1].key.name === \"then\") && _parentNode2.body[0].type === \"NGMicrosyntaxExpression\";\n          return concat$d([path.call(print, \"key\"), shouldNotPrintColon ? \" \" : \": \", path.call(print, \"expression\")]);\n        }\n\n      case \"NGMicrosyntaxLet\":\n        return concat$d([\"let \", path.call(print, \"key\"), n.value === null ? \"\" : concat$d([\" = \", path.call(print, \"value\")])]);\n\n      case \"NGMicrosyntaxAs\":\n        return concat$d([path.call(print, \"key\"), \" as \", path.call(print, \"alias\")]);\n\n      case \"ArgumentPlaceholder\":\n        return \"?\";\n\n      default:\n        /* istanbul ignore next */\n        throw new Error(\"unknown type: \" + JSON.stringify(n.type));\n    }\n  }\n\n  function printStatementSequence(path, options, print) {\n    var printed = [];\n    var bodyNode = path.getNode();\n    var isClass = bodyNode.type === \"ClassBody\";\n    path.map(function (stmtPath, i) {\n      var stmt = stmtPath.getValue(); // Just in case the AST has been modified to contain falsy\n      // \"statements,\" it's safer simply to skip them.\n\n      /* istanbul ignore if */\n\n      if (!stmt) {\n        return;\n      } // Skip printing EmptyStatement nodes to avoid leaving stray\n      // semicolons lying around.\n\n\n      if (stmt.type === \"EmptyStatement\") {\n        return;\n      }\n\n      var stmtPrinted = print(stmtPath);\n      var text = options.originalText;\n      var parts = []; // in no-semi mode, prepend statement with semicolon if it might break ASI\n      // don't prepend the only JSX element in a program with semicolon\n\n      if (!options.semi && !isClass && !isTheOnlyJSXElementInMarkdown$1(options, stmtPath) && stmtNeedsASIProtection(stmtPath, options)) {\n        if (stmt.comments && stmt.comments.some(function (comment) {\n          return comment.leading;\n        })) {\n          parts.push(print(stmtPath, {\n            needsSemi: true\n          }));\n        } else {\n          parts.push(\";\", stmtPrinted);\n        }\n      } else {\n        parts.push(stmtPrinted);\n      }\n\n      if (!options.semi && isClass) {\n        if (classPropMayCauseASIProblems$1(stmtPath)) {\n          parts.push(\";\");\n        } else if (stmt.type === \"ClassProperty\") {\n          var nextChild = bodyNode.body[i + 1];\n\n          if (classChildNeedsASIProtection$1(nextChild)) {\n            parts.push(\";\");\n          }\n        }\n      }\n\n      if (isNextLineEmpty$4(text, stmt, options) && !isLastStatement$1(stmtPath)) {\n        parts.push(hardline$9);\n      }\n\n      printed.push(concat$d(parts));\n    });\n    return join$9(hardline$9, printed);\n  }\n\n  function printPropertyKey(path, options, print) {\n    var node = path.getNode();\n\n    if (node.computed) {\n      return concat$d([\"[\", path.call(print, \"key\"), \"]\"]);\n    }\n\n    var parent = path.getParentNode();\n    var key = node.key;\n\n    if (options.quoteProps === \"consistent\" && !needsQuoteProps.has(parent)) {\n      var objectHasStringProp = (parent.properties || parent.body || parent.members).some(function (prop) {\n        return !prop.computed && prop.key && isStringLiteral$1(prop.key) && !isStringPropSafeToCoerceToIdentifier$1(prop, options);\n      });\n      needsQuoteProps.set(parent, objectHasStringProp);\n    }\n\n    if (key.type === \"Identifier\" && (options.parser === \"json\" || options.quoteProps === \"consistent\" && needsQuoteProps.get(parent))) {\n      // a -> \"a\"\n      var prop = printString$2(JSON.stringify(key.name), options);\n      return path.call(function (keyPath) {\n        return comments.printComments(keyPath, function () {\n          return prop;\n        }, options);\n      }, \"key\");\n    }\n\n    if (isStringPropSafeToCoerceToIdentifier$1(node, options) && (options.quoteProps === \"as-needed\" || options.quoteProps === \"consistent\" && !needsQuoteProps.get(parent))) {\n      // 'a' -> a\n      return path.call(function (keyPath) {\n        return comments.printComments(keyPath, function () {\n          return key.value;\n        }, options);\n      }, \"key\");\n    }\n\n    return path.call(print, \"key\");\n  }\n\n  function printMethod(path, options, print) {\n    var node = path.getNode();\n    var kind = node.kind;\n    var value = node.value || node;\n    var parts = [];\n\n    if (!kind || kind === \"init\" || kind === \"method\" || kind === \"constructor\") {\n      if (value.async) {\n        parts.push(\"async \");\n      }\n\n      if (value.generator) {\n        parts.push(\"*\");\n      }\n    } else {\n      assert.ok(kind === \"get\" || kind === \"set\");\n      parts.push(kind, \" \");\n    }\n\n    parts.push(printPropertyKey(path, options, print), node.optional || node.key.optional ? \"?\" : \"\", node === value ? printMethodInternal(path, options, print) : path.call(function (path) {\n      return printMethodInternal(path, options, print);\n    }, \"value\"));\n    return concat$d(parts);\n  }\n\n  function printMethodInternal(path, options, print) {\n    var parts = [printFunctionTypeParameters(path, options, print), group$b(concat$d([printFunctionParams(path, print, options), printReturnType(path, print, options)]))];\n\n    if (path.getNode().body) {\n      parts.push(\" \", path.call(print, \"body\"));\n    } else {\n      parts.push(options.semi ? \";\" : \"\");\n    }\n\n    return concat$d(parts);\n  }\n\n  function couldGroupArg(arg) {\n    return arg.type === \"ObjectExpression\" && (arg.properties.length > 0 || arg.comments) || arg.type === \"ArrayExpression\" && (arg.elements.length > 0 || arg.comments) || arg.type === \"TSTypeAssertion\" && couldGroupArg(arg.expression) || arg.type === \"TSAsExpression\" && couldGroupArg(arg.expression) || arg.type === \"FunctionExpression\" || arg.type === \"ArrowFunctionExpression\" && ( // we want to avoid breaking inside composite return types but not simple keywords\n    // https://github.com/prettier/prettier/issues/4070\n    // export class Thing implements OtherThing {\n    //   do: (type: Type) => Provider<Prop> = memoize(\n    //     (type: ObjectType): Provider<Opts> => {}\n    //   );\n    // }\n    // https://github.com/prettier/prettier/issues/6099\n    // app.get(\"/\", (req, res): void => {\n    //   res.send(\"Hello World!\");\n    // });\n    !arg.returnType || !arg.returnType.typeAnnotation || arg.returnType.typeAnnotation.type !== \"TSTypeReference\") && (arg.body.type === \"BlockStatement\" || arg.body.type === \"ArrowFunctionExpression\" || arg.body.type === \"ObjectExpression\" || arg.body.type === \"ArrayExpression\" || arg.body.type === \"CallExpression\" || arg.body.type === \"OptionalCallExpression\" || arg.body.type === \"ConditionalExpression\" || isJSXNode$1(arg.body));\n  }\n\n  function shouldGroupLastArg(args) {\n    var lastArg = getLast$2(args);\n    var penultimateArg = getPenultimate$1(args);\n    return !hasLeadingComment$3(lastArg) && !hasTrailingComment$1(lastArg) && couldGroupArg(lastArg) && ( // If the last two arguments are of the same type,\n    // disable last element expansion.\n    !penultimateArg || penultimateArg.type !== lastArg.type);\n  }\n\n  function shouldGroupFirstArg(args) {\n    if (args.length !== 2) {\n      return false;\n    }\n\n    var firstArg = args[0];\n    var secondArg = args[1];\n    return (!firstArg.comments || !firstArg.comments.length) && (firstArg.type === \"FunctionExpression\" || firstArg.type === \"ArrowFunctionExpression\" && firstArg.body.type === \"BlockStatement\") && secondArg.type !== \"FunctionExpression\" && secondArg.type !== \"ArrowFunctionExpression\" && secondArg.type !== \"ConditionalExpression\" && !couldGroupArg(secondArg);\n  }\n\n  function printJestEachTemplateLiteral(node, expressions, options) {\n    /**\n     * a    | b    | expected\n     * ${1} | ${1} | ${2}\n     * ${1} | ${2} | ${3}\n     * ${2} | ${1} | ${3}\n     */\n    var headerNames = node.quasis[0].value.raw.trim().split(/\\s*\\|\\s*/);\n\n    if (headerNames.length > 1 || headerNames.some(function (headerName) {\n      return headerName.length !== 0;\n    })) {\n      var parts = [];\n      var stringifiedExpressions = expressions.map(function (doc) {\n        return \"${\" + printDocToString$1(doc, Object.assign({}, options, {\n          printWidth: Infinity,\n          endOfLine: \"lf\"\n        })).formatted + \"}\";\n      });\n      var tableBody = [{\n        hasLineBreak: false,\n        cells: []\n      }];\n\n      for (var i = 1; i < node.quasis.length; i++) {\n        var row = tableBody[tableBody.length - 1];\n        var correspondingExpression = stringifiedExpressions[i - 1];\n        row.cells.push(correspondingExpression);\n\n        if (correspondingExpression.indexOf(\"\\n\") !== -1) {\n          row.hasLineBreak = true;\n        }\n\n        if (node.quasis[i].value.raw.indexOf(\"\\n\") !== -1) {\n          tableBody.push({\n            hasLineBreak: false,\n            cells: []\n          });\n        }\n      }\n\n      var maxColumnCount = tableBody.reduce(function (maxColumnCount, row) {\n        return Math.max(maxColumnCount, row.cells.length);\n      }, headerNames.length);\n      var maxColumnWidths = Array.from(new Array(maxColumnCount), function () {\n        return 0;\n      });\n      var table = [{\n        cells: headerNames\n      }].concat(tableBody.filter(function (row) {\n        return row.cells.length !== 0;\n      }));\n      table.filter(function (row) {\n        return !row.hasLineBreak;\n      }).forEach(function (row) {\n        row.cells.forEach(function (cell, index) {\n          maxColumnWidths[index] = Math.max(maxColumnWidths[index], getStringWidth$2(cell));\n        });\n      });\n      parts.push(lineSuffixBoundary$1, \"`\", indent$7(concat$d([hardline$9, join$9(hardline$9, table.map(function (row) {\n        return join$9(\" | \", row.cells.map(function (cell, index) {\n          return row.hasLineBreak ? cell : cell + \" \".repeat(maxColumnWidths[index] - getStringWidth$2(cell));\n        }));\n      }))])), hardline$9, \"`\");\n      return concat$d(parts);\n    }\n  }\n\n  function printArgumentsList(path, options, print) {\n    var node = path.getValue();\n    var args = node.arguments;\n\n    if (args.length === 0) {\n      return concat$d([\"(\", comments.printDanglingComments(path, options,\n      /* sameIndent */\n      true), \")\"]);\n    } // useEffect(() => { ... }, [foo, bar, baz])\n\n\n    if (args.length === 2 && args[0].type === \"ArrowFunctionExpression\" && args[0].params.length === 0 && args[0].body.type === \"BlockStatement\" && args[1].type === \"ArrayExpression\" && !args.find(function (arg) {\n      return arg.comments;\n    })) {\n      return concat$d([\"(\", path.call(print, \"arguments\", 0), \", \", path.call(print, \"arguments\", 1), \")\"]);\n    } // func(\n    //   ({\n    //     a,\n    //     b\n    //   }) => {}\n    // );\n\n\n    function shouldBreakForArrowFunctionInArguments(arg, argPath) {\n      if (!arg || arg.type !== \"ArrowFunctionExpression\" || !arg.body || arg.body.type !== \"BlockStatement\" || !arg.params || arg.params.length < 1) {\n        return false;\n      }\n\n      var shouldBreak = false;\n      argPath.each(function (paramPath) {\n        var printed = concat$d([print(paramPath)]);\n        shouldBreak = shouldBreak || willBreak$1(printed);\n      }, \"params\");\n      return shouldBreak;\n    }\n\n    var anyArgEmptyLine = false;\n    var shouldBreakForArrowFunction = false;\n    var hasEmptyLineFollowingFirstArg = false;\n    var lastArgIndex = args.length - 1;\n    var printedArguments = path.map(function (argPath, index) {\n      var arg = argPath.getNode();\n      var parts = [print(argPath)];\n\n      if (index === lastArgIndex) ; else if (isNextLineEmpty$4(options.originalText, arg, options)) {\n        if (index === 0) {\n          hasEmptyLineFollowingFirstArg = true;\n        }\n\n        anyArgEmptyLine = true;\n        parts.push(\",\", hardline$9, hardline$9);\n      } else {\n        parts.push(\",\", line$7);\n      }\n\n      shouldBreakForArrowFunction = shouldBreakForArrowFunctionInArguments(arg, argPath);\n      return concat$d(parts);\n    }, \"arguments\");\n    var maybeTrailingComma = // Dynamic imports cannot have trailing commas\n    !(node.callee && node.callee.type === \"Import\") && shouldPrintComma$1(options, \"all\") ? \",\" : \"\";\n\n    function allArgsBrokenOut() {\n      return group$b(concat$d([\"(\", indent$7(concat$d([line$7, concat$d(printedArguments)])), maybeTrailingComma, line$7, \")\"]), {\n        shouldBreak: true\n      });\n    }\n\n    if (isFunctionCompositionArgs$1(args)) {\n      return allArgsBrokenOut();\n    }\n\n    var shouldGroupFirst = shouldGroupFirstArg(args);\n    var shouldGroupLast = shouldGroupLastArg(args);\n\n    if (shouldGroupFirst || shouldGroupLast) {\n      var shouldBreak = (shouldGroupFirst ? printedArguments.slice(1).some(willBreak$1) : printedArguments.slice(0, -1).some(willBreak$1)) || anyArgEmptyLine || shouldBreakForArrowFunction; // We want to print the last argument with a special flag\n\n      var printedExpanded;\n      var i = 0;\n      path.each(function (argPath) {\n        if (shouldGroupFirst && i === 0) {\n          printedExpanded = [concat$d([argPath.call(function (p) {\n            return print(p, {\n              expandFirstArg: true\n            });\n          }), printedArguments.length > 1 ? \",\" : \"\", hasEmptyLineFollowingFirstArg ? hardline$9 : line$7, hasEmptyLineFollowingFirstArg ? hardline$9 : \"\"])].concat(printedArguments.slice(1));\n        }\n\n        if (shouldGroupLast && i === args.length - 1) {\n          printedExpanded = printedArguments.slice(0, -1).concat(argPath.call(function (p) {\n            return print(p, {\n              expandLastArg: true\n            });\n          }));\n        }\n\n        i++;\n      }, \"arguments\");\n      var somePrintedArgumentsWillBreak = printedArguments.some(willBreak$1);\n      var simpleConcat = concat$d([\"(\", concat$d(printedExpanded), \")\"]);\n      return concat$d([somePrintedArgumentsWillBreak ? breakParent$3 : \"\", conditionalGroup$1([!somePrintedArgumentsWillBreak && !node.typeArguments && !node.typeParameters ? simpleConcat : ifBreak$6(allArgsBrokenOut(), simpleConcat), shouldGroupFirst ? concat$d([\"(\", group$b(printedExpanded[0], {\n        shouldBreak: true\n      }), concat$d(printedExpanded.slice(1)), \")\"]) : concat$d([\"(\", concat$d(printedArguments.slice(0, -1)), group$b(getLast$2(printedExpanded), {\n        shouldBreak: true\n      }), \")\"]), allArgsBrokenOut()], {\n        shouldBreak: shouldBreak\n      })]);\n    }\n\n    var contents = concat$d([\"(\", indent$7(concat$d([softline$6, concat$d(printedArguments)])), ifBreak$6(maybeTrailingComma), softline$6, \")\"]);\n\n    if (isLongCurriedCallExpression$1(path)) {\n      // By not wrapping the arguments in a group, the printer prioritizes\n      // breaking up these arguments rather than the args of the parent call.\n      return contents;\n    }\n\n    return group$b(contents, {\n      shouldBreak: printedArguments.some(willBreak$1) || anyArgEmptyLine\n    });\n  }\n\n  function printTypeAnnotation(path, options, print) {\n    var node = path.getValue();\n\n    if (!node.typeAnnotation) {\n      return \"\";\n    }\n\n    var parentNode = path.getParentNode();\n    var isDefinite = node.definite || parentNode && parentNode.type === \"VariableDeclarator\" && parentNode.definite;\n    var isFunctionDeclarationIdentifier = parentNode.type === \"DeclareFunction\" && parentNode.id === node;\n\n    if (isFlowAnnotationComment$1(options.originalText, node.typeAnnotation, options)) {\n      return concat$d([\" /*: \", path.call(print, \"typeAnnotation\"), \" */\"]);\n    }\n\n    return concat$d([isFunctionDeclarationIdentifier ? \"\" : isDefinite ? \"!: \" : \": \", path.call(print, \"typeAnnotation\")]);\n  }\n\n  function printFunctionTypeParameters(path, options, print) {\n    var fun = path.getValue();\n\n    if (fun.typeArguments) {\n      return path.call(print, \"typeArguments\");\n    }\n\n    if (fun.typeParameters) {\n      return path.call(print, \"typeParameters\");\n    }\n\n    return \"\";\n  }\n\n  function printFunctionParams(path, print, options, expandArg, printTypeParams) {\n    var fun = path.getValue();\n    var parent = path.getParentNode();\n    var paramsField = fun.parameters ? \"parameters\" : \"params\";\n    var isParametersInTestCall = isTestCall$1(parent);\n    var shouldHugParameters = shouldHugArguments(fun);\n    var shouldExpandParameters = expandArg && !(fun[paramsField] && fun[paramsField].some(function (n) {\n      return n.comments;\n    }));\n    var typeParams = printTypeParams ? printFunctionTypeParameters(path, options, print) : \"\";\n    var printed = [];\n\n    if (fun[paramsField]) {\n      var lastArgIndex = fun[paramsField].length - 1;\n      printed = path.map(function (childPath, index) {\n        var parts = [];\n        var param = childPath.getValue();\n        parts.push(print(childPath));\n\n        if (index === lastArgIndex) {\n          if (fun.rest) {\n            parts.push(\",\", line$7);\n          }\n        } else if (isParametersInTestCall || shouldHugParameters || shouldExpandParameters) {\n          parts.push(\", \");\n        } else if (isNextLineEmpty$4(options.originalText, param, options)) {\n          parts.push(\",\", hardline$9, hardline$9);\n        } else {\n          parts.push(\",\", line$7);\n        }\n\n        return concat$d(parts);\n      }, paramsField);\n    }\n\n    if (fun.rest) {\n      printed.push(concat$d([\"...\", path.call(print, \"rest\")]));\n    }\n\n    if (printed.length === 0) {\n      return concat$d([typeParams, \"(\", comments.printDanglingComments(path, options,\n      /* sameIndent */\n      true, function (comment) {\n        return getNextNonSpaceNonCommentCharacter$1(options.originalText, comment, options.locEnd) === \")\";\n      }), \")\"]);\n    }\n\n    var lastParam = getLast$2(fun[paramsField]); // If the parent is a call with the first/last argument expansion and this is the\n    // params of the first/last argument, we don't want the arguments to break and instead\n    // want the whole expression to be on a new line.\n    //\n    // Good:                 Bad:\n    //   verylongcall(         verylongcall((\n    //     (a, b) => {           a,\n    //     }                     b,\n    //   })                    ) => {\n    //                         })\n\n    if (shouldExpandParameters) {\n      return group$b(concat$d([removeLines$2(typeParams), \"(\", concat$d(printed.map(removeLines$2)), \")\"]));\n    } // Single object destructuring should hug\n    //\n    // function({\n    //   a,\n    //   b,\n    //   c\n    // }) {}\n\n\n    var hasNotParameterDecorator = fun[paramsField].every(function (param) {\n      return !param.decorators;\n    });\n\n    if (shouldHugParameters && hasNotParameterDecorator) {\n      return concat$d([typeParams, \"(\", concat$d(printed), \")\"]);\n    } // don't break in specs, eg; `it(\"should maintain parens around done even when long\", (done) => {})`\n\n\n    if (isParametersInTestCall) {\n      return concat$d([typeParams, \"(\", concat$d(printed), \")\"]);\n    }\n\n    var isFlowShorthandWithOneArg = (isObjectTypePropertyAFunction$1(parent, options) || isTypeAnnotationAFunction$1(parent, options) || parent.type === \"TypeAlias\" || parent.type === \"UnionTypeAnnotation\" || parent.type === \"TSUnionType\" || parent.type === \"IntersectionTypeAnnotation\" || parent.type === \"FunctionTypeAnnotation\" && parent.returnType === fun) && fun[paramsField].length === 1 && fun[paramsField][0].name === null && fun[paramsField][0].typeAnnotation && fun.typeParameters === null && isSimpleFlowType$1(fun[paramsField][0].typeAnnotation) && !fun.rest;\n\n    if (isFlowShorthandWithOneArg) {\n      if (options.arrowParens === \"always\") {\n        return concat$d([\"(\", concat$d(printed), \")\"]);\n      }\n\n      return concat$d(printed);\n    }\n\n    var canHaveTrailingComma = !(lastParam && lastParam.type === \"RestElement\") && !fun.rest;\n    return concat$d([typeParams, \"(\", indent$7(concat$d([softline$6, concat$d(printed)])), ifBreak$6(canHaveTrailingComma && shouldPrintComma$1(options, \"all\") ? \",\" : \"\"), softline$6, \")\"]);\n  }\n\n  function shouldPrintParamsWithoutParens(path, options) {\n    if (options.arrowParens === \"always\") {\n      return false;\n    }\n\n    if (options.arrowParens === \"avoid\") {\n      var node = path.getValue();\n      return canPrintParamsWithoutParens(node);\n    } // Fallback default; should be unreachable\n\n\n    return false;\n  }\n\n  function canPrintParamsWithoutParens(node) {\n    return node.params.length === 1 && !node.rest && !node.typeParameters && !hasDanglingComments$1(node) && node.params[0].type === \"Identifier\" && !node.params[0].typeAnnotation && !node.params[0].comments && !node.params[0].optional && !node.predicate && !node.returnType;\n  }\n\n  function printFunctionDeclaration(path, print, options) {\n    var n = path.getValue();\n    var parts = [];\n\n    if (n.async) {\n      parts.push(\"async \");\n    }\n\n    parts.push(\"function\");\n\n    if (n.generator) {\n      parts.push(\"*\");\n    }\n\n    if (n.id) {\n      parts.push(\" \", path.call(print, \"id\"));\n    }\n\n    parts.push(printFunctionTypeParameters(path, options, print), group$b(concat$d([printFunctionParams(path, print, options), printReturnType(path, print, options)])), n.body ? \" \" : \"\", path.call(print, \"body\"));\n    return concat$d(parts);\n  }\n\n  function printReturnType(path, print, options) {\n    var n = path.getValue();\n    var returnType = path.call(print, \"returnType\");\n\n    if (n.returnType && isFlowAnnotationComment$1(options.originalText, n.returnType, options)) {\n      return concat$d([\" /*: \", returnType, \" */\"]);\n    }\n\n    var parts = [returnType]; // prepend colon to TypeScript type annotation\n\n    if (n.returnType && n.returnType.typeAnnotation) {\n      parts.unshift(\": \");\n    }\n\n    if (n.predicate) {\n      // The return type will already add the colon, but otherwise we\n      // need to do it ourselves\n      parts.push(n.returnType ? \" \" : \": \", path.call(print, \"predicate\"));\n    }\n\n    return concat$d(parts);\n  }\n\n  function printExportDeclaration(path, options, print) {\n    var decl = path.getValue();\n    var semi = options.semi ? \";\" : \"\";\n    var parts = [\"export \"];\n    var isDefault = decl[\"default\"] || decl.type === \"ExportDefaultDeclaration\";\n\n    if (isDefault) {\n      parts.push(\"default \");\n    }\n\n    parts.push(comments.printDanglingComments(path, options,\n    /* sameIndent */\n    true));\n\n    if (needsHardlineAfterDanglingComment$1(decl)) {\n      parts.push(hardline$9);\n    }\n\n    if (decl.declaration) {\n      parts.push(path.call(print, \"declaration\"));\n\n      if (isDefault && decl.declaration.type !== \"ClassDeclaration\" && decl.declaration.type !== \"FunctionDeclaration\" && decl.declaration.type !== \"TSInterfaceDeclaration\" && decl.declaration.type !== \"DeclareClass\" && decl.declaration.type !== \"DeclareFunction\" && decl.declaration.type !== \"TSDeclareFunction\") {\n        parts.push(semi);\n      }\n    } else {\n      if (decl.specifiers && decl.specifiers.length > 0) {\n        var specifiers = [];\n        var defaultSpecifiers = [];\n        var namespaceSpecifiers = [];\n        path.each(function (specifierPath) {\n          var specifierType = path.getValue().type;\n\n          if (specifierType === \"ExportSpecifier\") {\n            specifiers.push(print(specifierPath));\n          } else if (specifierType === \"ExportDefaultSpecifier\") {\n            defaultSpecifiers.push(print(specifierPath));\n          } else if (specifierType === \"ExportNamespaceSpecifier\") {\n            namespaceSpecifiers.push(concat$d([\"* as \", print(specifierPath)]));\n          }\n        }, \"specifiers\");\n        var isNamespaceFollowed = namespaceSpecifiers.length !== 0 && specifiers.length !== 0;\n        var isDefaultFollowed = defaultSpecifiers.length !== 0 && (namespaceSpecifiers.length !== 0 || specifiers.length !== 0);\n        var canBreak = specifiers.length > 1 || defaultSpecifiers.length > 0 || decl.specifiers && decl.specifiers.some(function (node) {\n          return node.comments;\n        });\n        var printed = \"\";\n\n        if (specifiers.length !== 0) {\n          if (canBreak) {\n            printed = group$b(concat$d([\"{\", indent$7(concat$d([options.bracketSpacing ? line$7 : softline$6, join$9(concat$d([\",\", line$7]), specifiers)])), ifBreak$6(shouldPrintComma$1(options) ? \",\" : \"\"), options.bracketSpacing ? line$7 : softline$6, \"}\"]));\n          } else {\n            printed = concat$d([\"{\", options.bracketSpacing ? \" \" : \"\", concat$d(specifiers), options.bracketSpacing ? \" \" : \"\", \"}\"]);\n          }\n        }\n\n        parts.push(decl.exportKind === \"type\" ? \"type \" : \"\", concat$d(defaultSpecifiers), concat$d([isDefaultFollowed ? \", \" : \"\"]), concat$d(namespaceSpecifiers), concat$d([isNamespaceFollowed ? \", \" : \"\"]), printed);\n      } else {\n        parts.push(\"{}\");\n      }\n\n      if (decl.source) {\n        parts.push(\" from \", path.call(print, \"source\"));\n      }\n\n      parts.push(semi);\n    }\n\n    return concat$d(parts);\n  }\n\n  function printFlowDeclaration(path, parts) {\n    var parentExportDecl = getParentExportDeclaration$1(path);\n\n    if (parentExportDecl) {\n      assert.strictEqual(parentExportDecl.type, \"DeclareExportDeclaration\");\n    } else {\n      // If the parent node has type DeclareExportDeclaration, then it\n      // will be responsible for printing the \"declare\" token. Otherwise\n      // it needs to be printed with this non-exported declaration node.\n      parts.unshift(\"declare \");\n    }\n\n    return concat$d(parts);\n  }\n\n  function printTypeScriptModifiers(path, options, print) {\n    var n = path.getValue();\n\n    if (!n.modifiers || !n.modifiers.length) {\n      return \"\";\n    }\n\n    return concat$d([join$9(\" \", path.map(print, \"modifiers\")), \" \"]);\n  }\n\n  function printTypeParameters(path, options, print, paramsKey) {\n    var n = path.getValue();\n\n    if (!n[paramsKey]) {\n      return \"\";\n    } // for TypeParameterDeclaration typeParameters is a single node\n\n\n    if (!Array.isArray(n[paramsKey])) {\n      return path.call(print, paramsKey);\n    }\n\n    var grandparent = path.getNode(2);\n    var greatGreatGrandParent = path.getNode(4);\n    var isParameterInTestCall = grandparent != null && isTestCall$1(grandparent);\n    var shouldInline = isParameterInTestCall || n[paramsKey].length === 0 || n[paramsKey].length === 1 && (shouldHugType(n[paramsKey][0]) || n[paramsKey][0].type === \"GenericTypeAnnotation\" && shouldHugType(n[paramsKey][0].id) || n[paramsKey][0].type === \"TSTypeReference\" && shouldHugType(n[paramsKey][0].typeName) || n[paramsKey][0].type === \"NullableTypeAnnotation\" || // See https://github.com/prettier/prettier/pull/6467 for the context.\n    greatGreatGrandParent && greatGreatGrandParent.type === \"VariableDeclarator\" && grandparent && grandparent.type === \"TSTypeAnnotation\" && n[paramsKey][0].type !== \"TSUnionType\" && n[paramsKey][0].type !== \"UnionTypeAnnotation\" && n[paramsKey][0].type !== \"TSConditionalType\" && n[paramsKey][0].type !== \"TSMappedType\");\n\n    if (shouldInline) {\n      return concat$d([\"<\", join$9(\", \", path.map(print, paramsKey)), \">\"]);\n    }\n\n    return group$b(concat$d([\"<\", indent$7(concat$d([softline$6, join$9(concat$d([\",\", line$7]), path.map(print, paramsKey))])), ifBreak$6(options.parser !== \"typescript\" && shouldPrintComma$1(options, \"all\") ? \",\" : \"\"), softline$6, \">\"]));\n  }\n\n  function printClass(path, options, print) {\n    var n = path.getValue();\n    var parts = [];\n\n    if (n.abstract) {\n      parts.push(\"abstract \");\n    }\n\n    parts.push(\"class\");\n\n    if (n.id) {\n      parts.push(\" \", path.call(print, \"id\"));\n    }\n\n    parts.push(path.call(print, \"typeParameters\"));\n    var partsGroup = [];\n\n    if (n.superClass) {\n      var printed = concat$d([\"extends \", path.call(print, \"superClass\"), path.call(print, \"superTypeParameters\")]); // Keep old behaviour of extends in same line\n      // If there is only on extends and there are not comments\n\n      if ((!n.implements || n.implements.length === 0) && (!n.superClass.comments || n.superClass.comments.length === 0)) {\n        parts.push(concat$d([\" \", path.call(function (superClass) {\n          return comments.printComments(superClass, function () {\n            return printed;\n          }, options);\n        }, \"superClass\")]));\n      } else {\n        partsGroup.push(group$b(concat$d([line$7, path.call(function (superClass) {\n          return comments.printComments(superClass, function () {\n            return printed;\n          }, options);\n        }, \"superClass\")])));\n      }\n    } else if (n.extends && n.extends.length > 0) {\n      parts.push(\" extends \", join$9(\", \", path.map(print, \"extends\")));\n    }\n\n    if (n[\"mixins\"] && n[\"mixins\"].length > 0) {\n      partsGroup.push(line$7, \"mixins \", group$b(indent$7(join$9(concat$d([\",\", line$7]), path.map(print, \"mixins\")))));\n    }\n\n    if (n[\"implements\"] && n[\"implements\"].length > 0) {\n      partsGroup.push(line$7, \"implements\", group$b(indent$7(concat$d([line$7, join$9(concat$d([\",\", line$7]), path.map(print, \"implements\"))]))));\n    }\n\n    if (partsGroup.length > 0) {\n      parts.push(group$b(indent$7(concat$d(partsGroup))));\n    }\n\n    if (n.body && n.body.comments && hasLeadingOwnLineComment$1(options.originalText, n.body, options)) {\n      parts.push(hardline$9);\n    } else {\n      parts.push(\" \");\n    }\n\n    parts.push(path.call(print, \"body\"));\n    return parts;\n  }\n\n  function printOptionalToken(path) {\n    var node = path.getValue();\n\n    if (!node.optional || // It's an optional computed method parsed by typescript-estree.\n    // \"?\" is printed in `printMethod`.\n    node.type === \"Identifier\" && node === path.getParentNode().key) {\n      return \"\";\n    }\n\n    if (node.type === \"OptionalCallExpression\" || node.type === \"OptionalMemberExpression\" && node.computed) {\n      return \"?.\";\n    }\n\n    return \"?\";\n  }\n\n  function printMemberLookup(path, options, print) {\n    var property = path.call(print, \"property\");\n    var n = path.getValue();\n    var optional = printOptionalToken(path);\n\n    if (!n.computed) {\n      return concat$d([optional, \".\", property]);\n    }\n\n    if (!n.property || isNumericLiteral$1(n.property)) {\n      return concat$d([optional, \"[\", property, \"]\"]);\n    }\n\n    return group$b(concat$d([optional, \"[\", indent$7(concat$d([softline$6, property])), softline$6, \"]\"]));\n  }\n\n  function printBindExpressionCallee(path, options, print) {\n    return concat$d([\"::\", path.call(print, \"callee\")]);\n  } // We detect calls on member expressions specially to format a\n  // common pattern better. The pattern we are looking for is this:\n  //\n  // arr\n  //   .map(x => x + 1)\n  //   .filter(x => x > 10)\n  //   .some(x => x % 2)\n  //\n  // The way it is structured in the AST is via a nested sequence of\n  // MemberExpression and CallExpression. We need to traverse the AST\n  // and make groups out of it to print it in the desired way.\n\n\n  function printMemberChain(path, options, print) {\n    // The first phase is to linearize the AST by traversing it down.\n    //\n    //   a().b()\n    // has the following AST structure:\n    //   CallExpression(MemberExpression(CallExpression(Identifier)))\n    // and we transform it into\n    //   [Identifier, CallExpression, MemberExpression, CallExpression]\n    var printedNodes = []; // Here we try to retain one typed empty line after each call expression or\n    // the first group whether it is in parentheses or not\n\n    function shouldInsertEmptyLineAfter(node) {\n      var originalText = options.originalText;\n      var nextCharIndex = getNextNonSpaceNonCommentCharacterIndex$2(originalText, node, options);\n      var nextChar = originalText.charAt(nextCharIndex); // if it is cut off by a parenthesis, we only account for one typed empty\n      // line after that parenthesis\n\n      if (nextChar == \")\") {\n        return isNextLineEmptyAfterIndex$1(originalText, nextCharIndex + 1, options);\n      }\n\n      return isNextLineEmpty$4(originalText, node, options);\n    }\n\n    function rec(path) {\n      var node = path.getValue();\n\n      if ((node.type === \"CallExpression\" || node.type === \"OptionalCallExpression\") && (isMemberish$1(node.callee) || node.callee.type === \"CallExpression\" || node.callee.type === \"OptionalCallExpression\")) {\n        printedNodes.unshift({\n          node: node,\n          printed: concat$d([comments.printComments(path, function () {\n            return concat$d([printOptionalToken(path), printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)]);\n          }, options), shouldInsertEmptyLineAfter(node) ? hardline$9 : \"\"])\n        });\n        path.call(function (callee) {\n          return rec(callee);\n        }, \"callee\");\n      } else if (isMemberish$1(node)) {\n        printedNodes.unshift({\n          node: node,\n          needsParens: needsParens_1(path, options),\n          printed: comments.printComments(path, function () {\n            return node.type === \"OptionalMemberExpression\" || node.type === \"MemberExpression\" ? printMemberLookup(path, options, print) : printBindExpressionCallee(path, options, print);\n          }, options)\n        });\n        path.call(function (object) {\n          return rec(object);\n        }, \"object\");\n      } else if (node.type === \"TSNonNullExpression\") {\n        printedNodes.unshift({\n          node: node,\n          printed: comments.printComments(path, function () {\n            return \"!\";\n          }, options)\n        });\n        path.call(function (expression) {\n          return rec(expression);\n        }, \"expression\");\n      } else {\n        printedNodes.unshift({\n          node: node,\n          printed: path.call(print)\n        });\n      }\n    } // Note: the comments of the root node have already been printed, so we\n    // need to extract this first call without printing them as they would\n    // if handled inside of the recursive call.\n\n\n    var node = path.getValue();\n    printedNodes.unshift({\n      node: node,\n      printed: concat$d([printOptionalToken(path), printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)])\n    });\n    path.call(function (callee) {\n      return rec(callee);\n    }, \"callee\"); // Once we have a linear list of printed nodes, we want to create groups out\n    // of it.\n    //\n    //   a().b.c().d().e\n    // will be grouped as\n    //   [\n    //     [Identifier, CallExpression],\n    //     [MemberExpression, MemberExpression, CallExpression],\n    //     [MemberExpression, CallExpression],\n    //     [MemberExpression],\n    //   ]\n    // so that we can print it as\n    //   a()\n    //     .b.c()\n    //     .d()\n    //     .e\n    // The first group is the first node followed by\n    //   - as many CallExpression as possible\n    //       < fn()()() >.something()\n    //   - as many array accessors as possible\n    //       < fn()[0][1][2] >.something()\n    //   - then, as many MemberExpression as possible but the last one\n    //       < this.items >.something()\n\n    var groups = [];\n    var currentGroup = [printedNodes[0]];\n    var i = 1;\n\n    for (; i < printedNodes.length; ++i) {\n      if (printedNodes[i].node.type === \"TSNonNullExpression\" || printedNodes[i].node.type === \"OptionalCallExpression\" || printedNodes[i].node.type === \"CallExpression\" || (printedNodes[i].node.type === \"MemberExpression\" || printedNodes[i].node.type === \"OptionalMemberExpression\") && printedNodes[i].node.computed && isNumericLiteral$1(printedNodes[i].node.property)) {\n        currentGroup.push(printedNodes[i]);\n      } else {\n        break;\n      }\n    }\n\n    if (printedNodes[0].node.type !== \"CallExpression\" && printedNodes[0].node.type !== \"OptionalCallExpression\") {\n      for (; i + 1 < printedNodes.length; ++i) {\n        if (isMemberish$1(printedNodes[i].node) && isMemberish$1(printedNodes[i + 1].node)) {\n          currentGroup.push(printedNodes[i]);\n        } else {\n          break;\n        }\n      }\n    }\n\n    groups.push(currentGroup);\n    currentGroup = []; // Then, each following group is a sequence of MemberExpression followed by\n    // a sequence of CallExpression. To compute it, we keep adding things to the\n    // group until we has seen a CallExpression in the past and reach a\n    // MemberExpression\n\n    var hasSeenCallExpression = false;\n\n    for (; i < printedNodes.length; ++i) {\n      if (hasSeenCallExpression && isMemberish$1(printedNodes[i].node)) {\n        // [0] should be appended at the end of the group instead of the\n        // beginning of the next one\n        if (printedNodes[i].node.computed && isNumericLiteral$1(printedNodes[i].node.property)) {\n          currentGroup.push(printedNodes[i]);\n          continue;\n        }\n\n        groups.push(currentGroup);\n        currentGroup = [];\n        hasSeenCallExpression = false;\n      }\n\n      if (printedNodes[i].node.type === \"CallExpression\" || printedNodes[i].node.type === \"OptionalCallExpression\") {\n        hasSeenCallExpression = true;\n      }\n\n      currentGroup.push(printedNodes[i]);\n\n      if (printedNodes[i].node.comments && printedNodes[i].node.comments.some(function (comment) {\n        return comment.trailing;\n      })) {\n        groups.push(currentGroup);\n        currentGroup = [];\n        hasSeenCallExpression = false;\n      }\n    }\n\n    if (currentGroup.length > 0) {\n      groups.push(currentGroup);\n    } // There are cases like Object.keys(), Observable.of(), _.values() where\n    // they are the subject of all the chained calls and therefore should\n    // be kept on the same line:\n    //\n    //   Object.keys(items)\n    //     .filter(x => x)\n    //     .map(x => x)\n    //\n    // In order to detect those cases, we use an heuristic: if the first\n    // node is an identifier with the name starting with a capital\n    // letter or just a sequence of _$. The rationale is that they are\n    // likely to be factories.\n\n\n    function isFactory(name) {\n      return /^[A-Z]|^[_$]+$/.test(name);\n    } // In case the Identifier is shorter than tab width, we can keep the\n    // first call in a single line, if it's an ExpressionStatement.\n    //\n    //   d3.scaleLinear()\n    //     .domain([0, 100])\n    //     .range([0, width]);\n    //\n\n\n    function isShort(name) {\n      return name.length <= options.tabWidth;\n    }\n\n    function shouldNotWrap(groups) {\n      var parent = path.getParentNode();\n      var isExpression = parent && parent.type === \"ExpressionStatement\";\n      var hasComputed = groups[1].length && groups[1][0].node.computed;\n\n      if (groups[0].length === 1) {\n        var firstNode = groups[0][0].node;\n        return firstNode.type === \"ThisExpression\" || firstNode.type === \"Identifier\" && (isFactory(firstNode.name) || isExpression && isShort(firstNode.name) || hasComputed);\n      }\n\n      var lastNode = getLast$2(groups[0]).node;\n      return (lastNode.type === \"MemberExpression\" || lastNode.type === \"OptionalMemberExpression\") && lastNode.property.type === \"Identifier\" && (isFactory(lastNode.property.name) || hasComputed);\n    }\n\n    var shouldMerge = groups.length >= 2 && !groups[1][0].node.comments && shouldNotWrap(groups);\n\n    function printGroup(printedGroup) {\n      var printed = printedGroup.map(function (tuple) {\n        return tuple.printed;\n      }); // Checks if the last node (i.e. the parent node) needs parens and print\n      // accordingly\n\n      if (printedGroup.length > 0 && printedGroup[printedGroup.length - 1].needsParens) {\n        return concat$d([\"(\"].concat(_toConsumableArray(printed), [\")\"]));\n      }\n\n      return concat$d(printed);\n    }\n\n    function printIndentedGroup(groups) {\n      if (groups.length === 0) {\n        return \"\";\n      }\n\n      return indent$7(group$b(concat$d([hardline$9, join$9(hardline$9, groups.map(printGroup))])));\n    }\n\n    var printedGroups = groups.map(printGroup);\n    var oneLine = concat$d(printedGroups);\n    var cutoff = shouldMerge ? 3 : 2;\n    var flatGroups = groups.slice(0, cutoff).reduce(function (res, group) {\n      return res.concat(group);\n    }, []);\n    var hasComment = flatGroups.slice(1, -1).some(function (node) {\n      return hasLeadingComment$3(node.node);\n    }) || flatGroups.slice(0, -1).some(function (node) {\n      return hasTrailingComment$1(node.node);\n    }) || groups[cutoff] && hasLeadingComment$3(groups[cutoff][0].node); // If we only have a single `.`, we shouldn't do anything fancy and just\n    // render everything concatenated together.\n\n    if (groups.length <= cutoff && !hasComment) {\n      if (isLongCurriedCallExpression$1(path)) {\n        return oneLine;\n      }\n\n      return group$b(oneLine);\n    } // Find out the last node in the first group and check if it has an\n    // empty line after\n\n\n    var lastNodeBeforeIndent = getLast$2(shouldMerge ? groups.slice(1, 2)[0] : groups[0]).node;\n    var shouldHaveEmptyLineBeforeIndent = lastNodeBeforeIndent.type !== \"CallExpression\" && lastNodeBeforeIndent.type !== \"OptionalCallExpression\" && shouldInsertEmptyLineAfter(lastNodeBeforeIndent);\n    var expanded = concat$d([printGroup(groups[0]), shouldMerge ? concat$d(groups.slice(1, 2).map(printGroup)) : \"\", shouldHaveEmptyLineBeforeIndent ? hardline$9 : \"\", printIndentedGroup(groups.slice(shouldMerge ? 2 : 1))]);\n    var callExpressions = printedNodes.map(function (_ref) {\n      var node = _ref.node;\n      return node;\n    }).filter(isCallOrOptionalCallExpression$1); // We don't want to print in one line if there's:\n    //  * A comment.\n    //  * 3 or more chained calls.\n    //  * Any group but the last one has a hard line.\n    // If the last group is a function it's okay to inline if it fits.\n\n    if (hasComment || callExpressions.length >= 3 || printedGroups.slice(0, -1).some(willBreak$1) ||\n    /**\n     *     scopes.filter(scope => scope.value !== '').map((scope, i) => {\n     *       // multi line content\n     *     })\n     */\n    function (lastGroupDoc, lastGroupNode) {\n      return isCallOrOptionalCallExpression$1(lastGroupNode) && willBreak$1(lastGroupDoc);\n    }(getLast$2(printedGroups), getLast$2(getLast$2(groups)).node) && callExpressions.slice(0, -1).some(function (n) {\n      return n.arguments.some(isFunctionOrArrowExpression$1);\n    })) {\n      return group$b(expanded);\n    }\n\n    return concat$d([// We only need to check `oneLine` because if `expanded` is chosen\n    // that means that the parent group has already been broken\n    // naturally\n    willBreak$1(oneLine) || shouldHaveEmptyLineBeforeIndent ? breakParent$3 : \"\", conditionalGroup$1([oneLine, expanded])]);\n  }\n\n  function separatorNoWhitespace(isFacebookTranslationTag, child, childNode, nextNode) {\n    if (isFacebookTranslationTag) {\n      return \"\";\n    }\n\n    if (childNode.type === \"JSXElement\" && !childNode.closingElement || nextNode && nextNode.type === \"JSXElement\" && !nextNode.closingElement) {\n      return child.length === 1 ? softline$6 : hardline$9;\n    }\n\n    return softline$6;\n  }\n\n  function separatorWithWhitespace(isFacebookTranslationTag, child, childNode, nextNode) {\n    if (isFacebookTranslationTag) {\n      return hardline$9;\n    }\n\n    if (child.length === 1) {\n      return childNode.type === \"JSXElement\" && !childNode.closingElement || nextNode && nextNode.type === \"JSXElement\" && !nextNode.closingElement ? hardline$9 : softline$6;\n    }\n\n    return hardline$9;\n  } // JSX Children are strange, mostly for two reasons:\n  // 1. JSX reads newlines into string values, instead of skipping them like JS\n  // 2. up to one whitespace between elements within a line is significant,\n  //    but not between lines.\n  //\n  // Leading, trailing, and lone whitespace all need to\n  // turn themselves into the rather ugly `{' '}` when breaking.\n  //\n  // We print JSX using the `fill` doc primitive.\n  // This requires that we give it an array of alternating\n  // content and whitespace elements.\n  // To ensure this we add dummy `\"\"` content elements as needed.\n\n\n  function printJSXChildren(path, options, print, jsxWhitespace, isFacebookTranslationTag) {\n    var n = path.getValue();\n    var children = []; // using `map` instead of `each` because it provides `i`\n\n    path.map(function (childPath, i) {\n      var child = childPath.getValue();\n\n      if (isLiteral$1(child)) {\n        var text = rawText$1(child); // Contains a non-whitespace character\n\n        if (isMeaningfulJSXText$1(child)) {\n          var words = text.split(matchJsxWhitespaceRegex$1); // Starts with whitespace\n\n          if (words[0] === \"\") {\n            children.push(\"\");\n            words.shift();\n\n            if (/\\n/.test(words[0])) {\n              var next = n.children[i + 1];\n              children.push(separatorWithWhitespace(isFacebookTranslationTag, words[1], child, next));\n            } else {\n              children.push(jsxWhitespace);\n            }\n\n            words.shift();\n          }\n\n          var endWhitespace; // Ends with whitespace\n\n          if (getLast$2(words) === \"\") {\n            words.pop();\n            endWhitespace = words.pop();\n          } // This was whitespace only without a new line.\n\n\n          if (words.length === 0) {\n            return;\n          }\n\n          words.forEach(function (word, i) {\n            if (i % 2 === 1) {\n              children.push(line$7);\n            } else {\n              children.push(word);\n            }\n          });\n\n          if (endWhitespace !== undefined) {\n            if (/\\n/.test(endWhitespace)) {\n              var _next = n.children[i + 1];\n              children.push(separatorWithWhitespace(isFacebookTranslationTag, getLast$2(children), child, _next));\n            } else {\n              children.push(jsxWhitespace);\n            }\n          } else {\n            var _next2 = n.children[i + 1];\n            children.push(separatorNoWhitespace(isFacebookTranslationTag, getLast$2(children), child, _next2));\n          }\n        } else if (/\\n/.test(text)) {\n          // Keep (up to one) blank line between tags/expressions/text.\n          // Note: We don't keep blank lines between text elements.\n          if (text.match(/\\n/g).length > 1) {\n            children.push(\"\");\n            children.push(hardline$9);\n          }\n        } else {\n          children.push(\"\");\n          children.push(jsxWhitespace);\n        }\n      } else {\n        var printedChild = print(childPath);\n        children.push(printedChild);\n        var _next3 = n.children[i + 1];\n\n        var directlyFollowedByMeaningfulText = _next3 && isMeaningfulJSXText$1(_next3);\n\n        if (directlyFollowedByMeaningfulText) {\n          var firstWord = rawText$1(_next3).trim().split(matchJsxWhitespaceRegex$1)[0];\n          children.push(separatorNoWhitespace(isFacebookTranslationTag, firstWord, child, _next3));\n        } else {\n          children.push(hardline$9);\n        }\n      }\n    }, \"children\");\n    return children;\n  } // JSX expands children from the inside-out, instead of the outside-in.\n  // This is both to break children before attributes,\n  // and to ensure that when children break, their parents do as well.\n  //\n  // Any element that is written without any newlines and fits on a single line\n  // is left that way.\n  // Not only that, any user-written-line containing multiple JSX siblings\n  // should also be kept on one line if possible,\n  // so each user-written-line is wrapped in its own group.\n  //\n  // Elements that contain newlines or don't fit on a single line (recursively)\n  // are fully-split, using hardline and shouldBreak: true.\n  //\n  // To support that case properly, all leading and trailing spaces\n  // are stripped from the list of children, and replaced with a single hardline.\n\n\n  function printJSXElement(path, options, print) {\n    var n = path.getValue();\n\n    if (n.type === \"JSXElement\" && isEmptyJSXElement$1(n)) {\n      return concat$d([path.call(print, \"openingElement\"), path.call(print, \"closingElement\")]);\n    }\n\n    var openingLines = n.type === \"JSXElement\" ? path.call(print, \"openingElement\") : path.call(print, \"openingFragment\");\n    var closingLines = n.type === \"JSXElement\" ? path.call(print, \"closingElement\") : path.call(print, \"closingFragment\");\n\n    if (n.children.length === 1 && n.children[0].type === \"JSXExpressionContainer\" && (n.children[0].expression.type === \"TemplateLiteral\" || n.children[0].expression.type === \"TaggedTemplateExpression\")) {\n      return concat$d([openingLines, concat$d(path.map(print, \"children\")), closingLines]);\n    } // Convert `{\" \"}` to text nodes containing a space.\n    // This makes it easy to turn them into `jsxWhitespace` which\n    // can then print as either a space or `{\" \"}` when breaking.\n\n\n    n.children = n.children.map(function (child) {\n      if (isJSXWhitespaceExpression$1(child)) {\n        return {\n          type: \"JSXText\",\n          value: \" \",\n          raw: \" \"\n        };\n      }\n\n      return child;\n    });\n    var containsTag = n.children.filter(isJSXNode$1).length > 0;\n    var containsMultipleExpressions = n.children.filter(function (child) {\n      return child.type === \"JSXExpressionContainer\";\n    }).length > 1;\n    var containsMultipleAttributes = n.type === \"JSXElement\" && n.openingElement.attributes.length > 1; // Record any breaks. Should never go from true to false, only false to true.\n\n    var forcedBreak = willBreak$1(openingLines) || containsTag || containsMultipleAttributes || containsMultipleExpressions;\n    var rawJsxWhitespace = options.singleQuote ? \"{' '}\" : '{\" \"}';\n    var jsxWhitespace = ifBreak$6(concat$d([rawJsxWhitespace, softline$6]), \" \");\n    var isFacebookTranslationTag = n.openingElement && n.openingElement.name && n.openingElement.name.name === \"fbt\";\n    var children = printJSXChildren(path, options, print, jsxWhitespace, isFacebookTranslationTag);\n    var containsText = n.children.filter(function (child) {\n      return isMeaningfulJSXText$1(child);\n    }).length > 0; // We can end up we multiple whitespace elements with empty string\n    // content between them.\n    // We need to remove empty whitespace and softlines before JSX whitespace\n    // to get the correct output.\n\n    for (var i = children.length - 2; i >= 0; i--) {\n      var isPairOfEmptyStrings = children[i] === \"\" && children[i + 1] === \"\";\n      var isPairOfHardlines = children[i] === hardline$9 && children[i + 1] === \"\" && children[i + 2] === hardline$9;\n      var isLineFollowedByJSXWhitespace = (children[i] === softline$6 || children[i] === hardline$9) && children[i + 1] === \"\" && children[i + 2] === jsxWhitespace;\n      var isJSXWhitespaceFollowedByLine = children[i] === jsxWhitespace && children[i + 1] === \"\" && (children[i + 2] === softline$6 || children[i + 2] === hardline$9);\n      var isDoubleJSXWhitespace = children[i] === jsxWhitespace && children[i + 1] === \"\" && children[i + 2] === jsxWhitespace;\n      var isPairOfHardOrSoftLines = children[i] === softline$6 && children[i + 1] === \"\" && children[i + 2] === hardline$9 || children[i] === hardline$9 && children[i + 1] === \"\" && children[i + 2] === softline$6;\n\n      if (isPairOfHardlines && containsText || isPairOfEmptyStrings || isLineFollowedByJSXWhitespace || isDoubleJSXWhitespace || isPairOfHardOrSoftLines) {\n        children.splice(i, 2);\n      } else if (isJSXWhitespaceFollowedByLine) {\n        children.splice(i + 1, 2);\n      }\n    } // Trim trailing lines (or empty strings)\n\n\n    while (children.length && (isLineNext$1(getLast$2(children)) || isEmpty$1(getLast$2(children)))) {\n      children.pop();\n    } // Trim leading lines (or empty strings)\n\n\n    while (children.length && (isLineNext$1(children[0]) || isEmpty$1(children[0])) && (isLineNext$1(children[1]) || isEmpty$1(children[1]))) {\n      children.shift();\n      children.shift();\n    } // Tweak how we format children if outputting this element over multiple lines.\n    // Also detect whether we will force this element to output over multiple lines.\n\n\n    var multilineChildren = [];\n    children.forEach(function (child, i) {\n      // There are a number of situations where we need to ensure we display\n      // whitespace as `{\" \"}` when outputting this element over multiple lines.\n      if (child === jsxWhitespace) {\n        if (i === 1 && children[i - 1] === \"\") {\n          if (children.length === 2) {\n            // Solitary whitespace\n            multilineChildren.push(rawJsxWhitespace);\n            return;\n          } // Leading whitespace\n\n\n          multilineChildren.push(concat$d([rawJsxWhitespace, hardline$9]));\n          return;\n        } else if (i === children.length - 1) {\n          // Trailing whitespace\n          multilineChildren.push(rawJsxWhitespace);\n          return;\n        } else if (children[i - 1] === \"\" && children[i - 2] === hardline$9) {\n          // Whitespace after line break\n          multilineChildren.push(rawJsxWhitespace);\n          return;\n        }\n      }\n\n      multilineChildren.push(child);\n\n      if (willBreak$1(child)) {\n        forcedBreak = true;\n      }\n    }); // If there is text we use `fill` to fit as much onto each line as possible.\n    // When there is no text (just tags and expressions) we use `group`\n    // to output each on a separate line.\n\n    var content = containsText ? fill$4(multilineChildren) : group$b(concat$d(multilineChildren), {\n      shouldBreak: true\n    });\n    var multiLineElem = group$b(concat$d([openingLines, indent$7(concat$d([hardline$9, content])), hardline$9, closingLines]));\n\n    if (forcedBreak) {\n      return multiLineElem;\n    }\n\n    return conditionalGroup$1([group$b(concat$d([openingLines, concat$d(children), closingLines])), multiLineElem]);\n  }\n\n  function maybeWrapJSXElementInParens(path, elem, options) {\n    var parent = path.getParentNode();\n\n    if (!parent) {\n      return elem;\n    }\n\n    var NO_WRAP_PARENTS = {\n      ArrayExpression: true,\n      JSXAttribute: true,\n      JSXElement: true,\n      JSXExpressionContainer: true,\n      JSXFragment: true,\n      ExpressionStatement: true,\n      CallExpression: true,\n      OptionalCallExpression: true,\n      ConditionalExpression: true,\n      JsExpressionRoot: true\n    };\n\n    if (NO_WRAP_PARENTS[parent.type]) {\n      return elem;\n    }\n\n    var shouldBreak = matchAncestorTypes$1(path, [\"ArrowFunctionExpression\", \"CallExpression\", \"JSXExpressionContainer\"]) || matchAncestorTypes$1(path, [\"ArrowFunctionExpression\", \"OptionalCallExpression\", \"JSXExpressionContainer\"]);\n    var needsParens = needsParens_1(path, options);\n    return group$b(concat$d([needsParens ? \"\" : ifBreak$6(\"(\"), indent$7(concat$d([softline$6, elem])), softline$6, needsParens ? \"\" : ifBreak$6(\")\")]), {\n      shouldBreak: shouldBreak\n    });\n  }\n\n  function shouldInlineLogicalExpression(node) {\n    if (node.type !== \"LogicalExpression\") {\n      return false;\n    }\n\n    if (node.right.type === \"ObjectExpression\" && node.right.properties.length !== 0) {\n      return true;\n    }\n\n    if (node.right.type === \"ArrayExpression\" && node.right.elements.length !== 0) {\n      return true;\n    }\n\n    if (isJSXNode$1(node.right)) {\n      return true;\n    }\n\n    return false;\n  } // For binary expressions to be consistent, we need to group\n  // subsequent operators with the same precedence level under a single\n  // group. Otherwise they will be nested such that some of them break\n  // onto new lines but not all. Operators with the same precedence\n  // level should either all break or not. Because we group them by\n  // precedence level and the AST is structured based on precedence\n  // level, things are naturally broken up correctly, i.e. `&&` is\n  // broken before `+`.\n\n\n  function printBinaryishExpressions(path, print, options, isNested, isInsideParenthesis) {\n    var parts = [];\n    var node = path.getValue(); // We treat BinaryExpression and LogicalExpression nodes the same.\n\n    if (isBinaryish$1(node)) {\n      // Put all operators with the same precedence level in the same\n      // group. The reason we only need to do this with the `left`\n      // expression is because given an expression like `1 + 2 - 3`, it\n      // is always parsed like `((1 + 2) - 3)`, meaning the `left` side\n      // is where the rest of the expression will exist. Binary\n      // expressions on the right side mean they have a difference\n      // precedence level and should be treated as a separate group, so\n      // print them normally. (This doesn't hold for the `**` operator,\n      // which is unique in that it is right-associative.)\n      if (shouldFlatten$1(node.operator, node.left.operator)) {\n        // Flatten them out by recursively calling this function.\n        parts = parts.concat(path.call(function (left) {\n          return printBinaryishExpressions(left, print, options,\n          /* isNested */\n          true, isInsideParenthesis);\n        }, \"left\"));\n      } else {\n        parts.push(path.call(print, \"left\"));\n      }\n\n      var shouldInline = shouldInlineLogicalExpression(node);\n      var lineBeforeOperator = (node.operator === \"|>\" || node.type === \"NGPipeExpression\" || node.operator === \"|\" && options.parser === \"__vue_expression\") && !hasLeadingOwnLineComment$1(options.originalText, node.right, options);\n      var operator = node.type === \"NGPipeExpression\" ? \"|\" : node.operator;\n      var rightSuffix = node.type === \"NGPipeExpression\" && node.arguments.length !== 0 ? group$b(indent$7(concat$d([softline$6, \": \", join$9(concat$d([softline$6, \":\", ifBreak$6(\" \")]), path.map(print, \"arguments\").map(function (arg) {\n        return align$1(2, group$b(arg));\n      }))]))) : \"\";\n      var right = shouldInline ? concat$d([operator, \" \", path.call(print, \"right\"), rightSuffix]) : concat$d([lineBeforeOperator ? softline$6 : \"\", operator, lineBeforeOperator ? \" \" : line$7, path.call(print, \"right\"), rightSuffix]); // If there's only a single binary expression, we want to create a group\n      // in order to avoid having a small right part like -1 be on its own line.\n\n      var parent = path.getParentNode();\n      var shouldGroup = !(isInsideParenthesis && node.type === \"LogicalExpression\") && parent.type !== node.type && node.left.type !== node.type && node.right.type !== node.type;\n      parts.push(\" \", shouldGroup ? group$b(right) : right); // The root comments are already printed, but we need to manually print\n      // the other ones since we don't call the normal print on BinaryExpression,\n      // only for the left and right parts\n\n      if (isNested && node.comments) {\n        parts = comments.printComments(path, function () {\n          return concat$d(parts);\n        }, options);\n      }\n    } else {\n      // Our stopping case. Simply print the node normally.\n      parts.push(path.call(print));\n    }\n\n    return parts;\n  }\n\n  function printAssignmentRight(leftNode, rightNode, printedRight, options) {\n    if (hasLeadingOwnLineComment$1(options.originalText, rightNode, options)) {\n      return indent$7(concat$d([hardline$9, printedRight]));\n    }\n\n    var canBreak = isBinaryish$1(rightNode) && !shouldInlineLogicalExpression(rightNode) || rightNode.type === \"ConditionalExpression\" && isBinaryish$1(rightNode.test) && !shouldInlineLogicalExpression(rightNode.test) || rightNode.type === \"StringLiteralTypeAnnotation\" || rightNode.type === \"ClassExpression\" && rightNode.decorators && rightNode.decorators.length || (leftNode.type === \"Identifier\" || isStringLiteral$1(leftNode) || leftNode.type === \"MemberExpression\") && (isStringLiteral$1(rightNode) || isMemberExpressionChain$1(rightNode)) && // do not put values on a separate line from the key in json\n    options.parser !== \"json\" && options.parser !== \"json5\" || rightNode.type === \"SequenceExpression\";\n\n    if (canBreak) {\n      return group$b(indent$7(concat$d([line$7, printedRight])));\n    }\n\n    return concat$d([\" \", printedRight]);\n  }\n\n  function printAssignment(leftNode, printedLeft, operator, rightNode, printedRight, options) {\n    if (!rightNode) {\n      return printedLeft;\n    }\n\n    var printed = printAssignmentRight(leftNode, rightNode, printedRight, options);\n    return group$b(concat$d([printedLeft, operator, printed]));\n  }\n\n  function adjustClause(node, clause, forceSpace) {\n    if (node.type === \"EmptyStatement\") {\n      return \";\";\n    }\n\n    if (node.type === \"BlockStatement\" || forceSpace) {\n      return concat$d([\" \", clause]);\n    }\n\n    return indent$7(concat$d([line$7, clause]));\n  }\n\n  function nodeStr(node, options, isFlowOrTypeScriptDirectiveLiteral) {\n    var raw = rawText$1(node);\n    var isDirectiveLiteral = isFlowOrTypeScriptDirectiveLiteral || node.type === \"DirectiveLiteral\";\n    return printString$2(raw, options, isDirectiveLiteral);\n  }\n\n  function printRegex(node) {\n    var flags = node.flags.split(\"\").sort().join(\"\");\n    return \"/\".concat(node.pattern, \"/\").concat(flags);\n  }\n\n  function exprNeedsASIProtection(path, options) {\n    var node = path.getValue();\n    var maybeASIProblem = needsParens_1(path, options) || node.type === \"ParenthesizedExpression\" || node.type === \"TypeCastExpression\" || node.type === \"ArrowFunctionExpression\" && !shouldPrintParamsWithoutParens(path, options) || node.type === \"ArrayExpression\" || node.type === \"ArrayPattern\" || node.type === \"UnaryExpression\" && node.prefix && (node.operator === \"+\" || node.operator === \"-\") || node.type === \"TemplateLiteral\" || node.type === \"TemplateElement\" || isJSXNode$1(node) || node.type === \"BindExpression\" && !node.object || node.type === \"RegExpLiteral\" || node.type === \"Literal\" && node.pattern || node.type === \"Literal\" && node.regex;\n\n    if (maybeASIProblem) {\n      return true;\n    }\n\n    if (!hasNakedLeftSide$2(node)) {\n      return false;\n    }\n\n    return path.call.apply(path, [function (childPath) {\n      return exprNeedsASIProtection(childPath, options);\n    }].concat(getLeftSidePathName$2(path, node)));\n  }\n\n  function stmtNeedsASIProtection(path, options) {\n    var node = path.getNode();\n\n    if (node.type !== \"ExpressionStatement\") {\n      return false;\n    }\n\n    return path.call(function (childPath) {\n      return exprNeedsASIProtection(childPath, options);\n    }, \"expression\");\n  }\n\n  function shouldHugType(node) {\n    if (isSimpleFlowType$1(node) || isObjectType$1(node)) {\n      return true;\n    }\n\n    if (node.type === \"UnionTypeAnnotation\" || node.type === \"TSUnionType\") {\n      var voidCount = node.types.filter(function (n) {\n        return n.type === \"VoidTypeAnnotation\" || n.type === \"TSVoidKeyword\" || n.type === \"NullLiteralTypeAnnotation\" || n.type === \"TSNullKeyword\";\n      }).length;\n      var objectCount = node.types.filter(function (n) {\n        return n.type === \"ObjectTypeAnnotation\" || n.type === \"TSTypeLiteral\" || // This is a bit aggressive but captures Array<{x}>\n        n.type === \"GenericTypeAnnotation\" || n.type === \"TSTypeReference\";\n      }).length;\n\n      if (node.types.length - 1 === voidCount && objectCount > 0) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function shouldHugArguments(fun) {\n    return fun && fun.params && fun.params.length === 1 && !fun.params[0].comments && (fun.params[0].type === \"ObjectPattern\" || fun.params[0].type === \"ArrayPattern\" || fun.params[0].type === \"Identifier\" && fun.params[0].typeAnnotation && (fun.params[0].typeAnnotation.type === \"TypeAnnotation\" || fun.params[0].typeAnnotation.type === \"TSTypeAnnotation\") && isObjectType$1(fun.params[0].typeAnnotation.typeAnnotation) || fun.params[0].type === \"FunctionTypeParam\" && isObjectType$1(fun.params[0].typeAnnotation) || fun.params[0].type === \"AssignmentPattern\" && (fun.params[0].left.type === \"ObjectPattern\" || fun.params[0].left.type === \"ArrayPattern\") && (fun.params[0].right.type === \"Identifier\" || fun.params[0].right.type === \"ObjectExpression\" && fun.params[0].right.properties.length === 0 || fun.params[0].right.type === \"ArrayExpression\" && fun.params[0].right.elements.length === 0)) && !fun.rest;\n  }\n\n  function printArrayItems(path, options, printPath, print) {\n    var printedElements = [];\n    var separatorParts = [];\n    path.each(function (childPath) {\n      printedElements.push(concat$d(separatorParts));\n      printedElements.push(group$b(print(childPath)));\n      separatorParts = [\",\", line$7];\n\n      if (childPath.getValue() && isNextLineEmpty$4(options.originalText, childPath.getValue(), options)) {\n        separatorParts.push(softline$6);\n      }\n    }, printPath);\n    return concat$d(printedElements);\n  }\n\n  function willPrintOwnComments(path\n  /*, options */\n  ) {\n    var node = path.getValue();\n    var parent = path.getParentNode();\n    return (node && (isJSXNode$1(node) || hasFlowShorthandAnnotationComment$2(node) || parent && (parent.type === \"CallExpression\" || parent.type === \"OptionalCallExpression\") && (hasFlowAnnotationComment$1(node.leadingComments) || hasFlowAnnotationComment$1(node.trailingComments))) || parent && (parent.type === \"JSXSpreadAttribute\" || parent.type === \"JSXSpreadChild\" || parent.type === \"UnionTypeAnnotation\" || parent.type === \"TSUnionType\" || (parent.type === \"ClassDeclaration\" || parent.type === \"ClassExpression\") && parent.superClass === node)) && !hasIgnoreComment$4(path);\n  }\n\n  function canAttachComment$1(node) {\n    return node.type && node.type !== \"CommentBlock\" && node.type !== \"CommentLine\" && node.type !== \"Line\" && node.type !== \"Block\" && node.type !== \"EmptyStatement\" && node.type !== \"TemplateElement\" && node.type !== \"Import\";\n  }\n\n  function printComment$2(commentPath, options) {\n    var comment = commentPath.getValue();\n\n    switch (comment.type) {\n      case \"CommentBlock\":\n      case \"Block\":\n        {\n          if (isIndentableBlockComment(comment)) {\n            var printed = printIndentableBlockComment(comment); // We need to prevent an edge case of a previous trailing comment\n            // printed as a `lineSuffix` which causes the comments to be\n            // interleaved. See https://github.com/prettier/prettier/issues/4412\n\n            if (comment.trailing && !hasNewline$4(options.originalText, options.locStart(comment), {\n              backwards: true\n            })) {\n              return concat$d([hardline$9, printed]);\n            }\n\n            return printed;\n          }\n\n          var isInsideFlowComment = options.originalText.substr(options.locEnd(comment) - 3, 3) === \"*-/\";\n          return \"/*\" + comment.value + (isInsideFlowComment ? \"*-/\" : \"*/\");\n        }\n\n      case \"CommentLine\":\n      case \"Line\":\n        // Print shebangs with the proper comment characters\n        if (options.originalText.slice(options.locStart(comment)).startsWith(\"#!\")) {\n          return \"#!\" + comment.value.trimRight();\n        }\n\n        return \"//\" + comment.value.trimRight();\n\n      default:\n        throw new Error(\"Not a comment: \" + JSON.stringify(comment));\n    }\n  }\n\n  function isIndentableBlockComment(comment) {\n    // If the comment has multiple lines and every line starts with a star\n    // we can fix the indentation of each line. The stars in the `/*` and\n    // `*/` delimiters are not included in the comment value, so add them\n    // back first.\n    var lines = \"*\".concat(comment.value, \"*\").split(\"\\n\");\n    return lines.length > 1 && lines.every(function (line) {\n      return line.trim()[0] === \"*\";\n    });\n  }\n\n  function printIndentableBlockComment(comment) {\n    var lines = comment.value.split(\"\\n\");\n    return concat$d([\"/*\", join$9(hardline$9, lines.map(function (line, index) {\n      return index === 0 ? line.trimRight() : \" \" + (index < lines.length - 1 ? line.trim() : line.trimLeft());\n    })), \"*/\"]);\n  }\n\n  var printerEstree = {\n    preprocess: preprocess_1$1,\n    print: genericPrint$3,\n    embed: embed_1$1,\n    insertPragma: insertPragma$7,\n    massageAstNode: clean_1$1,\n    hasPrettierIgnore: hasPrettierIgnore$3,\n    willPrintOwnComments: willPrintOwnComments,\n    canAttachComment: canAttachComment$1,\n    printComment: printComment$2,\n    isBlockComment: comments$1.isBlockComment,\n    handleComments: {\n      ownLine: comments$1.handleOwnLineComment,\n      endOfLine: comments$1.handleEndOfLineComment,\n      remaining: comments$1.handleRemainingComment\n    }\n  };\n\n  var _require$$0$builders$7 = doc.builders,\n      concat$e = _require$$0$builders$7.concat,\n      hardline$a = _require$$0$builders$7.hardline,\n      indent$8 = _require$$0$builders$7.indent,\n      join$a = _require$$0$builders$7.join;\n\n  function genericPrint$4(path, options, print) {\n    var node = path.getValue();\n\n    switch (node.type) {\n      case \"JsonRoot\":\n        return concat$e([path.call(print, \"node\"), hardline$a]);\n\n      case \"ArrayExpression\":\n        return node.elements.length === 0 ? \"[]\" : concat$e([\"[\", indent$8(concat$e([hardline$a, join$a(concat$e([\",\", hardline$a]), path.map(print, \"elements\"))])), hardline$a, \"]\"]);\n\n      case \"ObjectExpression\":\n        return node.properties.length === 0 ? \"{}\" : concat$e([\"{\", indent$8(concat$e([hardline$a, join$a(concat$e([\",\", hardline$a]), path.map(print, \"properties\"))])), hardline$a, \"}\"]);\n\n      case \"ObjectProperty\":\n        return concat$e([path.call(print, \"key\"), \": \", path.call(print, \"value\")]);\n\n      case \"UnaryExpression\":\n        return concat$e([node.operator === \"+\" ? \"\" : node.operator, path.call(print, \"argument\")]);\n\n      case \"NullLiteral\":\n        return \"null\";\n\n      case \"BooleanLiteral\":\n        return node.value ? \"true\" : \"false\";\n\n      case \"StringLiteral\":\n      case \"NumericLiteral\":\n        return JSON.stringify(node.value);\n\n      case \"Identifier\":\n        return JSON.stringify(node.name);\n\n      default:\n        /* istanbul ignore next */\n        throw new Error(\"unknown type: \" + JSON.stringify(node.type));\n    }\n  }\n\n  function clean$5(node, newNode\n  /*, parent*/\n  ) {\n    delete newNode.start;\n    delete newNode.end;\n    delete newNode.extra;\n    delete newNode.loc;\n    delete newNode.comments;\n    delete newNode.errors;\n\n    if (node.type === \"Identifier\") {\n      return {\n        type: \"StringLiteral\",\n        value: node.name\n      };\n    }\n\n    if (node.type === \"UnaryExpression\" && node.operator === \"+\") {\n      return newNode.argument;\n    }\n  }\n\n  var printerEstreeJson = {\n    preprocess: preprocess_1$1,\n    print: genericPrint$4,\n    massageAstNode: clean$5\n  };\n\n  var CATEGORY_JAVASCRIPT = \"JavaScript\"; // format based on https://github.com/prettier/prettier/blob/master/src/main/core-options.js\n\n  var options$5 = {\n    arrowParens: {\n      since: \"1.9.0\",\n      category: CATEGORY_JAVASCRIPT,\n      type: \"choice\",\n      default: \"avoid\",\n      description: \"Include parentheses around a sole arrow function parameter.\",\n      choices: [{\n        value: \"avoid\",\n        description: \"Omit parens when possible. Example: `x => x`\"\n      }, {\n        value: \"always\",\n        description: \"Always include parens. Example: `(x) => x`\"\n      }]\n    },\n    bracketSpacing: commonOptions.bracketSpacing,\n    jsxBracketSameLine: {\n      since: \"0.17.0\",\n      category: CATEGORY_JAVASCRIPT,\n      type: \"boolean\",\n      default: false,\n      description: \"Put > on the last line instead of at a new line.\"\n    },\n    semi: {\n      since: \"1.0.0\",\n      category: CATEGORY_JAVASCRIPT,\n      type: \"boolean\",\n      default: true,\n      description: \"Print semicolons.\",\n      oppositeDescription: \"Do not print semicolons, except at the beginning of lines which may need them.\"\n    },\n    singleQuote: commonOptions.singleQuote,\n    jsxSingleQuote: {\n      since: \"1.15.0\",\n      category: CATEGORY_JAVASCRIPT,\n      type: \"boolean\",\n      default: false,\n      description: \"Use single quotes in JSX.\"\n    },\n    quoteProps: {\n      since: \"1.17.0\",\n      category: CATEGORY_JAVASCRIPT,\n      type: \"choice\",\n      default: \"as-needed\",\n      description: \"Change when properties in objects are quoted.\",\n      choices: [{\n        value: \"as-needed\",\n        description: \"Only add quotes around object properties where required.\"\n      }, {\n        value: \"consistent\",\n        description: \"If at least one property in an object requires quotes, quote all properties.\"\n      }, {\n        value: \"preserve\",\n        description: \"Respect the input use of quotes in object properties.\"\n      }]\n    },\n    trailingComma: {\n      since: \"0.0.0\",\n      category: CATEGORY_JAVASCRIPT,\n      type: \"choice\",\n      default: [{\n        since: \"0.0.0\",\n        value: false\n      }, {\n        since: \"0.19.0\",\n        value: \"none\"\n      }],\n      description: \"Print trailing commas wherever possible when multi-line.\",\n      choices: [{\n        value: \"none\",\n        description: \"No trailing commas.\"\n      }, {\n        value: \"es5\",\n        description: \"Trailing commas where valid in ES5 (objects, arrays, etc.)\"\n      }, {\n        value: \"all\",\n        description: \"Trailing commas wherever possible (including function arguments).\"\n      }, {\n        value: true,\n        deprecated: \"0.19.0\",\n        redirect: \"es5\"\n      }, {\n        value: false,\n        deprecated: \"0.19.0\",\n        redirect: \"none\"\n      }]\n    }\n  };\n\n  var name$9 = \"JavaScript\";\n  var type$8 = \"programming\";\n  var tmScope$8 = \"source.js\";\n  var aceMode$8 = \"javascript\";\n  var codemirrorMode$4 = \"javascript\";\n  var codemirrorMimeType$4 = \"text/javascript\";\n  var color$3 = \"#f1e05a\";\n  var aliases$2 = [\n  \t\"js\",\n  \t\"node\"\n  ];\n  var extensions$8 = [\n  \t\".js\",\n  \t\"._js\",\n  \t\".bones\",\n  \t\".es\",\n  \t\".es6\",\n  \t\".frag\",\n  \t\".gs\",\n  \t\".jake\",\n  \t\".jsb\",\n  \t\".jscad\",\n  \t\".jsfl\",\n  \t\".jsm\",\n  \t\".jss\",\n  \t\".mjs\",\n  \t\".njs\",\n  \t\".pac\",\n  \t\".sjs\",\n  \t\".ssjs\",\n  \t\".xsjs\",\n  \t\".xsjslib\"\n  ];\n  var filenames = [\n  \t\"Jakefile\"\n  ];\n  var interpreters = [\n  \t\"chakra\",\n  \t\"d8\",\n  \t\"js\",\n  \t\"node\",\n  \t\"rhino\",\n  \t\"v8\",\n  \t\"v8-shell\"\n  ];\n  var languageId$8 = 183;\n  var JavaScript = {\n  \tname: name$9,\n  \ttype: type$8,\n  \ttmScope: tmScope$8,\n  \taceMode: aceMode$8,\n  \tcodemirrorMode: codemirrorMode$4,\n  \tcodemirrorMimeType: codemirrorMimeType$4,\n  \tcolor: color$3,\n  \taliases: aliases$2,\n  \textensions: extensions$8,\n  \tfilenames: filenames,\n  \tinterpreters: interpreters,\n  \tlanguageId: languageId$8\n  };\n\n  var JavaScript$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    name: name$9,\n    type: type$8,\n    tmScope: tmScope$8,\n    aceMode: aceMode$8,\n    codemirrorMode: codemirrorMode$4,\n    codemirrorMimeType: codemirrorMimeType$4,\n    color: color$3,\n    aliases: aliases$2,\n    extensions: extensions$8,\n    filenames: filenames,\n    interpreters: interpreters,\n    languageId: languageId$8,\n    'default': JavaScript\n  });\n\n  var name$a = \"JSX\";\n  var type$9 = \"programming\";\n  var group$c = \"JavaScript\";\n  var extensions$9 = [\n  \t\".jsx\"\n  ];\n  var tmScope$9 = \"source.js.jsx\";\n  var aceMode$9 = \"javascript\";\n  var codemirrorMode$5 = \"jsx\";\n  var codemirrorMimeType$5 = \"text/jsx\";\n  var languageId$9 = 178;\n  var JSX = {\n  \tname: name$a,\n  \ttype: type$9,\n  \tgroup: group$c,\n  \textensions: extensions$9,\n  \ttmScope: tmScope$9,\n  \taceMode: aceMode$9,\n  \tcodemirrorMode: codemirrorMode$5,\n  \tcodemirrorMimeType: codemirrorMimeType$5,\n  \tlanguageId: languageId$9\n  };\n\n  var JSX$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    name: name$a,\n    type: type$9,\n    group: group$c,\n    extensions: extensions$9,\n    tmScope: tmScope$9,\n    aceMode: aceMode$9,\n    codemirrorMode: codemirrorMode$5,\n    codemirrorMimeType: codemirrorMimeType$5,\n    languageId: languageId$9,\n    'default': JSX\n  });\n\n  var name$b = \"TypeScript\";\n  var type$a = \"programming\";\n  var color$4 = \"#2b7489\";\n  var aliases$3 = [\n  \t\"ts\"\n  ];\n  var interpreters$1 = [\n  \t\"deno\",\n  \t\"ts-node\"\n  ];\n  var extensions$a = [\n  \t\".ts\"\n  ];\n  var tmScope$a = \"source.ts\";\n  var aceMode$a = \"typescript\";\n  var codemirrorMode$6 = \"javascript\";\n  var codemirrorMimeType$6 = \"application/typescript\";\n  var languageId$a = 378;\n  var TypeScript = {\n  \tname: name$b,\n  \ttype: type$a,\n  \tcolor: color$4,\n  \taliases: aliases$3,\n  \tinterpreters: interpreters$1,\n  \textensions: extensions$a,\n  \ttmScope: tmScope$a,\n  \taceMode: aceMode$a,\n  \tcodemirrorMode: codemirrorMode$6,\n  \tcodemirrorMimeType: codemirrorMimeType$6,\n  \tlanguageId: languageId$a\n  };\n\n  var TypeScript$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    name: name$b,\n    type: type$a,\n    color: color$4,\n    aliases: aliases$3,\n    interpreters: interpreters$1,\n    extensions: extensions$a,\n    tmScope: tmScope$a,\n    aceMode: aceMode$a,\n    codemirrorMode: codemirrorMode$6,\n    codemirrorMimeType: codemirrorMimeType$6,\n    languageId: languageId$a,\n    'default': TypeScript\n  });\n\n  var name$c = \"TSX\";\n  var type$b = \"programming\";\n  var group$d = \"TypeScript\";\n  var extensions$b = [\n  \t\".tsx\"\n  ];\n  var tmScope$b = \"source.tsx\";\n  var aceMode$b = \"javascript\";\n  var codemirrorMode$7 = \"jsx\";\n  var codemirrorMimeType$7 = \"text/jsx\";\n  var languageId$b = 94901924;\n  var TSX = {\n  \tname: name$c,\n  \ttype: type$b,\n  \tgroup: group$d,\n  \textensions: extensions$b,\n  \ttmScope: tmScope$b,\n  \taceMode: aceMode$b,\n  \tcodemirrorMode: codemirrorMode$7,\n  \tcodemirrorMimeType: codemirrorMimeType$7,\n  \tlanguageId: languageId$b\n  };\n\n  var TSX$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    name: name$c,\n    type: type$b,\n    group: group$d,\n    extensions: extensions$b,\n    tmScope: tmScope$b,\n    aceMode: aceMode$b,\n    codemirrorMode: codemirrorMode$7,\n    codemirrorMimeType: codemirrorMimeType$7,\n    languageId: languageId$b,\n    'default': TSX\n  });\n\n  var name$d = \"JSON\";\n  var type$c = \"data\";\n  var tmScope$c = \"source.json\";\n  var aceMode$c = \"json\";\n  var codemirrorMode$8 = \"javascript\";\n  var codemirrorMimeType$8 = \"application/json\";\n  var searchable = false;\n  var extensions$c = [\n  \t\".json\",\n  \t\".avsc\",\n  \t\".geojson\",\n  \t\".gltf\",\n  \t\".har\",\n  \t\".ice\",\n  \t\".JSON-tmLanguage\",\n  \t\".jsonl\",\n  \t\".mcmeta\",\n  \t\".tfstate\",\n  \t\".tfstate.backup\",\n  \t\".topojson\",\n  \t\".webapp\",\n  \t\".webmanifest\",\n  \t\".yy\",\n  \t\".yyp\"\n  ];\n  var filenames$1 = [\n  \t\".arcconfig\",\n  \t\".htmlhintrc\",\n  \t\".tern-config\",\n  \t\".tern-project\",\n  \t\".watchmanconfig\",\n  \t\"composer.lock\",\n  \t\"mcmod.info\"\n  ];\n  var languageId$c = 174;\n  var _JSON = {\n  \tname: name$d,\n  \ttype: type$c,\n  \ttmScope: tmScope$c,\n  \taceMode: aceMode$c,\n  \tcodemirrorMode: codemirrorMode$8,\n  \tcodemirrorMimeType: codemirrorMimeType$8,\n  \tsearchable: searchable,\n  \textensions: extensions$c,\n  \tfilenames: filenames$1,\n  \tlanguageId: languageId$c\n  };\n\n  var _JSON$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    name: name$d,\n    type: type$c,\n    tmScope: tmScope$c,\n    aceMode: aceMode$c,\n    codemirrorMode: codemirrorMode$8,\n    codemirrorMimeType: codemirrorMimeType$8,\n    searchable: searchable,\n    extensions: extensions$c,\n    filenames: filenames$1,\n    languageId: languageId$c,\n    'default': _JSON\n  });\n\n  var name$e = \"JSON with Comments\";\n  var type$d = \"data\";\n  var group$e = \"JSON\";\n  var tmScope$d = \"source.js\";\n  var aceMode$d = \"javascript\";\n  var codemirrorMode$9 = \"javascript\";\n  var codemirrorMimeType$9 = \"text/javascript\";\n  var aliases$4 = [\n  \t\"jsonc\"\n  ];\n  var extensions$d = [\n  \t\".sublime-build\",\n  \t\".sublime-commands\",\n  \t\".sublime-completions\",\n  \t\".sublime-keymap\",\n  \t\".sublime-macro\",\n  \t\".sublime-menu\",\n  \t\".sublime-mousemap\",\n  \t\".sublime-project\",\n  \t\".sublime-settings\",\n  \t\".sublime-theme\",\n  \t\".sublime-workspace\",\n  \t\".sublime_metrics\",\n  \t\".sublime_session\"\n  ];\n  var filenames$2 = [\n  \t\".babelrc\",\n  \t\".eslintrc.json\",\n  \t\".jscsrc\",\n  \t\".jshintrc\",\n  \t\".jslintrc\",\n  \t\"jsconfig.json\",\n  \t\"language-configuration.json\",\n  \t\"tsconfig.json\"\n  ];\n  var languageId$d = 423;\n  var JSON_with_Comments = {\n  \tname: name$e,\n  \ttype: type$d,\n  \tgroup: group$e,\n  \ttmScope: tmScope$d,\n  \taceMode: aceMode$d,\n  \tcodemirrorMode: codemirrorMode$9,\n  \tcodemirrorMimeType: codemirrorMimeType$9,\n  \taliases: aliases$4,\n  \textensions: extensions$d,\n  \tfilenames: filenames$2,\n  \tlanguageId: languageId$d\n  };\n\n  var JSON_with_Comments$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    name: name$e,\n    type: type$d,\n    group: group$e,\n    tmScope: tmScope$d,\n    aceMode: aceMode$d,\n    codemirrorMode: codemirrorMode$9,\n    codemirrorMimeType: codemirrorMimeType$9,\n    aliases: aliases$4,\n    extensions: extensions$d,\n    filenames: filenames$2,\n    languageId: languageId$d,\n    'default': JSON_with_Comments\n  });\n\n  var name$f = \"JSON5\";\n  var type$e = \"data\";\n  var extensions$e = [\n  \t\".json5\"\n  ];\n  var tmScope$e = \"source.js\";\n  var aceMode$e = \"javascript\";\n  var codemirrorMode$a = \"javascript\";\n  var codemirrorMimeType$a = \"application/json\";\n  var languageId$e = 175;\n  var JSON5 = {\n  \tname: name$f,\n  \ttype: type$e,\n  \textensions: extensions$e,\n  \ttmScope: tmScope$e,\n  \taceMode: aceMode$e,\n  \tcodemirrorMode: codemirrorMode$a,\n  \tcodemirrorMimeType: codemirrorMimeType$a,\n  \tlanguageId: languageId$e\n  };\n\n  var JSON5$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    name: name$f,\n    type: type$e,\n    extensions: extensions$e,\n    tmScope: tmScope$e,\n    aceMode: aceMode$e,\n    codemirrorMode: codemirrorMode$a,\n    codemirrorMimeType: codemirrorMimeType$a,\n    languageId: languageId$e,\n    'default': JSON5\n  });\n\n  var require$$0$6 = getCjsExportFromNamespace(JavaScript$1);\n\n  var require$$1$2 = getCjsExportFromNamespace(JSX$1);\n\n  var require$$2$1 = getCjsExportFromNamespace(TypeScript$1);\n\n  var require$$3$1 = getCjsExportFromNamespace(TSX$1);\n\n  var require$$4 = getCjsExportFromNamespace(_JSON$1);\n\n  var require$$5 = getCjsExportFromNamespace(JSON_with_Comments$1);\n\n  var require$$6 = getCjsExportFromNamespace(JSON5$1);\n\n  var languages$4 = [createLanguage(require$$0$6, function (data) {\n    return Object.assign(data, {\n      since: \"0.0.0\",\n      parsers: [\"babel\", \"flow\"],\n      vscodeLanguageIds: [\"javascript\", \"mongo\"],\n      interpreters: data.interpreters.concat([\"nodejs\"])\n    });\n  }), createLanguage(require$$0$6, function (data) {\n    return Object.assign(data, {\n      name: \"Flow\",\n      since: \"0.0.0\",\n      parsers: [\"babel\", \"flow\"],\n      vscodeLanguageIds: [\"javascript\"],\n      aliases: [],\n      filenames: [],\n      extensions: [\".js.flow\"]\n    });\n  }), createLanguage(require$$1$2, function (data) {\n    return Object.assign(data, {\n      since: \"0.0.0\",\n      parsers: [\"babel\", \"flow\"],\n      vscodeLanguageIds: [\"javascriptreact\"]\n    });\n  }), createLanguage(require$$2$1, function (data) {\n    return Object.assign(data, {\n      since: \"1.4.0\",\n      parsers: [\"typescript\"],\n      vscodeLanguageIds: [\"typescript\"]\n    });\n  }), createLanguage(require$$3$1, function (data) {\n    return Object.assign(data, {\n      since: \"1.4.0\",\n      parsers: [\"typescript\"],\n      vscodeLanguageIds: [\"typescriptreact\"]\n    });\n  }), createLanguage(require$$4, function (data) {\n    return Object.assign(data, {\n      name: \"JSON.stringify\",\n      since: \"1.13.0\",\n      parsers: [\"json-stringify\"],\n      vscodeLanguageIds: [\"json\"],\n      extensions: [],\n      // .json file defaults to json instead of json-stringify\n      filenames: [\"package.json\", \"package-lock.json\", \"composer.json\"]\n    });\n  }), createLanguage(require$$4, function (data) {\n    return Object.assign(data, {\n      since: \"1.5.0\",\n      parsers: [\"json\"],\n      vscodeLanguageIds: [\"json\"],\n      filenames: data.filenames.concat([\".prettierrc\"])\n    });\n  }), createLanguage(require$$5, function (data) {\n    return Object.assign(data, {\n      since: \"1.5.0\",\n      parsers: [\"json\"],\n      vscodeLanguageIds: [\"jsonc\"],\n      filenames: data.filenames.concat([\".eslintrc\"])\n    });\n  }), createLanguage(require$$6, function (data) {\n    return Object.assign(data, {\n      since: \"1.13.0\",\n      parsers: [\"json5\"],\n      vscodeLanguageIds: [\"json5\"]\n    });\n  })];\n  var printers$4 = {\n    estree: printerEstree,\n    \"estree-json\": printerEstreeJson\n  };\n  var languageJs = {\n    languages: languages$4,\n    options: options$5,\n    printers: printers$4\n  };\n\n  var json$1 = {\n    \"cjkPattern\": \"[\\\\u02ea-\\\\u02eb\\\\u1100-\\\\u11ff\\\\u2e80-\\\\u2e99\\\\u2e9b-\\\\u2ef3\\\\u2f00-\\\\u2fd5\\\\u3000-\\\\u303f\\\\u3041-\\\\u3096\\\\u3099-\\\\u309f\\\\u30a1-\\\\u30fa\\\\u30fc-\\\\u30ff\\\\u3105-\\\\u312f\\\\u3131-\\\\u318e\\\\u3190-\\\\u3191\\\\u3196-\\\\u31ba\\\\u31c0-\\\\u31e3\\\\u31f0-\\\\u321e\\\\u322a-\\\\u3247\\\\u3260-\\\\u327e\\\\u328a-\\\\u32b0\\\\u32c0-\\\\u32cb\\\\u32d0-\\\\u3370\\\\u337b-\\\\u337f\\\\u33e0-\\\\u33fe\\\\u3400-\\\\u4db5\\\\u4e00-\\\\u9fef\\\\ua960-\\\\ua97c\\\\uac00-\\\\ud7a3\\\\ud7b0-\\\\ud7c6\\\\ud7cb-\\\\ud7fb\\\\uf900-\\\\ufa6d\\\\ufa70-\\\\ufad9\\\\ufe10-\\\\ufe1f\\\\ufe30-\\\\ufe6f\\\\uff00-\\\\uffef]|[\\\\ud840-\\\\ud868\\\\ud86a-\\\\ud86c\\\\ud86f-\\\\ud872\\\\ud874-\\\\ud879][\\\\udc00-\\\\udfff]|\\\\ud82c[\\\\udc00-\\\\udd1e\\\\udd50-\\\\udd52\\\\udd64-\\\\udd67]|\\\\ud83c[\\\\ude00\\\\ude50-\\\\ude51]|\\\\ud869[\\\\udc00-\\\\uded6\\\\udf00-\\\\udfff]|\\\\ud86d[\\\\udc00-\\\\udf34\\\\udf40-\\\\udfff]|\\\\ud86e[\\\\udc00-\\\\udc1d\\\\udc20-\\\\udfff]|\\\\ud873[\\\\udc00-\\\\udea1\\\\udeb0-\\\\udfff]|\\\\ud87a[\\\\udc00-\\\\udfe0]|\\\\ud87e[\\\\udc00-\\\\ude1d]\",\n    \"kPattern\": \"[\\\\u1100-\\\\u11ff\\\\u3001-\\\\u3003\\\\u3008-\\\\u3011\\\\u3013-\\\\u301f\\\\u302e-\\\\u3030\\\\u3037\\\\u30fb\\\\u3131-\\\\u318e\\\\u3200-\\\\u321e\\\\u3260-\\\\u327e\\\\ua960-\\\\ua97c\\\\uac00-\\\\ud7a3\\\\ud7b0-\\\\ud7c6\\\\ud7cb-\\\\ud7fb\\\\ufe45-\\\\ufe46\\\\uff61-\\\\uff65\\\\uffa0-\\\\uffbe\\\\uffc2-\\\\uffc7\\\\uffca-\\\\uffcf\\\\uffd2-\\\\uffd7\\\\uffda-\\\\uffdc]\",\n    \"punctuationPattern\": \"[\\\\u0021-\\\\u002f\\\\u003a-\\\\u0040\\\\u005b-\\\\u0060\\\\u007b-\\\\u007e\\\\u00a1\\\\u00a7\\\\u00ab\\\\u00b6-\\\\u00b7\\\\u00bb\\\\u00bf\\\\u037e\\\\u0387\\\\u055a-\\\\u055f\\\\u0589-\\\\u058a\\\\u05be\\\\u05c0\\\\u05c3\\\\u05c6\\\\u05f3-\\\\u05f4\\\\u0609-\\\\u060a\\\\u060c-\\\\u060d\\\\u061b\\\\u061e-\\\\u061f\\\\u066a-\\\\u066d\\\\u06d4\\\\u0700-\\\\u070d\\\\u07f7-\\\\u07f9\\\\u0830-\\\\u083e\\\\u085e\\\\u0964-\\\\u0965\\\\u0970\\\\u09fd\\\\u0a76\\\\u0af0\\\\u0c77\\\\u0c84\\\\u0df4\\\\u0e4f\\\\u0e5a-\\\\u0e5b\\\\u0f04-\\\\u0f12\\\\u0f14\\\\u0f3a-\\\\u0f3d\\\\u0f85\\\\u0fd0-\\\\u0fd4\\\\u0fd9-\\\\u0fda\\\\u104a-\\\\u104f\\\\u10fb\\\\u1360-\\\\u1368\\\\u1400\\\\u166e\\\\u169b-\\\\u169c\\\\u16eb-\\\\u16ed\\\\u1735-\\\\u1736\\\\u17d4-\\\\u17d6\\\\u17d8-\\\\u17da\\\\u1800-\\\\u180a\\\\u1944-\\\\u1945\\\\u1a1e-\\\\u1a1f\\\\u1aa0-\\\\u1aa6\\\\u1aa8-\\\\u1aad\\\\u1b5a-\\\\u1b60\\\\u1bfc-\\\\u1bff\\\\u1c3b-\\\\u1c3f\\\\u1c7e-\\\\u1c7f\\\\u1cc0-\\\\u1cc7\\\\u1cd3\\\\u2010-\\\\u2027\\\\u2030-\\\\u2043\\\\u2045-\\\\u2051\\\\u2053-\\\\u205e\\\\u207d-\\\\u207e\\\\u208d-\\\\u208e\\\\u2308-\\\\u230b\\\\u2329-\\\\u232a\\\\u2768-\\\\u2775\\\\u27c5-\\\\u27c6\\\\u27e6-\\\\u27ef\\\\u2983-\\\\u2998\\\\u29d8-\\\\u29db\\\\u29fc-\\\\u29fd\\\\u2cf9-\\\\u2cfc\\\\u2cfe-\\\\u2cff\\\\u2d70\\\\u2e00-\\\\u2e2e\\\\u2e30-\\\\u2e4f\\\\u3001-\\\\u3003\\\\u3008-\\\\u3011\\\\u3014-\\\\u301f\\\\u3030\\\\u303d\\\\u30a0\\\\u30fb\\\\ua4fe-\\\\ua4ff\\\\ua60d-\\\\ua60f\\\\ua673\\\\ua67e\\\\ua6f2-\\\\ua6f7\\\\ua874-\\\\ua877\\\\ua8ce-\\\\ua8cf\\\\ua8f8-\\\\ua8fa\\\\ua8fc\\\\ua92e-\\\\ua92f\\\\ua95f\\\\ua9c1-\\\\ua9cd\\\\ua9de-\\\\ua9df\\\\uaa5c-\\\\uaa5f\\\\uaade-\\\\uaadf\\\\uaaf0-\\\\uaaf1\\\\uabeb\\\\ufd3e-\\\\ufd3f\\\\ufe10-\\\\ufe19\\\\ufe30-\\\\ufe52\\\\ufe54-\\\\ufe61\\\\ufe63\\\\ufe68\\\\ufe6a-\\\\ufe6b\\\\uff01-\\\\uff03\\\\uff05-\\\\uff0a\\\\uff0c-\\\\uff0f\\\\uff1a-\\\\uff1b\\\\uff1f-\\\\uff20\\\\uff3b-\\\\uff3d\\\\uff3f\\\\uff5b\\\\uff5d\\\\uff5f-\\\\uff65]|\\\\ud800[\\\\udd00-\\\\udd02\\\\udf9f\\\\udfd0]|\\\\ud801[\\\\udd6f]|\\\\ud802[\\\\udc57\\\\udd1f\\\\udd3f\\\\ude50-\\\\ude58\\\\ude7f\\\\udef0-\\\\udef6\\\\udf39-\\\\udf3f\\\\udf99-\\\\udf9c]|\\\\ud803[\\\\udf55-\\\\udf59]|\\\\ud804[\\\\udc47-\\\\udc4d\\\\udcbb-\\\\udcbc\\\\udcbe-\\\\udcc1\\\\udd40-\\\\udd43\\\\udd74-\\\\udd75\\\\uddc5-\\\\uddc8\\\\uddcd\\\\udddb\\\\udddd-\\\\udddf\\\\ude38-\\\\ude3d\\\\udea9]|\\\\ud805[\\\\udc4b-\\\\udc4f\\\\udc5b\\\\udc5d\\\\udcc6\\\\uddc1-\\\\uddd7\\\\ude41-\\\\ude43\\\\ude60-\\\\ude6c\\\\udf3c-\\\\udf3e]|\\\\ud806[\\\\udc3b\\\\udde2\\\\ude3f-\\\\ude46\\\\ude9a-\\\\ude9c\\\\ude9e-\\\\udea2]|\\\\ud807[\\\\udc41-\\\\udc45\\\\udc70-\\\\udc71\\\\udef7-\\\\udef8\\\\udfff]|\\\\ud809[\\\\udc70-\\\\udc74]|\\\\ud81a[\\\\ude6e-\\\\ude6f\\\\udef5\\\\udf37-\\\\udf3b\\\\udf44]|\\\\ud81b[\\\\ude97-\\\\ude9a\\\\udfe2]|\\\\ud82f[\\\\udc9f]|\\\\ud836[\\\\ude87-\\\\ude8b]|\\\\ud83a[\\\\udd5e-\\\\udd5f]\"\n  };\n\n  var cjkPattern = json$1.cjkPattern,\n      kPattern = json$1.kPattern,\n      punctuationPattern = json$1.punctuationPattern;\n  var getLast$3 = util.getLast;\n  var INLINE_NODE_TYPES = [\"liquidNode\", \"inlineCode\", \"emphasis\", \"strong\", \"delete\", \"link\", \"linkReference\", \"image\", \"imageReference\", \"footnote\", \"footnoteReference\", \"sentence\", \"whitespace\", \"word\", \"break\", \"inlineMath\"];\n  var INLINE_NODE_WRAPPER_TYPES = INLINE_NODE_TYPES.concat([\"tableCell\", \"paragraph\", \"heading\"]);\n  var kRegex = new RegExp(kPattern);\n  var punctuationRegex = new RegExp(punctuationPattern);\n  /**\n   * split text into whitespaces and words\n   * @param {string} text\n   * @return {Array<{ type: \"whitespace\", value: \" \" | \"\\n\" | \"\" } | { type: \"word\", value: string }>}\n   */\n\n  function splitText(text, options) {\n    var KIND_NON_CJK = \"non-cjk\";\n    var KIND_CJ_LETTER = \"cj-letter\";\n    var KIND_K_LETTER = \"k-letter\";\n    var KIND_CJK_PUNCTUATION = \"cjk-punctuation\";\n    var nodes = [];\n    (options.proseWrap === \"preserve\" ? text : text.replace(new RegExp(\"(\".concat(cjkPattern, \")\\n(\").concat(cjkPattern, \")\"), \"g\"), \"$1$2\")).split(/([ \\t\\n]+)/).forEach(function (token, index, tokens) {\n      // whitespace\n      if (index % 2 === 1) {\n        nodes.push({\n          type: \"whitespace\",\n          value: /\\n/.test(token) ? \"\\n\" : \" \"\n        });\n        return;\n      } // word separated by whitespace\n\n\n      if ((index === 0 || index === tokens.length - 1) && token === \"\") {\n        return;\n      }\n\n      token.split(new RegExp(\"(\".concat(cjkPattern, \")\"))).forEach(function (innerToken, innerIndex, innerTokens) {\n        if ((innerIndex === 0 || innerIndex === innerTokens.length - 1) && innerToken === \"\") {\n          return;\n        } // non-CJK word\n\n\n        if (innerIndex % 2 === 0) {\n          if (innerToken !== \"\") {\n            appendNode({\n              type: \"word\",\n              value: innerToken,\n              kind: KIND_NON_CJK,\n              hasLeadingPunctuation: punctuationRegex.test(innerToken[0]),\n              hasTrailingPunctuation: punctuationRegex.test(getLast$3(innerToken))\n            });\n          }\n\n          return;\n        } // CJK character\n\n\n        appendNode(punctuationRegex.test(innerToken) ? {\n          type: \"word\",\n          value: innerToken,\n          kind: KIND_CJK_PUNCTUATION,\n          hasLeadingPunctuation: true,\n          hasTrailingPunctuation: true\n        } : {\n          type: \"word\",\n          value: innerToken,\n          kind: kRegex.test(innerToken) ? KIND_K_LETTER : KIND_CJ_LETTER,\n          hasLeadingPunctuation: false,\n          hasTrailingPunctuation: false\n        });\n      });\n    });\n    return nodes;\n\n    function appendNode(node) {\n      var lastNode = getLast$3(nodes);\n\n      if (lastNode && lastNode.type === \"word\") {\n        if (lastNode.kind === KIND_NON_CJK && node.kind === KIND_CJ_LETTER && !lastNode.hasTrailingPunctuation || lastNode.kind === KIND_CJ_LETTER && node.kind === KIND_NON_CJK && !node.hasLeadingPunctuation) {\n          nodes.push({\n            type: \"whitespace\",\n            value: \" \"\n          });\n        } else if (!isBetween(KIND_NON_CJK, KIND_CJK_PUNCTUATION) && // disallow leading/trailing full-width whitespace\n        ![lastNode.value, node.value].some(function (value) {\n          return /\\u3000/.test(value);\n        })) {\n          nodes.push({\n            type: \"whitespace\",\n            value: \"\"\n          });\n        }\n      }\n\n      nodes.push(node);\n\n      function isBetween(kind1, kind2) {\n        return lastNode.kind === kind1 && node.kind === kind2 || lastNode.kind === kind2 && node.kind === kind1;\n      }\n    }\n  }\n\n  function getOrderedListItemInfo(orderListItem, originalText) {\n    var _originalText$slice$m = originalText.slice(orderListItem.position.start.offset, orderListItem.position.end.offset).match(/^\\s*(\\d+)(\\.|\\))(\\s*)/),\n        _originalText$slice$m2 = _slicedToArray(_originalText$slice$m, 4),\n        numberText = _originalText$slice$m2[1],\n        marker = _originalText$slice$m2[2],\n        leadingSpaces = _originalText$slice$m2[3];\n\n    return {\n      numberText: numberText,\n      marker: marker,\n      leadingSpaces: leadingSpaces\n    };\n  } // workaround for https://github.com/remarkjs/remark/issues/351\n  // leading and trailing newlines are stripped by remark\n\n\n  function getFencedCodeBlockValue(node, originalText) {\n    var text = originalText.slice(node.position.start.offset, node.position.end.offset);\n    var leadingSpaceCount = text.match(/^\\s*/)[0].length;\n    var replaceRegex = new RegExp(\"^\\\\s{0,\".concat(leadingSpaceCount, \"}\"));\n    var lineContents = text.split(\"\\n\");\n    var markerStyle = text[leadingSpaceCount]; // ` or ~\n\n    var marker = text.slice(leadingSpaceCount).match(new RegExp(\"^[\".concat(markerStyle, \"]+\")))[0]; // https://spec.commonmark.org/0.28/#example-104: Closing fences may be indented by 0-3 spaces\n    // https://spec.commonmark.org/0.28/#example-93: The closing code fence must be at least as long as the opening fence\n\n    var hasEndMarker = new RegExp(\"^\\\\s{0,3}\".concat(marker)).test(lineContents[lineContents.length - 1].slice(getIndent(lineContents.length - 1)));\n    return lineContents.slice(1, hasEndMarker ? -1 : undefined).map(function (x, i) {\n      return x.slice(getIndent(i + 1)).replace(replaceRegex, \"\");\n    }).join(\"\\n\");\n\n    function getIndent(lineIndex) {\n      return node.position.indent[lineIndex - 1] - 1;\n    }\n  }\n\n  function mapAst(ast, handler) {\n    return function preorder(node, index, parentStack) {\n      parentStack = parentStack || [];\n      var newNode = handler(node, index, parentStack);\n\n      if (Array.isArray(newNode)) {\n        return newNode;\n      }\n\n      newNode = Object.assign({}, newNode);\n\n      if (newNode.children) {\n        newNode.children = newNode.children.reduce(function (nodes, child, index) {\n          var newNodes = preorder(child, index, [newNode].concat(parentStack));\n\n          if (!Array.isArray(newNodes)) {\n            newNodes = [newNodes];\n          }\n\n          nodes.push.apply(nodes, newNodes);\n          return nodes;\n        }, []);\n      }\n\n      return newNode;\n    }(ast, null, null);\n  }\n\n  var utils$5 = {\n    mapAst: mapAst,\n    splitText: splitText,\n    punctuationPattern: punctuationPattern,\n    getFencedCodeBlockValue: getFencedCodeBlockValue,\n    getOrderedListItemInfo: getOrderedListItemInfo,\n    INLINE_NODE_TYPES: INLINE_NODE_TYPES,\n    INLINE_NODE_WRAPPER_TYPES: INLINE_NODE_WRAPPER_TYPES\n  };\n\n  var _require$$0$builders$8 = doc.builders,\n      hardline$b = _require$$0$builders$8.hardline,\n      literalline$5 = _require$$0$builders$8.literalline,\n      concat$f = _require$$0$builders$8.concat,\n      markAsRoot$3 = _require$$0$builders$8.markAsRoot,\n      mapDoc$6 = doc.utils.mapDoc;\n  var getFencedCodeBlockValue$1 = utils$5.getFencedCodeBlockValue;\n\n  function embed$4(path, print, textToDoc, options) {\n    var node = path.getValue();\n\n    if (node.type === \"code\" && node.lang !== null) {\n      // only look for the first string so as to support [markdown-preview-enhanced](https://shd101wyy.github.io/markdown-preview-enhanced/#/code-chunk)\n      var langMatch = node.lang.match(/^[A-Za-z0-9_-]+/);\n      var lang = langMatch ? langMatch[0] : \"\";\n      var parser = getParserName(lang);\n\n      if (parser) {\n        var styleUnit = options.__inJsTemplate ? \"~\" : \"`\";\n        var style = styleUnit.repeat(Math.max(3, util.getMaxContinuousCount(node.value, styleUnit) + 1));\n        var doc = textToDoc(getFencedCodeBlockValue$1(node, options.originalText), {\n          parser: parser\n        });\n        return markAsRoot$3(concat$f([style, node.lang, hardline$b, replaceNewlinesWithLiterallines(doc), style]));\n      }\n    }\n\n    if (node.type === \"yaml\") {\n      return markAsRoot$3(concat$f([\"---\", hardline$b, node.value && node.value.trim() ? replaceNewlinesWithLiterallines(textToDoc(node.value, {\n        parser: \"yaml\"\n      })) : \"\", \"---\"]));\n    } // MDX\n\n\n    switch (node.type) {\n      case \"importExport\":\n        return textToDoc(node.value, {\n          parser: \"babel\"\n        });\n\n      case \"jsx\":\n        return textToDoc(node.value, {\n          parser: \"__js_expression\"\n        });\n    }\n\n    return null;\n\n    function getParserName(lang) {\n      var supportInfo = support.getSupportInfo(null, {\n        plugins: options.plugins\n      });\n      var language = supportInfo.languages.find(function (language) {\n        return language.name.toLowerCase() === lang || language.aliases && language.aliases.indexOf(lang) !== -1 || language.extensions && language.extensions.find(function (ext) {\n          return ext.substring(1) === lang;\n        });\n      });\n\n      if (language) {\n        return language.parsers[0];\n      }\n\n      return null;\n    }\n\n    function replaceNewlinesWithLiterallines(doc) {\n      return mapDoc$6(doc, function (currentDoc) {\n        return typeof currentDoc === \"string\" && currentDoc.includes(\"\\n\") ? concat$f(currentDoc.split(/(\\n)/g).map(function (v, i) {\n          return i % 2 === 0 ? v : literalline$5;\n        })) : currentDoc;\n      });\n    }\n  }\n\n  var embed_1$2 = embed$4;\n\n  var pragmas = [\"format\", \"prettier\"];\n\n  function startWithPragma(text) {\n    var pragma = \"@(\".concat(pragmas.join(\"|\"), \")\");\n    var regex = new RegExp([\"<!--\\\\s*\".concat(pragma, \"\\\\s*-->\"), \"<!--.*\\r?\\n[\\\\s\\\\S]*(^|\\n)[^\\\\S\\n]*\".concat(pragma, \"[^\\\\S\\n]*($|\\n)[\\\\s\\\\S]*\\n.*-->\")].join(\"|\"), \"m\");\n    var matched = text.match(regex);\n    return matched && matched.index === 0;\n  }\n\n  var pragma$4 = {\n    startWithPragma: startWithPragma,\n    hasPragma: function hasPragma(text) {\n      return startWithPragma(frontMatter(text).content.trimLeft());\n    },\n    insertPragma: function insertPragma(text) {\n      var extracted = frontMatter(text);\n      var pragma = \"<!-- @\".concat(pragmas[0], \" -->\");\n      return extracted.frontMatter ? \"\".concat(extracted.frontMatter.raw, \"\\n\\n\").concat(pragma, \"\\n\\n\").concat(extracted.content) : \"\".concat(pragma, \"\\n\\n\").concat(extracted.content);\n    }\n  };\n\n  var getOrderedListItemInfo$1 = utils$5.getOrderedListItemInfo,\n      mapAst$1 = utils$5.mapAst,\n      splitText$1 = utils$5.splitText; // 0x0 ~ 0x10ffff\n  // eslint-disable-next-line no-control-regex\n\n  var isSingleCharRegex = /^([\\u0000-\\uffff]|[\\ud800-\\udbff][\\udc00-\\udfff])$/;\n\n  function preprocess$2(ast, options) {\n    ast = restoreUnescapedCharacter(ast, options);\n    ast = mergeContinuousTexts(ast);\n    ast = transformInlineCode(ast);\n    ast = transformIndentedCodeblockAndMarkItsParentList(ast, options);\n    ast = markAlignedList(ast, options);\n    ast = splitTextIntoSentences(ast, options);\n    ast = transformImportExport(ast);\n    ast = mergeContinuousImportExport(ast);\n    return ast;\n  }\n\n  function transformImportExport(ast) {\n    return mapAst$1(ast, function (node) {\n      if (node.type !== \"import\" && node.type !== \"export\") {\n        return node;\n      }\n\n      return Object.assign({}, node, {\n        type: \"importExport\"\n      });\n    });\n  }\n\n  function transformInlineCode(ast) {\n    return mapAst$1(ast, function (node) {\n      if (node.type !== \"inlineCode\") {\n        return node;\n      }\n\n      return Object.assign({}, node, {\n        value: node.value.replace(/\\s+/g, \" \")\n      });\n    });\n  }\n\n  function restoreUnescapedCharacter(ast, options) {\n    return mapAst$1(ast, function (node) {\n      return node.type !== \"text\" ? node : Object.assign({}, node, {\n        value: node.value !== \"*\" && node.value !== \"_\" && node.value !== \"$\" && // handle these cases in printer\n        isSingleCharRegex.test(node.value) && node.position.end.offset - node.position.start.offset !== node.value.length ? options.originalText.slice(node.position.start.offset, node.position.end.offset) : node.value\n      });\n    });\n  }\n\n  function mergeContinuousImportExport(ast) {\n    return mergeChildren(ast, function (prevNode, node) {\n      return prevNode.type === \"importExport\" && node.type === \"importExport\";\n    }, function (prevNode, node) {\n      return {\n        type: \"importExport\",\n        value: prevNode.value + \"\\n\\n\" + node.value,\n        position: {\n          start: prevNode.position.start,\n          end: node.position.end\n        }\n      };\n    });\n  }\n\n  function mergeChildren(ast, shouldMerge, mergeNode) {\n    return mapAst$1(ast, function (node) {\n      if (!node.children) {\n        return node;\n      }\n\n      var children = node.children.reduce(function (current, child) {\n        var lastChild = current[current.length - 1];\n\n        if (lastChild && shouldMerge(lastChild, child)) {\n          current.splice(-1, 1, mergeNode(lastChild, child));\n        } else {\n          current.push(child);\n        }\n\n        return current;\n      }, []);\n      return Object.assign({}, node, {\n        children: children\n      });\n    });\n  }\n\n  function mergeContinuousTexts(ast) {\n    return mergeChildren(ast, function (prevNode, node) {\n      return prevNode.type === \"text\" && node.type === \"text\";\n    }, function (prevNode, node) {\n      return {\n        type: \"text\",\n        value: prevNode.value + node.value,\n        position: {\n          start: prevNode.position.start,\n          end: node.position.end\n        }\n      };\n    });\n  }\n\n  function splitTextIntoSentences(ast, options) {\n    return mapAst$1(ast, function (node, index, _ref) {\n      var _ref2 = _slicedToArray(_ref, 1),\n          parentNode = _ref2[0];\n\n      if (node.type !== \"text\") {\n        return node;\n      }\n\n      var value = node.value;\n\n      if (parentNode.type === \"paragraph\") {\n        if (index === 0) {\n          value = value.trimLeft();\n        }\n\n        if (index === parentNode.children.length - 1) {\n          value = value.trimRight();\n        }\n      }\n\n      return {\n        type: \"sentence\",\n        position: node.position,\n        children: splitText$1(value, options)\n      };\n    });\n  }\n\n  function transformIndentedCodeblockAndMarkItsParentList(ast, options) {\n    return mapAst$1(ast, function (node, index, parentStack) {\n      if (node.type === \"code\") {\n        // the first char may point to `\\n`, e.g. `\\n\\t\\tbar`, just ignore it\n        var isIndented = /^\\n?( {4,}|\\t)/.test(options.originalText.slice(node.position.start.offset, node.position.end.offset));\n        node.isIndented = isIndented;\n\n        if (isIndented) {\n          for (var i = 0; i < parentStack.length; i++) {\n            var parent = parentStack[i]; // no need to check checked items\n\n            if (parent.hasIndentedCodeblock) {\n              break;\n            }\n\n            if (parent.type === \"list\") {\n              parent.hasIndentedCodeblock = true;\n            }\n          }\n        }\n      }\n\n      return node;\n    });\n  }\n\n  function markAlignedList(ast, options) {\n    return mapAst$1(ast, function (node, index, parentStack) {\n      if (node.type === \"list\" && node.children.length !== 0) {\n        // if one of its parents is not aligned, it's not possible to be aligned in sub-lists\n        for (var i = 0; i < parentStack.length; i++) {\n          var parent = parentStack[i];\n\n          if (parent.type === \"list\" && !parent.isAligned) {\n            node.isAligned = false;\n            return node;\n          }\n        }\n\n        node.isAligned = isAligned(node);\n      }\n\n      return node;\n    });\n\n    function getListItemStart(listItem) {\n      return listItem.children.length === 0 ? -1 : listItem.children[0].position.start.column - 1;\n    }\n\n    function isAligned(list) {\n      if (!list.ordered) {\n        /**\n         * - 123\n         * - 123\n         */\n        return true;\n      }\n\n      var _list$children = _slicedToArray(list.children, 2),\n          firstItem = _list$children[0],\n          secondItem = _list$children[1];\n\n      var firstInfo = getOrderedListItemInfo$1(firstItem, options.originalText);\n\n      if (firstInfo.leadingSpaces.length > 1) {\n        /**\n         * 1.   123\n         *\n         * 1.   123\n         * 1. 123\n         */\n        return true;\n      }\n\n      var firstStart = getListItemStart(firstItem);\n\n      if (firstStart === -1) {\n        /**\n         * 1.\n         *\n         * 1.\n         * 1.\n         */\n        return false;\n      }\n\n      if (list.children.length === 1) {\n        /**\n         * aligned:\n         *\n         * 11. 123\n         *\n         * not aligned:\n         *\n         * 1. 123\n         */\n        return firstStart % options.tabWidth === 0;\n      }\n\n      var secondStart = getListItemStart(secondItem);\n\n      if (firstStart !== secondStart) {\n        /**\n         * 11. 123\n         * 1. 123\n         *\n         * 1. 123\n         * 11. 123\n         */\n        return false;\n      }\n\n      if (firstStart % options.tabWidth === 0) {\n        /**\n         * 11. 123\n         * 12. 123\n         */\n        return true;\n      }\n      /**\n       * aligned:\n       *\n       * 11. 123\n       * 1.  123\n       *\n       * not aligned:\n       *\n       * 1. 123\n       * 2. 123\n       */\n\n\n      var secondInfo = getOrderedListItemInfo$1(secondItem, options.originalText);\n      return secondInfo.leadingSpaces.length > 1;\n    }\n  }\n\n  var preprocess_1$2 = preprocess$2;\n\n  var _require$$0$builders$9 = doc.builders,\n      breakParent$4 = _require$$0$builders$9.breakParent,\n      concat$g = _require$$0$builders$9.concat,\n      join$b = _require$$0$builders$9.join,\n      line$8 = _require$$0$builders$9.line,\n      literalline$6 = _require$$0$builders$9.literalline,\n      markAsRoot$4 = _require$$0$builders$9.markAsRoot,\n      hardline$c = _require$$0$builders$9.hardline,\n      softline$7 = _require$$0$builders$9.softline,\n      ifBreak$7 = _require$$0$builders$9.ifBreak,\n      fill$5 = _require$$0$builders$9.fill,\n      align$2 = _require$$0$builders$9.align,\n      indent$9 = _require$$0$builders$9.indent,\n      group$f = _require$$0$builders$9.group,\n      mapDoc$7 = doc.utils.mapDoc,\n      printDocToString$2 = doc.printer.printDocToString;\n  var getFencedCodeBlockValue$2 = utils$5.getFencedCodeBlockValue,\n      getOrderedListItemInfo$2 = utils$5.getOrderedListItemInfo,\n      splitText$2 = utils$5.splitText,\n      punctuationPattern$1 = utils$5.punctuationPattern,\n      INLINE_NODE_TYPES$1 = utils$5.INLINE_NODE_TYPES,\n      INLINE_NODE_WRAPPER_TYPES$1 = utils$5.INLINE_NODE_WRAPPER_TYPES;\n  var replaceEndOfLineWith$2 = util.replaceEndOfLineWith;\n  var TRAILING_HARDLINE_NODES = [\"importExport\"];\n  var SINGLE_LINE_NODE_TYPES = [\"heading\", \"tableCell\", \"link\"];\n  var SIBLING_NODE_TYPES = [\"listItem\", \"definition\", \"footnoteDefinition\", \"jsx\"];\n\n  function genericPrint$5(path, options, print) {\n    var node = path.getValue();\n\n    if (shouldRemainTheSameContent(path)) {\n      return concat$g(splitText$2(options.originalText.slice(node.position.start.offset, node.position.end.offset), options).map(function (node) {\n        return node.type === \"word\" ? node.value : node.value === \"\" ? \"\" : printLine(path, node.value, options);\n      }));\n    }\n\n    switch (node.type) {\n      case \"root\":\n        if (node.children.length === 0) {\n          return \"\";\n        }\n\n        return concat$g([normalizeDoc(printRoot(path, options, print)), TRAILING_HARDLINE_NODES.indexOf(getLastDescendantNode(node).type) === -1 ? hardline$c : \"\"]);\n\n      case \"paragraph\":\n        return printChildren$2(path, options, print, {\n          postprocessor: fill$5\n        });\n\n      case \"sentence\":\n        return printChildren$2(path, options, print);\n\n      case \"word\":\n        return node.value.replace(/[*$]/g, \"\\\\$&\") // escape all `*` and `$` (math)\n        .replace(new RegExp([\"(^|\".concat(punctuationPattern$1, \")(_+)\"), \"(_+)(\".concat(punctuationPattern$1, \"|$)\")].join(\"|\"), \"g\"), function (_, text1, underscore1, underscore2, text2) {\n          return (underscore1 ? \"\".concat(text1).concat(underscore1) : \"\".concat(underscore2).concat(text2)).replace(/_/g, \"\\\\_\");\n        });\n      // escape all `_` except concating with non-punctuation, e.g. `1_2_3` is not considered emphasis\n\n      case \"whitespace\":\n        {\n          var parentNode = path.getParentNode();\n          var index = parentNode.children.indexOf(node);\n          var nextNode = parentNode.children[index + 1];\n          var proseWrap = // leading char that may cause different syntax\n          nextNode && /^>|^([-+*]|#{1,6}|[0-9]+[.)])$/.test(nextNode.value) ? \"never\" : options.proseWrap;\n          return printLine(path, node.value, {\n            proseWrap: proseWrap\n          });\n        }\n\n      case \"emphasis\":\n        {\n          var _parentNode = path.getParentNode();\n\n          var _index = _parentNode.children.indexOf(node);\n\n          var prevNode = _parentNode.children[_index - 1];\n          var _nextNode = _parentNode.children[_index + 1];\n          var hasPrevOrNextWord = // `1*2*3` is considered emphasis but `1_2_3` is not\n          prevNode && prevNode.type === \"sentence\" && prevNode.children.length > 0 && util.getLast(prevNode.children).type === \"word\" && !util.getLast(prevNode.children).hasTrailingPunctuation || _nextNode && _nextNode.type === \"sentence\" && _nextNode.children.length > 0 && _nextNode.children[0].type === \"word\" && !_nextNode.children[0].hasLeadingPunctuation;\n          var style = hasPrevOrNextWord || getAncestorNode$2(path, \"emphasis\") ? \"*\" : \"_\";\n          return concat$g([style, printChildren$2(path, options, print), style]);\n        }\n\n      case \"strong\":\n        return concat$g([\"**\", printChildren$2(path, options, print), \"**\"]);\n\n      case \"delete\":\n        return concat$g([\"~~\", printChildren$2(path, options, print), \"~~\"]);\n\n      case \"inlineCode\":\n        {\n          var backtickCount = util.getMinNotPresentContinuousCount(node.value, \"`\");\n\n          var _style = \"`\".repeat(backtickCount || 1);\n\n          var gap = backtickCount ? \" \" : \"\";\n          return concat$g([_style, gap, node.value, gap, _style]);\n        }\n\n      case \"link\":\n        switch (options.originalText[node.position.start.offset]) {\n          case \"<\":\n            {\n              var mailto = \"mailto:\";\n              var url = // <hello@example.com> is parsed as { url: \"mailto:hello@example.com\" }\n              node.url.startsWith(mailto) && options.originalText.slice(node.position.start.offset + 1, node.position.start.offset + 1 + mailto.length) !== mailto ? node.url.slice(mailto.length) : node.url;\n              return concat$g([\"<\", url, \">\"]);\n            }\n\n          case \"[\":\n            return concat$g([\"[\", printChildren$2(path, options, print), \"](\", printUrl(node.url, \")\"), printTitle(node.title, options), \")\"]);\n\n          default:\n            return options.originalText.slice(node.position.start.offset, node.position.end.offset);\n        }\n\n      case \"image\":\n        return concat$g([\"![\", node.alt || \"\", \"](\", printUrl(node.url, \")\"), printTitle(node.title, options), \")\"]);\n\n      case \"blockquote\":\n        return concat$g([\"> \", align$2(\"> \", printChildren$2(path, options, print))]);\n\n      case \"heading\":\n        return concat$g([\"#\".repeat(node.depth) + \" \", printChildren$2(path, options, print)]);\n\n      case \"code\":\n        {\n          if (node.isIndented) {\n            // indented code block\n            var alignment = \" \".repeat(4);\n            return align$2(alignment, concat$g([alignment, concat$g(replaceEndOfLineWith$2(node.value, hardline$c))]));\n          } // fenced code block\n\n\n          var styleUnit = options.__inJsTemplate ? \"~\" : \"`\";\n\n          var _style2 = styleUnit.repeat(Math.max(3, util.getMaxContinuousCount(node.value, styleUnit) + 1));\n\n          return concat$g([_style2, node.lang || \"\", hardline$c, concat$g(replaceEndOfLineWith$2(getFencedCodeBlockValue$2(node, options.originalText), hardline$c)), hardline$c, _style2]);\n        }\n\n      case \"yaml\":\n      case \"toml\":\n        return options.originalText.slice(node.position.start.offset, node.position.end.offset);\n\n      case \"html\":\n        {\n          var _parentNode2 = path.getParentNode();\n\n          var value = _parentNode2.type === \"root\" && util.getLast(_parentNode2.children) === node ? node.value.trimRight() : node.value;\n          var isHtmlComment = /^<!--[\\s\\S]*-->$/.test(value);\n          return concat$g(replaceEndOfLineWith$2(value, isHtmlComment ? hardline$c : markAsRoot$4(literalline$6)));\n        }\n\n      case \"list\":\n        {\n          var nthSiblingIndex = getNthListSiblingIndex(node, path.getParentNode());\n          var isGitDiffFriendlyOrderedList = node.ordered && node.children.length > 1 && +getOrderedListItemInfo$2(node.children[1], options.originalText).numberText === 1;\n          return printChildren$2(path, options, print, {\n            processor: function processor(childPath, index) {\n              var prefix = getPrefix();\n              return concat$g([prefix, align$2(\" \".repeat(prefix.length), printListItem(childPath, options, print, prefix))]);\n\n              function getPrefix() {\n                var rawPrefix = node.ordered ? (index === 0 ? node.start : isGitDiffFriendlyOrderedList ? 1 : node.start + index) + (nthSiblingIndex % 2 === 0 ? \". \" : \") \") : nthSiblingIndex % 2 === 0 ? \"- \" : \"* \";\n                return node.isAligned ||\n                /* workaround for https://github.com/remarkjs/remark/issues/315 */\n                node.hasIndentedCodeblock ? alignListPrefix(rawPrefix, options) : rawPrefix;\n              }\n            }\n          });\n        }\n\n      case \"thematicBreak\":\n        {\n          var counter = getAncestorCounter$1(path, \"list\");\n\n          if (counter === -1) {\n            return \"---\";\n          }\n\n          var _nthSiblingIndex = getNthListSiblingIndex(path.getParentNode(counter), path.getParentNode(counter + 1));\n\n          return _nthSiblingIndex % 2 === 0 ? \"***\" : \"---\";\n        }\n\n      case \"linkReference\":\n        return concat$g([\"[\", printChildren$2(path, options, print), \"]\", node.referenceType === \"full\" ? concat$g([\"[\", node.identifier, \"]\"]) : node.referenceType === \"collapsed\" ? \"[]\" : \"\"]);\n\n      case \"imageReference\":\n        switch (node.referenceType) {\n          case \"full\":\n            return concat$g([\"![\", node.alt || \"\", \"][\", node.identifier, \"]\"]);\n\n          default:\n            return concat$g([\"![\", node.alt, \"]\", node.referenceType === \"collapsed\" ? \"[]\" : \"\"]);\n        }\n\n      case \"definition\":\n        {\n          var lineOrSpace = options.proseWrap === \"always\" ? line$8 : \" \";\n          return group$f(concat$g([concat$g([\"[\", node.identifier, \"]:\"]), indent$9(concat$g([lineOrSpace, printUrl(node.url), node.title === null ? \"\" : concat$g([lineOrSpace, printTitle(node.title, options, false)])]))]));\n        }\n\n      case \"footnote\":\n        return concat$g([\"[^\", printChildren$2(path, options, print), \"]\"]);\n\n      case \"footnoteReference\":\n        return concat$g([\"[^\", node.identifier, \"]\"]);\n\n      case \"footnoteDefinition\":\n        {\n          var _nextNode2 = path.getParentNode().children[path.getName() + 1];\n          var shouldInlineFootnote = node.children.length === 1 && node.children[0].type === \"paragraph\" && (options.proseWrap === \"never\" || options.proseWrap === \"preserve\" && node.children[0].position.start.line === node.children[0].position.end.line);\n          return concat$g([\"[^\", node.identifier, \"]: \", shouldInlineFootnote ? printChildren$2(path, options, print) : group$f(concat$g([align$2(\" \".repeat(options.tabWidth), printChildren$2(path, options, print, {\n            processor: function processor(childPath, index) {\n              return index === 0 ? group$f(concat$g([softline$7, softline$7, childPath.call(print)])) : childPath.call(print);\n            }\n          })), _nextNode2 && _nextNode2.type === \"footnoteDefinition\" ? softline$7 : \"\"]))]);\n        }\n\n      case \"table\":\n        return printTable(path, options, print);\n\n      case \"tableCell\":\n        return printChildren$2(path, options, print);\n\n      case \"break\":\n        return /\\s/.test(options.originalText[node.position.start.offset]) ? concat$g([\"  \", markAsRoot$4(literalline$6)]) : concat$g([\"\\\\\", hardline$c]);\n\n      case \"liquidNode\":\n        return concat$g(replaceEndOfLineWith$2(node.value, hardline$c));\n      // MDX\n\n      case \"importExport\":\n      case \"jsx\":\n        return node.value;\n      // fallback to the original text if multiparser failed\n\n      case \"math\":\n        return concat$g([\"$$\", hardline$c, node.value ? concat$g([concat$g(replaceEndOfLineWith$2(node.value, hardline$c)), hardline$c]) : \"\", \"$$\"]);\n\n      case \"inlineMath\":\n        {\n          // remark-math trims content but we don't want to remove whitespaces\n          // since it's very possible that it's recognized as math accidentally\n          return options.originalText.slice(options.locStart(node), options.locEnd(node));\n        }\n\n      case \"tableRow\": // handled in \"table\"\n\n      case \"listItem\": // handled in \"list\"\n\n      default:\n        throw new Error(\"Unknown markdown type \".concat(JSON.stringify(node.type)));\n    }\n  }\n\n  function printListItem(path, options, print, listPrefix) {\n    var node = path.getValue();\n    var prefix = node.checked === null ? \"\" : node.checked ? \"[x] \" : \"[ ] \";\n    return concat$g([prefix, printChildren$2(path, options, print, {\n      processor: function processor(childPath, index) {\n        if (index === 0 && childPath.getValue().type !== \"list\") {\n          return align$2(\" \".repeat(prefix.length), childPath.call(print));\n        }\n\n        var alignment = \" \".repeat(clamp(options.tabWidth - listPrefix.length, 0, 3) // 4+ will cause indented code block\n        );\n        return concat$g([alignment, align$2(alignment, childPath.call(print))]);\n      }\n    })]);\n  }\n\n  function alignListPrefix(prefix, options) {\n    var additionalSpaces = getAdditionalSpaces();\n    return prefix + \" \".repeat(additionalSpaces >= 4 ? 0 : additionalSpaces // 4+ will cause indented code block\n    );\n\n    function getAdditionalSpaces() {\n      var restSpaces = prefix.length % options.tabWidth;\n      return restSpaces === 0 ? 0 : options.tabWidth - restSpaces;\n    }\n  }\n\n  function getNthListSiblingIndex(node, parentNode) {\n    return getNthSiblingIndex(node, parentNode, function (siblingNode) {\n      return siblingNode.ordered === node.ordered;\n    });\n  }\n\n  function getNthSiblingIndex(node, parentNode, condition) {\n    condition = condition || function () {\n      return true;\n    };\n\n    var index = -1;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = parentNode.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var childNode = _step.value;\n\n        if (childNode.type === node.type && condition(childNode)) {\n          index++;\n        } else {\n          index = -1;\n        }\n\n        if (childNode === node) {\n          return index;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  function getAncestorCounter$1(path, typeOrTypes) {\n    var types = [].concat(typeOrTypes);\n    var counter = -1;\n    var ancestorNode;\n\n    while (ancestorNode = path.getParentNode(++counter)) {\n      if (types.indexOf(ancestorNode.type) !== -1) {\n        return counter;\n      }\n    }\n\n    return -1;\n  }\n\n  function getAncestorNode$2(path, typeOrTypes) {\n    var counter = getAncestorCounter$1(path, typeOrTypes);\n    return counter === -1 ? null : path.getParentNode(counter);\n  }\n\n  function printLine(path, value, options) {\n    if (options.proseWrap === \"preserve\" && value === \"\\n\") {\n      return hardline$c;\n    }\n\n    var isBreakable = options.proseWrap === \"always\" && !getAncestorNode$2(path, SINGLE_LINE_NODE_TYPES);\n    return value !== \"\" ? isBreakable ? line$8 : \" \" : isBreakable ? softline$7 : \"\";\n  }\n\n  function printTable(path, options, print) {\n    var hardlineWithoutBreakParent = hardline$c.parts[0];\n    var node = path.getValue();\n    var contents = []; // { [rowIndex: number]: { [columnIndex: number]: string } }\n\n    path.map(function (rowPath) {\n      var rowContents = [];\n      rowPath.map(function (cellPath) {\n        rowContents.push(printDocToString$2(cellPath.call(print), options).formatted);\n      }, \"children\");\n      contents.push(rowContents);\n    }, \"children\"); // Get the width of each column\n\n    var columnMaxWidths = contents.reduce(function (currentWidths, rowContents) {\n      return currentWidths.map(function (width, columnIndex) {\n        return Math.max(width, util.getStringWidth(rowContents[columnIndex]));\n      });\n    }, contents[0].map(function () {\n      return 3;\n    }) // minimum width = 3 (---, :--, :-:, --:)\n    );\n    var alignedTable = join$b(hardlineWithoutBreakParent, [printRow(contents[0]), printSeparator(), join$b(hardlineWithoutBreakParent, contents.slice(1).map(function (rowContents) {\n      return printRow(rowContents);\n    }))]);\n\n    if (options.proseWrap !== \"never\") {\n      return concat$g([breakParent$4, alignedTable]);\n    } // Only if the --prose-wrap never is set and it exceeds the print width.\n\n\n    var compactTable = join$b(hardlineWithoutBreakParent, [printRow(contents[0],\n    /* isCompact */\n    true), printSeparator(\n    /* isCompact */\n    true), join$b(hardlineWithoutBreakParent, contents.slice(1).map(function (rowContents) {\n      return printRow(rowContents,\n      /* isCompact */\n      true);\n    }))]);\n    return concat$g([breakParent$4, group$f(ifBreak$7(compactTable, alignedTable))]);\n\n    function printSeparator(isCompact) {\n      return concat$g([\"| \", join$b(\" | \", columnMaxWidths.map(function (width, index) {\n        var spaces = isCompact ? 3 : width;\n\n        switch (node.align[index]) {\n          case \"left\":\n            return \":\" + \"-\".repeat(spaces - 1);\n\n          case \"right\":\n            return \"-\".repeat(spaces - 1) + \":\";\n\n          case \"center\":\n            return \":\" + \"-\".repeat(spaces - 2) + \":\";\n\n          default:\n            return \"-\".repeat(spaces);\n        }\n      })), \" |\"]);\n    }\n\n    function printRow(rowContents, isCompact) {\n      return concat$g([\"| \", join$b(\" | \", isCompact ? rowContents : rowContents.map(function (rowContent, columnIndex) {\n        switch (node.align[columnIndex]) {\n          case \"right\":\n            return alignRight(rowContent, columnMaxWidths[columnIndex]);\n\n          case \"center\":\n            return alignCenter(rowContent, columnMaxWidths[columnIndex]);\n\n          default:\n            return alignLeft(rowContent, columnMaxWidths[columnIndex]);\n        }\n      })), \" |\"]);\n    }\n\n    function alignLeft(text, width) {\n      var spaces = width - util.getStringWidth(text);\n      return concat$g([text, \" \".repeat(spaces)]);\n    }\n\n    function alignRight(text, width) {\n      var spaces = width - util.getStringWidth(text);\n      return concat$g([\" \".repeat(spaces), text]);\n    }\n\n    function alignCenter(text, width) {\n      var spaces = width - util.getStringWidth(text);\n      var left = Math.floor(spaces / 2);\n      var right = spaces - left;\n      return concat$g([\" \".repeat(left), text, \" \".repeat(right)]);\n    }\n  }\n\n  function printRoot(path, options, print) {\n    /** @typedef {{ index: number, offset: number }} IgnorePosition */\n\n    /** @type {Array<{start: IgnorePosition, end: IgnorePosition}>} */\n    var ignoreRanges = [];\n    /** @type {IgnorePosition | null} */\n\n    var ignoreStart = null;\n    var children = path.getValue().children;\n    children.forEach(function (childNode, index) {\n      switch (isPrettierIgnore$1(childNode)) {\n        case \"start\":\n          if (ignoreStart === null) {\n            ignoreStart = {\n              index: index,\n              offset: childNode.position.end.offset\n            };\n          }\n\n          break;\n\n        case \"end\":\n          if (ignoreStart !== null) {\n            ignoreRanges.push({\n              start: ignoreStart,\n              end: {\n                index: index,\n                offset: childNode.position.start.offset\n              }\n            });\n            ignoreStart = null;\n          }\n\n          break;\n      }\n    });\n    return printChildren$2(path, options, print, {\n      processor: function processor(childPath, index) {\n        if (ignoreRanges.length !== 0) {\n          var ignoreRange = ignoreRanges[0];\n\n          if (index === ignoreRange.start.index) {\n            return concat$g([children[ignoreRange.start.index].value, options.originalText.slice(ignoreRange.start.offset, ignoreRange.end.offset), children[ignoreRange.end.index].value]);\n          }\n\n          if (ignoreRange.start.index < index && index < ignoreRange.end.index) {\n            return false;\n          }\n\n          if (index === ignoreRange.end.index) {\n            ignoreRanges.shift();\n            return false;\n          }\n        }\n\n        return childPath.call(print);\n      }\n    });\n  }\n\n  function printChildren$2(path, options, print, events) {\n    events = events || {};\n    var postprocessor = events.postprocessor || concat$g;\n\n    var processor = events.processor || function (childPath) {\n      return childPath.call(print);\n    };\n\n    var node = path.getValue();\n    var parts = [];\n    var lastChildNode;\n    path.map(function (childPath, index) {\n      var childNode = childPath.getValue();\n      var result = processor(childPath, index);\n\n      if (result !== false) {\n        var data = {\n          parts: parts,\n          prevNode: lastChildNode,\n          parentNode: node,\n          options: options\n        };\n\n        if (!shouldNotPrePrintHardline(childNode, data)) {\n          parts.push(hardline$c);\n\n          if (lastChildNode && TRAILING_HARDLINE_NODES.indexOf(lastChildNode.type) !== -1) {\n            if (shouldPrePrintTripleHardline(childNode, data)) {\n              parts.push(hardline$c);\n            }\n          } else {\n            if (shouldPrePrintDoubleHardline(childNode, data) || shouldPrePrintTripleHardline(childNode, data)) {\n              parts.push(hardline$c);\n            }\n\n            if (shouldPrePrintTripleHardline(childNode, data)) {\n              parts.push(hardline$c);\n            }\n          }\n        }\n\n        parts.push(result);\n        lastChildNode = childNode;\n      }\n    }, \"children\");\n    return postprocessor(parts);\n  }\n\n  function getLastDescendantNode(node) {\n    var current = node;\n\n    while (current.children && current.children.length !== 0) {\n      current = current.children[current.children.length - 1];\n    }\n\n    return current;\n  }\n  /** @return {false | 'next' | 'start' | 'end'} */\n\n\n  function isPrettierIgnore$1(node) {\n    if (node.type !== \"html\") {\n      return false;\n    }\n\n    var match = node.value.match(/^<!--\\s*prettier-ignore(?:-(start|end))?\\s*-->$/);\n    return match === null ? false : match[1] ? match[1] : \"next\";\n  }\n\n  function isInlineNode(node) {\n    return node && INLINE_NODE_TYPES$1.indexOf(node.type) !== -1;\n  }\n\n  function isEndsWithHardLine(node) {\n    return node && /\\n+$/.test(node.value);\n  }\n\n  function last(nodes) {\n    return nodes && nodes[nodes.length - 1];\n  }\n\n  function shouldNotPrePrintHardline(node, _ref) {\n    var parentNode = _ref.parentNode,\n        parts = _ref.parts,\n        prevNode = _ref.prevNode;\n    var isFirstNode = parts.length === 0;\n    var isInlineHTML = node.type === \"html\" && INLINE_NODE_WRAPPER_TYPES$1.indexOf(parentNode.type) !== -1;\n    var isAfterHardlineNode = prevNode && (isEndsWithHardLine(prevNode) || isEndsWithHardLine(last(prevNode.children)));\n    return isFirstNode || isInlineNode(node) || isInlineHTML || isAfterHardlineNode;\n  }\n\n  function shouldPrePrintDoubleHardline(node, _ref2) {\n    var parentNode = _ref2.parentNode,\n        prevNode = _ref2.prevNode;\n    var prevNodeType = prevNode && prevNode.type;\n    var nodeType = node.type;\n    var isSequence = prevNodeType === nodeType;\n    var isSiblingNode = isSequence && SIBLING_NODE_TYPES.indexOf(nodeType) !== -1;\n    var isInTightListItem = parentNode.type === \"listItem\" && !parentNode.loose;\n    var isPrevNodeLooseListItem = prevNodeType === \"listItem\" && prevNode.loose;\n    var isPrevNodePrettierIgnore = isPrettierIgnore$1(prevNode) === \"next\";\n    var isBlockHtmlWithoutBlankLineBetweenPrevHtml = nodeType === \"html\" && prevNodeType === \"html\" && prevNode.position.end.line + 1 === node.position.start.line;\n    var isJsxInlineSibling = prevNodeType === \"jsx\" && isInlineNode(node) || nodeType === \"jsx\" && isInlineNode(prevNode);\n    return isPrevNodeLooseListItem || !(isSiblingNode || isInTightListItem || isPrevNodePrettierIgnore || isBlockHtmlWithoutBlankLineBetweenPrevHtml || isJsxInlineSibling);\n  }\n\n  function shouldPrePrintTripleHardline(node, data) {\n    var isPrevNodeList = data.prevNode && data.prevNode.type === \"list\";\n    var isIndentedCode = node.type === \"code\" && node.isIndented;\n    return isPrevNodeList && isIndentedCode;\n  }\n\n  function shouldRemainTheSameContent(path) {\n    var ancestorNode = getAncestorNode$2(path, [\"linkReference\", \"imageReference\"]);\n    return ancestorNode && (ancestorNode.type !== \"linkReference\" || ancestorNode.referenceType !== \"full\");\n  }\n\n  function normalizeDoc(doc) {\n    return mapDoc$7(doc, function (currentDoc) {\n      if (!currentDoc.parts) {\n        return currentDoc;\n      }\n\n      if (currentDoc.type === \"concat\" && currentDoc.parts.length === 1) {\n        return currentDoc.parts[0];\n      }\n\n      var parts = [];\n      currentDoc.parts.forEach(function (part) {\n        if (part.type === \"concat\") {\n          parts.push.apply(parts, part.parts);\n        } else if (part !== \"\") {\n          parts.push(part);\n        }\n      });\n      return Object.assign({}, currentDoc, {\n        parts: normalizeParts$2(parts)\n      });\n    });\n  }\n\n  function printUrl(url, dangerousCharOrChars) {\n    var dangerousChars = [\" \"].concat(dangerousCharOrChars || []);\n    return new RegExp(dangerousChars.map(function (x) {\n      return \"\\\\\".concat(x);\n    }).join(\"|\")).test(url) ? \"<\".concat(url, \">\") : url;\n  }\n\n  function printTitle(title, options, printSpace) {\n    if (printSpace == null) {\n      printSpace = true;\n    }\n\n    if (!title) {\n      return \"\";\n    }\n\n    if (printSpace) {\n      return \" \" + printTitle(title, options, false);\n    }\n\n    if (title.includes('\"') && title.includes(\"'\") && !title.includes(\")\")) {\n      return \"(\".concat(title, \")\"); // avoid escaped quotes\n    } // faster than using RegExps: https://jsperf.com/performance-of-match-vs-split\n\n\n    var singleCount = title.split(\"'\").length - 1;\n    var doubleCount = title.split('\"').length - 1;\n    var quote = singleCount > doubleCount ? '\"' : doubleCount > singleCount ? \"'\" : options.singleQuote ? \"'\" : '\"';\n    title = title.replace(new RegExp(\"(\".concat(quote, \")\"), \"g\"), \"\\\\$1\");\n    return \"\".concat(quote).concat(title).concat(quote);\n  }\n\n  function normalizeParts$2(parts) {\n    return parts.reduce(function (current, part) {\n      var lastPart = util.getLast(current);\n\n      if (typeof lastPart === \"string\" && typeof part === \"string\") {\n        current.splice(-1, 1, lastPart + part);\n      } else {\n        current.push(part);\n      }\n\n      return current;\n    }, []);\n  }\n\n  function clamp(value, min, max) {\n    return value < min ? min : value > max ? max : value;\n  }\n\n  function clean$6(ast, newObj, parent) {\n    delete newObj.position;\n    delete newObj.raw; // front-matter\n    // for codeblock\n\n    if (ast.type === \"code\" || ast.type === \"yaml\" || ast.type === \"import\" || ast.type === \"export\" || ast.type === \"jsx\") {\n      delete newObj.value;\n    }\n\n    if (ast.type === \"list\") {\n      delete newObj.isAligned;\n    } // texts can be splitted or merged\n\n\n    if (ast.type === \"text\") {\n      return null;\n    }\n\n    if (ast.type === \"inlineCode\") {\n      newObj.value = ast.value.replace(/[ \\t\\n]+/g, \" \");\n    } // for insert pragma\n\n\n    if (parent && parent.type === \"root\" && parent.children.length > 0 && (parent.children[0] === ast || (parent.children[0].type === \"yaml\" || parent.children[0].type === \"toml\") && parent.children[1] === ast) && ast.type === \"html\" && pragma$4.startWithPragma(ast.value)) {\n      return null;\n    }\n  }\n\n  function hasPrettierIgnore$4(path) {\n    var index = +path.getName();\n\n    if (index === 0) {\n      return false;\n    }\n\n    var prevNode = path.getParentNode().children[index - 1];\n    return isPrettierIgnore$1(prevNode) === \"next\";\n  }\n\n  var printerMarkdown = {\n    preprocess: preprocess_1$2,\n    print: genericPrint$5,\n    embed: embed_1$2,\n    massageAstNode: clean$6,\n    hasPrettierIgnore: hasPrettierIgnore$4,\n    insertPragma: pragma$4.insertPragma\n  };\n\n  var options$6 = {\n    proseWrap: commonOptions.proseWrap,\n    singleQuote: commonOptions.singleQuote\n  };\n\n  var name$g = \"Markdown\";\n  var type$f = \"prose\";\n  var aliases$5 = [\n  \t\"pandoc\"\n  ];\n  var aceMode$f = \"markdown\";\n  var codemirrorMode$b = \"gfm\";\n  var codemirrorMimeType$b = \"text/x-gfm\";\n  var wrap = true;\n  var extensions$f = [\n  \t\".md\",\n  \t\".markdown\",\n  \t\".mdown\",\n  \t\".mdwn\",\n  \t\".mdx\",\n  \t\".mkd\",\n  \t\".mkdn\",\n  \t\".mkdown\",\n  \t\".ronn\",\n  \t\".workbook\"\n  ];\n  var filenames$3 = [\n  \t\"contents.lr\"\n  ];\n  var tmScope$f = \"source.gfm\";\n  var languageId$f = 222;\n  var Markdown = {\n  \tname: name$g,\n  \ttype: type$f,\n  \taliases: aliases$5,\n  \taceMode: aceMode$f,\n  \tcodemirrorMode: codemirrorMode$b,\n  \tcodemirrorMimeType: codemirrorMimeType$b,\n  \twrap: wrap,\n  \textensions: extensions$f,\n  \tfilenames: filenames$3,\n  \ttmScope: tmScope$f,\n  \tlanguageId: languageId$f\n  };\n\n  var Markdown$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    name: name$g,\n    type: type$f,\n    aliases: aliases$5,\n    aceMode: aceMode$f,\n    codemirrorMode: codemirrorMode$b,\n    codemirrorMimeType: codemirrorMimeType$b,\n    wrap: wrap,\n    extensions: extensions$f,\n    filenames: filenames$3,\n    tmScope: tmScope$f,\n    languageId: languageId$f,\n    'default': Markdown\n  });\n\n  var require$$0$7 = getCjsExportFromNamespace(Markdown$1);\n\n  var languages$5 = [createLanguage(require$$0$7, function (data) {\n    return Object.assign(data, {\n      since: \"1.8.0\",\n      parsers: [\"remark\"],\n      vscodeLanguageIds: [\"markdown\"],\n      filenames: data.filenames.concat([\"README\"]),\n      extensions: data.extensions.filter(function (extension) {\n        return extension !== \".mdx\";\n      })\n    });\n  }), createLanguage(require$$0$7, function (data) {\n    return Object.assign(data, {\n      name: \"MDX\",\n      since: \"1.15.0\",\n      parsers: [\"mdx\"],\n      vscodeLanguageIds: [\"mdx\"],\n      filenames: [],\n      extensions: [\".mdx\"]\n    });\n  })];\n  var printers$5 = {\n    mdast: printerMarkdown\n  };\n  var languageMarkdown = {\n    languages: languages$5,\n    options: options$6,\n    printers: printers$5\n  };\n\n  function isPragma(text) {\n    return /^\\s*@(prettier|format)\\s*$/.test(text);\n  }\n\n  function hasPragma$4(text) {\n    return /^\\s*#[^\\n\\S]*@(prettier|format)\\s*?(\\n|$)/.test(text);\n  }\n\n  function insertPragma$8(text) {\n    return \"# @format\\n\\n\".concat(text);\n  }\n\n  var pragma$5 = {\n    isPragma: isPragma,\n    hasPragma: hasPragma$4,\n    insertPragma: insertPragma$8\n  };\n\n  var getLast$4 = util.getLast;\n\n  function getAncestorCount(path, filter) {\n    var counter = 0;\n    var pathStackLength = path.stack.length - 1;\n\n    for (var i = 0; i < pathStackLength; i++) {\n      var value = path.stack[i];\n\n      if (isNode(value) && filter(value)) {\n        counter++;\n      }\n    }\n\n    return counter;\n  }\n  /**\n   * @param {any} value\n   * @param {string[]=} types\n   */\n\n\n  function isNode(value, types) {\n    return value && typeof value.type === \"string\" && (!types || types.indexOf(value.type) !== -1);\n  }\n\n  function mapNode(node, callback, parent) {\n    return callback(\"children\" in node ? Object.assign({}, node, {\n      children: node.children.map(function (childNode) {\n        return mapNode(childNode, callback, node);\n      })\n    }) : node, parent);\n  }\n\n  function defineShortcut(x, key, getter) {\n    Object.defineProperty(x, key, {\n      get: getter,\n      enumerable: false\n    });\n  }\n\n  function isNextLineEmpty$5(node, text) {\n    var newlineCount = 0;\n    var textLength = text.length;\n\n    for (var i = node.position.end.offset - 1; i < textLength; i++) {\n      var char = text[i];\n\n      if (char === \"\\n\") {\n        newlineCount++;\n      }\n\n      if (newlineCount === 1 && /\\S/.test(char)) {\n        return false;\n      }\n\n      if (newlineCount === 2) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function isLastDescendantNode(path) {\n    var node = path.getValue();\n\n    switch (node.type) {\n      case \"tag\":\n      case \"anchor\":\n      case \"comment\":\n        return false;\n    }\n\n    var pathStackLength = path.stack.length;\n\n    for (var i = 1; i < pathStackLength; i++) {\n      var item = path.stack[i];\n      var parentItem = path.stack[i - 1];\n\n      if (Array.isArray(parentItem) && typeof item === \"number\" && item !== parentItem.length - 1) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function getLastDescendantNode$1(node) {\n    return \"children\" in node && node.children.length !== 0 ? getLastDescendantNode$1(getLast$4(node.children)) : node;\n  }\n\n  function isPrettierIgnore$2(comment) {\n    return comment.value.trim() === \"prettier-ignore\";\n  }\n\n  function hasPrettierIgnore$5(path) {\n    var node = path.getValue();\n\n    if (node.type === \"documentBody\") {\n      var document = path.getParentNode();\n      return hasEndComments(document.head) && isPrettierIgnore$2(getLast$4(document.head.endComments));\n    }\n\n    return hasLeadingComments(node) && isPrettierIgnore$2(getLast$4(node.leadingComments));\n  }\n\n  function isEmptyNode(node) {\n    return (!node.children || node.children.length === 0) && !hasComments(node);\n  }\n\n  function hasComments(node) {\n    return hasLeadingComments(node) || hasMiddleComments(node) || hasIndicatorComment(node) || hasTrailingComment$2(node) || hasEndComments(node);\n  }\n\n  function hasLeadingComments(node) {\n    return node && node.leadingComments && node.leadingComments.length !== 0;\n  }\n\n  function hasMiddleComments(node) {\n    return node && node.middleComments && node.middleComments.length !== 0;\n  }\n\n  function hasIndicatorComment(node) {\n    return node && node.indicatorComment;\n  }\n\n  function hasTrailingComment$2(node) {\n    return node && node.trailingComment;\n  }\n\n  function hasEndComments(node) {\n    return node && node.endComments && node.endComments.length !== 0;\n  }\n  /**\n   * \" a   b c   d e   f \" -> [\" a   b\", \"c   d\", \"e   f \"]\n   */\n\n\n  function splitWithSingleSpace(text) {\n    var parts = [];\n    var lastPart = undefined;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = text.split(/( +)/g)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var part = _step.value;\n\n        if (part !== \" \") {\n          if (lastPart === \" \") {\n            parts.push(part);\n          } else {\n            parts.push((parts.pop() || \"\") + part);\n          }\n        } else if (lastPart === undefined) {\n          parts.unshift(\"\");\n        }\n\n        lastPart = part;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    if (lastPart === \" \") {\n      parts.push((parts.pop() || \"\") + \" \");\n    }\n\n    if (parts[0] === \"\") {\n      parts.shift();\n      parts.unshift(\" \" + (parts.shift() || \"\"));\n    }\n\n    return parts;\n  }\n\n  function getFlowScalarLineContents(nodeType, content, options) {\n    var rawLineContents = content.split(\"\\n\").map(function (lineContent, index, lineContents) {\n      return index === 0 && index === lineContents.length - 1 ? lineContent : index !== 0 && index !== lineContents.length - 1 ? lineContent.trim() : index === 0 ? lineContent.trimRight() : lineContent.trimLeft();\n    });\n\n    if (options.proseWrap === \"preserve\") {\n      return rawLineContents.map(function (lineContent) {\n        return lineContent.length === 0 ? [] : [lineContent];\n      });\n    }\n\n    return rawLineContents.map(function (lineContent) {\n      return lineContent.length === 0 ? [] : splitWithSingleSpace(lineContent);\n    }).reduce(function (reduced, lineContentWords, index) {\n      return index !== 0 && rawLineContents[index - 1].length !== 0 && lineContentWords.length !== 0 && !( // trailing backslash in quoteDouble should be preserved\n      nodeType === \"quoteDouble\" && getLast$4(getLast$4(reduced)).endsWith(\"\\\\\")) ? reduced.concat([reduced.pop().concat(lineContentWords)]) : reduced.concat([lineContentWords]);\n    }, []).map(function (lineContentWords) {\n      return options.proseWrap === \"never\" ? [lineContentWords.join(\" \")] : lineContentWords;\n    });\n  }\n\n  function getBlockValueLineContents(node, _ref) {\n    var parentIndent = _ref.parentIndent,\n        isLastDescendant = _ref.isLastDescendant,\n        options = _ref.options;\n    var content = node.position.start.line === node.position.end.line ? \"\" : options.originalText.slice(node.position.start.offset, node.position.end.offset) // exclude open line `>` or `|`\n    .match(/^[^\\n]*?\\n([\\s\\S]*)$/)[1];\n    var leadingSpaceCount = node.indent === null ? function (match) {\n      return match ? match[1].length : Infinity;\n    }(content.match(/^( *)\\S/m)) : node.indent - 1 + parentIndent;\n    var rawLineContents = content.split(\"\\n\").map(function (lineContent) {\n      return lineContent.slice(leadingSpaceCount);\n    });\n\n    if (options.proseWrap === \"preserve\" || node.type === \"blockLiteral\") {\n      return removeUnnecessaryTrailingNewlines(rawLineContents.map(function (lineContent) {\n        return lineContent.length === 0 ? [] : [lineContent];\n      }));\n    }\n\n    return removeUnnecessaryTrailingNewlines(rawLineContents.map(function (lineContent) {\n      return lineContent.length === 0 ? [] : splitWithSingleSpace(lineContent);\n    }).reduce(function (reduced, lineContentWords, index) {\n      return index !== 0 && rawLineContents[index - 1].length !== 0 && lineContentWords.length !== 0 && !/^\\s/.test(lineContentWords[0]) && !/^\\s|\\s$/.test(getLast$4(reduced)) ? reduced.concat([reduced.pop().concat(lineContentWords)]) : reduced.concat([lineContentWords]);\n    }, []).map(function (lineContentWords) {\n      return lineContentWords.reduce(function (reduced, word) {\n        return (// disallow trailing spaces\n          reduced.length !== 0 && /\\s$/.test(getLast$4(reduced)) ? reduced.concat(reduced.pop() + \" \" + word) : reduced.concat(word)\n        );\n      }, []);\n    }).map(function (lineContentWords) {\n      return options.proseWrap === \"never\" ? [lineContentWords.join(\" \")] : lineContentWords;\n    }));\n\n    function removeUnnecessaryTrailingNewlines(lineContents) {\n      if (node.chomping === \"keep\") {\n        return getLast$4(lineContents).length === 0 ? lineContents.slice(0, -1) : lineContents;\n      }\n\n      var trailingNewlineCount = 0;\n\n      for (var i = lineContents.length - 1; i >= 0; i--) {\n        if (lineContents[i].length === 0) {\n          trailingNewlineCount++;\n        } else {\n          break;\n        }\n      }\n\n      return trailingNewlineCount === 0 ? lineContents : trailingNewlineCount >= 2 && !isLastDescendant ? // next empty line\n      lineContents.slice(0, -(trailingNewlineCount - 1)) : lineContents.slice(0, -trailingNewlineCount);\n    }\n  }\n\n  var utils$6 = {\n    getLast: getLast$4,\n    getAncestorCount: getAncestorCount,\n    isNode: isNode,\n    isEmptyNode: isEmptyNode,\n    mapNode: mapNode,\n    defineShortcut: defineShortcut,\n    isNextLineEmpty: isNextLineEmpty$5,\n    isLastDescendantNode: isLastDescendantNode,\n    getBlockValueLineContents: getBlockValueLineContents,\n    getFlowScalarLineContents: getFlowScalarLineContents,\n    getLastDescendantNode: getLastDescendantNode$1,\n    hasPrettierIgnore: hasPrettierIgnore$5,\n    hasLeadingComments: hasLeadingComments,\n    hasMiddleComments: hasMiddleComments,\n    hasIndicatorComment: hasIndicatorComment,\n    hasTrailingComment: hasTrailingComment$2,\n    hasEndComments: hasEndComments\n  };\n\n  var insertPragma$9 = pragma$5.insertPragma,\n      isPragma$1 = pragma$5.isPragma;\n  var getAncestorCount$1 = utils$6.getAncestorCount,\n      getBlockValueLineContents$1 = utils$6.getBlockValueLineContents,\n      getFlowScalarLineContents$1 = utils$6.getFlowScalarLineContents,\n      getLast$5 = utils$6.getLast,\n      getLastDescendantNode$2 = utils$6.getLastDescendantNode,\n      hasLeadingComments$1 = utils$6.hasLeadingComments,\n      hasMiddleComments$1 = utils$6.hasMiddleComments,\n      hasIndicatorComment$1 = utils$6.hasIndicatorComment,\n      hasTrailingComment$3 = utils$6.hasTrailingComment,\n      hasEndComments$1 = utils$6.hasEndComments,\n      hasPrettierIgnore$6 = utils$6.hasPrettierIgnore,\n      isLastDescendantNode$1 = utils$6.isLastDescendantNode,\n      isNextLineEmpty$6 = utils$6.isNextLineEmpty,\n      isNode$1 = utils$6.isNode,\n      isEmptyNode$1 = utils$6.isEmptyNode,\n      defineShortcut$1 = utils$6.defineShortcut,\n      mapNode$1 = utils$6.mapNode;\n  var docBuilders$2 = doc.builders;\n  var conditionalGroup$2 = docBuilders$2.conditionalGroup,\n      breakParent$5 = docBuilders$2.breakParent,\n      concat$h = docBuilders$2.concat,\n      dedent$3 = docBuilders$2.dedent,\n      dedentToRoot$3 = docBuilders$2.dedentToRoot,\n      fill$6 = docBuilders$2.fill,\n      group$g = docBuilders$2.group,\n      hardline$d = docBuilders$2.hardline,\n      ifBreak$8 = docBuilders$2.ifBreak,\n      join$c = docBuilders$2.join,\n      line$9 = docBuilders$2.line,\n      lineSuffix$2 = docBuilders$2.lineSuffix,\n      literalline$7 = docBuilders$2.literalline,\n      markAsRoot$5 = docBuilders$2.markAsRoot,\n      softline$8 = docBuilders$2.softline;\n  var replaceEndOfLineWith$3 = util.replaceEndOfLineWith;\n\n  function preprocess$3(ast) {\n    return mapNode$1(ast, defineShortcuts);\n  }\n\n  function defineShortcuts(node) {\n    switch (node.type) {\n      case \"document\":\n        defineShortcut$1(node, \"head\", function () {\n          return node.children[0];\n        });\n        defineShortcut$1(node, \"body\", function () {\n          return node.children[1];\n        });\n        break;\n\n      case \"documentBody\":\n      case \"sequenceItem\":\n      case \"flowSequenceItem\":\n      case \"mappingKey\":\n      case \"mappingValue\":\n        defineShortcut$1(node, \"content\", function () {\n          return node.children[0];\n        });\n        break;\n\n      case \"mappingItem\":\n      case \"flowMappingItem\":\n        defineShortcut$1(node, \"key\", function () {\n          return node.children[0];\n        });\n        defineShortcut$1(node, \"value\", function () {\n          return node.children[1];\n        });\n        break;\n    }\n\n    return node;\n  }\n\n  function genericPrint$6(path, options, print) {\n    var node = path.getValue();\n    var parentNode = path.getParentNode();\n    var tag = !node.tag ? \"\" : path.call(print, \"tag\");\n    var anchor = !node.anchor ? \"\" : path.call(print, \"anchor\");\n    var nextEmptyLine = isNode$1(node, [\"mapping\", \"sequence\", \"comment\", \"directive\", \"mappingItem\", \"sequenceItem\"]) && !isLastDescendantNode$1(path) ? printNextEmptyLine(path, options.originalText) : \"\";\n    return concat$h([node.type !== \"mappingValue\" && hasLeadingComments$1(node) ? concat$h([join$c(hardline$d, path.map(print, \"leadingComments\")), hardline$d]) : \"\", tag, tag && anchor ? \" \" : \"\", anchor, tag || anchor ? isNode$1(node, [\"sequence\", \"mapping\"]) && !hasMiddleComments$1(node) ? hardline$d : \" \" : \"\", hasMiddleComments$1(node) ? concat$h([node.middleComments.length === 1 ? \"\" : hardline$d, join$c(hardline$d, path.map(print, \"middleComments\")), hardline$d]) : \"\", hasPrettierIgnore$6(path) ? concat$h(replaceEndOfLineWith$3(options.originalText.slice(node.position.start.offset, node.position.end.offset), literalline$7)) : group$g(_print(node, parentNode, path, options, print)), hasTrailingComment$3(node) && !isNode$1(node, [\"document\", \"documentHead\"]) ? lineSuffix$2(concat$h([node.type === \"mappingValue\" && !node.content ? \"\" : \" \", parentNode.type === \"mappingKey\" && path.getParentNode(2).type === \"mapping\" && isInlineNode$1(node) ? \"\" : breakParent$5, path.call(print, \"trailingComment\")])) : \"\", nextEmptyLine, hasEndComments$1(node) && !isNode$1(node, [\"documentHead\", \"documentBody\"]) ? align$3(node.type === \"sequenceItem\" ? 2 : 0, concat$h([hardline$d, join$c(hardline$d, path.map(print, \"endComments\"))])) : \"\"]);\n  }\n\n  function _print(node, parentNode, path, options, print) {\n    switch (node.type) {\n      case \"root\":\n        return concat$h([join$c(hardline$d, path.map(function (childPath, index) {\n          var document = node.children[index];\n          var nextDocument = node.children[index + 1];\n          return concat$h([print(childPath), shouldPrintDocumentEndMarker(document, nextDocument) ? concat$h([hardline$d, \"...\", hasTrailingComment$3(document) ? concat$h([\" \", path.call(print, \"trailingComment\")]) : \"\"]) : !nextDocument || hasTrailingComment$3(nextDocument.head) ? \"\" : concat$h([hardline$d, \"---\"])]);\n        }, \"children\")), node.children.length === 0 || function (lastDescendantNode) {\n          return isNode$1(lastDescendantNode, [\"blockLiteral\", \"blockFolded\"]) && lastDescendantNode.chomping === \"keep\";\n        }(getLastDescendantNode$2(node)) ? \"\" : hardline$d]);\n\n      case \"document\":\n        {\n          var nextDocument = parentNode.children[path.getName() + 1];\n          return join$c(hardline$d, [shouldPrintDocumentHeadEndMarker(node, nextDocument, parentNode, options) === \"head\" ? join$c(hardline$d, [node.head.children.length === 0 && node.head.endComments.length === 0 ? \"\" : path.call(print, \"head\"), concat$h([\"---\", hasTrailingComment$3(node.head) ? concat$h([\" \", path.call(print, \"head\", \"trailingComment\")]) : \"\"])].filter(Boolean)) : \"\", shouldPrintDocumentBody(node) ? path.call(print, \"body\") : \"\"].filter(Boolean));\n        }\n\n      case \"documentHead\":\n        return join$c(hardline$d, [].concat(path.map(print, \"children\"), path.map(print, \"endComments\")));\n\n      case \"documentBody\":\n        {\n          var children = join$c(hardline$d, path.map(print, \"children\")).parts;\n          var endComments = join$c(hardline$d, path.map(print, \"endComments\")).parts;\n          var separator = children.length === 0 || endComments.length === 0 ? \"\" : function (lastDescendantNode) {\n            return isNode$1(lastDescendantNode, [\"blockFolded\", \"blockLiteral\"]) ? lastDescendantNode.chomping === \"keep\" ? // there's already a newline printed at the end of blockValue (chomping=keep, lastDescendant=true)\n            \"\" : // an extra newline for better readability\n            concat$h([hardline$d, hardline$d]) : hardline$d;\n          }(getLastDescendantNode$2(node));\n          return concat$h([].concat(children, separator, endComments));\n        }\n\n      case \"directive\":\n        return concat$h([\"%\", join$c(\" \", [node.name].concat(node.parameters))]);\n\n      case \"comment\":\n        return concat$h([\"#\", node.value]);\n\n      case \"alias\":\n        return concat$h([\"*\", node.value]);\n\n      case \"tag\":\n        return options.originalText.slice(node.position.start.offset, node.position.end.offset);\n\n      case \"anchor\":\n        return concat$h([\"&\", node.value]);\n\n      case \"plain\":\n        return printFlowScalarContent(node.type, options.originalText.slice(node.position.start.offset, node.position.end.offset), options);\n\n      case \"quoteDouble\":\n      case \"quoteSingle\":\n        {\n          var singleQuote = \"'\";\n          var doubleQuote = '\"';\n          var raw = options.originalText.slice(node.position.start.offset + 1, node.position.end.offset - 1);\n\n          if (node.type === \"quoteSingle\" && raw.includes(\"\\\\\") || node.type === \"quoteDouble\" && /\\\\[^\"]/.test(raw)) {\n            // only quoteDouble can use escape chars\n            // and quoteSingle do not need to escape backslashes\n            var originalQuote = node.type === \"quoteDouble\" ? doubleQuote : singleQuote;\n            return concat$h([originalQuote, printFlowScalarContent(node.type, raw, options), originalQuote]);\n          } else if (raw.includes(doubleQuote)) {\n            return concat$h([singleQuote, printFlowScalarContent(node.type, node.type === \"quoteDouble\" ? raw // double quote needs to be escaped by backslash in quoteDouble\n            .replace(/\\\\\"/g, doubleQuote).replace(/'/g, singleQuote.repeat(2)) : raw, options), singleQuote]);\n          }\n\n          if (raw.includes(singleQuote)) {\n            return concat$h([doubleQuote, printFlowScalarContent(node.type, node.type === \"quoteSingle\" ? // single quote needs to be escaped by 2 single quotes in quoteSingle\n            raw.replace(/''/g, singleQuote) : raw, options), doubleQuote]);\n          }\n\n          var quote = options.singleQuote ? singleQuote : doubleQuote;\n          return concat$h([quote, printFlowScalarContent(node.type, raw, options), quote]);\n        }\n\n      case \"blockFolded\":\n      case \"blockLiteral\":\n        {\n          var parentIndent = getAncestorCount$1(path, function (ancestorNode) {\n            return isNode$1(ancestorNode, [\"sequence\", \"mapping\"]);\n          });\n          var isLastDescendant = isLastDescendantNode$1(path);\n          return concat$h([node.type === \"blockFolded\" ? \">\" : \"|\", node.indent === null ? \"\" : node.indent.toString(), node.chomping === \"clip\" ? \"\" : node.chomping === \"keep\" ? \"+\" : \"-\", hasIndicatorComment$1(node) ? concat$h([\" \", path.call(print, \"indicatorComment\")]) : \"\", (node.indent === null ? dedent$3 : dedentToRoot$3)(align$3(node.indent === null ? options.tabWidth : node.indent - 1 + parentIndent, concat$h(getBlockValueLineContents$1(node, {\n            parentIndent: parentIndent,\n            isLastDescendant: isLastDescendant,\n            options: options\n          }).reduce(function (reduced, lineWords, index, lineContents) {\n            return reduced.concat(index === 0 ? hardline$d : \"\", fill$6(join$c(line$9, lineWords).parts), index !== lineContents.length - 1 ? lineWords.length === 0 ? hardline$d : markAsRoot$5(literalline$7) : node.chomping === \"keep\" && isLastDescendant ? lineWords.length === 0 ? dedentToRoot$3(hardline$d) : dedentToRoot$3(literalline$7) : \"\");\n          }, []))))]);\n        }\n\n      case \"sequence\":\n        return join$c(hardline$d, path.map(print, \"children\"));\n\n      case \"sequenceItem\":\n        return concat$h([\"- \", align$3(2, !node.content ? \"\" : path.call(print, \"content\"))]);\n\n      case \"mappingKey\":\n        return !node.content ? \"\" : path.call(print, \"content\");\n\n      case \"mappingValue\":\n        return !node.content ? \"\" : path.call(print, \"content\");\n\n      case \"mapping\":\n        return join$c(hardline$d, path.map(print, \"children\"));\n\n      case \"mappingItem\":\n      case \"flowMappingItem\":\n        {\n          var isEmptyMappingKey = isEmptyNode$1(node.key);\n          var isEmptyMappingValue = isEmptyNode$1(node.value);\n\n          if (isEmptyMappingKey && isEmptyMappingValue) {\n            return concat$h([\": \"]);\n          }\n\n          var key = path.call(print, \"key\");\n          var value = path.call(print, \"value\");\n\n          if (isEmptyMappingValue) {\n            return node.type === \"flowMappingItem\" && parentNode.type === \"flowMapping\" ? key : node.type === \"mappingItem\" && isAbsolutelyPrintedAsSingleLineNode(node.key.content, options) && !hasTrailingComment$3(node.key.content) && (!parentNode.tag || parentNode.tag.value !== \"tag:yaml.org,2002:set\") ? concat$h([key, needsSpaceInFrontOfMappingValue(node) ? \" \" : \"\", \":\"]) : concat$h([\"? \", align$3(2, key)]);\n          }\n\n          if (isEmptyMappingKey) {\n            return concat$h([\": \", align$3(2, value)]);\n          }\n\n          var groupId = Symbol(\"mappingKey\");\n          var forceExplicitKey = hasLeadingComments$1(node.value) || !isInlineNode$1(node.key.content);\n          return forceExplicitKey ? concat$h([\"? \", align$3(2, key), hardline$d, join$c(\"\", path.map(print, \"value\", \"leadingComments\").map(function (comment) {\n            return concat$h([comment, hardline$d]);\n          })), \": \", align$3(2, value)]) : // force singleline\n          isSingleLineNode(node.key.content) && !hasLeadingComments$1(node.key.content) && !hasMiddleComments$1(node.key.content) && !hasTrailingComment$3(node.key.content) && !hasEndComments$1(node.key) && !hasLeadingComments$1(node.value.content) && !hasMiddleComments$1(node.value.content) && !hasEndComments$1(node.value) && isAbsolutelyPrintedAsSingleLineNode(node.value.content, options) ? concat$h([key, needsSpaceInFrontOfMappingValue(node) ? \" \" : \"\", \": \", value]) : conditionalGroup$2([concat$h([group$g(concat$h([ifBreak$8(\"? \"), group$g(align$3(2, key), {\n            id: groupId\n          })])), ifBreak$8(concat$h([hardline$d, \": \", align$3(2, value)]), indent(concat$h([needsSpaceInFrontOfMappingValue(node) ? \" \" : \"\", \":\", hasLeadingComments$1(node.value.content) || hasEndComments$1(node.value) && node.value.content && !isNode$1(node.value.content, [\"mapping\", \"sequence\"]) || parentNode.type === \"mapping\" && hasTrailingComment$3(node.key.content) && isInlineNode$1(node.value.content) || isNode$1(node.value.content, [\"mapping\", \"sequence\"]) && node.value.content.tag === null && node.value.content.anchor === null ? hardline$d : !node.value.content ? \"\" : line$9, value])), {\n            groupId: groupId\n          })])]);\n        }\n\n      case \"flowMapping\":\n      case \"flowSequence\":\n        {\n          var openMarker = node.type === \"flowMapping\" ? \"{\" : \"[\";\n          var closeMarker = node.type === \"flowMapping\" ? \"}\" : \"]\";\n          var bracketSpacing = node.type === \"flowMapping\" && node.children.length !== 0 && options.bracketSpacing ? line$9 : softline$8;\n\n          var isLastItemEmptyMappingItem = node.children.length !== 0 && function (lastItem) {\n            return lastItem.type === \"flowMappingItem\" && isEmptyNode$1(lastItem.key) && isEmptyNode$1(lastItem.value);\n          }(getLast$5(node.children));\n\n          return concat$h([openMarker, indent(concat$h([bracketSpacing, concat$h(path.map(function (childPath, index) {\n            return concat$h([print(childPath), index === node.children.length - 1 ? \"\" : concat$h([\",\", line$9, node.children[index].position.start.line !== node.children[index + 1].position.start.line ? printNextEmptyLine(childPath, options.originalText) : \"\"])]);\n          }, \"children\")), ifBreak$8(\",\", \"\")])), isLastItemEmptyMappingItem ? \"\" : bracketSpacing, closeMarker]);\n        }\n\n      case \"flowSequenceItem\":\n        return path.call(print, \"content\");\n      // istanbul ignore next\n\n      default:\n        throw new Error(\"Unexpected node type \".concat(node.type));\n    }\n\n    function indent(doc) {\n      return docBuilders$2.align(\" \".repeat(options.tabWidth), doc);\n    }\n  }\n\n  function align$3(n, doc) {\n    return typeof n === \"number\" && n > 0 ? docBuilders$2.align(\" \".repeat(n), doc) : docBuilders$2.align(n, doc);\n  }\n\n  function isInlineNode$1(node) {\n    if (!node) {\n      return true;\n    }\n\n    switch (node.type) {\n      case \"plain\":\n      case \"quoteDouble\":\n      case \"quoteSingle\":\n      case \"alias\":\n      case \"flowMapping\":\n      case \"flowSequence\":\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  function isSingleLineNode(node) {\n    if (!node) {\n      return true;\n    }\n\n    switch (node.type) {\n      case \"plain\":\n      case \"quoteDouble\":\n      case \"quoteSingle\":\n        return node.position.start.line === node.position.end.line;\n\n      case \"alias\":\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  function shouldPrintDocumentBody(document) {\n    return document.body.children.length !== 0 || hasEndComments$1(document.body);\n  }\n\n  function shouldPrintDocumentEndMarker(document, nextDocument) {\n    return (\n      /**\n       *... # trailingComment\n       */\n      hasTrailingComment$3(document) || nextDocument && (\n      /**\n       * ...\n       * %DIRECTIVE\n       * ---\n       */\n      nextDocument.head.children.length !== 0 ||\n      /**\n       * ...\n       * # endComment\n       * ---\n       */\n      hasEndComments$1(nextDocument.head))\n    );\n  }\n\n  function shouldPrintDocumentHeadEndMarker(document, nextDocument, root, options) {\n    if (\n    /**\n     * ---\n     * preserve the first document head end marker\n     */\n    root.children[0] === document && /---(\\s|$)/.test(options.originalText.slice(options.locStart(document), options.locStart(document) + 4)) ||\n    /**\n     * %DIRECTIVE\n     * ---\n     */\n    document.head.children.length !== 0 ||\n    /**\n     * # end comment\n     * ---\n     */\n    hasEndComments$1(document.head) ||\n    /**\n     * --- # trailing comment\n     */\n    hasTrailingComment$3(document.head)) {\n      return \"head\";\n    }\n\n    if (shouldPrintDocumentEndMarker(document, nextDocument)) {\n      return false;\n    }\n\n    return nextDocument ? \"root\" : false;\n  }\n\n  function isAbsolutelyPrintedAsSingleLineNode(node, options) {\n    if (!node) {\n      return true;\n    }\n\n    switch (node.type) {\n      case \"plain\":\n      case \"quoteSingle\":\n      case \"quoteDouble\":\n        break;\n\n      case \"alias\":\n        return true;\n\n      default:\n        return false;\n    }\n\n    if (options.proseWrap === \"preserve\") {\n      return node.position.start.line === node.position.end.line;\n    }\n\n    if ( // backslash-newline\n    /\\\\$/m.test(options.originalText.slice(node.position.start.offset, node.position.end.offset))) {\n      return false;\n    }\n\n    switch (options.proseWrap) {\n      case \"never\":\n        return node.value.indexOf(\"\\n\") === -1;\n\n      case \"always\":\n        return !/[\\n ]/.test(node.value);\n      // istanbul ignore next\n\n      default:\n        return false;\n    }\n  }\n\n  function needsSpaceInFrontOfMappingValue(node) {\n    return node.key.content && node.key.content.type === \"alias\";\n  }\n\n  function printNextEmptyLine(path, originalText) {\n    var node = path.getValue();\n    var root = path.stack[0];\n    root.isNextEmptyLinePrintedChecklist = root.isNextEmptyLinePrintedChecklist || [];\n\n    if (!root.isNextEmptyLinePrintedChecklist[node.position.end.line]) {\n      if (isNextLineEmpty$6(node, originalText)) {\n        root.isNextEmptyLinePrintedChecklist[node.position.end.line] = true;\n        return softline$8;\n      }\n    }\n\n    return \"\";\n  }\n\n  function printFlowScalarContent(nodeType, content, options) {\n    var lineContents = getFlowScalarLineContents$1(nodeType, content, options);\n    return join$c(hardline$d, lineContents.map(function (lineContentWords) {\n      return fill$6(join$c(line$9, lineContentWords).parts);\n    }));\n  }\n\n  function clean$7(node, newNode\n  /*, parent */\n  ) {\n    if (isNode$1(newNode)) {\n      delete newNode.position;\n\n      switch (newNode.type) {\n        case \"comment\":\n          // insert pragma\n          if (isPragma$1(newNode.value)) {\n            return null;\n          }\n\n          break;\n\n        case \"quoteDouble\":\n        case \"quoteSingle\":\n          newNode.type = \"quote\";\n          break;\n      }\n    }\n  }\n\n  var printerYaml = {\n    preprocess: preprocess$3,\n    print: genericPrint$6,\n    massageAstNode: clean$7,\n    insertPragma: insertPragma$9\n  };\n\n  var options$7 = {\n    bracketSpacing: commonOptions.bracketSpacing,\n    singleQuote: commonOptions.singleQuote,\n    proseWrap: commonOptions.proseWrap\n  };\n\n  var name$h = \"YAML\";\n  var type$g = \"data\";\n  var tmScope$g = \"source.yaml\";\n  var aliases$6 = [\n  \t\"yml\"\n  ];\n  var extensions$g = [\n  \t\".yml\",\n  \t\".mir\",\n  \t\".reek\",\n  \t\".rviz\",\n  \t\".sublime-syntax\",\n  \t\".syntax\",\n  \t\".yaml\",\n  \t\".yaml-tmlanguage\",\n  \t\".yml.mysql\"\n  ];\n  var filenames$4 = [\n  \t\".clang-format\",\n  \t\".clang-tidy\",\n  \t\".gemrc\",\n  \t\"glide.lock\"\n  ];\n  var aceMode$g = \"yaml\";\n  var codemirrorMode$c = \"yaml\";\n  var codemirrorMimeType$c = \"text/x-yaml\";\n  var languageId$g = 407;\n  var YAML = {\n  \tname: name$h,\n  \ttype: type$g,\n  \ttmScope: tmScope$g,\n  \taliases: aliases$6,\n  \textensions: extensions$g,\n  \tfilenames: filenames$4,\n  \taceMode: aceMode$g,\n  \tcodemirrorMode: codemirrorMode$c,\n  \tcodemirrorMimeType: codemirrorMimeType$c,\n  \tlanguageId: languageId$g\n  };\n\n  var YAML$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    name: name$h,\n    type: type$g,\n    tmScope: tmScope$g,\n    aliases: aliases$6,\n    extensions: extensions$g,\n    filenames: filenames$4,\n    aceMode: aceMode$g,\n    codemirrorMode: codemirrorMode$c,\n    codemirrorMimeType: codemirrorMimeType$c,\n    languageId: languageId$g,\n    'default': YAML\n  });\n\n  var require$$0$8 = getCjsExportFromNamespace(YAML$1);\n\n  var languages$6 = [createLanguage(require$$0$8, function (data) {\n    return Object.assign(data, {\n      since: \"1.14.0\",\n      parsers: [\"yaml\"],\n      vscodeLanguageIds: [\"yaml\"]\n    });\n  })];\n  var languageYaml = {\n    languages: languages$6,\n    printers: {\n      yaml: printerYaml\n    },\n    options: options$7\n  };\n\n  var version$2 = require$$0.version;\n  var getSupportInfo$2 = support.getSupportInfo;\n  var internalPlugins = [languageCss, languageGraphql, languageHandlebars, languageHtml, languageJs, languageMarkdown, languageYaml];\n\n  var isArray$1 = Array.isArray || function (arr) {\n    return Object.prototype.toString.call(arr) === \"[object Array]\";\n  }; // Luckily `opts` is always the 2nd argument\n\n\n  function withPlugins(fn) {\n    return function () {\n      var args = Array.from(arguments);\n      var plugins = args[1] && args[1].plugins || [];\n\n      if (!isArray$1(plugins)) {\n        plugins = Object.values(plugins);\n      }\n\n      args[1] = Object.assign({}, args[1], {\n        plugins: internalPlugins.concat(plugins)\n      });\n      return fn.apply(null, args);\n    };\n  }\n\n  var formatWithCursor = withPlugins(core.formatWithCursor);\n  var standalone = {\n    formatWithCursor: formatWithCursor,\n    format: function format(text, opts) {\n      return formatWithCursor(text, opts).formatted;\n    },\n    check: function check(text, opts) {\n      var formatted = formatWithCursor(text, opts).formatted;\n      return formatted === text;\n    },\n    doc: doc,\n    getSupportInfo: withPlugins(getSupportInfo$2),\n    version: version$2,\n    util: utilShared,\n    __debug: {\n      parse: withPlugins(core.parse),\n      formatAST: withPlugins(core.formatAST),\n      formatDoc: withPlugins(core.formatDoc),\n      printToDoc: withPlugins(core.printToDoc),\n      printDocToString: withPlugins(core.printDocToString)\n    }\n  };\n\n  var standalone$1 = standalone;\n\n  return standalone$1;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJldHRpZXIvc3RhbmRhbG9uZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLEVBQUUsS0FBNEQ7QUFDOUQsRUFBRSxDQUNzRDtBQUN4RCxDQUFDLHNCQUFzQjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSEFBb0gsbUJBQW1CLG1CQUFtQix1QkFBdUI7QUFDakwsMElBQTBJLG1CQUFtQixtQkFBbUIsdUJBQXVCO0FBQ3ZNLDJJQUEySSx1QkFBdUI7QUFDbEs7QUFDQTtBQUNBLDZCQUE2Qiw0QkFBNEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0JBQWdCLFVBQVUsdUNBQXVDO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRCxnQkFBZ0I7O0FBRXBFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdELCtCQUErQjtBQUMvRTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEdBQUc7O0FBRVY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFROzs7QUFHUjtBQUNBLGlEQUFpRCw0QkFBNEI7QUFDN0U7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBOztBQUVBLHNGQUFzRjs7QUFFdEY7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLDZCQUE2QjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsV0FBVzs7QUFFdEQsb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EscURBQXFEOztBQUVyRDtBQUNBO0FBQ0EsTUFBTTs7O0FBR04sb0JBQW9CLDZCQUE2QjtBQUNqRDs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRCQUE0QixFQUFFO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvREFBb0QsZ0JBQWdCO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTtBQUNBLDhCQUE4Qjs7QUFFOUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07OztBQUdOLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLDJCQUEyQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7OztBQUdBO0FBQ0EsTUFBTTs7O0FBR047O0FBRUEscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCOzs7QUFHdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQSxTQUFTLEtBQUs7OztBQUdkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7O0FBRzVCO0FBQ0EsWUFBWTtBQUNaLDRCQUE0Qjs7O0FBRzVCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHlCQUF5Qjs7O0FBR3pCO0FBQ0EsUUFBUTtBQUNSLDBCQUEwQjs7O0FBRzFCO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLG9CQUFvQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLG9CQUFvQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IscUJBQU0sbUJBQW1CLHFCQUFNOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7OztBQUdBLDRFQUE0RTs7QUFFNUUsK0NBQStDOztBQUUvQztBQUNBOztBQUVBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBLDZDQUE2QyxVQUFVO0FBQ3ZEO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsV0FBVzs7QUFFdEI7QUFDQTtBQUNBOztBQUVBLFdBQVcsV0FBVzs7QUFFdEI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxXQUFXOztBQUV0QjtBQUNBOztBQUVBLFdBQVcsVUFBVTs7QUFFckI7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQixpQkFBaUI7QUFDakM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7O0FBRTdCOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOERBQThEOztBQUU5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0QsRUFBRTtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6QixNQUFNO0FBQ04sOEJBQThCO0FBQzlCLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQSwyQkFBMkIsUUFBUTtBQUNuQzs7QUFFQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLE1BQU07QUFDTjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7O0FBRVIsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQ7QUFDNUQsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLFNBQVM7QUFDakM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMERBQTBELE9BQU87QUFDakU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBEQUEwRCxPQUFPO0FBQ2pFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUJBQWlCOztBQUU5RDtBQUNBLDREQUE0RDs7QUFFNUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0VBQWtFOztBQUVsRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBEOztBQUUxRCxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsWUFBWTtBQUNoQyx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7O0FBR1o7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCLElBQUk7QUFDSjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQSx3SEFBd0gscUJBQU0sbUJBQW1CLHFCQUFNOztBQUV2SjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7QUFDekMsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixvQkFBb0I7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0Qix3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBLGdFQUFnRTtBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1S0FBdUs7QUFDdks7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0hBQXdIO0FBQ3hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUlBQWlJO0FBQ2pJOztBQUVBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQSxvR0FBb0c7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGOztBQUVBO0FBQ0EseUNBQXlDLG9DQUFvQyxpQkFBaUIsb0NBQW9DLG1CQUFtQixvQ0FBb0M7QUFDekw7QUFDQSxzREFBc0Q7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjs7QUFFaEY7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGOztBQUVBO0FBQ0EsbUhBQW1IOztBQUVuSDtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0lBQXNJOztBQUV0STtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQSxvQkFBb0IsT0FBTztBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSLE9BQU87QUFDUDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQ7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQSw2REFBNkQ7O0FBRTdELGdFQUFnRTs7QUFFaEUsZ0VBQWdFOztBQUVoRSw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUCxPQUFPO0FBQ1A7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7O0FBR047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjs7O0FBR0E7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUyxHQUFHO0FBQ1o7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTs7O0FBR1I7O0FBRUEsc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTs7O0FBR1IsOEJBQThCOztBQUU5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsdUNBQXVDO0FBQ3ZELGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixpQkFBaUI7QUFDakMsZ0JBQWdCLGlCQUFpQjtBQUNqQyxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0Isb0JBQW9CO0FBQ3BDLGdCQUFnQix5QkFBeUI7QUFDekMsZ0JBQWdCLG9CQUFvQjtBQUNwQyxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDLGVBQWUsaUJBQWlCLHNCQUFzQixZQUFZLGtDQUFrQyxHQUFHO0FBQ3ZHO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixrQkFBa0I7QUFDbEMsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLGlCQUFpQjtBQUNqQzs7QUFFQSxlQUFlLDhCQUE4Qjs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBLEtBQUs7QUFDTCxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsU0FBUztBQUNULFFBQVE7OztBQUdSO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxPQUFPO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhIQUE4SCxjQUFjO0FBQzVJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzTEFBc0wseUNBQXlDLFFBQVE7QUFDdk87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzQkFBc0I7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUTtBQUMxRDtBQUNBOztBQUVBLHlDQUF5QyxRQUFRO0FBQ2pELHVEQUF1RCxRQUFRO0FBQy9EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHO0FBQzNHO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQSxTQUFTLGlCQUFpQjtBQUMxQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDs7QUFFQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDLDBEQUEwRDs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLE9BQU87QUFDN0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7O0FBRTVFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9EQUFvRCxFQUFFLFVBQVUsRUFBRTs7QUFFbEU7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0IsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsRUFBRTtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxFQUFFLG9CQUFvQixvQkFBb0I7QUFDdkY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBLDJEQUEyRCwwQkFBMEI7QUFDckY7QUFDQTs7QUFFQSw4REFBOEQsNEJBQTRCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtRUFBbUUsNEJBQTRCO0FBQy9GOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLEdBQUc7QUFDeEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsRUFBRSxVQUFVLEVBQUUsVUFBVSx1RUFBdUU7QUFDdEk7QUFDQTtBQUNBLGtDQUFrQyxFQUFFLFVBQVUsRUFBRTtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkRBQTZELGdFQUFnRTtBQUM3SDs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0RBQStELG1FQUFtRTtBQUNsSTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlFQUF5RSxtRUFBbUU7QUFDNUk7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwREFBMEQsMEJBQTBCO0FBQ3BGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsOElBQThJO0FBQzlJO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJIQUEySDs7QUFFM0gsK0RBQStEOztBQUUvRDtBQUNBOztBQUVBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2REFBNkQsMEJBQTBCO0FBQ3ZGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwRUFBMEUsNEJBQTRCO0FBQ3RHOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEVBQTRFLDRCQUE0QjtBQUN4Rzs7QUFFQTtBQUNBOztBQUVBLHNEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU8sR0FBRzs7QUFFViwwRUFBMEU7QUFDMUU7O0FBRUEsaUNBQWlDOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUZBQXVGLGdFQUFnRTtBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7QUFFVixRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0Isb0JBQW9CO0FBQzFDLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0EsNkNBQTZDO0FBQzdDLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxRUFBcUUsZ0VBQWdFO0FBQ3JJOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVYsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVYsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0EsNEVBQTRFLGFBQWE7QUFDekY7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUdBQXlHO0FBQ3pHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrRUFBa0UsZ0VBQWdFO0FBQ2xJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9FQUFvRSxtRUFBbUU7QUFDdkk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvRUFBb0UsbUVBQW1FO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0VBQW9FLG1FQUFtRTtBQUN2STtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQThELGdFQUFnRTtBQUM5SDtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBLFlBQVk7OztBQUdaO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdFQUFnRSxtRUFBbUU7QUFDbkk7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnRUFBZ0UsbUVBQW1FO0FBQ25JOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEVBQTRFLDBCQUEwQjtBQUN0RztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhFQUE4RSw0QkFBNEI7QUFDMUc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLGdDQUFnQztBQUN4SDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVGQUF1RixtRUFBbUU7QUFDMUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwRkFBMEYsbUVBQW1FO0FBQzdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2RUFBNkUsZ0VBQWdFO0FBQzdJO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlGQUFpRixtRUFBbUU7QUFDcEo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDhFQUE4RSw0QkFBNEI7QUFDMUc7O0FBRUEsd0RBQXdEOztBQUV4RDtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkVBQTZFO0FBQzdFLE1BQU07QUFDTiwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0VBQWtFLGdFQUFnRTtBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkY7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQUk7QUFDVjtBQUNBLEtBQUssOENBQThDO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRztBQUNSOztBQUVBLGlHQUFpRyxNQUFNLE9BQU8sSUFBSSxHQUFHLElBQUksS0FBSyxpSkFBaUosK0JBQStCLElBQUksOENBQThDLGtKQUFrSixFQUFFLE1BQU0sYUFBYSwyQkFBMkIsRUFBRSxtQkFBbUIsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLE9BQU8sSUFBSSxXQUFXLE9BQU87O0FBRXRtQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsMENBQTBDLHFFQUFxRSx3Q0FBd0MseUNBQXlDLHdDQUF3Qyw4Q0FBOEM7QUFDelc7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEZBQTRGOztBQUU1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0EseUNBQXlDO0FBQ3pDLFFBQVE7OztBQUdSOztBQUVBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQTs7QUFFQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsUUFBUTtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQ0FBb0MsUUFBUTtBQUM1Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEVBQTRFLGFBQWE7QUFDekY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLG1DQUFtQzs7QUFFbkMsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsZUFBZTtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0VBQXNFLGdFQUFnRTtBQUN0STs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUZBQXFGLG1FQUFtRTtBQUN4SjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyx3QkFBd0Isb0JBQW9CO0FBQ2hGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLLElBQUk7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EseUZBQXlGO0FBQ3pGLEtBQUssa0JBQWtCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHNEQUFzRDtBQUN0RCxLQUFLLElBQUk7QUFDVCx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EscURBQXFEOztBQUVyRDs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsYUFBYTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRSxnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNEQUFzRCwwQkFBMEI7QUFDaEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBOzs7QUFHQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixhQUFhLEtBQUs7QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsaUNBQWlDO0FBQ3ZEO0FBQ0EsUUFBUTs7O0FBR1IsaURBQWlEO0FBQ2pEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw2Q0FBNkMsNEJBQTRCLG9EQUFvRCxJQUFJLElBQUksSUFBSSxJQUFJO0FBQzdJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixtQkFBbUI7QUFDdkMsd0NBQXdDOztBQUV4QztBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUNBQW1DOztBQUVuQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7O0FBRUE7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QixlQUFlO0FBQ2Y7OztBQUdBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7OztBQUdBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGdCQUFnQjtBQUM3QixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsaUJBQWlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsZ0JBQWdCO0FBQzdCLGVBQWU7QUFDZjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxnQkFBZ0I7QUFDN0IsYUFBYSxjQUFjO0FBQzNCLGVBQWU7QUFDZjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsY0FBYztBQUMzQixlQUFlO0FBQ2Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmOzs7QUFHQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsR0FBRztBQUNoQixhQUFhLHFCQUFxQjtBQUNsQzs7O0FBR0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7OztBQUdBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQSxlQUFlLGdCQUFnQjs7QUFFL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsR0FBRztBQUNoQixhQUFhLHFCQUFxQjtBQUNsQyxlQUFlO0FBQ2Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7OztBQUdBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQSxlQUFlLGdCQUFnQjs7QUFFL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxHQUFHO0FBQ2hCLGFBQWEscUJBQXFCO0FBQ2xDLGVBQWU7QUFDZjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLEdBQUc7QUFDaEIsYUFBYSxxQkFBcUI7QUFDbEMsZUFBZTtBQUNmOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLGNBQWM7QUFDM0IsZUFBZTtBQUNmOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUEyQztBQUN6RCxhQUFhLFFBQVE7QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUNBQXlDO0FBQ3ZELGFBQWEsUUFBUTtBQUNyQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLHdDQUF3QztBQUM1QywwQ0FBMEM7QUFDMUM7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsZUFBZTtBQUNmOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLGtCQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDZCQUE2Qjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNkJBQTZCOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0EsZUFBZSxPQUFPOztBQUV0Qix3SkFBd0o7QUFDeEo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQixhQUFhLFVBQVU7QUFDdkIsZUFBZTtBQUNmOzs7QUFHQTtBQUNBLHlEQUF5RDs7QUFFekQsc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjs7O0FBR0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQThELGdFQUFnRTtBQUM5SDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5RUFBeUUsbUVBQW1FO0FBQzVJOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzREFBc0Q7O0FBRW5FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSyw0REFBNEQ7QUFDakU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDREQUE0RCxnRUFBZ0U7QUFDNUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsMENBQTBDLHNDQUFzQztBQUNoRjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0IsY0FBYyxrQkFBa0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsUUFBUTtBQUMvRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxxRUFBcUUsU0FBUztBQUM5RTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxnQ0FBZ0M7QUFDaEM7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLHNCQUFzQjtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCO0FBQzdCO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ04sNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOLDZCQUE2QjtBQUM3QjtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0RBQWdELGdDQUFnQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkZBQTZGO0FBQzdGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkZBQTZGO0FBQzdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7OztBQUdBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9GQUFvRixnRUFBZ0U7QUFDcEo7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdGQUF3RixtRUFBbUU7QUFDM0o7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0dBQXNHLG1FQUFtRTtBQUN6SztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkMsb0NBQW9DO0FBQy9FO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUwsMkNBQTJDOztBQUUzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1RUFBdUUsZ0VBQWdFO0FBQ3ZJOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssbUJBQW1CO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhHQUE4Rzs7QUFFOUc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsS0FBSywrQkFBK0I7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7O0FBRUEsa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNEOztBQUV0RDtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwREFBMEQ7QUFDMUQ7O0FBRUE7QUFDQSwwREFBMEQ7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdIQUF3SCx5SEFBeUgsZ0RBQWdELGFBQWE7QUFDOVM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseURBQXlELGtwQkFBa3BCLDRGQUE0Rix1SEFBdUgsV0FBVztBQUN6NkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG10QkFBbXRCLHlIQUF5SCwrSEFBK0gsV0FBVztBQUN0OUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0VBQXNFOztBQUV0RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQix3QkFBd0I7QUFDbEQscUNBQXFDOzs7QUFHckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDs7QUFFcEQ7QUFDQTtBQUNBLGNBQWMsNkRBQTZELFdBQVc7OztBQUd0Riw4R0FBOEc7QUFDOUcsdUpBQXVKOztBQUV2SjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYzs7O0FBR2Q7QUFDQTtBQUNBLGNBQWMsbUNBQW1DOzs7QUFHakQ7QUFDQTtBQUNBLGNBQWMsZ0ZBQWdGOzs7QUFHOUY7QUFDQTtBQUNBLGNBQWM7OztBQUdkO0FBQ0E7QUFDQSxjQUFjOzs7QUFHZDtBQUNBO0FBQ0EsY0FBYyx3Q0FBd0M7OztBQUd0RDtBQUNBO0FBQ0EsY0FBYyx1REFBdUQ7OztBQUdyRTtBQUNBO0FBQ0EsY0FBYyx1Q0FBdUMsZUFBZSxpQ0FBaUMsU0FBUzs7O0FBRzlHO0FBQ0E7QUFDQSxjQUFjLDZEQUE2RCxLQUFLOzs7QUFHaEY7QUFDQTtBQUNBLGNBQWM7OztBQUdkO0FBQ0Esc0VBQXNFO0FBQ3RFLHdCQUF3QixLQUFLLFFBQVEsTUFBTSxRQUFRLEtBQUssU0FBUyxNQUFNO0FBQ3ZFLDBCQUEwQixLQUFLLFNBQVMsS0FBSyxTQUFTLEtBQUssVUFBVSxLQUFLOztBQUUxRTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQSxnTUFBZ007O0FBRWhNO0FBQ0E7QUFDQSxjQUFjLG9FQUFvRTs7O0FBR2xGO0FBQ0E7O0FBRUE7QUFDQSxjQUFjOzs7QUFHZDtBQUNBOztBQUVBO0FBQ0EsY0FBYzs7O0FBR2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7OztBQUdkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjOzs7QUFHZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDZCQUE2QixzQkFBc0I7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLFdBQVcsbUNBQW1DO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxzUUFBc1E7QUFDM1M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyYkFBMmI7QUFDM2I7QUFDQSxXQUFXLCtCQUErQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxUEFBcVA7QUFDclA7QUFDQSxXQUFXLCtCQUErQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2UEFBNlA7QUFDN1A7QUFDQSxXQUFXLCtCQUErQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0EsV0FBVyw0Q0FBNEM7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK1BBQStQO0FBQy9QO0FBQ0EsV0FBVywrQkFBK0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRCxrSUFBa0k7QUFDbEk7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQSxxREFBcUQseUNBQXlDLHFKQUFxSixNQUFNO0FBQ3pQLFlBQVk7QUFDWiwwQ0FBMEMseUNBQXlDO0FBQ25GOztBQUVBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2REFBNkQsT0FBTztBQUNwRTtBQUNBLFdBQVcseURBQXlELE9BQU87QUFDM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDO0FBQ2xDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyw4QkFBOEIsZ0NBQWdDO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGVBQWU7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLHlFQUF5RTtBQUN6Rzs7QUFFQTtBQUNBLHdCQUF3QixpQ0FBaUM7QUFDekQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQsZ0VBQWdFO0FBQzVIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlEQUF5RCwwQkFBMEI7QUFDbkY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsUUFBUTtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5RUFBeUUsbUVBQW1FO0FBQzVJOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtCQUErQix3QkFBd0I7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwRUFBMEUsZ0VBQWdFO0FBQzFJO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEIsMEJBQTBCO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQiwwQkFBMEI7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQiwwQkFBMEI7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsRUFBRSxZQUFZLEVBQUU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3RUFBd0UsbUVBQW1FO0FBQzNJOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQix1QkFBdUI7QUFDakQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUEsc0VBQXNFLE1BQU0sT0FBTzs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDs7QUFFL0QsdUhBQXVIOztBQUV2SDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQ7O0FBRXpEO0FBQ0EsK0JBQStCO0FBQy9CLFlBQVk7QUFDWjs7O0FBR0EsMERBQTBEOztBQUUxRCw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RDs7QUFFeEQsZ0NBQWdDO0FBQ2hDLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjs7QUFFQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsaURBQWlEOztBQUVqRCxrQ0FBa0M7O0FBRWxDOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQjs7QUFFaEIsY0FBYztBQUNkO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7O0FBR2Qsc0JBQXNCO0FBQ3RCLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCOztBQUVoQixjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFlBQVk7QUFDWjtBQUNBLHNFQUFzRTs7QUFFdEUsYUFBYTtBQUNiO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0NBQW9DLElBQUk7OztBQUdwRDtBQUNBO0FBQ0EsWUFBWSxtQ0FBbUMsTUFBTTs7O0FBR3JEO0FBQ0EseUNBQXlDLFNBQVM7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVcsb1BBQW9QO0FBQy9QO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwySUFBMkksaUNBQWlDO0FBQzVLOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQSxrQ0FBa0MsRUFBRSxZQUFZLEVBQUU7O0FBRWxEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0Esd0VBQXdFOztBQUV4RSxlQUFlLGlCQUFpQjtBQUNoQyxjQUFjO0FBQ2QsNEJBQTRCLDZEQUE2RDtBQUN6RjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLHdPQUF3TztBQUN4TztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7O0FBRWxCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0Msb0JBQW9CO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQLDZCQUE2QjtBQUM3QjtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBOztBQUVBLGlEQUFpRDtBQUNqRCwrQkFBK0IsS0FBSzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0EsOERBQThELGlCQUFpQjtBQUMvRTs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLEdBQUc7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsS0FBSyxVQUFVLEVBQUU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQyxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdLQUFnSztBQUNoSyxzRkFBc0Y7QUFDdEYsNkVBQTZFO0FBQzdFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUVBQXFFLGdFQUFnRTtBQUNySTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxJQUFJOzs7QUFHSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQix1QkFBdUI7QUFDN0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsZ0RBQWdEO0FBQ2hGOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBTSxxQkFBcUI7OztBQUczQjtBQUNBO0FBQ0EsTUFBTSx1REFBdUQ7OztBQUc3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxNQUFNLDREQUE0RDtBQUNsRSxnREFBZ0Q7OztBQUdoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sY0FBYyxjQUFjLE1BQU07OztBQUd4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNOzs7QUFHTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSw0Q0FBNEMsSUFBSTs7O0FBR3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBLElBQUk7QUFDSixnQkFBZ0I7QUFDaEIsZ0JBQWdCOzs7QUFHaEI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSSxPQUFPLHFDQUFxQzs7O0FBR2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDhCQUE4QixLQUFLO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQ0FBa0M7OztBQUdyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBLHdCQUF3QixPQUFPO0FBQy9COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyREFBMkQsZ0VBQWdFO0FBQzNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RSxtRUFBbUU7QUFDL0k7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0EsMkZBQTJGLDRCQUE0QixPQUFPOztBQUU5SDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVAsdUJBQXVCLE1BQU07QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0VBQWdFLGdFQUFnRTtBQUNoSTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLDBCQUEwQjs7O0FBR2hDO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxLQUFLLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMEVBQTBFO0FBQzFFOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMsSUFBSTtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1SQUFtUjtBQUNuUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQiwyQkFBMkI7QUFDM0MsZ0JBQWdCLHFEQUFxRDtBQUNyRSxnQkFBZ0IsU0FBUztBQUN6QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsU0FBUztBQUN6QixhQUFhLFVBQVU7QUFDdkIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsVUFBVTtBQUN2QixhQUFhLGlCQUFpQjtBQUM5QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZHQUE2RztBQUM3RztBQUNBLFVBQVU7OztBQUdWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEI7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0Esd0RBQXdELGdDQUFnQzs7O0FBR3hGO0FBQ0EscUdBQXFHO0FBQ3JHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IscUNBQXFDLDhGQUE4RjtBQUNuSSxjQUFjO0FBQ2QsNkNBQTZDLG9OQUFvTjtBQUNqUTs7QUFFQTtBQUNBLFlBQVksaUVBQWlFO0FBQzdFLFlBQVksSUFBSTtBQUNoQiwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBLHVCQUF1QixJQUFJOztBQUUzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxrVEFBa1Q7QUFDbFQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVzs7QUFFWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsc0RBQXNELG1GQUFtRjtBQUN6SSxzQ0FBc0MsT0FBTztBQUM3Qyx3Q0FBd0MsTUFBTSxHQUFHO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUEsdUZBQXVGO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0VBQXdFO0FBQ3hFOztBQUVBLG9KQUFvSix1Q0FBdUM7QUFDM0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0pBQWtKO0FBQ2xKO0FBQ0E7QUFDQSxTQUFTLG1DQUFtQzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7O0FBRTFDLDJDQUEyQyx3QkFBd0I7QUFDbkU7O0FBRUEsaURBQWlELFdBQVc7O0FBRTVEO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVyxrRUFBa0U7QUFDN0U7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsdUNBQXVDLDJEQUEyRDtBQUNsRzs7QUFFQSxxQ0FBcUMseUdBQXlHO0FBQzlJOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0xBQXdMOztBQUV4TDtBQUNBO0FBQ0EsWUFBWTs7O0FBR1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGOztBQUVBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBLFNBQVMsNEVBQTRFOztBQUVyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpRUFBaUUsS0FBSztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDLG9DQUFvQztBQUNsRjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsZ0VBQWdFO0FBQzNHLFlBQVk7QUFDWiwyQ0FBMkM7QUFDM0M7QUFDQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSwwSUFBMEk7QUFDMUk7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixtQkFBbUI7QUFDOUM7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDOzs7QUFHL0Msc2tCQUFza0I7QUFDdGtCO0FBQ0EsZUFBZTtBQUNmOztBQUVBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXOztBQUVYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUhBQXVIO0FBQ3ZIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7O0FBR1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFDQUFxQztBQUNyQztBQUNBLGlFQUFpRTtBQUNqRTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlDQUF5QyxnRUFBZ0U7QUFDekcsVUFBVTtBQUNWLHlDQUF5QztBQUN6QztBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtSEFBbUg7QUFDbkgsbUNBQW1DOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEdBQThHO0FBQzlHLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVix1QkFBdUI7QUFDdkI7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLFVBQVU7QUFDVjs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRyxJQUFJLEdBQUcsSUFBSTtBQUN2QixTQUFTLEdBQUcsSUFBSSxHQUFHLElBQUk7QUFDdkIsU0FBUyxHQUFHLElBQUksR0FBRyxJQUFJO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0JBQWtCLDRDQUE0QztBQUM5RDtBQUNBO0FBQ0EsU0FBUyxpQkFBaUI7QUFDMUIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVAsc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHFCQUFxQixLQUFLOzs7QUFHaEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDhMQUE4TDs7QUFFOUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsVUFBVTtBQUNWLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLE1BQU0sNkJBQTZCLHFFQUFxRTs7O0FBR3hHO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHFCQUFxQjs7O0FBRzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyx1TkFBdU47QUFDalEsWUFBWTtBQUNaLGtDQUFrQyxpR0FBaUc7QUFDbkk7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUixzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFIQUFxSDtBQUNySDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLLGFBQWE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSw2QkFBNkI7QUFDMUM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sR0FBRztBQUNWOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSyxvRUFBb0U7QUFDekU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssNENBQTRDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsSUFBSTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBOztBQUVBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQSxZQUFZOzs7QUFHWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxhQUFhLElBQUk7QUFDdkI7QUFDQSw2Q0FBNkMsSUFBSTs7O0FBR2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHdHQUF3Rzs7QUFFeEc7QUFDQSxtREFBbUQsSUFBSSxNQUFNLElBQUk7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssY0FBYztBQUNuQjtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixJQUFJO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7OztBQUdaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNE9BQTRPO0FBQzVPOztBQUVBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxrSUFBa0ksRUFBRTtBQUNwSTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxnQkFBZ0IsdUhBQXVIOztBQUV4TDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUSw2Q0FBNkMsSUFBSSw2QkFBNkI7QUFDcEc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZ0NBQWdDO0FBQ3hFO0FBQ0EsK0NBQStDOztBQUUvQyxxR0FBcUc7QUFDckc7O0FBRUEsd0NBQXdDLElBQUk7QUFDNUM7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCO0FBQzdCO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLDZCQUE2QjtBQUM3QjtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsR0FBRztBQUNwQzs7QUFFQTtBQUNBLDBCQUEwQix3QkFBd0I7QUFDbEQseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7O0FBR1o7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwRUFBMEUsZ0VBQWdFO0FBQzFJOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixLQUFLLHNCQUFzQjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLLGVBQWU7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixpQ0FBaUM7O0FBRXJELGVBQWUsT0FBTywyQ0FBMkMsR0FBRztBQUNwRTtBQUNBLGVBQWUsdUJBQXVCOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsa0NBQWtDOzs7QUFHakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCw2QkFBNkI7QUFDN0I7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckMsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHFCQUFxQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEIsYUFBYSxXQUFXO0FBQ3hCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxnQkFBZ0I7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEVBQTBFLGdFQUFnRTtBQUMxSTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELDREQUE0RDtBQUM1RDs7QUFFQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdDQUFnQztBQUNoQztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3ByZXR0aWVyL3N0YW5kYWxvbmUuanM/MzQyNSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLnByZXR0aWVyID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBuYW1lID0gXCJwcmV0dGllclwiO1xuICB2YXIgdmVyc2lvbiA9IFwiMS4xOS4xXCI7XG4gIHZhciBkZXNjcmlwdGlvbiA9IFwiUHJldHRpZXIgaXMgYW4gb3BpbmlvbmF0ZWQgY29kZSBmb3JtYXR0ZXJcIjtcbiAgdmFyIGJpbiA9IHtcbiAgXHRwcmV0dGllcjogXCIuL2Jpbi9wcmV0dGllci5qc1wiXG4gIH07XG4gIHZhciByZXBvc2l0b3J5ID0gXCJwcmV0dGllci9wcmV0dGllclwiO1xuICB2YXIgaG9tZXBhZ2UgPSBcImh0dHBzOi8vcHJldHRpZXIuaW9cIjtcbiAgdmFyIGF1dGhvciA9IFwiSmFtZXMgTG9uZ1wiO1xuICB2YXIgbGljZW5zZSA9IFwiTUlUXCI7XG4gIHZhciBtYWluID0gXCIuL2luZGV4LmpzXCI7XG4gIHZhciBlbmdpbmVzID0ge1xuICBcdG5vZGU6IFwiPj04XCJcbiAgfTtcbiAgdmFyIGRlcGVuZGVuY2llcyA9IHtcbiAgXHRcIkBhbmd1bGFyL2NvbXBpbGVyXCI6IFwiOC4yLjEzXCIsXG4gIFx0XCJAYmFiZWwvY29kZS1mcmFtZVwiOiBcIjcuNS41XCIsXG4gIFx0XCJAYmFiZWwvcGFyc2VyXCI6IFwiNy43LjNcIixcbiAgXHRcIkBnbGltbWVyL3N5bnRheFwiOiBcIjAuNDEuMFwiLFxuICBcdFwiQGlhcm5hL3RvbWxcIjogXCIyLjIuM1wiLFxuICBcdFwiQHR5cGVzY3JpcHQtZXNsaW50L3R5cGVzY3JpcHQtZXN0cmVlXCI6IFwiMi42LjFcIixcbiAgXHRcImFuZ3VsYXItZXN0cmVlLXBhcnNlclwiOiBcIjEuMS41XCIsXG4gIFx0XCJhbmd1bGFyLWh0bWwtcGFyc2VyXCI6IFwiMS4zLjBcIixcbiAgXHRjYW1lbGNhc2U6IFwiNS4zLjFcIixcbiAgXHRjaGFsazogXCIyLjQuMlwiLFxuICBcdFwiY2prLXJlZ2V4XCI6IFwiMi4wLjBcIixcbiAgXHRjb3NtaWNvbmZpZzogXCI1LjIuMVwiLFxuICBcdGRhc2hpZnk6IFwiMi4wLjBcIixcbiAgXHRkZWRlbnQ6IFwiMC43LjBcIixcbiAgXHRkaWZmOiBcIjQuMC4xXCIsXG4gIFx0ZWRpdG9yY29uZmlnOiBcIjAuMTUuM1wiLFxuICBcdFwiZWRpdG9yY29uZmlnLXRvLXByZXR0aWVyXCI6IFwiMC4xLjFcIixcbiAgXHRcImVzY2FwZS1zdHJpbmctcmVnZXhwXCI6IFwiMS4wLjVcIixcbiAgXHRlc3V0aWxzOiBcIjIuMC4zXCIsXG4gIFx0XCJmaW5kLXBhcmVudC1kaXJcIjogXCIwLjMuMFwiLFxuICBcdFwiZmluZC1wcm9qZWN0LXJvb3RcIjogXCIxLjEuMVwiLFxuICBcdFwiZmxvdy1wYXJzZXJcIjogXCIwLjExMS4zXCIsXG4gIFx0XCJnZXQtc3RyZWFtXCI6IFwiNC4xLjBcIixcbiAgXHRnbG9iYnk6IFwiNi4xLjBcIixcbiAgXHRncmFwaHFsOiBcIjE0LjUuOFwiLFxuICBcdFwiaHRtbC1lbGVtZW50LWF0dHJpYnV0ZXNcIjogXCIyLjIuMFwiLFxuICBcdFwiaHRtbC1zdHlsZXNcIjogXCIxLjAuMFwiLFxuICBcdFwiaHRtbC10YWctbmFtZXNcIjogXCIxLjEuNFwiLFxuICBcdGlnbm9yZTogXCI0LjAuNlwiLFxuICBcdFwiaXMtY2lcIjogXCIyLjAuMFwiLFxuICBcdFwiamVzdC1kb2NibG9ja1wiOiBcIjI0LjkuMFwiLFxuICBcdFwianNvbi1zdGFibGUtc3RyaW5naWZ5XCI6IFwiMS4wLjFcIixcbiAgXHRsZXZlbjogXCIzLjEuMFwiLFxuICBcdFwibGluZXMtYW5kLWNvbHVtbnNcIjogXCIxLjEuNlwiLFxuICBcdFwibGluZ3Vpc3QtbGFuZ3VhZ2VzXCI6IFwiNy42LjBcIixcbiAgXHRcImxvZGFzaC51bmlxYnlcIjogXCI0LjcuMFwiLFxuICBcdG1lbTogXCI1LjEuMVwiLFxuICBcdG1pbmltYXRjaDogXCIzLjAuNFwiLFxuICBcdG1pbmltaXN0OiBcIjEuMi4wXCIsXG4gIFx0XCJuLXJlYWRsaW5lc1wiOiBcIjEuMC4wXCIsXG4gIFx0XCJub3JtYWxpemUtcGF0aFwiOiBcIjMuMC4wXCIsXG4gIFx0XCJwYXJzZS1zcmNzZXRcIjogXCJpa2F0eWFuZy9wYXJzZS1zcmNzZXQjNTRlYjljMWNiMjFkYjVjNjJiNGQwZTI3NWQ3MjQ5NTE2ZGY2ZjBlZVwiLFxuICBcdFwicG9zdGNzcy1sZXNzXCI6IFwiMi4wLjBcIixcbiAgXHRcInBvc3Rjc3MtbWVkaWEtcXVlcnktcGFyc2VyXCI6IFwiMC4yLjNcIixcbiAgXHRcInBvc3Rjc3Mtc2Nzc1wiOiBcIjIuMC4wXCIsXG4gIFx0XCJwb3N0Y3NzLXNlbGVjdG9yLXBhcnNlclwiOiBcIjIuMi4zXCIsXG4gIFx0XCJwb3N0Y3NzLXZhbHVlcy1wYXJzZXJcIjogXCIxLjUuMFwiLFxuICBcdFwicmVnZXhwLXV0aWxcIjogXCIxLjIuMlwiLFxuICBcdFwicmVtYXJrLW1hdGhcIjogXCIxLjAuNlwiLFxuICBcdFwicmVtYXJrLXBhcnNlXCI6IFwiNS4wLjBcIixcbiAgXHRyZXNvbHZlOiBcIjEuMTIuMFwiLFxuICBcdHNlbXZlcjogXCI2LjMuMFwiLFxuICBcdFwic3RyaW5nLXdpZHRoXCI6IFwiNC4xLjBcIixcbiAgXHR0eXBlc2NyaXB0OiBcIjMuNy4yXCIsXG4gIFx0XCJ1bmljb2RlLXJlZ2V4XCI6IFwiMy4wLjBcIixcbiAgXHR1bmlmaWVkOiBcIjguNC4xXCIsXG4gIFx0dm5vcHRzOiBcIjEuMC4yXCIsXG4gIFx0XCJ5YW1sLXVuaXN0LXBhcnNlclwiOiBcIjEuMS4xXCJcbiAgfTtcbiAgdmFyIGRldkRlcGVuZGVuY2llcyA9IHtcbiAgXHRcIkBiYWJlbC9jb3JlXCI6IFwiNy43LjJcIixcbiAgXHRcIkBiYWJlbC9wcmVzZXQtZW52XCI6IFwiNy43LjFcIixcbiAgXHRcIkByb2xsdXAvcGx1Z2luLWFsaWFzXCI6IFwiMi4yLjBcIixcbiAgXHRcIkByb2xsdXAvcGx1Z2luLXJlcGxhY2VcIjogXCIyLjIuMVwiLFxuICBcdFwiYmFiZWwtbG9hZGVyXCI6IFwiOC4wLjZcIixcbiAgXHRiZW5jaG1hcms6IFwiMi4xLjRcIixcbiAgXHRcImJ1aWx0aW4tbW9kdWxlc1wiOiBcIjMuMS4wXCIsXG4gIFx0Y29kZWNvdjogXCIzLjYuMVwiLFxuICBcdFwiY3Jvc3MtZW52XCI6IFwiNi4wLjNcIixcbiAgXHRlc2xpbnQ6IFwiNi42LjBcIixcbiAgXHRcImVzbGludC1jb25maWctcHJldHRpZXJcIjogXCI2LjUuMFwiLFxuICBcdFwiZXNsaW50LWZvcm1hdHRlci1mcmllbmRseVwiOiBcIjcuMC4wXCIsXG4gIFx0XCJlc2xpbnQtcGx1Z2luLWltcG9ydFwiOiBcIjIuMTguMlwiLFxuICBcdFwiZXNsaW50LXBsdWdpbi1wcmV0dGllclwiOiBcIjMuMS4xXCIsXG4gIFx0XCJlc2xpbnQtcGx1Z2luLXJlYWN0XCI6IFwiNy4xNi4wXCIsXG4gIFx0ZXhlY2E6IFwiMy4yLjBcIixcbiAgXHRqZXN0OiBcIjIzLjMuMFwiLFxuICBcdFwiamVzdC1qdW5pdFwiOiBcIjkuMC4wXCIsXG4gIFx0XCJqZXN0LXNuYXBzaG90LXNlcmlhbGl6ZXItYW5zaVwiOiBcIjEuMC4wXCIsXG4gIFx0XCJqZXN0LXNuYXBzaG90LXNlcmlhbGl6ZXItcmF3XCI6IFwiMS4xLjBcIixcbiAgXHRcImplc3Qtd2F0Y2gtdHlwZWFoZWFkXCI6IFwiMC40LjBcIixcbiAgXHRta2RpcnA6IFwiMC41LjFcIixcbiAgXHRwcmV0dGllcjogXCIxLjE5LjBcIixcbiAgXHRwcmV0dHlsaW50OiBcIjEuMC4wXCIsXG4gIFx0cmltcmFmOiBcIjMuMC4wXCIsXG4gIFx0cm9sbHVwOiBcIjEuMjYuM1wiLFxuICBcdFwicm9sbHVwLXBsdWdpbi1iYWJlbFwiOiBcIjQuMy4zXCIsXG4gIFx0XCJyb2xsdXAtcGx1Z2luLWNvbW1vbmpzXCI6IFwiMTAuMS4wXCIsXG4gIFx0XCJyb2xsdXAtcGx1Z2luLWpzb25cIjogXCI0LjAuMFwiLFxuICBcdFwicm9sbHVwLXBsdWdpbi1ub2RlLWdsb2JhbHNcIjogXCIxLjQuMFwiLFxuICBcdFwicm9sbHVwLXBsdWdpbi1ub2RlLXJlc29sdmVcIjogXCI1LjIuMFwiLFxuICBcdFwicm9sbHVwLXBsdWdpbi10ZXJzZXJcIjogXCI1LjEuMlwiLFxuICBcdHNoZWxsanM6IFwiMC44LjNcIixcbiAgXHRcInNuYXBzaG90LWRpZmZcIjogXCIwLjQuMFwiLFxuICBcdFwic3RyaXAtYW5zaVwiOiBcIjUuMi4wXCIsXG4gIFx0XCJzeW5jaHJvbm91cy1wcm9taXNlXCI6IFwiMi4wLjEwXCIsXG4gIFx0dGVtcHk6IFwiMC4yLjFcIixcbiAgXHRcInRlcnNlci13ZWJwYWNrLXBsdWdpblwiOiBcIjIuMi4xXCIsXG4gIFx0d2VicGFjazogXCI0LjQxLjJcIlxuICB9O1xuICB2YXIgc2NyaXB0cyA9IHtcbiAgXHRwcmVwdWJsaXNoT25seTogXCJlY2hvIFxcXCJFcnJvcjogbXVzdCBwdWJsaXNoIGZyb20gZGlzdC9cXFwiICYmIGV4aXQgMVwiLFxuICBcdFwicHJlcGFyZS1yZWxlYXNlXCI6IFwieWFybiAmJiB5YXJuIGJ1aWxkICYmIHlhcm4gdGVzdDpkaXN0XCIsXG4gIFx0dGVzdDogXCJqZXN0XCIsXG4gIFx0XCJ0ZXN0OmRpc3RcIjogXCJub2RlIC4vc2NyaXB0cy90ZXN0LWRpc3QuanNcIixcbiAgXHRcInRlc3QtaW50ZWdyYXRpb25cIjogXCJqZXN0IHRlc3RzX2ludGVncmF0aW9uXCIsXG4gIFx0XCJwZXJmLXJlcGVhdFwiOiBcInlhcm4gJiYgeWFybiBidWlsZCAmJiBjcm9zcy1lbnYgTk9ERV9FTlY9cHJvZHVjdGlvbiBub2RlIC4vZGlzdC9iaW4tcHJldHRpZXIuanMgLS1kZWJ1Zy1yZXBlYXQgJHtQRVJGX1JFUEVBVDotMTAwMH0gLS1sb2dsZXZlbCBkZWJ1ZyAke1BFUkZfRklMRTotLi9pbmRleC5qc30gPiAvZGV2L251bGxcIixcbiAgXHRcInBlcmYtcmVwZWF0LWluc3BlY3RcIjogXCJ5YXJuICYmIHlhcm4gYnVpbGQgJiYgY3Jvc3MtZW52IE5PREVfRU5WPXByb2R1Y3Rpb24gbm9kZSAtLWluc3BlY3QtYnJrIC4vZGlzdC9iaW4tcHJldHRpZXIuanMgLS1kZWJ1Zy1yZXBlYXQgJHtQRVJGX1JFUEVBVDotMTAwMH0gLS1sb2dsZXZlbCBkZWJ1ZyAke1BFUkZfRklMRTotLi9pbmRleC5qc30gPiAvZGV2L251bGxcIixcbiAgXHRcInBlcmYtYmVuY2htYXJrXCI6IFwieWFybiAmJiB5YXJuIGJ1aWxkICYmIGNyb3NzLWVudiBOT0RFX0VOVj1wcm9kdWN0aW9uIG5vZGUgLi9kaXN0L2Jpbi1wcmV0dGllci5qcyAtLWRlYnVnLWJlbmNobWFyayAtLWxvZ2xldmVsIGRlYnVnICR7UEVSRl9GSUxFOi0uL2luZGV4LmpzfSA+IC9kZXYvbnVsbFwiLFxuICBcdFwiY2hlY2stdHlwZXNcIjogXCJ0c2NcIixcbiAgXHRsaW50OiBcImNyb3NzLWVudiBFRkZfTk9fTElOS19SVUxFUz10cnVlIGVzbGludCAuIC0tZm9ybWF0IGZyaWVuZGx5XCIsXG4gIFx0XCJsaW50LWRvY3NcIjogXCJwcmV0dHlsaW50IHsuLGRvY3Msd2Vic2l0ZSx3ZWJzaXRlL2Jsb2d9LyoubWRcIixcbiAgXHRcImxpbnQtZGlzdFwiOiBcImVzbGludCAtLW5vLWVzbGludHJjIC0tbm8taWdub3JlIC0tZW52PWJyb3dzZXIgXFxcImRpc3QvIShiaW4tcHJldHRpZXJ8aW5kZXh8dGhpcmQtcGFydHkpLmpzXFxcIlwiLFxuICBcdGJ1aWxkOiBcIm5vZGUgLS1tYXgtb2xkLXNwYWNlLXNpemU9MzA3MiAuL3NjcmlwdHMvYnVpbGQvYnVpbGQuanNcIixcbiAgXHRcImJ1aWxkLWRvY3NcIjogXCJub2RlIC4vc2NyaXB0cy9idWlsZC1kb2NzLmpzXCIsXG4gIFx0XCJjaGVjay1kZXBzXCI6IFwibm9kZSAuL3NjcmlwdHMvY2hlY2stZGVwcy5qc1wiLFxuICBcdHNwZWxsY2hlY2s6IFwibnB4IC1wIGNzcGVsbEA0LjAuMzEgY3NwZWxsIHtiaW4sc2NyaXB0cyxzcmN9LyoqLyouanMge2RvY3Msd2Vic2l0ZS9ibG9nLGNoYW5nZWxvZ191bnJlbGVhc2VkfS8qKi8qLm1kXCJcbiAgfTtcbiAgdmFyIF9wYWNrYWdlID0ge1xuICBcdG5hbWU6IG5hbWUsXG4gIFx0dmVyc2lvbjogdmVyc2lvbixcbiAgXHRkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gIFx0YmluOiBiaW4sXG4gIFx0cmVwb3NpdG9yeTogcmVwb3NpdG9yeSxcbiAgXHRob21lcGFnZTogaG9tZXBhZ2UsXG4gIFx0YXV0aG9yOiBhdXRob3IsXG4gIFx0bGljZW5zZTogbGljZW5zZSxcbiAgXHRtYWluOiBtYWluLFxuICBcdGVuZ2luZXM6IGVuZ2luZXMsXG4gIFx0ZGVwZW5kZW5jaWVzOiBkZXBlbmRlbmNpZXMsXG4gIFx0ZGV2RGVwZW5kZW5jaWVzOiBkZXZEZXBlbmRlbmNpZXMsXG4gIFx0c2NyaXB0czogc2NyaXB0c1xuICB9O1xuXG4gIHZhciBfcGFja2FnZSQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBuYW1lOiBuYW1lLFxuICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuICAgIGJpbjogYmluLFxuICAgIHJlcG9zaXRvcnk6IHJlcG9zaXRvcnksXG4gICAgaG9tZXBhZ2U6IGhvbWVwYWdlLFxuICAgIGF1dGhvcjogYXV0aG9yLFxuICAgIGxpY2Vuc2U6IGxpY2Vuc2UsXG4gICAgbWFpbjogbWFpbixcbiAgICBlbmdpbmVzOiBlbmdpbmVzLFxuICAgIGRlcGVuZGVuY2llczogZGVwZW5kZW5jaWVzLFxuICAgIGRldkRlcGVuZGVuY2llczogZGV2RGVwZW5kZW5jaWVzLFxuICAgIHNjcmlwdHM6IHNjcmlwdHMsXG4gICAgJ2RlZmF1bHQnOiBfcGFja2FnZVxuICB9KTtcblxuICBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xuICB9XG5cbiAgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICAgIG8uX19wcm90b19fID0gcDtcbiAgICAgIHJldHVybiBvO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgICB0cnkge1xuICAgICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICAgIF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDtcbiAgICB9IGVsc2Uge1xuICAgICAgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgICB2YXIgYSA9IFtudWxsXTtcbiAgICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgICBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHtcbiAgICByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICAgIHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7XG5cbiAgICBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICAgICAgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzcztcblxuICAgICAgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7XG5cbiAgICAgICAgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIFdyYXBwZXIoKSB7XG4gICAgICAgIHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7XG4gICAgICB9XG5cbiAgICAgIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogV3JhcHBlcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG4gIH1cblxuICBmdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICAgIF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcblxuICAgICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTtcblxuICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoc3RyaW5ncywgcmF3KSB7XG4gICAgaWYgKCFyYXcpIHtcbiAgICAgIHJhdyA9IHN0cmluZ3Muc2xpY2UoMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc3RyaW5ncywge1xuICAgICAgcmF3OiB7XG4gICAgICAgIHZhbHVlOiBPYmplY3QuZnJlZXplKHJhdylcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cblxuICBmdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICAgIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG4gIH1cblxuICBmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICAgIHJldHVybiBhcnIyO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xuICB9XG5cbiAgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gICAgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXIpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgICBpZiAoIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF9hcnIgPSBbXTtcbiAgICB2YXIgX24gPSB0cnVlO1xuICAgIHZhciBfZCA9IGZhbHNlO1xuICAgIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2QgPSB0cnVlO1xuICAgICAgX2UgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICBmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIERpZmYoKSB7fVxuXG4gIERpZmYucHJvdG90eXBlID0ge1xuICAgIGRpZmY6IGZ1bmN0aW9uIGRpZmYob2xkU3RyaW5nLCBuZXdTdHJpbmcpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgIHZhciBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgZnVuY3Rpb24gZG9uZSh2YWx1ZSkge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgdmFsdWUpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBBbGxvdyBzdWJjbGFzc2VzIHRvIG1hc3NhZ2UgdGhlIGlucHV0IHByaW9yIHRvIHJ1bm5pbmdcblxuXG4gICAgICBvbGRTdHJpbmcgPSB0aGlzLmNhc3RJbnB1dChvbGRTdHJpbmcpO1xuICAgICAgbmV3U3RyaW5nID0gdGhpcy5jYXN0SW5wdXQobmV3U3RyaW5nKTtcbiAgICAgIG9sZFN0cmluZyA9IHRoaXMucmVtb3ZlRW1wdHkodGhpcy50b2tlbml6ZShvbGRTdHJpbmcpKTtcbiAgICAgIG5ld1N0cmluZyA9IHRoaXMucmVtb3ZlRW1wdHkodGhpcy50b2tlbml6ZShuZXdTdHJpbmcpKTtcbiAgICAgIHZhciBuZXdMZW4gPSBuZXdTdHJpbmcubGVuZ3RoLFxuICAgICAgICAgIG9sZExlbiA9IG9sZFN0cmluZy5sZW5ndGg7XG4gICAgICB2YXIgZWRpdExlbmd0aCA9IDE7XG4gICAgICB2YXIgbWF4RWRpdExlbmd0aCA9IG5ld0xlbiArIG9sZExlbjtcbiAgICAgIHZhciBiZXN0UGF0aCA9IFt7XG4gICAgICAgIG5ld1BvczogLTEsXG4gICAgICAgIGNvbXBvbmVudHM6IFtdXG4gICAgICB9XTsgLy8gU2VlZCBlZGl0TGVuZ3RoID0gMCwgaS5lLiB0aGUgY29udGVudCBzdGFydHMgd2l0aCB0aGUgc2FtZSB2YWx1ZXNcblxuICAgICAgdmFyIG9sZFBvcyA9IHRoaXMuZXh0cmFjdENvbW1vbihiZXN0UGF0aFswXSwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIDApO1xuXG4gICAgICBpZiAoYmVzdFBhdGhbMF0ubmV3UG9zICsgMSA+PSBuZXdMZW4gJiYgb2xkUG9zICsgMSA+PSBvbGRMZW4pIHtcbiAgICAgICAgLy8gSWRlbnRpdHkgcGVyIHRoZSBlcXVhbGl0eSBhbmQgdG9rZW5pemVyXG4gICAgICAgIHJldHVybiBkb25lKFt7XG4gICAgICAgICAgdmFsdWU6IHRoaXMuam9pbihuZXdTdHJpbmcpLFxuICAgICAgICAgIGNvdW50OiBuZXdTdHJpbmcubGVuZ3RoXG4gICAgICAgIH1dKTtcbiAgICAgIH0gLy8gTWFpbiB3b3JrZXIgbWV0aG9kLiBjaGVja3MgYWxsIHBlcm11dGF0aW9ucyBvZiBhIGdpdmVuIGVkaXQgbGVuZ3RoIGZvciBhY2NlcHRhbmNlLlxuXG5cbiAgICAgIGZ1bmN0aW9uIGV4ZWNFZGl0TGVuZ3RoKCkge1xuICAgICAgICBmb3IgKHZhciBkaWFnb25hbFBhdGggPSAtMSAqIGVkaXRMZW5ndGg7IGRpYWdvbmFsUGF0aCA8PSBlZGl0TGVuZ3RoOyBkaWFnb25hbFBhdGggKz0gMikge1xuICAgICAgICAgIHZhciBiYXNlUGF0aCA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBhZGRQYXRoID0gYmVzdFBhdGhbZGlhZ29uYWxQYXRoIC0gMV0sXG4gICAgICAgICAgICAgIHJlbW92ZVBhdGggPSBiZXN0UGF0aFtkaWFnb25hbFBhdGggKyAxXSxcbiAgICAgICAgICAgICAgX29sZFBvcyA9IChyZW1vdmVQYXRoID8gcmVtb3ZlUGF0aC5uZXdQb3MgOiAwKSAtIGRpYWdvbmFsUGF0aDtcblxuICAgICAgICAgIGlmIChhZGRQYXRoKSB7XG4gICAgICAgICAgICAvLyBObyBvbmUgZWxzZSBpcyBnb2luZyB0byBhdHRlbXB0IHRvIHVzZSB0aGlzIHZhbHVlLCBjbGVhciBpdFxuICAgICAgICAgICAgYmVzdFBhdGhbZGlhZ29uYWxQYXRoIC0gMV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGNhbkFkZCA9IGFkZFBhdGggJiYgYWRkUGF0aC5uZXdQb3MgKyAxIDwgbmV3TGVuLFxuICAgICAgICAgICAgICBjYW5SZW1vdmUgPSByZW1vdmVQYXRoICYmIDAgPD0gX29sZFBvcyAmJiBfb2xkUG9zIDwgb2xkTGVuO1xuXG4gICAgICAgICAgaWYgKCFjYW5BZGQgJiYgIWNhblJlbW92ZSkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBwYXRoIGlzIGEgdGVybWluYWwgdGhlbiBwcnVuZVxuICAgICAgICAgICAgYmVzdFBhdGhbZGlhZ29uYWxQYXRoXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gLy8gU2VsZWN0IHRoZSBkaWFnb25hbCB0aGF0IHdlIHdhbnQgdG8gYnJhbmNoIGZyb20uIFdlIHNlbGVjdCB0aGUgcHJpb3JcbiAgICAgICAgICAvLyBwYXRoIHdob3NlIHBvc2l0aW9uIGluIHRoZSBuZXcgc3RyaW5nIGlzIHRoZSBmYXJ0aGVzdCBmcm9tIHRoZSBvcmlnaW5cbiAgICAgICAgICAvLyBhbmQgZG9lcyBub3QgcGFzcyB0aGUgYm91bmRzIG9mIHRoZSBkaWZmIGdyYXBoXG5cblxuICAgICAgICAgIGlmICghY2FuQWRkIHx8IGNhblJlbW92ZSAmJiBhZGRQYXRoLm5ld1BvcyA8IHJlbW92ZVBhdGgubmV3UG9zKSB7XG4gICAgICAgICAgICBiYXNlUGF0aCA9IGNsb25lUGF0aChyZW1vdmVQYXRoKTtcbiAgICAgICAgICAgIHNlbGYucHVzaENvbXBvbmVudChiYXNlUGF0aC5jb21wb25lbnRzLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXNlUGF0aCA9IGFkZFBhdGg7IC8vIE5vIG5lZWQgdG8gY2xvbmUsIHdlJ3ZlIHB1bGxlZCBpdCBmcm9tIHRoZSBsaXN0XG5cbiAgICAgICAgICAgIGJhc2VQYXRoLm5ld1BvcysrO1xuICAgICAgICAgICAgc2VsZi5wdXNoQ29tcG9uZW50KGJhc2VQYXRoLmNvbXBvbmVudHMsIHRydWUsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX29sZFBvcyA9IHNlbGYuZXh0cmFjdENvbW1vbihiYXNlUGF0aCwgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIGRpYWdvbmFsUGF0aCk7IC8vIElmIHdlIGhhdmUgaGl0IHRoZSBlbmQgb2YgYm90aCBzdHJpbmdzLCB0aGVuIHdlIGFyZSBkb25lXG5cbiAgICAgICAgICBpZiAoYmFzZVBhdGgubmV3UG9zICsgMSA+PSBuZXdMZW4gJiYgX29sZFBvcyArIDEgPj0gb2xkTGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9uZShidWlsZFZhbHVlcyhzZWxmLCBiYXNlUGF0aC5jb21wb25lbnRzLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgc2VsZi51c2VMb25nZXN0VG9rZW4pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHRyYWNrIHRoaXMgcGF0aCBhcyBhIHBvdGVudGlhbCBjYW5kaWRhdGUgYW5kIGNvbnRpbnVlLlxuICAgICAgICAgICAgYmVzdFBhdGhbZGlhZ29uYWxQYXRoXSA9IGJhc2VQYXRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVkaXRMZW5ndGgrKztcbiAgICAgIH0gLy8gUGVyZm9ybXMgdGhlIGxlbmd0aCBvZiBlZGl0IGl0ZXJhdGlvbi4gSXMgYSBiaXQgZnVnbHkgYXMgdGhpcyBoYXMgdG8gc3VwcG9ydCB0aGVcbiAgICAgIC8vIHN5bmMgYW5kIGFzeW5jIG1vZGUgd2hpY2ggaXMgbmV2ZXIgZnVuLiBMb29wcyBvdmVyIGV4ZWNFZGl0TGVuZ3RoIHVudGlsIGEgdmFsdWVcbiAgICAgIC8vIGlzIHByb2R1Y2VkLlxuXG5cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAoZnVuY3Rpb24gZXhlYygpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW4sIGJ1dCB3ZSB3YW50IHRvIGJlIHNhZmUuXG5cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAoZWRpdExlbmd0aCA+IG1heEVkaXRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZXhlY0VkaXRMZW5ndGgoKSkge1xuICAgICAgICAgICAgICBleGVjKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH0pKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aGlsZSAoZWRpdExlbmd0aCA8PSBtYXhFZGl0TGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHJldCA9IGV4ZWNFZGl0TGVuZ3RoKCk7XG5cbiAgICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcHVzaENvbXBvbmVudDogZnVuY3Rpb24gcHVzaENvbXBvbmVudChjb21wb25lbnRzLCBhZGRlZCwgcmVtb3ZlZCkge1xuICAgICAgdmFyIGxhc3QgPSBjb21wb25lbnRzW2NvbXBvbmVudHMubGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmIChsYXN0ICYmIGxhc3QuYWRkZWQgPT09IGFkZGVkICYmIGxhc3QucmVtb3ZlZCA9PT0gcmVtb3ZlZCkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGNsb25lIGhlcmUgYXMgdGhlIGNvbXBvbmVudCBjbG9uZSBvcGVyYXRpb24gaXMganVzdFxuICAgICAgICAvLyBhcyBzaGFsbG93IGFycmF5IGNsb25lXG4gICAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50cy5sZW5ndGggLSAxXSA9IHtcbiAgICAgICAgICBjb3VudDogbGFzdC5jb3VudCArIDEsXG4gICAgICAgICAgYWRkZWQ6IGFkZGVkLFxuICAgICAgICAgIHJlbW92ZWQ6IHJlbW92ZWRcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaCh7XG4gICAgICAgICAgY291bnQ6IDEsXG4gICAgICAgICAgYWRkZWQ6IGFkZGVkLFxuICAgICAgICAgIHJlbW92ZWQ6IHJlbW92ZWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBleHRyYWN0Q29tbW9uOiBmdW5jdGlvbiBleHRyYWN0Q29tbW9uKGJhc2VQYXRoLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgZGlhZ29uYWxQYXRoKSB7XG4gICAgICB2YXIgbmV3TGVuID0gbmV3U3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICBvbGRMZW4gPSBvbGRTdHJpbmcubGVuZ3RoLFxuICAgICAgICAgIG5ld1BvcyA9IGJhc2VQYXRoLm5ld1BvcyxcbiAgICAgICAgICBvbGRQb3MgPSBuZXdQb3MgLSBkaWFnb25hbFBhdGgsXG4gICAgICAgICAgY29tbW9uQ291bnQgPSAwO1xuXG4gICAgICB3aGlsZSAobmV3UG9zICsgMSA8IG5ld0xlbiAmJiBvbGRQb3MgKyAxIDwgb2xkTGVuICYmIHRoaXMuZXF1YWxzKG5ld1N0cmluZ1tuZXdQb3MgKyAxXSwgb2xkU3RyaW5nW29sZFBvcyArIDFdKSkge1xuICAgICAgICBuZXdQb3MrKztcbiAgICAgICAgb2xkUG9zKys7XG4gICAgICAgIGNvbW1vbkNvdW50Kys7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21tb25Db3VudCkge1xuICAgICAgICBiYXNlUGF0aC5jb21wb25lbnRzLnB1c2goe1xuICAgICAgICAgIGNvdW50OiBjb21tb25Db3VudFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgYmFzZVBhdGgubmV3UG9zID0gbmV3UG9zO1xuICAgICAgcmV0dXJuIG9sZFBvcztcbiAgICB9LFxuICAgIGVxdWFsczogZnVuY3Rpb24gZXF1YWxzKGxlZnQsIHJpZ2h0KSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNvbXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5jb21wYXJhdG9yKGxlZnQsIHJpZ2h0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsZWZ0ID09PSByaWdodCB8fCB0aGlzLm9wdGlvbnMuaWdub3JlQ2FzZSAmJiBsZWZ0LnRvTG93ZXJDYXNlKCkgPT09IHJpZ2h0LnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW1vdmVFbXB0eTogZnVuY3Rpb24gcmVtb3ZlRW1wdHkoYXJyYXkpIHtcbiAgICAgIHZhciByZXQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXJyYXlbaV0pIHtcbiAgICAgICAgICByZXQucHVzaChhcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuICAgIGNhc3RJbnB1dDogZnVuY3Rpb24gY2FzdElucHV0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICB0b2tlbml6ZTogZnVuY3Rpb24gdG9rZW5pemUodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5zcGxpdCgnJyk7XG4gICAgfSxcbiAgICBqb2luOiBmdW5jdGlvbiBqb2luKGNoYXJzKSB7XG4gICAgICByZXR1cm4gY2hhcnMuam9pbignJyk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGJ1aWxkVmFsdWVzKGRpZmYsIGNvbXBvbmVudHMsIG5ld1N0cmluZywgb2xkU3RyaW5nLCB1c2VMb25nZXN0VG9rZW4pIHtcbiAgICB2YXIgY29tcG9uZW50UG9zID0gMCxcbiAgICAgICAgY29tcG9uZW50TGVuID0gY29tcG9uZW50cy5sZW5ndGgsXG4gICAgICAgIG5ld1BvcyA9IDAsXG4gICAgICAgIG9sZFBvcyA9IDA7XG5cbiAgICBmb3IgKDsgY29tcG9uZW50UG9zIDwgY29tcG9uZW50TGVuOyBjb21wb25lbnRQb3MrKykge1xuICAgICAgdmFyIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbY29tcG9uZW50UG9zXTtcblxuICAgICAgaWYgKCFjb21wb25lbnQucmVtb3ZlZCkge1xuICAgICAgICBpZiAoIWNvbXBvbmVudC5hZGRlZCAmJiB1c2VMb25nZXN0VG9rZW4pIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBuZXdTdHJpbmcuc2xpY2UobmV3UG9zLCBuZXdQb3MgKyBjb21wb25lbnQuY291bnQpO1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUubWFwKGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gb2xkU3RyaW5nW29sZFBvcyArIGldO1xuICAgICAgICAgICAgcmV0dXJuIG9sZFZhbHVlLmxlbmd0aCA+IHZhbHVlLmxlbmd0aCA/IG9sZFZhbHVlIDogdmFsdWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29tcG9uZW50LnZhbHVlID0gZGlmZi5qb2luKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21wb25lbnQudmFsdWUgPSBkaWZmLmpvaW4obmV3U3RyaW5nLnNsaWNlKG5ld1BvcywgbmV3UG9zICsgY29tcG9uZW50LmNvdW50KSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdQb3MgKz0gY29tcG9uZW50LmNvdW50OyAvLyBDb21tb24gY2FzZVxuXG4gICAgICAgIGlmICghY29tcG9uZW50LmFkZGVkKSB7XG4gICAgICAgICAgb2xkUG9zICs9IGNvbXBvbmVudC5jb3VudDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcG9uZW50LnZhbHVlID0gZGlmZi5qb2luKG9sZFN0cmluZy5zbGljZShvbGRQb3MsIG9sZFBvcyArIGNvbXBvbmVudC5jb3VudCkpO1xuICAgICAgICBvbGRQb3MgKz0gY29tcG9uZW50LmNvdW50OyAvLyBSZXZlcnNlIGFkZCBhbmQgcmVtb3ZlIHNvIHJlbW92ZXMgYXJlIG91dHB1dCBmaXJzdCB0byBtYXRjaCBjb21tb24gY29udmVudGlvblxuICAgICAgICAvLyBUaGUgZGlmZmluZyBhbGdvcml0aG0gaXMgdGllZCB0byBhZGQgdGhlbiByZW1vdmUgb3V0cHV0IGFuZCB0aGlzIGlzIHRoZSBzaW1wbGVzdFxuICAgICAgICAvLyByb3V0ZSB0byBnZXQgdGhlIGRlc2lyZWQgb3V0cHV0IHdpdGggbWluaW1hbCBvdmVyaGVhZC5cblxuICAgICAgICBpZiAoY29tcG9uZW50UG9zICYmIGNvbXBvbmVudHNbY29tcG9uZW50UG9zIC0gMV0uYWRkZWQpIHtcbiAgICAgICAgICB2YXIgdG1wID0gY29tcG9uZW50c1tjb21wb25lbnRQb3MgLSAxXTtcbiAgICAgICAgICBjb21wb25lbnRzW2NvbXBvbmVudFBvcyAtIDFdID0gY29tcG9uZW50c1tjb21wb25lbnRQb3NdO1xuICAgICAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50UG9zXSA9IHRtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gU3BlY2lhbCBjYXNlIGhhbmRsZSBmb3Igd2hlbiBvbmUgdGVybWluYWwgaXMgaWdub3JlZCAoaS5lLiB3aGl0ZXNwYWNlKS5cbiAgICAvLyBGb3IgdGhpcyBjYXNlIHdlIG1lcmdlIHRoZSB0ZXJtaW5hbCBpbnRvIHRoZSBwcmlvciBzdHJpbmcgYW5kIGRyb3AgdGhlIGNoYW5nZS5cbiAgICAvLyBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIGZvciBzdHJpbmcgbW9kZS5cblxuXG4gICAgdmFyIGxhc3RDb21wb25lbnQgPSBjb21wb25lbnRzW2NvbXBvbmVudExlbiAtIDFdO1xuXG4gICAgaWYgKGNvbXBvbmVudExlbiA+IDEgJiYgdHlwZW9mIGxhc3RDb21wb25lbnQudmFsdWUgPT09ICdzdHJpbmcnICYmIChsYXN0Q29tcG9uZW50LmFkZGVkIHx8IGxhc3RDb21wb25lbnQucmVtb3ZlZCkgJiYgZGlmZi5lcXVhbHMoJycsIGxhc3RDb21wb25lbnQudmFsdWUpKSB7XG4gICAgICBjb21wb25lbnRzW2NvbXBvbmVudExlbiAtIDJdLnZhbHVlICs9IGxhc3RDb21wb25lbnQudmFsdWU7XG4gICAgICBjb21wb25lbnRzLnBvcCgpO1xuICAgIH1cblxuICAgIHJldHVybiBjb21wb25lbnRzO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xvbmVQYXRoKHBhdGgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmV3UG9zOiBwYXRoLm5ld1BvcyxcbiAgICAgIGNvbXBvbmVudHM6IHBhdGguY29tcG9uZW50cy5zbGljZSgwKVxuICAgIH07XG4gIH1cblxuICB2YXIgY2hhcmFjdGVyRGlmZiA9IG5ldyBEaWZmKCk7XG5cbiAgZnVuY3Rpb24gZGlmZkNoYXJzKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGNoYXJhY3RlckRpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZU9wdGlvbnMob3B0aW9ucywgZGVmYXVsdHMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGRlZmF1bHRzLmNhbGxiYWNrID0gb3B0aW9ucztcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gb3B0aW9ucykge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIGRlZmF1bHRzW25hbWVdID0gb3B0aW9uc1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkZWZhdWx0cztcbiAgfSAvL1xuICAvLyBSYW5nZXMgYW5kIGV4Y2VwdGlvbnM6XG4gIC8vIExhdGluLTEgU3VwcGxlbWVudCwgMDA4MOKAkzAwRkZcbiAgLy8gIC0gVSswMEQ3ICDDlyBNdWx0aXBsaWNhdGlvbiBzaWduXG4gIC8vICAtIFUrMDBGNyAgw7cgRGl2aXNpb24gc2lnblxuICAvLyBMYXRpbiBFeHRlbmRlZC1BLCAwMTAw4oCTMDE3RlxuICAvLyBMYXRpbiBFeHRlbmRlZC1CLCAwMTgw4oCTMDI0RlxuICAvLyBJUEEgRXh0ZW5zaW9ucywgMDI1MOKAkzAyQUZcbiAgLy8gU3BhY2luZyBNb2RpZmllciBMZXR0ZXJzLCAwMkIw4oCTMDJGRlxuICAvLyAgLSBVKzAyQzcgIMuHICYjNzExOyAgQ2Fyb25cbiAgLy8gIC0gVSswMkQ4ICDLmCAmIzcyODsgIEJyZXZlXG4gIC8vICAtIFUrMDJEOSAgy5kgJiM3Mjk7ICBEb3QgQWJvdmVcbiAgLy8gIC0gVSswMkRBICDLmiAmIzczMDsgIFJpbmcgQWJvdmVcbiAgLy8gIC0gVSswMkRCICDLmyAmIzczMTsgIE9nb25la1xuICAvLyAgLSBVKzAyREMgIMucICYjNzMyOyAgU21hbGwgVGlsZGVcbiAgLy8gIC0gVSswMkREICDLnSAmIzczMzsgIERvdWJsZSBBY3V0ZSBBY2NlbnRcbiAgLy8gTGF0aW4gRXh0ZW5kZWQgQWRkaXRpb25hbCwgMUUwMOKAkzFFRkZcblxuXG4gIHZhciBleHRlbmRlZFdvcmRDaGFycyA9IC9eW0EtWmEtelxceEMwLVxcdTAyQzZcXHUwMkM4LVxcdTAyRDdcXHUwMkRFLVxcdTAyRkZcXHUxRTAwLVxcdTFFRkZdKyQvO1xuICB2YXIgcmVXaGl0ZXNwYWNlID0gL1xcUy87XG4gIHZhciB3b3JkRGlmZiA9IG5ldyBEaWZmKCk7XG5cbiAgd29yZERpZmYuZXF1YWxzID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5pZ25vcmVDYXNlKSB7XG4gICAgICBsZWZ0ID0gbGVmdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmlnaHQgPSByaWdodC50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBsZWZ0ID09PSByaWdodCB8fCB0aGlzLm9wdGlvbnMuaWdub3JlV2hpdGVzcGFjZSAmJiAhcmVXaGl0ZXNwYWNlLnRlc3QobGVmdCkgJiYgIXJlV2hpdGVzcGFjZS50ZXN0KHJpZ2h0KTtcbiAgfTtcblxuICB3b3JkRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciB0b2tlbnMgPSB2YWx1ZS5zcGxpdCgvKFxccyt8WygpW1xcXXt9J1wiXXxcXGIpLyk7IC8vIEpvaW4gdGhlIGJvdW5kYXJ5IHNwbGl0cyB0aGF0IHdlIGRvIG5vdCBjb25zaWRlciB0byBiZSBib3VuZGFyaWVzLiBUaGlzIGlzIHByaW1hcmlseSB0aGUgZXh0ZW5kZWQgTGF0aW4gY2hhcmFjdGVyIHNldC5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBlbXB0eSBzdHJpbmcgaW4gdGhlIG5leHQgZmllbGQgYW5kIHdlIGhhdmUgb25seSB3b3JkIGNoYXJzIGJlZm9yZSBhbmQgYWZ0ZXIsIG1lcmdlXG4gICAgICBpZiAoIXRva2Vuc1tpICsgMV0gJiYgdG9rZW5zW2kgKyAyXSAmJiBleHRlbmRlZFdvcmRDaGFycy50ZXN0KHRva2Vuc1tpXSkgJiYgZXh0ZW5kZWRXb3JkQ2hhcnMudGVzdCh0b2tlbnNbaSArIDJdKSkge1xuICAgICAgICB0b2tlbnNbaV0gKz0gdG9rZW5zW2kgKyAyXTtcbiAgICAgICAgdG9rZW5zLnNwbGljZShpICsgMSwgMik7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdG9rZW5zO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGRpZmZXb3JkcyhvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBnZW5lcmF0ZU9wdGlvbnMob3B0aW9ucywge1xuICAgICAgaWdub3JlV2hpdGVzcGFjZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiB3b3JkRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpZmZXb3Jkc1dpdGhTcGFjZShvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucykge1xuICAgIHJldHVybiB3b3JkRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbiAgfVxuXG4gIHZhciBsaW5lRGlmZiA9IG5ldyBEaWZmKCk7XG5cbiAgbGluZURpZmYudG9rZW5pemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgcmV0TGluZXMgPSBbXSxcbiAgICAgICAgbGluZXNBbmROZXdsaW5lcyA9IHZhbHVlLnNwbGl0KC8oXFxufFxcclxcbikvKTsgLy8gSWdub3JlIHRoZSBmaW5hbCBlbXB0eSB0b2tlbiB0aGF0IG9jY3VycyBpZiB0aGUgc3RyaW5nIGVuZHMgd2l0aCBhIG5ldyBsaW5lXG5cbiAgICBpZiAoIWxpbmVzQW5kTmV3bGluZXNbbGluZXNBbmROZXdsaW5lcy5sZW5ndGggLSAxXSkge1xuICAgICAgbGluZXNBbmROZXdsaW5lcy5wb3AoKTtcbiAgICB9IC8vIE1lcmdlIHRoZSBjb250ZW50IGFuZCBsaW5lIHNlcGFyYXRvcnMgaW50byBzaW5nbGUgdG9rZW5zXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXNBbmROZXdsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpbmUgPSBsaW5lc0FuZE5ld2xpbmVzW2ldO1xuXG4gICAgICBpZiAoaSAlIDIgJiYgIXRoaXMub3B0aW9ucy5uZXdsaW5lSXNUb2tlbikge1xuICAgICAgICByZXRMaW5lc1tyZXRMaW5lcy5sZW5ndGggLSAxXSArPSBsaW5lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pZ25vcmVXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgbGluZSA9IGxpbmUudHJpbSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0TGluZXMucHVzaChsaW5lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0TGluZXM7XG4gIH07XG5cbiAgZnVuY3Rpb24gZGlmZkxpbmVzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBsaW5lRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7XG4gIH1cblxuICBmdW5jdGlvbiBkaWZmVHJpbW1lZExpbmVzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykge1xuICAgIHZhciBvcHRpb25zID0gZ2VuZXJhdGVPcHRpb25zKGNhbGxiYWNrLCB7XG4gICAgICBpZ25vcmVXaGl0ZXNwYWNlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGxpbmVEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIHNlbnRlbmNlRGlmZiA9IG5ldyBEaWZmKCk7XG5cbiAgc2VudGVuY2VEaWZmLnRva2VuaXplID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnNwbGl0KC8oXFxTLis/Wy4hP10pKD89XFxzK3wkKS8pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGRpZmZTZW50ZW5jZXMob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHNlbnRlbmNlRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgY3NzRGlmZiA9IG5ldyBEaWZmKCk7XG5cbiAgY3NzRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5zcGxpdCgvKFt7fTo7LF18XFxzKykvKTtcbiAgfTtcblxuICBmdW5jdGlvbiBkaWZmQ3NzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBjc3NEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90eXBlb2YkMShvYmopIHtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIF90eXBlb2YoU3ltYm9sLml0ZXJhdG9yKSA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgX3R5cGVvZiQxID0gZnVuY3Rpb24gX3R5cGVvZiQxKG9iaikge1xuICAgICAgICByZXR1cm4gX3R5cGVvZihvYmopO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3R5cGVvZiQxID0gZnVuY3Rpb24gX3R5cGVvZiQxKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogX3R5cGVvZihvYmopO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3R5cGVvZiQxKG9iaik7XG4gIH1cblxuICBmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkkMShhcnIpIHtcbiAgICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzJDEoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5JDEoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQkMSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzJDEoYXJyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyMltpXSA9IGFycltpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFycjI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheSQxKGl0ZXIpIHtcbiAgICBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcikgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkJDEoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xuICB9XG5cbiAgdmFyIG9iamVjdFByb3RvdHlwZVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgdmFyIGpzb25EaWZmID0gbmV3IERpZmYoKTsgLy8gRGlzY3JpbWluYXRlIGJldHdlZW4gdHdvIGxpbmVzIG9mIHByZXR0eS1wcmludGVkLCBzZXJpYWxpemVkIEpTT04gd2hlcmUgb25lIG9mIHRoZW0gaGFzIGFcbiAgLy8gZGFuZ2xpbmcgY29tbWEgYW5kIHRoZSBvdGhlciBkb2Vzbid0LiBUdXJucyBvdXQgaW5jbHVkaW5nIHRoZSBkYW5nbGluZyBjb21tYSB5aWVsZHMgdGhlIG5pY2VzdCBvdXRwdXQ6XG5cbiAganNvbkRpZmYudXNlTG9uZ2VzdFRva2VuID0gdHJ1ZTtcbiAganNvbkRpZmYudG9rZW5pemUgPSBsaW5lRGlmZi50b2tlbml6ZTtcblxuICBqc29uRGlmZi5jYXN0SW5wdXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgX3RoaXMkb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgdW5kZWZpbmVkUmVwbGFjZW1lbnQgPSBfdGhpcyRvcHRpb25zLnVuZGVmaW5lZFJlcGxhY2VtZW50LFxuICAgICAgICBfdGhpcyRvcHRpb25zJHN0cmluZ2kgPSBfdGhpcyRvcHRpb25zLnN0cmluZ2lmeVJlcGxhY2VyLFxuICAgICAgICBzdHJpbmdpZnlSZXBsYWNlciA9IF90aGlzJG9wdGlvbnMkc3RyaW5naSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdiA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWRSZXBsYWNlbWVudCA6IHY7XG4gICAgfSA6IF90aGlzJG9wdGlvbnMkc3RyaW5naTtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlIDogSlNPTi5zdHJpbmdpZnkoY2Fub25pY2FsaXplKHZhbHVlLCBudWxsLCBudWxsLCBzdHJpbmdpZnlSZXBsYWNlciksIHN0cmluZ2lmeVJlcGxhY2VyLCAnICAnKTtcbiAgfTtcblxuICBqc29uRGlmZi5lcXVhbHMgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gRGlmZi5wcm90b3R5cGUuZXF1YWxzLmNhbGwoanNvbkRpZmYsIGxlZnQucmVwbGFjZSgvLChbXFxyXFxuXSkvZywgJyQxJyksIHJpZ2h0LnJlcGxhY2UoLywoW1xcclxcbl0pL2csICckMScpKTtcbiAgfTtcblxuICBmdW5jdGlvbiBkaWZmSnNvbihvbGRPYmosIG5ld09iaiwgb3B0aW9ucykge1xuICAgIHJldHVybiBqc29uRGlmZi5kaWZmKG9sZE9iaiwgbmV3T2JqLCBvcHRpb25zKTtcbiAgfSAvLyBUaGlzIGZ1bmN0aW9uIGhhbmRsZXMgdGhlIHByZXNlbmNlIG9mIGNpcmN1bGFyIHJlZmVyZW5jZXMgYnkgYmFpbGluZyBvdXQgd2hlbiBlbmNvdW50ZXJpbmcgYW5cbiAgLy8gb2JqZWN0IHRoYXQgaXMgYWxyZWFkeSBvbiB0aGUgXCJzdGFja1wiIG9mIGl0ZW1zIGJlaW5nIHByb2Nlc3NlZC4gQWNjZXB0cyBhbiBvcHRpb25hbCByZXBsYWNlclxuXG5cbiAgZnVuY3Rpb24gY2Fub25pY2FsaXplKG9iaiwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2ssIHJlcGxhY2VyLCBrZXkpIHtcbiAgICBzdGFjayA9IHN0YWNrIHx8IFtdO1xuICAgIHJlcGxhY2VtZW50U3RhY2sgPSByZXBsYWNlbWVudFN0YWNrIHx8IFtdO1xuXG4gICAgaWYgKHJlcGxhY2VyKSB7XG4gICAgICBvYmogPSByZXBsYWNlcihrZXksIG9iaik7XG4gICAgfVxuXG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChzdGFja1tpXSA9PT0gb2JqKSB7XG4gICAgICAgIHJldHVybiByZXBsYWNlbWVudFN0YWNrW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjYW5vbmljYWxpemVkT2JqO1xuXG4gICAgaWYgKCdbb2JqZWN0IEFycmF5XScgPT09IG9iamVjdFByb3RvdHlwZVRvU3RyaW5nLmNhbGwob2JqKSkge1xuICAgICAgc3RhY2sucHVzaChvYmopO1xuICAgICAgY2Fub25pY2FsaXplZE9iaiA9IG5ldyBBcnJheShvYmoubGVuZ3RoKTtcbiAgICAgIHJlcGxhY2VtZW50U3RhY2sucHVzaChjYW5vbmljYWxpemVkT2JqKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjYW5vbmljYWxpemVkT2JqW2ldID0gY2Fub25pY2FsaXplKG9ialtpXSwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2ssIHJlcGxhY2VyLCBrZXkpO1xuICAgICAgfVxuXG4gICAgICBzdGFjay5wb3AoKTtcbiAgICAgIHJlcGxhY2VtZW50U3RhY2sucG9wKCk7XG4gICAgICByZXR1cm4gY2Fub25pY2FsaXplZE9iajtcbiAgICB9XG5cbiAgICBpZiAob2JqICYmIG9iai50b0pTT04pIHtcbiAgICAgIG9iaiA9IG9iai50b0pTT04oKTtcbiAgICB9XG5cbiAgICBpZiAoX3R5cGVvZiQxKG9iaikgPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkge1xuICAgICAgc3RhY2sucHVzaChvYmopO1xuICAgICAgY2Fub25pY2FsaXplZE9iaiA9IHt9O1xuICAgICAgcmVwbGFjZW1lbnRTdGFjay5wdXNoKGNhbm9uaWNhbGl6ZWRPYmopO1xuXG4gICAgICB2YXIgc29ydGVkS2V5cyA9IFtdLFxuICAgICAgICAgIF9rZXk7XG5cbiAgICAgIGZvciAoX2tleSBpbiBvYmopIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShfa2V5KSkge1xuICAgICAgICAgIHNvcnRlZEtleXMucHVzaChfa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzb3J0ZWRLZXlzLnNvcnQoKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHNvcnRlZEtleXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgX2tleSA9IHNvcnRlZEtleXNbaV07XG4gICAgICAgIGNhbm9uaWNhbGl6ZWRPYmpbX2tleV0gPSBjYW5vbmljYWxpemUob2JqW19rZXldLCBzdGFjaywgcmVwbGFjZW1lbnRTdGFjaywgcmVwbGFjZXIsIF9rZXkpO1xuICAgICAgfVxuXG4gICAgICBzdGFjay5wb3AoKTtcbiAgICAgIHJlcGxhY2VtZW50U3RhY2sucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSBvYmo7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbm9uaWNhbGl6ZWRPYmo7XG4gIH1cblxuICB2YXIgYXJyYXlEaWZmID0gbmV3IERpZmYoKTtcblxuICBhcnJheURpZmYudG9rZW5pemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuc2xpY2UoKTtcbiAgfTtcblxuICBhcnJheURpZmYuam9pbiA9IGFycmF5RGlmZi5yZW1vdmVFbXB0eSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBmdW5jdGlvbiBkaWZmQXJyYXlzKG9sZEFyciwgbmV3QXJyLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBhcnJheURpZmYuZGlmZihvbGRBcnIsIG5ld0FyciwgY2FsbGJhY2spO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VQYXRjaCh1bmlEaWZmKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBkaWZmc3RyID0gdW5pRGlmZi5zcGxpdCgvXFxyXFxufFtcXG5cXHZcXGZcXHJcXHg4NV0vKSxcbiAgICAgICAgZGVsaW1pdGVycyA9IHVuaURpZmYubWF0Y2goL1xcclxcbnxbXFxuXFx2XFxmXFxyXFx4ODVdL2cpIHx8IFtdLFxuICAgICAgICBsaXN0ID0gW10sXG4gICAgICAgIGkgPSAwO1xuXG4gICAgZnVuY3Rpb24gcGFyc2VJbmRleCgpIHtcbiAgICAgIHZhciBpbmRleCA9IHt9O1xuICAgICAgbGlzdC5wdXNoKGluZGV4KTsgLy8gUGFyc2UgZGlmZiBtZXRhZGF0YVxuXG4gICAgICB3aGlsZSAoaSA8IGRpZmZzdHIubGVuZ3RoKSB7XG4gICAgICAgIHZhciBsaW5lID0gZGlmZnN0cltpXTsgLy8gRmlsZSBoZWFkZXIgZm91bmQsIGVuZCBwYXJzaW5nIGRpZmYgbWV0YWRhdGFcblxuICAgICAgICBpZiAoL14oXFwtXFwtXFwtfFxcK1xcK1xcK3xAQClcXHMvLnRlc3QobGluZSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSAvLyBEaWZmIGluZGV4XG5cblxuICAgICAgICB2YXIgaGVhZGVyID0gL14oPzpJbmRleDp8ZGlmZig/OiAtciBcXHcrKSspXFxzKyguKz8pXFxzKiQvLmV4ZWMobGluZSk7XG5cbiAgICAgICAgaWYgKGhlYWRlcikge1xuICAgICAgICAgIGluZGV4LmluZGV4ID0gaGVhZGVyWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgaSsrO1xuICAgICAgfSAvLyBQYXJzZSBmaWxlIGhlYWRlcnMgaWYgdGhleSBhcmUgZGVmaW5lZC4gVW5pZmllZCBkaWZmIHJlcXVpcmVzIHRoZW0sIGJ1dFxuICAgICAgLy8gdGhlcmUncyBubyB0ZWNobmljYWwgaXNzdWVzIHRvIGhhdmUgYW4gaXNvbGF0ZWQgaHVuayB3aXRob3V0IGZpbGUgaGVhZGVyXG5cblxuICAgICAgcGFyc2VGaWxlSGVhZGVyKGluZGV4KTtcbiAgICAgIHBhcnNlRmlsZUhlYWRlcihpbmRleCk7IC8vIFBhcnNlIGh1bmtzXG5cbiAgICAgIGluZGV4Lmh1bmtzID0gW107XG5cbiAgICAgIHdoaWxlIChpIDwgZGlmZnN0ci5sZW5ndGgpIHtcbiAgICAgICAgdmFyIF9saW5lID0gZGlmZnN0cltpXTtcblxuICAgICAgICBpZiAoL14oSW5kZXg6fGRpZmZ8XFwtXFwtXFwtfFxcK1xcK1xcKylcXHMvLnRlc3QoX2xpbmUpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoL15AQC8udGVzdChfbGluZSkpIHtcbiAgICAgICAgICBpbmRleC5odW5rcy5wdXNoKHBhcnNlSHVuaygpKTtcbiAgICAgICAgfSBlbHNlIGlmIChfbGluZSAmJiBvcHRpb25zLnN0cmljdCkge1xuICAgICAgICAgIC8vIElnbm9yZSB1bmV4cGVjdGVkIGNvbnRlbnQgdW5sZXNzIGluIHN0cmljdCBtb2RlXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGxpbmUgJyArIChpICsgMSkgKyAnICcgKyBKU09OLnN0cmluZ2lmeShfbGluZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gUGFyc2VzIHRoZSAtLS0gYW5kICsrKyBoZWFkZXJzLCBpZiBub25lIGFyZSBmb3VuZCwgbm8gbGluZXNcbiAgICAvLyBhcmUgY29uc3VtZWQuXG5cblxuICAgIGZ1bmN0aW9uIHBhcnNlRmlsZUhlYWRlcihpbmRleCkge1xuICAgICAgdmFyIGZpbGVIZWFkZXIgPSAvXigtLS18XFwrXFwrXFwrKVxccysoLiopJC8uZXhlYyhkaWZmc3RyW2ldKTtcblxuICAgICAgaWYgKGZpbGVIZWFkZXIpIHtcbiAgICAgICAgdmFyIGtleVByZWZpeCA9IGZpbGVIZWFkZXJbMV0gPT09ICctLS0nID8gJ29sZCcgOiAnbmV3JztcbiAgICAgICAgdmFyIGRhdGEgPSBmaWxlSGVhZGVyWzJdLnNwbGl0KCdcXHQnLCAyKTtcbiAgICAgICAgdmFyIGZpbGVOYW1lID0gZGF0YVswXS5yZXBsYWNlKC9cXFxcXFxcXC9nLCAnXFxcXCcpO1xuXG4gICAgICAgIGlmICgvXlwiLipcIiQvLnRlc3QoZmlsZU5hbWUpKSB7XG4gICAgICAgICAgZmlsZU5hbWUgPSBmaWxlTmFtZS5zdWJzdHIoMSwgZmlsZU5hbWUubGVuZ3RoIC0gMik7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleFtrZXlQcmVmaXggKyAnRmlsZU5hbWUnXSA9IGZpbGVOYW1lO1xuICAgICAgICBpbmRleFtrZXlQcmVmaXggKyAnSGVhZGVyJ10gPSAoZGF0YVsxXSB8fCAnJykudHJpbSgpO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfSAvLyBQYXJzZXMgYSBodW5rXG4gICAgLy8gVGhpcyBhc3N1bWVzIHRoYXQgd2UgYXJlIGF0IHRoZSBzdGFydCBvZiBhIGh1bmsuXG5cblxuICAgIGZ1bmN0aW9uIHBhcnNlSHVuaygpIHtcbiAgICAgIHZhciBjaHVua0hlYWRlckluZGV4ID0gaSxcbiAgICAgICAgICBjaHVua0hlYWRlckxpbmUgPSBkaWZmc3RyW2krK10sXG4gICAgICAgICAgY2h1bmtIZWFkZXIgPSBjaHVua0hlYWRlckxpbmUuc3BsaXQoL0BAIC0oXFxkKykoPzosKFxcZCspKT8gXFwrKFxcZCspKD86LChcXGQrKSk/IEBALyk7XG4gICAgICB2YXIgaHVuayA9IHtcbiAgICAgICAgb2xkU3RhcnQ6ICtjaHVua0hlYWRlclsxXSxcbiAgICAgICAgb2xkTGluZXM6ICtjaHVua0hlYWRlclsyXSB8fCAxLFxuICAgICAgICBuZXdTdGFydDogK2NodW5rSGVhZGVyWzNdLFxuICAgICAgICBuZXdMaW5lczogK2NodW5rSGVhZGVyWzRdIHx8IDEsXG4gICAgICAgIGxpbmVzOiBbXSxcbiAgICAgICAgbGluZWRlbGltaXRlcnM6IFtdXG4gICAgICB9O1xuICAgICAgdmFyIGFkZENvdW50ID0gMCxcbiAgICAgICAgICByZW1vdmVDb3VudCA9IDA7XG5cbiAgICAgIGZvciAoOyBpIDwgZGlmZnN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBMaW5lcyBzdGFydGluZyB3aXRoICctLS0nIGNvdWxkIGJlIG1pc3Rha2VuIGZvciB0aGUgXCJyZW1vdmUgbGluZVwiIG9wZXJhdGlvblxuICAgICAgICAvLyBCdXQgdGhleSBjb3VsZCBiZSB0aGUgaGVhZGVyIGZvciB0aGUgbmV4dCBmaWxlLiBUaGVyZWZvcmUgcHJ1bmUgc3VjaCBjYXNlcyBvdXQuXG4gICAgICAgIGlmIChkaWZmc3RyW2ldLmluZGV4T2YoJy0tLSAnKSA9PT0gMCAmJiBpICsgMiA8IGRpZmZzdHIubGVuZ3RoICYmIGRpZmZzdHJbaSArIDFdLmluZGV4T2YoJysrKyAnKSA9PT0gMCAmJiBkaWZmc3RyW2kgKyAyXS5pbmRleE9mKCdAQCcpID09PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3BlcmF0aW9uID0gZGlmZnN0cltpXS5sZW5ndGggPT0gMCAmJiBpICE9IGRpZmZzdHIubGVuZ3RoIC0gMSA/ICcgJyA6IGRpZmZzdHJbaV1bMF07XG5cbiAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJysnIHx8IG9wZXJhdGlvbiA9PT0gJy0nIHx8IG9wZXJhdGlvbiA9PT0gJyAnIHx8IG9wZXJhdGlvbiA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgaHVuay5saW5lcy5wdXNoKGRpZmZzdHJbaV0pO1xuICAgICAgICAgIGh1bmsubGluZWRlbGltaXRlcnMucHVzaChkZWxpbWl0ZXJzW2ldIHx8ICdcXG4nKTtcblxuICAgICAgICAgIGlmIChvcGVyYXRpb24gPT09ICcrJykge1xuICAgICAgICAgICAgYWRkQ291bnQrKztcbiAgICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJy0nKSB7XG4gICAgICAgICAgICByZW1vdmVDb3VudCsrO1xuICAgICAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnICcpIHtcbiAgICAgICAgICAgIGFkZENvdW50Kys7XG4gICAgICAgICAgICByZW1vdmVDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSAvLyBIYW5kbGUgdGhlIGVtcHR5IGJsb2NrIGNvdW50IGNhc2VcblxuXG4gICAgICBpZiAoIWFkZENvdW50ICYmIGh1bmsubmV3TGluZXMgPT09IDEpIHtcbiAgICAgICAgaHVuay5uZXdMaW5lcyA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICghcmVtb3ZlQ291bnQgJiYgaHVuay5vbGRMaW5lcyA9PT0gMSkge1xuICAgICAgICBodW5rLm9sZExpbmVzID0gMDtcbiAgICAgIH0gLy8gUGVyZm9ybSBvcHRpb25hbCBzYW5pdHkgY2hlY2tpbmdcblxuXG4gICAgICBpZiAob3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgaWYgKGFkZENvdW50ICE9PSBodW5rLm5ld0xpbmVzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZGRlZCBsaW5lIGNvdW50IGRpZCBub3QgbWF0Y2ggZm9yIGh1bmsgYXQgbGluZSAnICsgKGNodW5rSGVhZGVySW5kZXggKyAxKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVtb3ZlQ291bnQgIT09IGh1bmsub2xkTGluZXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbW92ZWQgbGluZSBjb3VudCBkaWQgbm90IG1hdGNoIGZvciBodW5rIGF0IGxpbmUgJyArIChjaHVua0hlYWRlckluZGV4ICsgMSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBodW5rO1xuICAgIH1cblxuICAgIHdoaWxlIChpIDwgZGlmZnN0ci5sZW5ndGgpIHtcbiAgICAgIHBhcnNlSW5kZXgoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdDtcbiAgfSAvLyBJdGVyYXRvciB0aGF0IHRyYXZlcnNlcyBpbiB0aGUgcmFuZ2Ugb2YgW21pbiwgbWF4XSwgc3RlcHBpbmdcbiAgLy8gYnkgZGlzdGFuY2UgZnJvbSBhIGdpdmVuIHN0YXJ0IHBvc2l0aW9uLiBJLmUuIGZvciBbMCwgNF0sIHdpdGhcbiAgLy8gc3RhcnQgb2YgMiwgdGhpcyB3aWxsIGl0ZXJhdGUgMiwgMywgMSwgNCwgMC5cblxuXG4gIGZ1bmN0aW9uIGRpc3RhbmNlSXRlcmF0b3Ioc3RhcnQsIG1pbkxpbmUsIG1heExpbmUpIHtcbiAgICB2YXIgd2FudEZvcndhcmQgPSB0cnVlLFxuICAgICAgICBiYWNrd2FyZEV4aGF1c3RlZCA9IGZhbHNlLFxuICAgICAgICBmb3J3YXJkRXhoYXVzdGVkID0gZmFsc2UsXG4gICAgICAgIGxvY2FsT2Zmc2V0ID0gMTtcbiAgICByZXR1cm4gZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICBpZiAod2FudEZvcndhcmQgJiYgIWZvcndhcmRFeGhhdXN0ZWQpIHtcbiAgICAgICAgaWYgKGJhY2t3YXJkRXhoYXVzdGVkKSB7XG4gICAgICAgICAgbG9jYWxPZmZzZXQrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YW50Rm9yd2FyZCA9IGZhbHNlO1xuICAgICAgICB9IC8vIENoZWNrIGlmIHRyeWluZyB0byBmaXQgYmV5b25kIHRleHQgbGVuZ3RoLCBhbmQgaWYgbm90LCBjaGVjayBpdCBmaXRzXG4gICAgICAgIC8vIGFmdGVyIG9mZnNldCBsb2NhdGlvbiAob3IgZGVzaXJlZCBsb2NhdGlvbiBvbiBmaXJzdCBpdGVyYXRpb24pXG5cblxuICAgICAgICBpZiAoc3RhcnQgKyBsb2NhbE9mZnNldCA8PSBtYXhMaW5lKSB7XG4gICAgICAgICAgcmV0dXJuIGxvY2FsT2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yd2FyZEV4aGF1c3RlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghYmFja3dhcmRFeGhhdXN0ZWQpIHtcbiAgICAgICAgaWYgKCFmb3J3YXJkRXhoYXVzdGVkKSB7XG4gICAgICAgICAgd2FudEZvcndhcmQgPSB0cnVlO1xuICAgICAgICB9IC8vIENoZWNrIGlmIHRyeWluZyB0byBmaXQgYmVmb3JlIHRleHQgYmVnaW5uaW5nLCBhbmQgaWYgbm90LCBjaGVjayBpdCBmaXRzXG4gICAgICAgIC8vIGJlZm9yZSBvZmZzZXQgbG9jYXRpb25cblxuXG4gICAgICAgIGlmIChtaW5MaW5lIDw9IHN0YXJ0IC0gbG9jYWxPZmZzZXQpIHtcbiAgICAgICAgICByZXR1cm4gLWxvY2FsT2Zmc2V0Kys7XG4gICAgICAgIH1cblxuICAgICAgICBiYWNrd2FyZEV4aGF1c3RlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBpdGVyYXRvcigpO1xuICAgICAgfSAvLyBXZSB0cmllZCB0byBmaXQgaHVuayBiZWZvcmUgdGV4dCBiZWdpbm5pbmcgYW5kIGJleW9uZCB0ZXh0IGxlbmd0aCwgdGhlblxuICAgICAgLy8gaHVuayBjYW4ndCBmaXQgb24gdGhlIHRleHQuIFJldHVybiB1bmRlZmluZWRcblxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseVBhdGNoKHNvdXJjZSwgdW5pRGlmZikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIGlmICh0eXBlb2YgdW5pRGlmZiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHVuaURpZmYgPSBwYXJzZVBhdGNoKHVuaURpZmYpO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHVuaURpZmYpKSB7XG4gICAgICBpZiAodW5pRGlmZi5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXBwbHlQYXRjaCBvbmx5IHdvcmtzIHdpdGggYSBzaW5nbGUgaW5wdXQuJyk7XG4gICAgICB9XG5cbiAgICAgIHVuaURpZmYgPSB1bmlEaWZmWzBdO1xuICAgIH0gLy8gQXBwbHkgdGhlIGRpZmYgdG8gdGhlIGlucHV0XG5cblxuICAgIHZhciBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvXFxyXFxufFtcXG5cXHZcXGZcXHJcXHg4NV0vKSxcbiAgICAgICAgZGVsaW1pdGVycyA9IHNvdXJjZS5tYXRjaCgvXFxyXFxufFtcXG5cXHZcXGZcXHJcXHg4NV0vZykgfHwgW10sXG4gICAgICAgIGh1bmtzID0gdW5pRGlmZi5odW5rcyxcbiAgICAgICAgY29tcGFyZUxpbmUgPSBvcHRpb25zLmNvbXBhcmVMaW5lIHx8IGZ1bmN0aW9uIChsaW5lTnVtYmVyLCBsaW5lLCBvcGVyYXRpb24sIHBhdGNoQ29udGVudCkge1xuICAgICAgcmV0dXJuIGxpbmUgPT09IHBhdGNoQ29udGVudDtcbiAgICB9LFxuICAgICAgICBlcnJvckNvdW50ID0gMCxcbiAgICAgICAgZnV6ekZhY3RvciA9IG9wdGlvbnMuZnV6ekZhY3RvciB8fCAwLFxuICAgICAgICBtaW5MaW5lID0gMCxcbiAgICAgICAgb2Zmc2V0ID0gMCxcbiAgICAgICAgcmVtb3ZlRU9GTkwsXG4gICAgICAgIGFkZEVPRk5MO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgaHVuayBleGFjdGx5IGZpdHMgb24gdGhlIHByb3ZpZGVkIGxvY2F0aW9uXG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIGh1bmtGaXRzKGh1bmssIHRvUG9zKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGh1bmsubGluZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSBodW5rLmxpbmVzW2pdLFxuICAgICAgICAgICAgb3BlcmF0aW9uID0gbGluZS5sZW5ndGggPiAwID8gbGluZVswXSA6ICcgJyxcbiAgICAgICAgICAgIGNvbnRlbnQgPSBsaW5lLmxlbmd0aCA+IDAgPyBsaW5lLnN1YnN0cigxKSA6IGxpbmU7XG5cbiAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJyAnIHx8IG9wZXJhdGlvbiA9PT0gJy0nKSB7XG4gICAgICAgICAgLy8gQ29udGV4dCBzYW5pdHkgY2hlY2tcbiAgICAgICAgICBpZiAoIWNvbXBhcmVMaW5lKHRvUG9zICsgMSwgbGluZXNbdG9Qb3NdLCBvcGVyYXRpb24sIGNvbnRlbnQpKSB7XG4gICAgICAgICAgICBlcnJvckNvdW50Kys7XG5cbiAgICAgICAgICAgIGlmIChlcnJvckNvdW50ID4gZnV6ekZhY3Rvcikge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9Qb3MrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIFNlYXJjaCBiZXN0IGZpdCBvZmZzZXRzIGZvciBlYWNoIGh1bmsgYmFzZWQgb24gdGhlIHByZXZpb3VzIG9uZXNcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBodW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGh1bmsgPSBodW5rc1tpXSxcbiAgICAgICAgICBtYXhMaW5lID0gbGluZXMubGVuZ3RoIC0gaHVuay5vbGRMaW5lcyxcbiAgICAgICAgICBsb2NhbE9mZnNldCA9IDAsXG4gICAgICAgICAgdG9Qb3MgPSBvZmZzZXQgKyBodW5rLm9sZFN0YXJ0IC0gMTtcbiAgICAgIHZhciBpdGVyYXRvciA9IGRpc3RhbmNlSXRlcmF0b3IodG9Qb3MsIG1pbkxpbmUsIG1heExpbmUpO1xuXG4gICAgICBmb3IgKDsgbG9jYWxPZmZzZXQgIT09IHVuZGVmaW5lZDsgbG9jYWxPZmZzZXQgPSBpdGVyYXRvcigpKSB7XG4gICAgICAgIGlmIChodW5rRml0cyhodW5rLCB0b1BvcyArIGxvY2FsT2Zmc2V0KSkge1xuICAgICAgICAgIGh1bmsub2Zmc2V0ID0gb2Zmc2V0ICs9IGxvY2FsT2Zmc2V0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsb2NhbE9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gU2V0IGxvd2VyIHRleHQgbGltaXQgdG8gZW5kIG9mIHRoZSBjdXJyZW50IGh1bmssIHNvIG5leHQgb25lcyBkb24ndCB0cnlcbiAgICAgIC8vIHRvIGZpdCBvdmVyIGFscmVhZHkgcGF0Y2hlZCB0ZXh0XG5cblxuICAgICAgbWluTGluZSA9IGh1bmsub2Zmc2V0ICsgaHVuay5vbGRTdGFydCArIGh1bmsub2xkTGluZXM7XG4gICAgfSAvLyBBcHBseSBwYXRjaCBodW5rc1xuXG5cbiAgICB2YXIgZGlmZk9mZnNldCA9IDA7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgaHVua3MubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2h1bmsgPSBodW5rc1tfaV0sXG4gICAgICAgICAgX3RvUG9zID0gX2h1bmsub2xkU3RhcnQgKyBfaHVuay5vZmZzZXQgKyBkaWZmT2Zmc2V0IC0gMTtcblxuICAgICAgZGlmZk9mZnNldCArPSBfaHVuay5uZXdMaW5lcyAtIF9odW5rLm9sZExpbmVzO1xuXG4gICAgICBpZiAoX3RvUG9zIDwgMCkge1xuICAgICAgICAvLyBDcmVhdGluZyBhIG5ldyBmaWxlXG4gICAgICAgIF90b1BvcyA9IDA7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgX2h1bmsubGluZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSBfaHVuay5saW5lc1tqXSxcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IGxpbmUubGVuZ3RoID4gMCA/IGxpbmVbMF0gOiAnICcsXG4gICAgICAgICAgICBjb250ZW50ID0gbGluZS5sZW5ndGggPiAwID8gbGluZS5zdWJzdHIoMSkgOiBsaW5lLFxuICAgICAgICAgICAgZGVsaW1pdGVyID0gX2h1bmsubGluZWRlbGltaXRlcnNbal07XG5cbiAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJyAnKSB7XG4gICAgICAgICAgX3RvUG9zKys7XG4gICAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnLScpIHtcbiAgICAgICAgICBsaW5lcy5zcGxpY2UoX3RvUG9zLCAxKTtcbiAgICAgICAgICBkZWxpbWl0ZXJzLnNwbGljZShfdG9Qb3MsIDEpO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnKycpIHtcbiAgICAgICAgICBsaW5lcy5zcGxpY2UoX3RvUG9zLCAwLCBjb250ZW50KTtcbiAgICAgICAgICBkZWxpbWl0ZXJzLnNwbGljZShfdG9Qb3MsIDAsIGRlbGltaXRlcik7XG4gICAgICAgICAgX3RvUG9zKys7XG4gICAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnXFxcXCcpIHtcbiAgICAgICAgICB2YXIgcHJldmlvdXNPcGVyYXRpb24gPSBfaHVuay5saW5lc1tqIC0gMV0gPyBfaHVuay5saW5lc1tqIC0gMV1bMF0gOiBudWxsO1xuXG4gICAgICAgICAgaWYgKHByZXZpb3VzT3BlcmF0aW9uID09PSAnKycpIHtcbiAgICAgICAgICAgIHJlbW92ZUVPRk5MID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByZXZpb3VzT3BlcmF0aW9uID09PSAnLScpIHtcbiAgICAgICAgICAgIGFkZEVPRk5MID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIEhhbmRsZSBFT0ZOTCBpbnNlcnRpb24vcmVtb3ZhbFxuXG5cbiAgICBpZiAocmVtb3ZlRU9GTkwpIHtcbiAgICAgIHdoaWxlICghbGluZXNbbGluZXMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgbGluZXMucG9wKCk7XG4gICAgICAgIGRlbGltaXRlcnMucG9wKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhZGRFT0ZOTCkge1xuICAgICAgbGluZXMucHVzaCgnJyk7XG4gICAgICBkZWxpbWl0ZXJzLnB1c2goJ1xcbicpO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9rID0gMDsgX2sgPCBsaW5lcy5sZW5ndGggLSAxOyBfaysrKSB7XG4gICAgICBsaW5lc1tfa10gPSBsaW5lc1tfa10gKyBkZWxpbWl0ZXJzW19rXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGluZXMuam9pbignJyk7XG4gIH0gLy8gV3JhcHBlciB0aGF0IHN1cHBvcnRzIG11bHRpcGxlIGZpbGUgcGF0Y2hlcyB2aWEgY2FsbGJhY2tzLlxuXG5cbiAgZnVuY3Rpb24gYXBwbHlQYXRjaGVzKHVuaURpZmYsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHVuaURpZmYgPT09ICdzdHJpbmcnKSB7XG4gICAgICB1bmlEaWZmID0gcGFyc2VQYXRjaCh1bmlEaWZmKTtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudEluZGV4ID0gMDtcblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NJbmRleCgpIHtcbiAgICAgIHZhciBpbmRleCA9IHVuaURpZmZbY3VycmVudEluZGV4KytdO1xuXG4gICAgICBpZiAoIWluZGV4KSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmNvbXBsZXRlKCk7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMubG9hZEZpbGUoaW5kZXgsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBvcHRpb25zLmNvbXBsZXRlKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdXBkYXRlZENvbnRlbnQgPSBhcHBseVBhdGNoKGRhdGEsIGluZGV4LCBvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy5wYXRjaGVkKGluZGV4LCB1cGRhdGVkQ29udGVudCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNvbXBsZXRlKGVycik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHJvY2Vzc0luZGV4KCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJvY2Vzc0luZGV4KCk7XG4gIH1cblxuICBmdW5jdGlvbiBzdHJ1Y3R1cmVkUGF0Y2gob2xkRmlsZU5hbWUsIG5ld0ZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuY29udGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9wdGlvbnMuY29udGV4dCA9IDQ7XG4gICAgfVxuXG4gICAgdmFyIGRpZmYgPSBkaWZmTGluZXMob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpO1xuICAgIGRpZmYucHVzaCh7XG4gICAgICB2YWx1ZTogJycsXG4gICAgICBsaW5lczogW11cbiAgICB9KTsgLy8gQXBwZW5kIGFuIGVtcHR5IHZhbHVlIHRvIG1ha2UgY2xlYW51cCBlYXNpZXJcblxuICAgIGZ1bmN0aW9uIGNvbnRleHRMaW5lcyhsaW5lcykge1xuICAgICAgcmV0dXJuIGxpbmVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgcmV0dXJuICcgJyArIGVudHJ5O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGh1bmtzID0gW107XG4gICAgdmFyIG9sZFJhbmdlU3RhcnQgPSAwLFxuICAgICAgICBuZXdSYW5nZVN0YXJ0ID0gMCxcbiAgICAgICAgY3VyUmFuZ2UgPSBbXSxcbiAgICAgICAgb2xkTGluZSA9IDEsXG4gICAgICAgIG5ld0xpbmUgPSAxO1xuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBkaWZmW2ldLFxuICAgICAgICAgIGxpbmVzID0gY3VycmVudC5saW5lcyB8fCBjdXJyZW50LnZhbHVlLnJlcGxhY2UoL1xcbiQvLCAnJykuc3BsaXQoJ1xcbicpO1xuICAgICAgY3VycmVudC5saW5lcyA9IGxpbmVzO1xuXG4gICAgICBpZiAoY3VycmVudC5hZGRlZCB8fCBjdXJyZW50LnJlbW92ZWQpIHtcbiAgICAgICAgdmFyIF9jdXJSYW5nZTsgLy8gSWYgd2UgaGF2ZSBwcmV2aW91cyBjb250ZXh0LCBzdGFydCB3aXRoIHRoYXRcblxuXG4gICAgICAgIGlmICghb2xkUmFuZ2VTdGFydCkge1xuICAgICAgICAgIHZhciBwcmV2ID0gZGlmZltpIC0gMV07XG4gICAgICAgICAgb2xkUmFuZ2VTdGFydCA9IG9sZExpbmU7XG4gICAgICAgICAgbmV3UmFuZ2VTdGFydCA9IG5ld0xpbmU7XG5cbiAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgY3VyUmFuZ2UgPSBvcHRpb25zLmNvbnRleHQgPiAwID8gY29udGV4dExpbmVzKHByZXYubGluZXMuc2xpY2UoLW9wdGlvbnMuY29udGV4dCkpIDogW107XG4gICAgICAgICAgICBvbGRSYW5nZVN0YXJ0IC09IGN1clJhbmdlLmxlbmd0aDtcbiAgICAgICAgICAgIG5ld1JhbmdlU3RhcnQgLT0gY3VyUmFuZ2UubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBPdXRwdXQgb3VyIGNoYW5nZXNcblxuXG4gICAgICAgIChfY3VyUmFuZ2UgPSBjdXJSYW5nZSkucHVzaC5hcHBseShfY3VyUmFuZ2UsIF90b0NvbnN1bWFibGVBcnJheSQxKGxpbmVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICByZXR1cm4gKGN1cnJlbnQuYWRkZWQgPyAnKycgOiAnLScpICsgZW50cnk7XG4gICAgICAgIH0pKSk7IC8vIFRyYWNrIHRoZSB1cGRhdGVkIGZpbGUgcG9zaXRpb25cblxuXG4gICAgICAgIGlmIChjdXJyZW50LmFkZGVkKSB7XG4gICAgICAgICAgbmV3TGluZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2xkTGluZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElkZW50aWNhbCBjb250ZXh0IGxpbmVzLiBUcmFjayBsaW5lIGNoYW5nZXNcbiAgICAgICAgaWYgKG9sZFJhbmdlU3RhcnQpIHtcbiAgICAgICAgICAvLyBDbG9zZSBvdXQgYW55IGNoYW5nZXMgdGhhdCBoYXZlIGJlZW4gb3V0cHV0IChvciBqb2luIG92ZXJsYXBwaW5nKVxuICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPD0gb3B0aW9ucy5jb250ZXh0ICogMiAmJiBpIDwgZGlmZi5sZW5ndGggLSAyKSB7XG4gICAgICAgICAgICB2YXIgX2N1clJhbmdlMjsgLy8gT3ZlcmxhcHBpbmdcblxuXG4gICAgICAgICAgICAoX2N1clJhbmdlMiA9IGN1clJhbmdlKS5wdXNoLmFwcGx5KF9jdXJSYW5nZTIsIF90b0NvbnN1bWFibGVBcnJheSQxKGNvbnRleHRMaW5lcyhsaW5lcykpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIF9jdXJSYW5nZTM7IC8vIGVuZCB0aGUgcmFuZ2UgYW5kIG91dHB1dFxuXG5cbiAgICAgICAgICAgIHZhciBjb250ZXh0U2l6ZSA9IE1hdGgubWluKGxpbmVzLmxlbmd0aCwgb3B0aW9ucy5jb250ZXh0KTtcblxuICAgICAgICAgICAgKF9jdXJSYW5nZTMgPSBjdXJSYW5nZSkucHVzaC5hcHBseShfY3VyUmFuZ2UzLCBfdG9Db25zdW1hYmxlQXJyYXkkMShjb250ZXh0TGluZXMobGluZXMuc2xpY2UoMCwgY29udGV4dFNpemUpKSkpO1xuXG4gICAgICAgICAgICB2YXIgaHVuayA9IHtcbiAgICAgICAgICAgICAgb2xkU3RhcnQ6IG9sZFJhbmdlU3RhcnQsXG4gICAgICAgICAgICAgIG9sZExpbmVzOiBvbGRMaW5lIC0gb2xkUmFuZ2VTdGFydCArIGNvbnRleHRTaXplLFxuICAgICAgICAgICAgICBuZXdTdGFydDogbmV3UmFuZ2VTdGFydCxcbiAgICAgICAgICAgICAgbmV3TGluZXM6IG5ld0xpbmUgLSBuZXdSYW5nZVN0YXJ0ICsgY29udGV4dFNpemUsXG4gICAgICAgICAgICAgIGxpbmVzOiBjdXJSYW5nZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGkgPj0gZGlmZi5sZW5ndGggLSAyICYmIGxpbmVzLmxlbmd0aCA8PSBvcHRpb25zLmNvbnRleHQpIHtcbiAgICAgICAgICAgICAgLy8gRU9GIGlzIGluc2lkZSB0aGlzIGh1bmtcbiAgICAgICAgICAgICAgdmFyIG9sZEVPRk5ld2xpbmUgPSAvXFxuJC8udGVzdChvbGRTdHIpO1xuICAgICAgICAgICAgICB2YXIgbmV3RU9GTmV3bGluZSA9IC9cXG4kLy50ZXN0KG5ld1N0cik7XG4gICAgICAgICAgICAgIHZhciBub05sQmVmb3JlQWRkcyA9IGxpbmVzLmxlbmd0aCA9PSAwICYmIGN1clJhbmdlLmxlbmd0aCA+IGh1bmsub2xkTGluZXM7XG5cbiAgICAgICAgICAgICAgaWYgKCFvbGRFT0ZOZXdsaW5lICYmIG5vTmxCZWZvcmVBZGRzKSB7XG4gICAgICAgICAgICAgICAgLy8gc3BlY2lhbCBjYXNlOiBvbGQgaGFzIG5vIGVvbCBhbmQgbm8gdHJhaWxpbmcgY29udGV4dDsgbm8tbmwgY2FuIGVuZCB1cCBiZWZvcmUgYWRkc1xuICAgICAgICAgICAgICAgIGN1clJhbmdlLnNwbGljZShodW5rLm9sZExpbmVzLCAwLCAnXFxcXCBObyBuZXdsaW5lIGF0IGVuZCBvZiBmaWxlJyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIW9sZEVPRk5ld2xpbmUgJiYgIW5vTmxCZWZvcmVBZGRzIHx8ICFuZXdFT0ZOZXdsaW5lKSB7XG4gICAgICAgICAgICAgICAgY3VyUmFuZ2UucHVzaCgnXFxcXCBObyBuZXdsaW5lIGF0IGVuZCBvZiBmaWxlJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaHVua3MucHVzaChodW5rKTtcbiAgICAgICAgICAgIG9sZFJhbmdlU3RhcnQgPSAwO1xuICAgICAgICAgICAgbmV3UmFuZ2VTdGFydCA9IDA7XG4gICAgICAgICAgICBjdXJSYW5nZSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9sZExpbmUgKz0gbGluZXMubGVuZ3RoO1xuICAgICAgICBuZXdMaW5lICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWZmLmxlbmd0aDsgaSsrKSB7XG4gICAgICBfbG9vcChpKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgb2xkRmlsZU5hbWU6IG9sZEZpbGVOYW1lLFxuICAgICAgbmV3RmlsZU5hbWU6IG5ld0ZpbGVOYW1lLFxuICAgICAgb2xkSGVhZGVyOiBvbGRIZWFkZXIsXG4gICAgICBuZXdIZWFkZXI6IG5ld0hlYWRlcixcbiAgICAgIGh1bmtzOiBodW5rc1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVUd29GaWxlc1BhdGNoKG9sZEZpbGVOYW1lLCBuZXdGaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKSB7XG4gICAgdmFyIGRpZmYgPSBzdHJ1Y3R1cmVkUGF0Y2gob2xkRmlsZU5hbWUsIG5ld0ZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpO1xuICAgIHZhciByZXQgPSBbXTtcblxuICAgIGlmIChvbGRGaWxlTmFtZSA9PSBuZXdGaWxlTmFtZSkge1xuICAgICAgcmV0LnB1c2goJ0luZGV4OiAnICsgb2xkRmlsZU5hbWUpO1xuICAgIH1cblxuICAgIHJldC5wdXNoKCc9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Jyk7XG4gICAgcmV0LnB1c2goJy0tLSAnICsgZGlmZi5vbGRGaWxlTmFtZSArICh0eXBlb2YgZGlmZi5vbGRIZWFkZXIgPT09ICd1bmRlZmluZWQnID8gJycgOiAnXFx0JyArIGRpZmYub2xkSGVhZGVyKSk7XG4gICAgcmV0LnB1c2goJysrKyAnICsgZGlmZi5uZXdGaWxlTmFtZSArICh0eXBlb2YgZGlmZi5uZXdIZWFkZXIgPT09ICd1bmRlZmluZWQnID8gJycgOiAnXFx0JyArIGRpZmYubmV3SGVhZGVyKSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpZmYuaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBodW5rID0gZGlmZi5odW5rc1tpXTtcbiAgICAgIHJldC5wdXNoKCdAQCAtJyArIGh1bmsub2xkU3RhcnQgKyAnLCcgKyBodW5rLm9sZExpbmVzICsgJyArJyArIGh1bmsubmV3U3RhcnQgKyAnLCcgKyBodW5rLm5ld0xpbmVzICsgJyBAQCcpO1xuICAgICAgcmV0LnB1c2guYXBwbHkocmV0LCBodW5rLmxpbmVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0LmpvaW4oJ1xcbicpICsgJ1xcbic7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQYXRjaChmaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVR3b0ZpbGVzUGF0Y2goZmlsZU5hbWUsIGZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlFcXVhbChhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheVN0YXJ0c1dpdGgoYSwgYik7XG4gIH1cblxuICBmdW5jdGlvbiBhcnJheVN0YXJ0c1dpdGgoYXJyYXksIHN0YXJ0KSB7XG4gICAgaWYgKHN0YXJ0Lmxlbmd0aCA+IGFycmF5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzdGFydFtpXSAhPT0gYXJyYXlbaV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FsY0xpbmVDb3VudChodW5rKSB7XG4gICAgdmFyIF9jYWxjT2xkTmV3TGluZUNvdW50ID0gY2FsY09sZE5ld0xpbmVDb3VudChodW5rLmxpbmVzKSxcbiAgICAgICAgb2xkTGluZXMgPSBfY2FsY09sZE5ld0xpbmVDb3VudC5vbGRMaW5lcyxcbiAgICAgICAgbmV3TGluZXMgPSBfY2FsY09sZE5ld0xpbmVDb3VudC5uZXdMaW5lcztcblxuICAgIGlmIChvbGRMaW5lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBodW5rLm9sZExpbmVzID0gb2xkTGluZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBodW5rLm9sZExpbmVzO1xuICAgIH1cblxuICAgIGlmIChuZXdMaW5lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBodW5rLm5ld0xpbmVzID0gbmV3TGluZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBodW5rLm5ld0xpbmVzO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlKG1pbmUsIHRoZWlycywgYmFzZSkge1xuICAgIG1pbmUgPSBsb2FkUGF0Y2gobWluZSwgYmFzZSk7XG4gICAgdGhlaXJzID0gbG9hZFBhdGNoKHRoZWlycywgYmFzZSk7XG4gICAgdmFyIHJldCA9IHt9OyAvLyBGb3IgaW5kZXggd2UganVzdCBsZXQgaXQgcGFzcyB0aHJvdWdoIGFzIGl0IGRvZXNuJ3QgaGF2ZSBhbnkgbmVjZXNzYXJ5IG1lYW5pbmcuXG4gICAgLy8gTGVhdmluZyBzYW5pdHkgY2hlY2tzIG9uIHRoaXMgdG8gdGhlIEFQSSBjb25zdW1lciB0aGF0IG1heSBrbm93IG1vcmUgYWJvdXQgdGhlXG4gICAgLy8gbWVhbmluZyBpbiB0aGVpciBvd24gY29udGV4dC5cblxuICAgIGlmIChtaW5lLmluZGV4IHx8IHRoZWlycy5pbmRleCkge1xuICAgICAgcmV0LmluZGV4ID0gbWluZS5pbmRleCB8fCB0aGVpcnMuaW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKG1pbmUubmV3RmlsZU5hbWUgfHwgdGhlaXJzLm5ld0ZpbGVOYW1lKSB7XG4gICAgICBpZiAoIWZpbGVOYW1lQ2hhbmdlZChtaW5lKSkge1xuICAgICAgICAvLyBObyBoZWFkZXIgb3Igbm8gY2hhbmdlIGluIG91cnMsIHVzZSB0aGVpcnMgKGFuZCBvdXJzIGlmIHRoZWlycyBkb2VzIG5vdCBleGlzdClcbiAgICAgICAgcmV0Lm9sZEZpbGVOYW1lID0gdGhlaXJzLm9sZEZpbGVOYW1lIHx8IG1pbmUub2xkRmlsZU5hbWU7XG4gICAgICAgIHJldC5uZXdGaWxlTmFtZSA9IHRoZWlycy5uZXdGaWxlTmFtZSB8fCBtaW5lLm5ld0ZpbGVOYW1lO1xuICAgICAgICByZXQub2xkSGVhZGVyID0gdGhlaXJzLm9sZEhlYWRlciB8fCBtaW5lLm9sZEhlYWRlcjtcbiAgICAgICAgcmV0Lm5ld0hlYWRlciA9IHRoZWlycy5uZXdIZWFkZXIgfHwgbWluZS5uZXdIZWFkZXI7XG4gICAgICB9IGVsc2UgaWYgKCFmaWxlTmFtZUNoYW5nZWQodGhlaXJzKSkge1xuICAgICAgICAvLyBObyBoZWFkZXIgb3Igbm8gY2hhbmdlIGluIHRoZWlycywgdXNlIG91cnNcbiAgICAgICAgcmV0Lm9sZEZpbGVOYW1lID0gbWluZS5vbGRGaWxlTmFtZTtcbiAgICAgICAgcmV0Lm5ld0ZpbGVOYW1lID0gbWluZS5uZXdGaWxlTmFtZTtcbiAgICAgICAgcmV0Lm9sZEhlYWRlciA9IG1pbmUub2xkSGVhZGVyO1xuICAgICAgICByZXQubmV3SGVhZGVyID0gbWluZS5uZXdIZWFkZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCb3RoIGNoYW5nZWQuLi4gZmlndXJlIGl0IG91dFxuICAgICAgICByZXQub2xkRmlsZU5hbWUgPSBzZWxlY3RGaWVsZChyZXQsIG1pbmUub2xkRmlsZU5hbWUsIHRoZWlycy5vbGRGaWxlTmFtZSk7XG4gICAgICAgIHJldC5uZXdGaWxlTmFtZSA9IHNlbGVjdEZpZWxkKHJldCwgbWluZS5uZXdGaWxlTmFtZSwgdGhlaXJzLm5ld0ZpbGVOYW1lKTtcbiAgICAgICAgcmV0Lm9sZEhlYWRlciA9IHNlbGVjdEZpZWxkKHJldCwgbWluZS5vbGRIZWFkZXIsIHRoZWlycy5vbGRIZWFkZXIpO1xuICAgICAgICByZXQubmV3SGVhZGVyID0gc2VsZWN0RmllbGQocmV0LCBtaW5lLm5ld0hlYWRlciwgdGhlaXJzLm5ld0hlYWRlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0Lmh1bmtzID0gW107XG4gICAgdmFyIG1pbmVJbmRleCA9IDAsXG4gICAgICAgIHRoZWlyc0luZGV4ID0gMCxcbiAgICAgICAgbWluZU9mZnNldCA9IDAsXG4gICAgICAgIHRoZWlyc09mZnNldCA9IDA7XG5cbiAgICB3aGlsZSAobWluZUluZGV4IDwgbWluZS5odW5rcy5sZW5ndGggfHwgdGhlaXJzSW5kZXggPCB0aGVpcnMuaHVua3MubGVuZ3RoKSB7XG4gICAgICB2YXIgbWluZUN1cnJlbnQgPSBtaW5lLmh1bmtzW21pbmVJbmRleF0gfHwge1xuICAgICAgICBvbGRTdGFydDogSW5maW5pdHlcbiAgICAgIH0sXG4gICAgICAgICAgdGhlaXJzQ3VycmVudCA9IHRoZWlycy5odW5rc1t0aGVpcnNJbmRleF0gfHwge1xuICAgICAgICBvbGRTdGFydDogSW5maW5pdHlcbiAgICAgIH07XG5cbiAgICAgIGlmIChodW5rQmVmb3JlKG1pbmVDdXJyZW50LCB0aGVpcnNDdXJyZW50KSkge1xuICAgICAgICAvLyBUaGlzIHBhdGNoIGRvZXMgbm90IG92ZXJsYXAgd2l0aCBhbnkgb2YgdGhlIG90aGVycywgeWF5LlxuICAgICAgICByZXQuaHVua3MucHVzaChjbG9uZUh1bmsobWluZUN1cnJlbnQsIG1pbmVPZmZzZXQpKTtcbiAgICAgICAgbWluZUluZGV4Kys7XG4gICAgICAgIHRoZWlyc09mZnNldCArPSBtaW5lQ3VycmVudC5uZXdMaW5lcyAtIG1pbmVDdXJyZW50Lm9sZExpbmVzO1xuICAgICAgfSBlbHNlIGlmIChodW5rQmVmb3JlKHRoZWlyc0N1cnJlbnQsIG1pbmVDdXJyZW50KSkge1xuICAgICAgICAvLyBUaGlzIHBhdGNoIGRvZXMgbm90IG92ZXJsYXAgd2l0aCBhbnkgb2YgdGhlIG90aGVycywgeWF5LlxuICAgICAgICByZXQuaHVua3MucHVzaChjbG9uZUh1bmsodGhlaXJzQ3VycmVudCwgdGhlaXJzT2Zmc2V0KSk7XG4gICAgICAgIHRoZWlyc0luZGV4Kys7XG4gICAgICAgIG1pbmVPZmZzZXQgKz0gdGhlaXJzQ3VycmVudC5uZXdMaW5lcyAtIHRoZWlyc0N1cnJlbnQub2xkTGluZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdmVybGFwLCBtZXJnZSBhcyBiZXN0IHdlIGNhblxuICAgICAgICB2YXIgbWVyZ2VkSHVuayA9IHtcbiAgICAgICAgICBvbGRTdGFydDogTWF0aC5taW4obWluZUN1cnJlbnQub2xkU3RhcnQsIHRoZWlyc0N1cnJlbnQub2xkU3RhcnQpLFxuICAgICAgICAgIG9sZExpbmVzOiAwLFxuICAgICAgICAgIG5ld1N0YXJ0OiBNYXRoLm1pbihtaW5lQ3VycmVudC5uZXdTdGFydCArIG1pbmVPZmZzZXQsIHRoZWlyc0N1cnJlbnQub2xkU3RhcnQgKyB0aGVpcnNPZmZzZXQpLFxuICAgICAgICAgIG5ld0xpbmVzOiAwLFxuICAgICAgICAgIGxpbmVzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBtZXJnZUxpbmVzKG1lcmdlZEh1bmssIG1pbmVDdXJyZW50Lm9sZFN0YXJ0LCBtaW5lQ3VycmVudC5saW5lcywgdGhlaXJzQ3VycmVudC5vbGRTdGFydCwgdGhlaXJzQ3VycmVudC5saW5lcyk7XG4gICAgICAgIHRoZWlyc0luZGV4Kys7XG4gICAgICAgIG1pbmVJbmRleCsrO1xuICAgICAgICByZXQuaHVua3MucHVzaChtZXJnZWRIdW5rKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgZnVuY3Rpb24gbG9hZFBhdGNoKHBhcmFtLCBiYXNlKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICgvXkBAL20udGVzdChwYXJhbSkgfHwgL15JbmRleDovbS50ZXN0KHBhcmFtKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VQYXRjaChwYXJhbSlbMF07XG4gICAgICB9XG5cbiAgICAgIGlmICghYmFzZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBhIGJhc2UgcmVmZXJlbmNlIG9yIHBhc3MgaW4gYSBwYXRjaCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RydWN0dXJlZFBhdGNoKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBiYXNlLCBwYXJhbSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlsZU5hbWVDaGFuZ2VkKHBhdGNoKSB7XG4gICAgcmV0dXJuIHBhdGNoLm5ld0ZpbGVOYW1lICYmIHBhdGNoLm5ld0ZpbGVOYW1lICE9PSBwYXRjaC5vbGRGaWxlTmFtZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdEZpZWxkKGluZGV4LCBtaW5lLCB0aGVpcnMpIHtcbiAgICBpZiAobWluZSA9PT0gdGhlaXJzKSB7XG4gICAgICByZXR1cm4gbWluZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kZXguY29uZmxpY3QgPSB0cnVlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWluZTogbWluZSxcbiAgICAgICAgdGhlaXJzOiB0aGVpcnNcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaHVua0JlZm9yZSh0ZXN0LCBjaGVjaykge1xuICAgIHJldHVybiB0ZXN0Lm9sZFN0YXJ0IDwgY2hlY2sub2xkU3RhcnQgJiYgdGVzdC5vbGRTdGFydCArIHRlc3Qub2xkTGluZXMgPCBjaGVjay5vbGRTdGFydDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb25lSHVuayhodW5rLCBvZmZzZXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb2xkU3RhcnQ6IGh1bmsub2xkU3RhcnQsXG4gICAgICBvbGRMaW5lczogaHVuay5vbGRMaW5lcyxcbiAgICAgIG5ld1N0YXJ0OiBodW5rLm5ld1N0YXJ0ICsgb2Zmc2V0LFxuICAgICAgbmV3TGluZXM6IGh1bmsubmV3TGluZXMsXG4gICAgICBsaW5lczogaHVuay5saW5lc1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUxpbmVzKGh1bmssIG1pbmVPZmZzZXQsIG1pbmVMaW5lcywgdGhlaXJPZmZzZXQsIHRoZWlyTGluZXMpIHtcbiAgICAvLyBUaGlzIHdpbGwgZ2VuZXJhbGx5IHJlc3VsdCBpbiBhIGNvbmZsaWN0ZWQgaHVuaywgYnV0IHRoZXJlIGFyZSBjYXNlcyB3aGVyZSB0aGUgY29udGV4dFxuICAgIC8vIGlzIHRoZSBvbmx5IG92ZXJsYXAgd2hlcmUgd2UgY2FuIHN1Y2Nlc3NmdWxseSBtZXJnZSB0aGUgY29udGVudCBoZXJlLlxuICAgIHZhciBtaW5lID0ge1xuICAgICAgb2Zmc2V0OiBtaW5lT2Zmc2V0LFxuICAgICAgbGluZXM6IG1pbmVMaW5lcyxcbiAgICAgIGluZGV4OiAwXG4gICAgfSxcbiAgICAgICAgdGhlaXIgPSB7XG4gICAgICBvZmZzZXQ6IHRoZWlyT2Zmc2V0LFxuICAgICAgbGluZXM6IHRoZWlyTGluZXMsXG4gICAgICBpbmRleDogMFxuICAgIH07IC8vIEhhbmRsZSBhbnkgbGVhZGluZyBjb250ZW50XG5cbiAgICBpbnNlcnRMZWFkaW5nKGh1bmssIG1pbmUsIHRoZWlyKTtcbiAgICBpbnNlcnRMZWFkaW5nKGh1bmssIHRoZWlyLCBtaW5lKTsgLy8gTm93IGluIHRoZSBvdmVybGFwIGNvbnRlbnQuIFNjYW4gdGhyb3VnaCBhbmQgc2VsZWN0IHRoZSBiZXN0IGNoYW5nZXMgZnJvbSBlYWNoLlxuXG4gICAgd2hpbGUgKG1pbmUuaW5kZXggPCBtaW5lLmxpbmVzLmxlbmd0aCAmJiB0aGVpci5pbmRleCA8IHRoZWlyLmxpbmVzLmxlbmd0aCkge1xuICAgICAgdmFyIG1pbmVDdXJyZW50ID0gbWluZS5saW5lc1ttaW5lLmluZGV4XSxcbiAgICAgICAgICB0aGVpckN1cnJlbnQgPSB0aGVpci5saW5lc1t0aGVpci5pbmRleF07XG5cbiAgICAgIGlmICgobWluZUN1cnJlbnRbMF0gPT09ICctJyB8fCBtaW5lQ3VycmVudFswXSA9PT0gJysnKSAmJiAodGhlaXJDdXJyZW50WzBdID09PSAnLScgfHwgdGhlaXJDdXJyZW50WzBdID09PSAnKycpKSB7XG4gICAgICAgIC8vIEJvdGggbW9kaWZpZWQgLi4uXG4gICAgICAgIG11dHVhbENoYW5nZShodW5rLCBtaW5lLCB0aGVpcik7XG4gICAgICB9IGVsc2UgaWYgKG1pbmVDdXJyZW50WzBdID09PSAnKycgJiYgdGhlaXJDdXJyZW50WzBdID09PSAnICcpIHtcbiAgICAgICAgdmFyIF9odW5rJGxpbmVzOyAvLyBNaW5lIGluc2VydGVkXG5cblxuICAgICAgICAoX2h1bmskbGluZXMgPSBodW5rLmxpbmVzKS5wdXNoLmFwcGx5KF9odW5rJGxpbmVzLCBfdG9Db25zdW1hYmxlQXJyYXkkMShjb2xsZWN0Q2hhbmdlKG1pbmUpKSk7XG4gICAgICB9IGVsc2UgaWYgKHRoZWlyQ3VycmVudFswXSA9PT0gJysnICYmIG1pbmVDdXJyZW50WzBdID09PSAnICcpIHtcbiAgICAgICAgdmFyIF9odW5rJGxpbmVzMjsgLy8gVGhlaXJzIGluc2VydGVkXG5cblxuICAgICAgICAoX2h1bmskbGluZXMyID0gaHVuay5saW5lcykucHVzaC5hcHBseShfaHVuayRsaW5lczIsIF90b0NvbnN1bWFibGVBcnJheSQxKGNvbGxlY3RDaGFuZ2UodGhlaXIpKSk7XG4gICAgICB9IGVsc2UgaWYgKG1pbmVDdXJyZW50WzBdID09PSAnLScgJiYgdGhlaXJDdXJyZW50WzBdID09PSAnICcpIHtcbiAgICAgICAgLy8gTWluZSByZW1vdmVkIG9yIGVkaXRlZFxuICAgICAgICByZW1vdmFsKGh1bmssIG1pbmUsIHRoZWlyKTtcbiAgICAgIH0gZWxzZSBpZiAodGhlaXJDdXJyZW50WzBdID09PSAnLScgJiYgbWluZUN1cnJlbnRbMF0gPT09ICcgJykge1xuICAgICAgICAvLyBUaGVpciByZW1vdmVkIG9yIGVkaXRlZFxuICAgICAgICByZW1vdmFsKGh1bmssIHRoZWlyLCBtaW5lLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAobWluZUN1cnJlbnQgPT09IHRoZWlyQ3VycmVudCkge1xuICAgICAgICAvLyBDb250ZXh0IGlkZW50aXR5XG4gICAgICAgIGh1bmsubGluZXMucHVzaChtaW5lQ3VycmVudCk7XG4gICAgICAgIG1pbmUuaW5kZXgrKztcbiAgICAgICAgdGhlaXIuaW5kZXgrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENvbnRleHQgbWlzbWF0Y2hcbiAgICAgICAgY29uZmxpY3QoaHVuaywgY29sbGVjdENoYW5nZShtaW5lKSwgY29sbGVjdENoYW5nZSh0aGVpcikpO1xuICAgICAgfVxuICAgIH0gLy8gTm93IHB1c2ggYW55dGhpbmcgdGhhdCBtYXkgYmUgcmVtYWluaW5nXG5cblxuICAgIGluc2VydFRyYWlsaW5nKGh1bmssIG1pbmUpO1xuICAgIGluc2VydFRyYWlsaW5nKGh1bmssIHRoZWlyKTtcbiAgICBjYWxjTGluZUNvdW50KGh1bmspO1xuICB9XG5cbiAgZnVuY3Rpb24gbXV0dWFsQ2hhbmdlKGh1bmssIG1pbmUsIHRoZWlyKSB7XG4gICAgdmFyIG15Q2hhbmdlcyA9IGNvbGxlY3RDaGFuZ2UobWluZSksXG4gICAgICAgIHRoZWlyQ2hhbmdlcyA9IGNvbGxlY3RDaGFuZ2UodGhlaXIpO1xuXG4gICAgaWYgKGFsbFJlbW92ZXMobXlDaGFuZ2VzKSAmJiBhbGxSZW1vdmVzKHRoZWlyQ2hhbmdlcykpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgcmVtb3ZlIGNoYW5nZXMgdGhhdCBhcmUgc3VwZXJzZXRzIG9mIG9uZSBhbm90aGVyXG4gICAgICBpZiAoYXJyYXlTdGFydHNXaXRoKG15Q2hhbmdlcywgdGhlaXJDaGFuZ2VzKSAmJiBza2lwUmVtb3ZlU3VwZXJzZXQodGhlaXIsIG15Q2hhbmdlcywgbXlDaGFuZ2VzLmxlbmd0aCAtIHRoZWlyQ2hhbmdlcy5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBfaHVuayRsaW5lczM7XG5cbiAgICAgICAgKF9odW5rJGxpbmVzMyA9IGh1bmsubGluZXMpLnB1c2guYXBwbHkoX2h1bmskbGluZXMzLCBfdG9Db25zdW1hYmxlQXJyYXkkMShteUNoYW5nZXMpKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKGFycmF5U3RhcnRzV2l0aCh0aGVpckNoYW5nZXMsIG15Q2hhbmdlcykgJiYgc2tpcFJlbW92ZVN1cGVyc2V0KG1pbmUsIHRoZWlyQ2hhbmdlcywgdGhlaXJDaGFuZ2VzLmxlbmd0aCAtIG15Q2hhbmdlcy5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBfaHVuayRsaW5lczQ7XG5cbiAgICAgICAgKF9odW5rJGxpbmVzNCA9IGh1bmsubGluZXMpLnB1c2guYXBwbHkoX2h1bmskbGluZXM0LCBfdG9Db25zdW1hYmxlQXJyYXkkMSh0aGVpckNoYW5nZXMpKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcnJheUVxdWFsKG15Q2hhbmdlcywgdGhlaXJDaGFuZ2VzKSkge1xuICAgICAgdmFyIF9odW5rJGxpbmVzNTtcblxuICAgICAgKF9odW5rJGxpbmVzNSA9IGh1bmsubGluZXMpLnB1c2guYXBwbHkoX2h1bmskbGluZXM1LCBfdG9Db25zdW1hYmxlQXJyYXkkMShteUNoYW5nZXMpKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbmZsaWN0KGh1bmssIG15Q2hhbmdlcywgdGhlaXJDaGFuZ2VzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92YWwoaHVuaywgbWluZSwgdGhlaXIsIHN3YXApIHtcbiAgICB2YXIgbXlDaGFuZ2VzID0gY29sbGVjdENoYW5nZShtaW5lKSxcbiAgICAgICAgdGhlaXJDaGFuZ2VzID0gY29sbGVjdENvbnRleHQodGhlaXIsIG15Q2hhbmdlcyk7XG5cbiAgICBpZiAodGhlaXJDaGFuZ2VzLm1lcmdlZCkge1xuICAgICAgdmFyIF9odW5rJGxpbmVzNjtcblxuICAgICAgKF9odW5rJGxpbmVzNiA9IGh1bmsubGluZXMpLnB1c2guYXBwbHkoX2h1bmskbGluZXM2LCBfdG9Db25zdW1hYmxlQXJyYXkkMSh0aGVpckNoYW5nZXMubWVyZ2VkKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZsaWN0KGh1bmssIHN3YXAgPyB0aGVpckNoYW5nZXMgOiBteUNoYW5nZXMsIHN3YXAgPyBteUNoYW5nZXMgOiB0aGVpckNoYW5nZXMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmZsaWN0KGh1bmssIG1pbmUsIHRoZWlyKSB7XG4gICAgaHVuay5jb25mbGljdCA9IHRydWU7XG4gICAgaHVuay5saW5lcy5wdXNoKHtcbiAgICAgIGNvbmZsaWN0OiB0cnVlLFxuICAgICAgbWluZTogbWluZSxcbiAgICAgIHRoZWlyczogdGhlaXJcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydExlYWRpbmcoaHVuaywgaW5zZXJ0LCB0aGVpcikge1xuICAgIHdoaWxlIChpbnNlcnQub2Zmc2V0IDwgdGhlaXIub2Zmc2V0ICYmIGluc2VydC5pbmRleCA8IGluc2VydC5saW5lcy5sZW5ndGgpIHtcbiAgICAgIHZhciBsaW5lID0gaW5zZXJ0LmxpbmVzW2luc2VydC5pbmRleCsrXTtcbiAgICAgIGh1bmsubGluZXMucHVzaChsaW5lKTtcbiAgICAgIGluc2VydC5vZmZzZXQrKztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnRUcmFpbGluZyhodW5rLCBpbnNlcnQpIHtcbiAgICB3aGlsZSAoaW5zZXJ0LmluZGV4IDwgaW5zZXJ0LmxpbmVzLmxlbmd0aCkge1xuICAgICAgdmFyIGxpbmUgPSBpbnNlcnQubGluZXNbaW5zZXJ0LmluZGV4KytdO1xuICAgICAgaHVuay5saW5lcy5wdXNoKGxpbmUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbGxlY3RDaGFuZ2Uoc3RhdGUpIHtcbiAgICB2YXIgcmV0ID0gW10sXG4gICAgICAgIG9wZXJhdGlvbiA9IHN0YXRlLmxpbmVzW3N0YXRlLmluZGV4XVswXTtcblxuICAgIHdoaWxlIChzdGF0ZS5pbmRleCA8IHN0YXRlLmxpbmVzLmxlbmd0aCkge1xuICAgICAgdmFyIGxpbmUgPSBzdGF0ZS5saW5lc1tzdGF0ZS5pbmRleF07IC8vIEdyb3VwIGFkZGl0aW9ucyB0aGF0IGFyZSBpbW1lZGlhdGVseSBhZnRlciBzdWJ0cmFjdGlvbnMgYW5kIHRyZWF0IHRoZW0gYXMgb25lIFwiYXRvbWljXCIgbW9kaWZ5IGNoYW5nZS5cblxuICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJy0nICYmIGxpbmVbMF0gPT09ICcrJykge1xuICAgICAgICBvcGVyYXRpb24gPSAnKyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcGVyYXRpb24gPT09IGxpbmVbMF0pIHtcbiAgICAgICAgcmV0LnB1c2gobGluZSk7XG4gICAgICAgIHN0YXRlLmluZGV4Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgZnVuY3Rpb24gY29sbGVjdENvbnRleHQoc3RhdGUsIG1hdGNoQ2hhbmdlcykge1xuICAgIHZhciBjaGFuZ2VzID0gW10sXG4gICAgICAgIG1lcmdlZCA9IFtdLFxuICAgICAgICBtYXRjaEluZGV4ID0gMCxcbiAgICAgICAgY29udGV4dENoYW5nZXMgPSBmYWxzZSxcbiAgICAgICAgY29uZmxpY3RlZCA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKG1hdGNoSW5kZXggPCBtYXRjaENoYW5nZXMubGVuZ3RoICYmIHN0YXRlLmluZGV4IDwgc3RhdGUubGluZXMubGVuZ3RoKSB7XG4gICAgICB2YXIgY2hhbmdlID0gc3RhdGUubGluZXNbc3RhdGUuaW5kZXhdLFxuICAgICAgICAgIG1hdGNoID0gbWF0Y2hDaGFuZ2VzW21hdGNoSW5kZXhdOyAvLyBPbmNlIHdlJ3ZlIGhpdCBvdXIgYWRkLCB0aGVuIHdlIGFyZSBkb25lXG5cbiAgICAgIGlmIChtYXRjaFswXSA9PT0gJysnKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Q2hhbmdlcyA9IGNvbnRleHRDaGFuZ2VzIHx8IGNoYW5nZVswXSAhPT0gJyAnO1xuICAgICAgbWVyZ2VkLnB1c2gobWF0Y2gpO1xuICAgICAgbWF0Y2hJbmRleCsrOyAvLyBDb25zdW1lIGFueSBhZGRpdGlvbnMgaW4gdGhlIG90aGVyIGJsb2NrIGFzIGEgY29uZmxpY3QgdG8gYXR0ZW1wdFxuICAgICAgLy8gdG8gcHVsbCBpbiB0aGUgcmVtYWluaW5nIGNvbnRleHQgYWZ0ZXIgdGhpc1xuXG4gICAgICBpZiAoY2hhbmdlWzBdID09PSAnKycpIHtcbiAgICAgICAgY29uZmxpY3RlZCA9IHRydWU7XG5cbiAgICAgICAgd2hpbGUgKGNoYW5nZVswXSA9PT0gJysnKSB7XG4gICAgICAgICAgY2hhbmdlcy5wdXNoKGNoYW5nZSk7XG4gICAgICAgICAgY2hhbmdlID0gc3RhdGUubGluZXNbKytzdGF0ZS5pbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoLnN1YnN0cigxKSA9PT0gY2hhbmdlLnN1YnN0cigxKSkge1xuICAgICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgc3RhdGUuaW5kZXgrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbmZsaWN0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgobWF0Y2hDaGFuZ2VzW21hdGNoSW5kZXhdIHx8ICcnKVswXSA9PT0gJysnICYmIGNvbnRleHRDaGFuZ2VzKSB7XG4gICAgICBjb25mbGljdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmxpY3RlZCkge1xuICAgICAgcmV0dXJuIGNoYW5nZXM7XG4gICAgfVxuXG4gICAgd2hpbGUgKG1hdGNoSW5kZXggPCBtYXRjaENoYW5nZXMubGVuZ3RoKSB7XG4gICAgICBtZXJnZWQucHVzaChtYXRjaENoYW5nZXNbbWF0Y2hJbmRleCsrXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1lcmdlZDogbWVyZ2VkLFxuICAgICAgY2hhbmdlczogY2hhbmdlc1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBhbGxSZW1vdmVzKGNoYW5nZXMpIHtcbiAgICByZXR1cm4gY2hhbmdlcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGNoYW5nZSkge1xuICAgICAgcmV0dXJuIHByZXYgJiYgY2hhbmdlWzBdID09PSAnLSc7XG4gICAgfSwgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBza2lwUmVtb3ZlU3VwZXJzZXQoc3RhdGUsIHJlbW92ZUNoYW5nZXMsIGRlbHRhKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWx0YTsgaSsrKSB7XG4gICAgICB2YXIgY2hhbmdlQ29udGVudCA9IHJlbW92ZUNoYW5nZXNbcmVtb3ZlQ2hhbmdlcy5sZW5ndGggLSBkZWx0YSArIGldLnN1YnN0cigxKTtcblxuICAgICAgaWYgKHN0YXRlLmxpbmVzW3N0YXRlLmluZGV4ICsgaV0gIT09ICcgJyArIGNoYW5nZUNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRlLmluZGV4ICs9IGRlbHRhO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FsY09sZE5ld0xpbmVDb3VudChsaW5lcykge1xuICAgIHZhciBvbGRMaW5lcyA9IDA7XG4gICAgdmFyIG5ld0xpbmVzID0gMDtcbiAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBpZiAodHlwZW9mIGxpbmUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBteUNvdW50ID0gY2FsY09sZE5ld0xpbmVDb3VudChsaW5lLm1pbmUpO1xuICAgICAgICB2YXIgdGhlaXJDb3VudCA9IGNhbGNPbGROZXdMaW5lQ291bnQobGluZS50aGVpcnMpO1xuXG4gICAgICAgIGlmIChvbGRMaW5lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKG15Q291bnQub2xkTGluZXMgPT09IHRoZWlyQ291bnQub2xkTGluZXMpIHtcbiAgICAgICAgICAgIG9sZExpbmVzICs9IG15Q291bnQub2xkTGluZXM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9sZExpbmVzID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXdMaW5lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKG15Q291bnQubmV3TGluZXMgPT09IHRoZWlyQ291bnQubmV3TGluZXMpIHtcbiAgICAgICAgICAgIG5ld0xpbmVzICs9IG15Q291bnQubmV3TGluZXM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0xpbmVzID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG5ld0xpbmVzICE9PSB1bmRlZmluZWQgJiYgKGxpbmVbMF0gPT09ICcrJyB8fCBsaW5lWzBdID09PSAnICcpKSB7XG4gICAgICAgICAgbmV3TGluZXMrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvbGRMaW5lcyAhPT0gdW5kZWZpbmVkICYmIChsaW5lWzBdID09PSAnLScgfHwgbGluZVswXSA9PT0gJyAnKSkge1xuICAgICAgICAgIG9sZExpbmVzKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgb2xkTGluZXM6IG9sZExpbmVzLFxuICAgICAgbmV3TGluZXM6IG5ld0xpbmVzXG4gICAgfTtcbiAgfSAvLyBTZWU6IGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9nb29nbGUtZGlmZi1tYXRjaC1wYXRjaC93aWtpL0FQSVxuXG5cbiAgZnVuY3Rpb24gY29udmVydENoYW5nZXNUb0RNUChjaGFuZ2VzKSB7XG4gICAgdmFyIHJldCA9IFtdLFxuICAgICAgICBjaGFuZ2UsXG4gICAgICAgIG9wZXJhdGlvbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhbmdlID0gY2hhbmdlc1tpXTtcblxuICAgICAgaWYgKGNoYW5nZS5hZGRlZCkge1xuICAgICAgICBvcGVyYXRpb24gPSAxO1xuICAgICAgfSBlbHNlIGlmIChjaGFuZ2UucmVtb3ZlZCkge1xuICAgICAgICBvcGVyYXRpb24gPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wZXJhdGlvbiA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldC5wdXNoKFtvcGVyYXRpb24sIGNoYW5nZS52YWx1ZV0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBjb252ZXJ0Q2hhbmdlc1RvWE1MKGNoYW5nZXMpIHtcbiAgICB2YXIgcmV0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzW2ldO1xuXG4gICAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XG4gICAgICAgIHJldC5wdXNoKCc8aW5zPicpO1xuICAgICAgfSBlbHNlIGlmIChjaGFuZ2UucmVtb3ZlZCkge1xuICAgICAgICByZXQucHVzaCgnPGRlbD4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0LnB1c2goZXNjYXBlSFRNTChjaGFuZ2UudmFsdWUpKTtcblxuICAgICAgaWYgKGNoYW5nZS5hZGRlZCkge1xuICAgICAgICByZXQucHVzaCgnPC9pbnM+Jyk7XG4gICAgICB9IGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XG4gICAgICAgIHJldC5wdXNoKCc8L2RlbD4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0LmpvaW4oJycpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXNjYXBlSFRNTChzKSB7XG4gICAgdmFyIG4gPSBzO1xuICAgIG4gPSBuLnJlcGxhY2UoLyYvZywgJyZhbXA7Jyk7XG4gICAgbiA9IG4ucmVwbGFjZSgvPC9nLCAnJmx0OycpO1xuICAgIG4gPSBuLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcbiAgICBuID0gbi5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG4gICAgcmV0dXJuIG47XG4gIH1cblxuICB2YXIgaW5kZXhfZXM2ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBEaWZmOiBEaWZmLFxuICAgIGRpZmZDaGFyczogZGlmZkNoYXJzLFxuICAgIGRpZmZXb3JkczogZGlmZldvcmRzLFxuICAgIGRpZmZXb3Jkc1dpdGhTcGFjZTogZGlmZldvcmRzV2l0aFNwYWNlLFxuICAgIGRpZmZMaW5lczogZGlmZkxpbmVzLFxuICAgIGRpZmZUcmltbWVkTGluZXM6IGRpZmZUcmltbWVkTGluZXMsXG4gICAgZGlmZlNlbnRlbmNlczogZGlmZlNlbnRlbmNlcyxcbiAgICBkaWZmQ3NzOiBkaWZmQ3NzLFxuICAgIGRpZmZKc29uOiBkaWZmSnNvbixcbiAgICBkaWZmQXJyYXlzOiBkaWZmQXJyYXlzLFxuICAgIHN0cnVjdHVyZWRQYXRjaDogc3RydWN0dXJlZFBhdGNoLFxuICAgIGNyZWF0ZVR3b0ZpbGVzUGF0Y2g6IGNyZWF0ZVR3b0ZpbGVzUGF0Y2gsXG4gICAgY3JlYXRlUGF0Y2g6IGNyZWF0ZVBhdGNoLFxuICAgIGFwcGx5UGF0Y2g6IGFwcGx5UGF0Y2gsXG4gICAgYXBwbHlQYXRjaGVzOiBhcHBseVBhdGNoZXMsXG4gICAgcGFyc2VQYXRjaDogcGFyc2VQYXRjaCxcbiAgICBtZXJnZTogbWVyZ2UsXG4gICAgY29udmVydENoYW5nZXNUb0RNUDogY29udmVydENoYW5nZXNUb0RNUCxcbiAgICBjb252ZXJ0Q2hhbmdlc1RvWE1MOiBjb252ZXJ0Q2hhbmdlc1RvWE1MLFxuICAgIGNhbm9uaWNhbGl6ZTogY2Fub25pY2FsaXplXG4gIH0pO1xuXG4gIHZhciBfc2hpbV9mcyA9IHt9O1xuXG4gIHZhciBfc2hpbV9mcyQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAnZGVmYXVsdCc6IF9zaGltX2ZzXG4gIH0pO1xuXG4gIC8qIVxuICAgKiBub3JtYWxpemUtcGF0aCA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvbm9ybWFsaXplLXBhdGg+XG4gICAqXG4gICAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE4LCBKb24gU2NobGlua2VydC5cbiAgICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICAgKi9cbiAgdmFyIG5vcm1hbGl6ZVBhdGggPSBmdW5jdGlvbiBub3JtYWxpemVQYXRoKHBhdGgsIHN0cmlwVHJhaWxpbmcpIHtcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBwYXRoIHRvIGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgaWYgKHBhdGggPT09ICdcXFxcJyB8fCBwYXRoID09PSAnLycpIHJldHVybiAnLyc7XG4gICAgdmFyIGxlbiA9IHBhdGgubGVuZ3RoO1xuICAgIGlmIChsZW4gPD0gMSkgcmV0dXJuIHBhdGg7IC8vIGVuc3VyZSB0aGF0IHdpbjMyIG5hbWVzcGFjZXMgaGFzIHR3byBsZWFkaW5nIHNsYXNoZXMsIHNvIHRoYXQgdGhlIHBhdGggaXNcbiAgICAvLyBoYW5kbGVkIHByb3Blcmx5IGJ5IHRoZSB3aW4zMiB2ZXJzaW9uIG9mIHBhdGgucGFyc2UoKSBhZnRlciBiZWluZyBub3JtYWxpemVkXG4gICAgLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vbGlicmFyeS93aW5kb3dzL2Rlc2t0b3AvYWEzNjUyNDcodj12cy44NSkuYXNweCNuYW1lc3BhY2VzXG5cbiAgICB2YXIgcHJlZml4ID0gJyc7XG5cbiAgICBpZiAobGVuID4gNCAmJiBwYXRoWzNdID09PSAnXFxcXCcpIHtcbiAgICAgIHZhciBjaCA9IHBhdGhbMl07XG5cbiAgICAgIGlmICgoY2ggPT09ICc/JyB8fCBjaCA9PT0gJy4nKSAmJiBwYXRoLnNsaWNlKDAsIDIpID09PSAnXFxcXFxcXFwnKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDIpO1xuICAgICAgICBwcmVmaXggPSAnLy8nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzZWdzID0gcGF0aC5zcGxpdCgvWy9cXFxcXSsvKTtcblxuICAgIGlmIChzdHJpcFRyYWlsaW5nICE9PSBmYWxzZSAmJiBzZWdzW3NlZ3MubGVuZ3RoIC0gMV0gPT09ICcnKSB7XG4gICAgICBzZWdzLnBvcCgpO1xuICAgIH1cblxuICAgIHJldHVybiBwcmVmaXggKyBzZWdzLmpvaW4oJy8nKTtcbiAgfTtcblxuICB2YXIgZ2xvYmFsJDEgPSB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9O1xuXG4gIHZhciBsb29rdXAgPSBbXTtcbiAgdmFyIHJldkxvb2t1cCA9IFtdO1xuICB2YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5O1xuICB2YXIgaW5pdGVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBpbml0ZWQgPSB0cnVlO1xuICAgIHZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGxvb2t1cFtpXSA9IGNvZGVbaV07XG4gICAgICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gICAgfVxuXG4gICAgcmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyO1xuICAgIHJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2MztcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvQnl0ZUFycmF5KGI2NCkge1xuICAgIGlmICghaW5pdGVkKSB7XG4gICAgICBpbml0KCk7XG4gICAgfVxuXG4gICAgdmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnI7XG4gICAgdmFyIGxlbiA9IGI2NC5sZW5ndGg7XG5cbiAgICBpZiAobGVuICUgNCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpO1xuICAgIH0gLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gICAgLy8gcmVwcmVzZW50IG9uZSBieXRlXG4gICAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gICAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXG5cbiAgICBwbGFjZUhvbGRlcnMgPSBiNjRbbGVuIC0gMl0gPT09ICc9JyA/IDIgOiBiNjRbbGVuIC0gMV0gPT09ICc9JyA/IDEgOiAwOyAvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblxuICAgIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpOyAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cbiAgICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW47XG4gICAgdmFyIEwgPSAwO1xuXG4gICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuICAgICAgdG1wID0gcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNiB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldO1xuICAgICAgYXJyW0wrK10gPSB0bXAgPj4gMTYgJiAweEZGO1xuICAgICAgYXJyW0wrK10gPSB0bXAgPj4gOCAmIDB4RkY7XG4gICAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkY7XG4gICAgfVxuXG4gICAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgICAgdG1wID0gcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNDtcbiAgICAgIGFycltMKytdID0gdG1wICYgMHhGRjtcbiAgICB9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuICAgICAgdG1wID0gcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyO1xuICAgICAgYXJyW0wrK10gPSB0bXAgPj4gOCAmIDB4RkY7XG4gICAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkY7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NChudW0pIHtcbiAgICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl07XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVDaHVuayh1aW50OCwgc3RhcnQsIGVuZCkge1xuICAgIHZhciB0bXA7XG4gICAgdmFyIG91dHB1dCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICAgIHRtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgdWludDhbaSArIDJdO1xuICAgICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQuam9pbignJyk7XG4gIH1cblxuICBmdW5jdGlvbiBmcm9tQnl0ZUFycmF5KHVpbnQ4KSB7XG4gICAgaWYgKCFpbml0ZWQpIHtcbiAgICAgIGluaXQoKTtcbiAgICB9XG5cbiAgICB2YXIgdG1wO1xuICAgIHZhciBsZW4gPSB1aW50OC5sZW5ndGg7XG4gICAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzOyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXG4gICAgdmFyIG91dHB1dCA9ICcnO1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzOyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcbiAgICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCBpICsgbWF4Q2h1bmtMZW5ndGggPiBsZW4yID8gbGVuMiA6IGkgKyBtYXhDaHVua0xlbmd0aCkpO1xuICAgIH0gLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXG5cbiAgICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgICAgdG1wID0gdWludDhbbGVuIC0gMV07XG4gICAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAyXTtcbiAgICAgIG91dHB1dCArPSBsb29rdXBbdG1wIDw8IDQgJiAweDNGXTtcbiAgICAgIG91dHB1dCArPSAnPT0nO1xuICAgIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV07XG4gICAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF07XG4gICAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiA0ICYgMHgzRl07XG4gICAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA8PCAyICYgMHgzRl07XG4gICAgICBvdXRwdXQgKz0gJz0nO1xuICAgIH1cblxuICAgIHBhcnRzLnB1c2gob3V0cHV0KTtcbiAgICByZXR1cm4gcGFydHMuam9pbignJyk7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgICB2YXIgZSwgbTtcbiAgICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTtcbiAgICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gICAgdmFyIG5CaXRzID0gLTc7XG4gICAgdmFyIGkgPSBpc0xFID8gbkJ5dGVzIC0gMSA6IDA7XG4gICAgdmFyIGQgPSBpc0xFID8gLTEgOiAxO1xuICAgIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldO1xuICAgIGkgKz0gZDtcbiAgICBlID0gcyAmICgxIDw8IC1uQml0cykgLSAxO1xuICAgIHMgPj49IC1uQml0cztcbiAgICBuQml0cyArPSBlTGVuO1xuXG4gICAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICAgIG0gPSBlICYgKDEgPDwgLW5CaXRzKSAtIDE7XG4gICAgZSA+Pj0gLW5CaXRzO1xuICAgIG5CaXRzICs9IG1MZW47XG5cbiAgICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gICAgaWYgKGUgPT09IDApIHtcbiAgICAgIGUgPSAxIC0gZUJpYXM7XG4gICAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgICByZXR1cm4gbSA/IE5hTiA6IChzID8gLTEgOiAxKSAqIEluZmluaXR5O1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgLSBlQmlhcztcbiAgICB9XG5cbiAgICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKTtcbiAgfVxuICBmdW5jdGlvbiB3cml0ZShidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICAgIHZhciBlLCBtLCBjO1xuICAgIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICAgIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICAgIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgICB2YXIgcnQgPSBtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMDtcbiAgICB2YXIgaSA9IGlzTEUgPyAwIDogbkJ5dGVzIC0gMTtcbiAgICB2YXIgZCA9IGlzTEUgPyAxIDogLTE7XG4gICAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgdmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCA/IDEgOiAwO1xuICAgIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuXG4gICAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSB7XG4gICAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG5cbiAgICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgICAgZS0tO1xuICAgICAgICBjICo9IDI7XG4gICAgICB9XG5cbiAgICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgICBlKys7XG4gICAgICAgIGMgLz0gMjtcbiAgICAgIH1cblxuICAgICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICAgIG0gPSAwO1xuICAgICAgICBlID0gZU1heDtcbiAgICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgICBlID0gZSArIGVCaWFzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgICBlID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gICAgZSA9IGUgPDwgbUxlbiB8IG07XG4gICAgZUxlbiArPSBtTGVuO1xuXG4gICAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gICAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4O1xuICB9XG5cbiAgdmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xuXG4gIHZhciBJTlNQRUNUX01BWF9CWVRFUyA9IDUwO1xuICAvKipcbiAgICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAgICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAgICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICAgKlxuICAgKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gICAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAgICpcbiAgICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICAgKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAgICpcbiAgICogTm90ZTpcbiAgICpcbiAgICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAgICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICAgKlxuICAgKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAgICpcbiAgICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAgICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gICAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gICAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICAgKi9cblxuICBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbCQxLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZCA/IGdsb2JhbCQxLlRZUEVEX0FSUkFZX1NVUFBPUlQgOiB0cnVlO1xuXG4gIGZ1bmN0aW9uIGtNYXhMZW5ndGgoKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID8gMHg3ZmZmZmZmZiA6IDB4M2ZmZmZmZmY7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKSB7XG4gICAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJyk7XG4gICAgfVxuXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhhdDtcbiAgfVxuICAvKipcbiAgICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gICAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAgICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICAgKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICAgKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICAgKlxuICAgKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gICAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7XG4gICAgfSAvLyBDb21tb24gY2FzZS5cblxuXG4gICAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpO1xuICB9XG4gIEJ1ZmZlci5wb29sU2l6ZSA9IDgxOTI7IC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cbiAgLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5cbiAgQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICAgIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlO1xuICAgIHJldHVybiBhcnI7XG4gIH07XG5cbiAgZnVuY3Rpb24gZnJvbSh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gICAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICAgKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gICAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICAgKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gICAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICAgKiovXG5cblxuICBCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZTtcbiAgICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydFNpemUoc2l6ZSkge1xuICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKTtcbiAgICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhbGxvYyh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICAgIGFzc2VydFNpemUoc2l6ZSk7XG5cbiAgICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpO1xuICAgIH1cblxuICAgIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKSA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAgICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICAgKiovXG5cblxuICBCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGFsbG9jVW5zYWZlKHRoYXQsIHNpemUpIHtcbiAgICBhc3NlcnRTaXplKHNpemUpO1xuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApO1xuXG4gICAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgICAgdGhhdFtpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoYXQ7XG4gIH1cbiAgLyoqXG4gICAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gICAqICovXG5cblxuICBCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKTtcbiAgfTtcbiAgLyoqXG4gICAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICAgKi9cblxuXG4gIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKTtcbiAgfTtcblxuICBmdW5jdGlvbiBmcm9tU3RyaW5nKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgIH1cblxuICAgIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpO1xuICAgIH1cblxuICAgIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMDtcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aCk7XG4gICAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZyk7XG5cbiAgICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhhdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwO1xuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhhdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlcih0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgYXJyYXkuYnl0ZUxlbmd0aDsgLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gICAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG5cbiAgICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG5cbiAgICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KTtcbiAgICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgICAgdGhhdCA9IGFycmF5O1xuICAgICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoYXQ7XG4gIH1cblxuICBmdW5jdGlvbiBmcm9tT2JqZWN0KHRoYXQsIG9iaikge1xuICAgIGlmIChpbnRlcm5hbElzQnVmZmVyKG9iaikpIHtcbiAgICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMDtcbiAgICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKTtcblxuICAgICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgICAgfVxuXG4gICAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pO1xuICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfVxuXG4gICAgaWYgKG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iaik7XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrZWQobGVuZ3RoKSB7XG4gICAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gICAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gICAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgKyAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGVuZ3RoIHwgMDtcbiAgfVxuICBCdWZmZXIuaXNCdWZmZXIgPSBpc0J1ZmZlcjtcblxuICBmdW5jdGlvbiBpbnRlcm5hbElzQnVmZmVyKGIpIHtcbiAgICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKTtcbiAgfVxuXG4gIEJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gICAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGEpIHx8ICFpbnRlcm5hbElzQnVmZmVyKGIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJyk7XG4gICAgfVxuXG4gICAgaWYgKGEgPT09IGIpIHJldHVybiAwO1xuICAgIHZhciB4ID0gYS5sZW5ndGg7XG4gICAgdmFyIHkgPSBiLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgICB4ID0gYVtpXTtcbiAgICAgICAgeSA9IGJbaV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh4IDwgeSkgcmV0dXJuIC0xO1xuICAgIGlmICh5IDwgeCkgcmV0dXJuIDE7XG4gICAgcmV0dXJuIDA7XG4gIH07XG5cbiAgQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nKGVuY29kaW5nKSB7XG4gICAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIEJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQobGlzdCwgbGVuZ3RoKSB7XG4gICAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKTtcbiAgICB9XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgfVxuXG4gICAgdmFyIGk7XG5cbiAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxlbmd0aCA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aCk7XG4gICAgdmFyIHBvcyA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGJ1ZiA9IGxpc3RbaV07XG5cbiAgICAgIGlmICghaW50ZXJuYWxJc0J1ZmZlcihidWYpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpO1xuICAgICAgfVxuXG4gICAgICBidWYuY29weShidWZmZXIsIHBvcyk7XG4gICAgICBwb3MgKz0gYnVmLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZmVyO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykge1xuICAgIGlmIChpbnRlcm5hbElzQnVmZmVyKHN0cmluZykpIHtcbiAgICAgIHJldHVybiBzdHJpbmcubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgc3RyaW5nID0gJycgKyBzdHJpbmc7XG4gICAgfVxuXG4gICAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGg7XG4gICAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDA7IC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuXG4gICAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2U7XG5cbiAgICBmb3IgKDs7KSB7XG4gICAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgICByZXR1cm4gbGVuO1xuXG4gICAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aDtcblxuICAgICAgICBjYXNlICd1Y3MyJzpcbiAgICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICAgIHJldHVybiBsZW4gKiAyO1xuXG4gICAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMTtcblxuICAgICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGg7IC8vIGFzc3VtZSB1dGY4XG5cbiAgICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBCdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGg7XG5cbiAgZnVuY3Rpb24gc2xvd1RvU3RyaW5nKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2U7IC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAgIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG4gICAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gICAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAgIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gICAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG5cbiAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9IC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gICAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cblxuXG4gICAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmIChlbmQgPD0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0gLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cblxuXG4gICAgZW5kID4+Pj0gMDtcbiAgICBzdGFydCA+Pj49IDA7XG5cbiAgICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCc7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgICBjYXNlICdoZXgnOlxuICAgICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKTtcblxuICAgICAgICBjYXNlICd1dGY4JzpcbiAgICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZCk7XG5cbiAgICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpO1xuXG4gICAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpO1xuXG4gICAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpO1xuXG4gICAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgICBjYXNlICd1Y3MtMic6XG4gICAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3RcbiAgLy8gQnVmZmVyIGluc3RhbmNlcy5cblxuXG4gIEJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZTtcblxuICBmdW5jdGlvbiBzd2FwKGIsIG4sIG0pIHtcbiAgICB2YXIgaSA9IGJbbl07XG4gICAgYltuXSA9IGJbbV07XG4gICAgYlttXSA9IGk7XG4gIH1cblxuICBCdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNigpIHtcbiAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG5cbiAgICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgc3dhcCh0aGlzLCBpLCBpICsgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIoKSB7XG4gICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuXG4gICAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgIHN3YXAodGhpcywgaSwgaSArIDMpO1xuICAgICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0KCkge1xuICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcblxuICAgIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgICBzd2FwKHRoaXMsIGksIGkgKyA3KTtcbiAgICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KTtcbiAgICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KTtcbiAgICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMDtcbiAgICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKTtcbiAgICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMoYikge1xuICAgIGlmICghaW50ZXJuYWxJc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpO1xuICAgIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDA7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgICB2YXIgc3RyID0gJyc7XG4gICAgdmFyIG1heCA9IElOU1BFQ1RfTUFYX0JZVEVTO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJyk7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnO1xuICAgIH1cblxuICAgIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nO1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgICBpZiAoIWludGVybmFsSXNCdWZmZXIodGFyZ2V0KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMDtcbiAgICB9XG5cbiAgICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXNTdGFydCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHN0YXJ0ID4+Pj0gMDtcbiAgICBlbmQgPj4+PSAwO1xuICAgIHRoaXNTdGFydCA+Pj49IDA7XG4gICAgdGhpc0VuZCA+Pj49IDA7XG4gICAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDA7XG4gICAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0O1xuICAgIHZhciB5ID0gZW5kIC0gc3RhcnQ7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpO1xuICAgIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKTtcbiAgICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgICB4ID0gdGhpc0NvcHlbaV07XG4gICAgICAgIHkgPSB0YXJnZXRDb3B5W2ldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoeCA8IHkpIHJldHVybiAtMTtcbiAgICBpZiAoeSA8IHgpIHJldHVybiAxO1xuICAgIHJldHVybiAwO1xuICB9OyAvLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4gIC8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4gIC8vXG4gIC8vIEFyZ3VtZW50czpcbiAgLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbiAgLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbiAgLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4gIC8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4gIC8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5cblxuICBmdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAgIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTE7IC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG5cbiAgICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXQ7XG4gICAgICBieXRlT2Zmc2V0ID0gMDtcbiAgICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZjtcbiAgICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwO1xuICAgIH1cblxuICAgIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldDsgLy8gQ29lcmNlIHRvIE51bWJlci5cblxuICAgIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IGJ1ZmZlci5sZW5ndGggLSAxO1xuICAgIH0gLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcblxuXG4gICAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXQ7XG5cbiAgICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgICBpZiAoZGlyKSByZXR1cm4gLTE7ZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDE7XG4gICAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDA7ZWxzZSByZXR1cm4gLTE7XG4gICAgfSAvLyBOb3JtYWxpemUgdmFsXG5cblxuICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZyk7XG4gICAgfSAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuXG5cbiAgICBpZiAoaW50ZXJuYWxJc0J1ZmZlcih2YWwpKSB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhbCA9IHZhbCAmIDB4RkY7IC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cblxuICAgICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFt2YWxdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5SW5kZXhPZihhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAgIHZhciBpbmRleFNpemUgPSAxO1xuICAgIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoO1xuICAgIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoO1xuXG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fCBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4U2l6ZSA9IDI7XG4gICAgICAgIGFyckxlbmd0aCAvPSAyO1xuICAgICAgICB2YWxMZW5ndGggLz0gMjtcbiAgICAgICAgYnl0ZU9mZnNldCAvPSAyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWQoYnVmLCBpKSB7XG4gICAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICAgIHJldHVybiBidWZbaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaTtcblxuICAgIGlmIChkaXIpIHtcbiAgICAgIHZhciBmb3VuZEluZGV4ID0gLTE7XG5cbiAgICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaTtcbiAgICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleDtcbiAgICAgICAgICBmb3VuZEluZGV4ID0gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBmb3VuZCA9IHRydWU7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICAgIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm91bmQpIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIEJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTE7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gICAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpO1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gICAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKTtcbiAgfTtcblxuICBmdW5jdGlvbiBoZXhXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwO1xuICAgIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0O1xuXG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aCk7XG5cbiAgICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgICAgfVxuICAgIH0gLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcblxuXG4gICAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGg7XG4gICAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpO1xuXG4gICAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICAgIGxlbmd0aCA9IHN0ckxlbiAvIDI7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNik7XG4gICAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGk7XG4gICAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGk7XG4gIH1cblxuICBmdW5jdGlvbiB1dGY4V3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aCk7XG4gIH1cblxuICBmdW5jdGlvbiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxhdGluMVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG4gIH1cblxuICBmdW5jdGlvbiBiYXNlNjRXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpO1xuICB9XG5cbiAgZnVuY3Rpb24gdWNzMldyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpO1xuICB9XG5cbiAgQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gICAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICBvZmZzZXQgPSAwOyAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IG9mZnNldDtcbiAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgICAgb2Zmc2V0ID0gMDsgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCB8IDA7XG5cbiAgICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDA7XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuY29kaW5nID0gbGVuZ3RoO1xuICAgICAgICBsZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgICB9IC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcblxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJyk7XG4gICAgfVxuXG4gICAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZztcblxuICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJyk7XG4gICAgfVxuXG4gICAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCc7XG4gICAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2U7XG5cbiAgICBmb3IgKDs7KSB7XG4gICAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgICAgICBjYXNlICd1Y3MyJzpcbiAgICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gICAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gYmFzZTY0U2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZyb21CeXRlQXJyYXkoYnVmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1dGY4U2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7XG4gICAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgdmFyIGkgPSBzdGFydDtcblxuICAgIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldO1xuICAgICAgdmFyIGNvZGVQb2ludCA9IG51bGw7XG4gICAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IGZpcnN0Qnl0ZSA+IDB4RUYgPyA0IDogZmlyc3RCeXRlID4gMHhERiA/IDMgOiBmaXJzdEJ5dGUgPiAweEJGID8gMiA6IDE7XG5cbiAgICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludDtcblxuICAgICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07XG5cbiAgICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgc2Vjb25kQnl0ZSAmIDB4M0Y7XG5cbiAgICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdO1xuICAgICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXTtcblxuICAgICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IHRoaXJkQnl0ZSAmIDB4M0Y7XG5cbiAgICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTtcbiAgICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl07XG4gICAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXTtcblxuICAgICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCBmb3VydGhCeXRlICYgMHgzRjtcblxuICAgICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgICBjb2RlUG9pbnQgPSAweEZGRkQ7XG4gICAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxO1xuICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG4gICAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGO1xuICAgICAgfVxuXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQpO1xuICAgICAgaSArPSBieXRlc1BlclNlcXVlbmNlO1xuICAgIH1cblxuICAgIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKTtcbiAgfSAvLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbiAgLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuICAvLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG5cblxuICB2YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDA7XG5cbiAgZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5KGNvZGVQb2ludHMpIHtcbiAgICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGg7XG5cbiAgICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpOyAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gICAgfSAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG5cblxuICAgIHZhciByZXMgPSAnJztcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgZnVuY3Rpb24gYXNjaWlTbGljZShidWYsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgcmV0ID0gJyc7XG4gICAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTtcblxuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgZnVuY3Rpb24gbGF0aW4xU2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHJldCA9ICcnO1xuICAgIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7XG5cbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgZnVuY3Rpb24gaGV4U2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7XG4gICAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMDtcbiAgICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuO1xuICAgIHZhciBvdXQgPSAnJztcblxuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgZnVuY3Rpb24gdXRmMTZsZVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKTtcbiAgICB2YXIgcmVzID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1Nik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIEJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICAgIHN0YXJ0ID0gfn5zdGFydDtcbiAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kO1xuXG4gICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgc3RhcnQgKz0gbGVuO1xuICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwO1xuICAgIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICAgIHN0YXJ0ID0gbGVuO1xuICAgIH1cblxuICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICBlbmQgKz0gbGVuO1xuICAgICAgaWYgKGVuZCA8IDApIGVuZCA9IDA7XG4gICAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICAgIGVuZCA9IGxlbjtcbiAgICB9XG5cbiAgICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0O1xuICAgIHZhciBuZXdCdWY7XG5cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCk7XG4gICAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnQ7XG4gICAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXdCdWY7XG4gIH07XG4gIC8qXG4gICAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGNoZWNrT2Zmc2V0KG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgICBpZiAob2Zmc2V0ICUgMSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50Jyk7XG4gICAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gICAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuICAgIHZhciB2YWwgPSB0aGlzW29mZnNldF07XG4gICAgdmFyIG11bCA9IDE7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsO1xuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRShvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG5cbiAgICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTtcbiAgICB9XG5cbiAgICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdO1xuICAgIHZhciBtdWwgPSAxO1xuXG4gICAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsO1xuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDgob2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpO1xuICAgIHJldHVybiB0aGlzW29mZnNldF07XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUob2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICAgIHJldHVybiB0aGlzW29mZnNldF0gfCB0aGlzW29mZnNldCArIDFdIDw8IDg7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUob2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICAgIHJldHVybiB0aGlzW29mZnNldF0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgMV07XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUob2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICAgIHJldHVybiAodGhpc1tvZmZzZXRdIHwgdGhpc1tvZmZzZXQgKyAxXSA8PCA4IHwgdGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgKyB0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwO1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpc1tvZmZzZXRdICogMHgxMDAwMDAwICsgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYgfCB0aGlzW29mZnNldCArIDJdIDw8IDggfCB0aGlzW29mZnNldCArIDNdKTtcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRShvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG4gICAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XTtcbiAgICB2YXIgbXVsID0gMTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWw7XG4gICAgfVxuXG4gICAgbXVsICo9IDB4ODA7XG4gICAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRShvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG4gICAgdmFyIGkgPSBieXRlTGVuZ3RoO1xuICAgIHZhciBtdWwgPSAxO1xuICAgIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV07XG5cbiAgICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWw7XG4gICAgfVxuXG4gICAgbXVsICo9IDB4ODA7XG4gICAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDgob2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpO1xuICAgIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gdGhpc1tvZmZzZXRdO1xuICAgIHJldHVybiAoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTE7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgdGhpc1tvZmZzZXQgKyAxXSA8PCA4O1xuICAgIHJldHVybiB2YWwgJiAweDgwMDAgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsO1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRShvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gICAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCB0aGlzW29mZnNldF0gPDwgODtcbiAgICByZXR1cm4gdmFsICYgMHg4MDAwID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbDtcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUob2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICAgIHJldHVybiB0aGlzW29mZnNldF0gfCB0aGlzW29mZnNldCArIDFdIDw8IDggfCB0aGlzW29mZnNldCArIDJdIDw8IDE2IHwgdGhpc1tvZmZzZXQgKyAzXSA8PCAyNDtcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUob2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICAgIHJldHVybiB0aGlzW29mZnNldF0gPDwgMjQgfCB0aGlzW29mZnNldCArIDFdIDw8IDE2IHwgdGhpc1tvZmZzZXQgKyAyXSA8PCA4IHwgdGhpc1tvZmZzZXQgKyAzXTtcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUob2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICAgIHJldHVybiByZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpO1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRShvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG4gICAgcmV0dXJuIHJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpO1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKTtcbiAgICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KTtcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRShvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCk7XG4gICAgcmV0dXJuIHJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGNoZWNrSW50KGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICAgIGlmICghaW50ZXJuYWxJc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKTtcbiAgICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpO1xuICAgIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gIH1cblxuICBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcblxuICAgIGlmICghbm9Bc3NlcnQpIHtcbiAgICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDE7XG4gICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMCk7XG4gICAgfVxuXG4gICAgdmFyIG11bCA9IDE7XG4gICAgdmFyIGkgPSAwO1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRjtcblxuICAgIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgLyBtdWwgJiAweEZGO1xuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gICAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuXG4gICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMTtcbiAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKTtcbiAgICB9XG5cbiAgICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxO1xuICAgIHZhciBtdWwgPSAxO1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkY7XG5cbiAgICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAvIG11bCAmIDB4RkY7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMCk7XG4gICAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4ZmY7XG4gICAgcmV0dXJuIG9mZnNldCArIDE7XG4gIH07XG5cbiAgZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmIDB4ZmYgPDwgOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4O1xuICAgIH1cbiAgfVxuXG4gIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMCk7XG5cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhmZjtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gODtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldCArIDI7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKTtcblxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgPj4+IDg7XG4gICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgJiAweGZmO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldCArIDI7XG4gIH07XG5cbiAgZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDE7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgICBidWZbb2Zmc2V0ICsgaV0gPSB2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4ICYgMHhmZjtcbiAgICB9XG4gIH1cblxuICBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgdmFsdWUgPSArdmFsdWU7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKTtcblxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlID4+PiAyNDtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSB2YWx1ZSA+Pj4gMTY7XG4gICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgPj4+IDg7XG4gICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4ZmY7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXQgKyA0O1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApO1xuXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSA+Pj4gMjQ7XG4gICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgPj4+IDE2O1xuICAgICAgdGhpc1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+PiA4O1xuICAgICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlICYgMHhmZjtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXQgKyA0O1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuXG4gICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKTtcbiAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KTtcbiAgICB9XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIG11bCA9IDE7XG4gICAgdmFyIHN1YiA9IDA7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGO1xuXG4gICAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICAgIHN1YiA9IDE7XG4gICAgICB9XG5cbiAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwgPj4gMCkgLSBzdWIgJiAweEZGO1xuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuXG4gICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKTtcbiAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KTtcbiAgICB9XG5cbiAgICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxO1xuICAgIHZhciBtdWwgPSAxO1xuICAgIHZhciBzdWIgPSAwO1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkY7XG5cbiAgICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICAgIHN1YiA9IDE7XG4gICAgICB9XG5cbiAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwgPj4gMCkgLSBzdWIgJiAweEZGO1xuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgdmFsdWUgPSArdmFsdWU7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MCk7XG4gICAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDE7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweGZmO1xuICAgIHJldHVybiBvZmZzZXQgKyAxO1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgdmFsdWUgPSArdmFsdWU7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApO1xuXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4ZmY7XG4gICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgPj4+IDg7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXQgKyAyO1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgdmFsdWUgPSArdmFsdWU7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApO1xuXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSA+Pj4gODtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSAmIDB4ZmY7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0ICsgMjtcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApO1xuXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4ZmY7XG4gICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgPj4+IDg7XG4gICAgICB0aGlzW29mZnNldCArIDJdID0gdmFsdWUgPj4+IDE2O1xuICAgICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlID4+PiAyNDtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldCArIDQ7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKTtcbiAgICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDE7XG5cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlID4+PiAyNDtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gMTY7XG4gICAgICB0aGlzW29mZnNldCArIDJdID0gdmFsdWUgPj4+IDg7XG4gICAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWUgJiAweGZmO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldCArIDQ7XG4gIH07XG5cbiAgZnVuY3Rpb24gY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICAgIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gICAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyaXRlRmxvYXQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCk7XG4gICAgfVxuXG4gICAgd3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KTtcbiAgICByZXR1cm4gb2Zmc2V0ICsgNDtcbiAgfVxuXG4gIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbiAgfTtcblxuICBmdW5jdGlvbiB3cml0ZURvdWJsZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4KTtcbiAgICB9XG5cbiAgICB3cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpO1xuICAgIHJldHVybiBvZmZzZXQgKyA4O1xuICB9XG5cbiAgQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xuICB9OyAvLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5cblxuICBCdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5KHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoIXN0YXJ0KSBzdGFydCA9IDA7XG4gICAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoO1xuICAgIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMDtcbiAgICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnQ7IC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuXG4gICAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwO1xuICAgIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMDsgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuXG4gICAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICAgIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKTsgLy8gQXJlIHdlIG9vYj9cblxuICAgIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGg7XG5cbiAgICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0O1xuICAgIH1cblxuICAgIHZhciBsZW4gPSBlbmQgLSBzdGFydDtcbiAgICB2YXIgaTtcblxuICAgIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKHRhcmdldCwgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRTdGFydCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlbjtcbiAgfTsgLy8gVXNhZ2U6XG4gIC8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuICAvLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbiAgLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5cblxuICBCdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZW5jb2RpbmcgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZW5jb2RpbmcgPSBlbmQ7XG4gICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApO1xuXG4gICAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgICAgdmFsID0gY29kZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhbCA9IHZhbCAmIDI1NTtcbiAgICB9IC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuXG5cbiAgICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKTtcbiAgICB9XG5cbiAgICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzdGFydCA9IHN0YXJ0ID4+PiAwO1xuICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDA7XG4gICAgaWYgKCF2YWwpIHZhbCA9IDA7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgdGhpc1tpXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJ5dGVzID0gaW50ZXJuYWxJc0J1ZmZlcih2YWwpID8gdmFsIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKTtcbiAgICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9OyAvLyBIRUxQRVIgRlVOQ1RJT05TXG4gIC8vID09PT09PT09PT09PT09PT1cblxuXG4gIHZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZztcblxuICBmdW5jdGlvbiBiYXNlNjRjbGVhbihzdHIpIHtcbiAgICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpOyAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG5cbiAgICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJzsgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG5cbiAgICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICAgIHN0ciA9IHN0ciArICc9JztcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5ndHJpbShzdHIpIHtcbiAgICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpO1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9IZXgobikge1xuICAgIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gbi50b1N0cmluZygxNik7XG4gIH1cblxuICBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHJpbmcsIHVuaXRzKSB7XG4gICAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eTtcbiAgICB2YXIgY29kZVBvaW50O1xuICAgIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbDtcbiAgICB2YXIgYnl0ZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpOyAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG5cbiAgICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IC8vIHZhbGlkIGxlYWRcblxuXG4gICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyAyIGxlYWRzIGluIGEgcm93XG5cblxuICAgICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcblxuXG4gICAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gICAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICB9XG5cbiAgICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsOyAvLyBlbmNvZGUgdXRmOFxuXG4gICAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWs7XG4gICAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrO1xuICAgICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCA+PiAweDYgfCAweEMwLCBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MCk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrO1xuICAgICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCA+PiAweEMgfCAweEUwLCBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwKTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrO1xuICAgICAgICBieXRlcy5wdXNoKGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCwgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLCBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9XG5cbiAgZnVuY3Rpb24gYXNjaWlUb0J5dGVzKHN0cikge1xuICAgIHZhciBieXRlQXJyYXkgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ5dGVBcnJheTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzKHN0ciwgdW5pdHMpIHtcbiAgICB2YXIgYywgaGksIGxvO1xuICAgIHZhciBieXRlQXJyYXkgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWs7XG4gICAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICBoaSA9IGMgPj4gODtcbiAgICAgIGxvID0gYyAlIDI1NjtcbiAgICAgIGJ5dGVBcnJheS5wdXNoKGxvKTtcbiAgICAgIGJ5dGVBcnJheS5wdXNoKGhpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnl0ZUFycmF5O1xuICB9XG5cbiAgZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyhzdHIpIHtcbiAgICByZXR1cm4gdG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSk7XG4gIH1cblxuICBmdW5jdGlvbiBibGl0QnVmZmVyKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGggfHwgaSA+PSBzcmMubGVuZ3RoKSBicmVhaztcbiAgICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gaTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzbmFuKHZhbCkge1xuICAgIHJldHVybiB2YWwgIT09IHZhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgfSAvLyB0aGUgZm9sbG93aW5nIGlzIGZyb20gaXMtYnVmZmVyLCBhbHNvIGJ5IEZlcm9zcyBBYm91a2hhZGlqZWggYW5kIHdpdGggc2FtZSBsaXNlbmNlXG4gIC8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3NpbmdcbiAgLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxuXG5cbiAgZnVuY3Rpb24gaXNCdWZmZXIob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmICghIW9iai5faXNCdWZmZXIgfHwgaXNGYXN0QnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNGYXN0QnVmZmVyKG9iaikge1xuICAgIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopO1xuICB9IC8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5cblxuICBmdW5jdGlvbiBpc1Nsb3dCdWZmZXIob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0Zhc3RCdWZmZXIob2JqLnNsaWNlKDAsIDApKTtcbiAgfVxuXG4gIHZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG4gIGZ1bmN0aW9uIHVud3JhcEV4cG9ydHMgKHgpIHtcbiAgXHRyZXR1cm4geCAmJiB4Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdkZWZhdWx0JykgPyB4WydkZWZhdWx0J10gOiB4O1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4sIG1vZHVsZSkge1xuICBcdHJldHVybiBtb2R1bGUgPSB7IGV4cG9ydHM6IHt9IH0sIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENqc0V4cG9ydEZyb21OYW1lc3BhY2UgKG4pIHtcbiAgXHRyZXR1cm4gbiAmJiBuWydkZWZhdWx0J10gfHwgbjtcbiAgfVxuXG4gIHZhciBmcyA9IGdldENqc0V4cG9ydEZyb21OYW1lc3BhY2UoX3NoaW1fZnMkMSk7XG5cbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKi9cblxuXG4gIHZhciBMaW5lQnlMaW5lID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGluZUJ5TGluZShmaWxlLCBvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGluZUJ5TGluZSk7XG5cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgaWYgKCFvcHRpb25zLnJlYWRDaHVuaykgb3B0aW9ucy5yZWFkQ2h1bmsgPSAxMDI0O1xuXG4gICAgICBpZiAoIW9wdGlvbnMubmV3TGluZUNoYXJhY3Rlcikge1xuICAgICAgICBvcHRpb25zLm5ld0xpbmVDaGFyYWN0ZXIgPSAweDBhOyAvL2xpbnV4IGxpbmUgZW5kaW5nXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLm5ld0xpbmVDaGFyYWN0ZXIgPSBvcHRpb25zLm5ld0xpbmVDaGFyYWN0ZXIuY2hhckNvZGVBdCgwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBmaWxlID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLmZkID0gZmlsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmQgPSBmcy5vcGVuU3luYyhmaWxlLCAncicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgdGhpcy5uZXdMaW5lQ2hhcmFjdGVyID0gb3B0aW9ucy5uZXdMaW5lQ2hhcmFjdGVyO1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhMaW5lQnlMaW5lLCBbe1xuICAgICAga2V5OiBcIl9zZWFyY2hJbkJ1ZmZlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZWFyY2hJbkJ1ZmZlcihidWZmZXIsIGhleE5lZWRsZSkge1xuICAgICAgICB2YXIgZm91bmQgPSAtMTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBidWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgYl9ieXRlID0gYnVmZmVyW2ldO1xuXG4gICAgICAgICAgaWYgKGJfYnl0ZSA9PT0gaGV4TmVlZGxlKSB7XG4gICAgICAgICAgICBmb3VuZCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlc2V0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuZW9mUmVhY2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxpbmVzQ2FjaGUgPSBbXTtcbiAgICAgICAgdGhpcy5mZFBvc2l0aW9uID0gMDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2xvc2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgZnMuY2xvc2VTeW5jKHRoaXMuZmQpO1xuICAgICAgICB0aGlzLmZkID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2V4dHJhY3RMaW5lc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9leHRyYWN0TGluZXMoYnVmZmVyKSB7XG4gICAgICAgIHZhciBsaW5lO1xuICAgICAgICB2YXIgbGluZXMgPSBbXTtcbiAgICAgICAgdmFyIGJ1ZmZlclBvc2l0aW9uID0gMDtcbiAgICAgICAgdmFyIGxhc3ROZXdMaW5lQnVmZmVyUG9zaXRpb24gPSAwO1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgdmFyIGJ1ZmZlclBvc2l0aW9uVmFsdWUgPSBidWZmZXJbYnVmZmVyUG9zaXRpb24rK107XG5cbiAgICAgICAgICBpZiAoYnVmZmVyUG9zaXRpb25WYWx1ZSA9PT0gdGhpcy5uZXdMaW5lQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICBsaW5lID0gYnVmZmVyLnNsaWNlKGxhc3ROZXdMaW5lQnVmZmVyUG9zaXRpb24sIGJ1ZmZlclBvc2l0aW9uKTtcbiAgICAgICAgICAgIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgICAgICBsYXN0TmV3TGluZUJ1ZmZlclBvc2l0aW9uID0gYnVmZmVyUG9zaXRpb247XG4gICAgICAgICAgfSBlbHNlIGlmICghYnVmZmVyUG9zaXRpb25WYWx1ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlZnRvdmVycyA9IGJ1ZmZlci5zbGljZShsYXN0TmV3TGluZUJ1ZmZlclBvc2l0aW9uLCBidWZmZXJQb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKGxlZnRvdmVycy5sZW5ndGgpIHtcbiAgICAgICAgICBsaW5lcy5wdXNoKGxlZnRvdmVycyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9yZWFkQ2h1bmtcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVhZENodW5rKGxpbmVMZWZ0b3ZlcnMpIHtcbiAgICAgICAgdmFyIHRvdGFsQnl0ZXNSZWFkID0gMDtcbiAgICAgICAgdmFyIGJ5dGVzUmVhZDtcbiAgICAgICAgdmFyIGJ1ZmZlcnMgPSBbXTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgdmFyIHJlYWRCdWZmZXIgPSBuZXcgQnVmZmVyKHRoaXMub3B0aW9ucy5yZWFkQ2h1bmspO1xuICAgICAgICAgIGJ5dGVzUmVhZCA9IGZzLnJlYWRTeW5jKHRoaXMuZmQsIHJlYWRCdWZmZXIsIDAsIHRoaXMub3B0aW9ucy5yZWFkQ2h1bmssIHRoaXMuZmRQb3NpdGlvbik7XG4gICAgICAgICAgdG90YWxCeXRlc1JlYWQgPSB0b3RhbEJ5dGVzUmVhZCArIGJ5dGVzUmVhZDtcbiAgICAgICAgICB0aGlzLmZkUG9zaXRpb24gPSB0aGlzLmZkUG9zaXRpb24gKyBieXRlc1JlYWQ7XG4gICAgICAgICAgYnVmZmVycy5wdXNoKHJlYWRCdWZmZXIpO1xuICAgICAgICB9IHdoaWxlIChieXRlc1JlYWQgJiYgdGhpcy5fc2VhcmNoSW5CdWZmZXIoYnVmZmVyc1tidWZmZXJzLmxlbmd0aCAtIDFdLCB0aGlzLm9wdGlvbnMubmV3TGluZUNoYXJhY3RlcikgPT09IC0xKTtcblxuICAgICAgICB2YXIgYnVmZmVyRGF0YSA9IEJ1ZmZlci5jb25jYXQoYnVmZmVycyk7XG5cbiAgICAgICAgaWYgKGJ5dGVzUmVhZCA8IHRoaXMub3B0aW9ucy5yZWFkQ2h1bmspIHtcbiAgICAgICAgICB0aGlzLmVvZlJlYWNoZWQgPSB0cnVlO1xuICAgICAgICAgIGJ1ZmZlckRhdGEgPSBidWZmZXJEYXRhLnNsaWNlKDAsIHRvdGFsQnl0ZXNSZWFkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b3RhbEJ5dGVzUmVhZCkge1xuICAgICAgICAgIHRoaXMubGluZXNDYWNoZSA9IHRoaXMuX2V4dHJhY3RMaW5lcyhidWZmZXJEYXRhKTtcblxuICAgICAgICAgIGlmIChsaW5lTGVmdG92ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVzQ2FjaGVbMF0gPSBCdWZmZXIuY29uY2F0KFtsaW5lTGVmdG92ZXJzLCB0aGlzLmxpbmVzQ2FjaGVbMF1dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG90YWxCeXRlc1JlYWQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIm5leHRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICBpZiAoIXRoaXMuZmQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGxpbmUgPSBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5lb2ZSZWFjaGVkICYmIHRoaXMubGluZXNDYWNoZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbGluZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBieXRlc1JlYWQ7XG5cbiAgICAgICAgaWYgKCF0aGlzLmxpbmVzQ2FjaGUubGVuZ3RoKSB7XG4gICAgICAgICAgYnl0ZXNSZWFkID0gdGhpcy5fcmVhZENodW5rKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5saW5lc0NhY2hlLmxlbmd0aCkge1xuICAgICAgICAgIGxpbmUgPSB0aGlzLmxpbmVzQ2FjaGUuc2hpZnQoKTtcbiAgICAgICAgICB2YXIgbGFzdExpbmVDaGFyYWN0ZXIgPSBsaW5lW2xpbmUubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICBpZiAobGFzdExpbmVDaGFyYWN0ZXIgIT09IDB4MGEpIHtcbiAgICAgICAgICAgIGJ5dGVzUmVhZCA9IHRoaXMuX3JlYWRDaHVuayhsaW5lKTtcblxuICAgICAgICAgICAgaWYgKGJ5dGVzUmVhZCkge1xuICAgICAgICAgICAgICBsaW5lID0gdGhpcy5saW5lc0NhY2hlLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZW9mUmVhY2hlZCAmJiB0aGlzLmxpbmVzQ2FjaGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpbmUgJiYgbGluZVtsaW5lLmxlbmd0aCAtIDFdID09PSB0aGlzLm5ld0xpbmVDaGFyYWN0ZXIpIHtcbiAgICAgICAgICBsaW5lID0gbGluZS5zbGljZSgwLCBsaW5lLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIExpbmVCeUxpbmU7XG4gIH0oKTtcblxuICB2YXIgcmVhZGxpbmVzID0gTGluZUJ5TGluZTtcblxuICB2YXIgQ29uZmlnRXJyb3IgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfRXJyb3IpIHtcbiAgICBfaW5oZXJpdHMoQ29uZmlnRXJyb3IsIF9FcnJvcik7XG5cbiAgICBmdW5jdGlvbiBDb25maWdFcnJvcigpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb25maWdFcnJvcik7XG5cbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQ29uZmlnRXJyb3IpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH1cblxuICAgIHJldHVybiBDb25maWdFcnJvcjtcbiAgfShfd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG5cbiAgdmFyIERlYnVnRXJyb3IgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfRXJyb3IyKSB7XG4gICAgX2luaGVyaXRzKERlYnVnRXJyb3IsIF9FcnJvcjIpO1xuXG4gICAgZnVuY3Rpb24gRGVidWdFcnJvcigpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEZWJ1Z0Vycm9yKTtcblxuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihEZWJ1Z0Vycm9yKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gRGVidWdFcnJvcjtcbiAgfShfd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG5cbiAgdmFyIFVuZGVmaW5lZFBhcnNlckVycm9yID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0Vycm9yMykge1xuICAgIF9pbmhlcml0cyhVbmRlZmluZWRQYXJzZXJFcnJvciwgX0Vycm9yMyk7XG5cbiAgICBmdW5jdGlvbiBVbmRlZmluZWRQYXJzZXJFcnJvcigpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBVbmRlZmluZWRQYXJzZXJFcnJvcik7XG5cbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoVW5kZWZpbmVkUGFyc2VyRXJyb3IpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH1cblxuICAgIHJldHVybiBVbmRlZmluZWRQYXJzZXJFcnJvcjtcbiAgfShfd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG5cbiAgdmFyIGVycm9ycyA9IHtcbiAgICBDb25maWdFcnJvcjogQ29uZmlnRXJyb3IsXG4gICAgRGVidWdFcnJvcjogRGVidWdFcnJvcixcbiAgICBVbmRlZmluZWRQYXJzZXJFcnJvcjogVW5kZWZpbmVkUGFyc2VyRXJyb3JcbiAgfTtcblxuICAvLyBiYXNlZCBvZmYgaHR0cHM6Ly9naXRodWIuY29tL2RlZnVuY3R6b21iaWUvbm9kZS1wcm9jZXNzL2Jsb2IvbWFzdGVyL2Jyb3dzZXIuanNcblxuICBmdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xuICB9XG5cbiAgdmFyIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICB2YXIgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcblxuICBpZiAodHlwZW9mIGdsb2JhbCQxLnNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZ2xvYmFsJDEuY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICB9XG5cbiAgZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcblxuXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuXG5cbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBxdWV1ZSA9IFtdO1xuICB2YXIgZHJhaW5pbmcgPSBmYWxzZTtcbiAgdmFyIGN1cnJlbnRRdWV1ZTtcbiAgdmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuICBmdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcblxuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuXG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuKSB7XG4gICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgIHF1ZXVlID0gW107XG5cbiAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuXG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHRUaWNrKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcblxuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbiAgfSAvLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5cbiAgZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICB9XG5cbiAgSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xuICB9O1xuXG4gIHZhciB0aXRsZSA9ICdicm93c2VyJztcbiAgdmFyIHBsYXRmb3JtID0gJ2Jyb3dzZXInO1xuICB2YXIgYnJvd3NlciA9IHRydWU7XG4gIHZhciBlbnYgPSB7fTtcbiAgdmFyIGFyZ3YgPSBbXTtcbiAgdmFyIHZlcnNpb24kMSA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xuXG4gIHZhciB2ZXJzaW9ucyA9IHt9O1xuICB2YXIgcmVsZWFzZSA9IHt9O1xuICB2YXIgY29uZmlnID0ge307XG5cbiAgZnVuY3Rpb24gbm9vcCgpIHt9XG5cbiAgdmFyIG9uID0gbm9vcDtcbiAgdmFyIGFkZExpc3RlbmVyID0gbm9vcDtcbiAgdmFyIG9uY2UgPSBub29wO1xuICB2YXIgb2ZmID0gbm9vcDtcbiAgdmFyIHJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbiAgdmFyIHJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG4gIHZhciBlbWl0ID0gbm9vcDtcbiAgZnVuY3Rpb24gYmluZGluZyhuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xuICB9XG4gIGZ1bmN0aW9uIGN3ZCgpIHtcbiAgICByZXR1cm4gJy8nO1xuICB9XG4gIGZ1bmN0aW9uIGNoZGlyKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cbiAgZnVuY3Rpb24gdW1hc2soKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20va3VtYXZpcy9icm93c2VyLXByb2Nlc3MtaHJ0aW1lL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG5cbiAgdmFyIHBlcmZvcm1hbmNlID0gZ2xvYmFsJDEucGVyZm9ybWFuY2UgfHwge307XG5cbiAgdmFyIHBlcmZvcm1hbmNlTm93ID0gcGVyZm9ybWFuY2Uubm93IHx8IHBlcmZvcm1hbmNlLm1vek5vdyB8fCBwZXJmb3JtYW5jZS5tc05vdyB8fCBwZXJmb3JtYW5jZS5vTm93IHx8IHBlcmZvcm1hbmNlLndlYmtpdE5vdyB8fCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9OyAvLyBnZW5lcmF0ZSB0aW1lc3RhbXAgb3IgZGVsdGFcbiAgLy8gc2VlIGh0dHA6Ly9ub2RlanMub3JnL2FwaS9wcm9jZXNzLmh0bWwjcHJvY2Vzc19wcm9jZXNzX2hydGltZVxuXG5cbiAgZnVuY3Rpb24gaHJ0aW1lKHByZXZpb3VzVGltZXN0YW1wKSB7XG4gICAgdmFyIGNsb2NrdGltZSA9IHBlcmZvcm1hbmNlTm93LmNhbGwocGVyZm9ybWFuY2UpICogMWUtMztcbiAgICB2YXIgc2Vjb25kcyA9IE1hdGguZmxvb3IoY2xvY2t0aW1lKTtcbiAgICB2YXIgbmFub3NlY29uZHMgPSBNYXRoLmZsb29yKGNsb2NrdGltZSAlIDEgKiAxZTkpO1xuXG4gICAgaWYgKHByZXZpb3VzVGltZXN0YW1wKSB7XG4gICAgICBzZWNvbmRzID0gc2Vjb25kcyAtIHByZXZpb3VzVGltZXN0YW1wWzBdO1xuICAgICAgbmFub3NlY29uZHMgPSBuYW5vc2Vjb25kcyAtIHByZXZpb3VzVGltZXN0YW1wWzFdO1xuXG4gICAgICBpZiAobmFub3NlY29uZHMgPCAwKSB7XG4gICAgICAgIHNlY29uZHMtLTtcbiAgICAgICAgbmFub3NlY29uZHMgKz0gMWU5O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbc2Vjb25kcywgbmFub3NlY29uZHNdO1xuICB9XG4gIHZhciBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuICBmdW5jdGlvbiB1cHRpbWUoKSB7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICB2YXIgZGlmID0gY3VycmVudFRpbWUgLSBzdGFydFRpbWU7XG4gICAgcmV0dXJuIGRpZiAvIDEwMDA7XG4gIH1cbiAgdmFyIHByb2Nlc3MgPSB7XG4gICAgbmV4dFRpY2s6IG5leHRUaWNrLFxuICAgIHRpdGxlOiB0aXRsZSxcbiAgICBicm93c2VyOiBicm93c2VyLFxuICAgIGVudjogZW52LFxuICAgIGFyZ3Y6IGFyZ3YsXG4gICAgdmVyc2lvbjogdmVyc2lvbiQxLFxuICAgIHZlcnNpb25zOiB2ZXJzaW9ucyxcbiAgICBvbjogb24sXG4gICAgYWRkTGlzdGVuZXI6IGFkZExpc3RlbmVyLFxuICAgIG9uY2U6IG9uY2UsXG4gICAgb2ZmOiBvZmYsXG4gICAgcmVtb3ZlTGlzdGVuZXI6IHJlbW92ZUxpc3RlbmVyLFxuICAgIHJlbW92ZUFsbExpc3RlbmVyczogcmVtb3ZlQWxsTGlzdGVuZXJzLFxuICAgIGVtaXQ6IGVtaXQsXG4gICAgYmluZGluZzogYmluZGluZyxcbiAgICBjd2Q6IGN3ZCxcbiAgICBjaGRpcjogY2hkaXIsXG4gICAgdW1hc2s6IHVtYXNrLFxuICAgIGhydGltZTogaHJ0aW1lLFxuICAgIHBsYXRmb3JtOiBwbGF0Zm9ybSxcbiAgICByZWxlYXNlOiByZWxlYXNlLFxuICAgIGNvbmZpZzogY29uZmlnLFxuICAgIHVwdGltZTogdXB0aW1lXG4gIH07XG5cbiAgdmFyIHNlbXZlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBTZW1WZXI7XG4gICAgdmFyIGRlYnVnO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgICBpZiAoX3R5cGVvZihwcm9jZXNzKSA9PT0gJ29iamVjdCcgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyAmJiAvXFxic2VtdmVyXFxiL2kudGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKSkge1xuICAgICAgZGVidWcgPSBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICBhcmdzLnVuc2hpZnQoJ1NFTVZFUicpO1xuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnID0gZnVuY3Rpb24gZGVidWcoKSB7fTtcbiAgICB9IC8vIE5vdGU6IHRoaXMgaXMgdGhlIHNlbXZlci5vcmcgdmVyc2lvbiBvZiB0aGUgc3BlYyB0aGF0IGl0IGltcGxlbWVudHNcbiAgICAvLyBOb3QgbmVjZXNzYXJpbHkgdGhlIHBhY2thZ2UgdmVyc2lvbiBvZiB0aGlzIGNvZGUuXG5cblxuICAgIGV4cG9ydHMuU0VNVkVSX1NQRUNfVkVSU0lPTiA9ICcyLjAuMCc7XG4gICAgdmFyIE1BWF9MRU5HVEggPSAyNTY7XG4gICAgdmFyIE1BWF9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgOTAwNzE5OTI1NDc0MDk5MTsgLy8gTWF4IHNhZmUgc2VnbWVudCBsZW5ndGggZm9yIGNvZXJjaW9uLlxuXG4gICAgdmFyIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggPSAxNjsgLy8gVGhlIGFjdHVhbCByZWdleHBzIGdvIG9uIGV4cG9ydHMucmVcblxuICAgIHZhciByZSA9IGV4cG9ydHMucmUgPSBbXTtcbiAgICB2YXIgc3JjID0gZXhwb3J0cy5zcmMgPSBbXTtcbiAgICB2YXIgdCA9IGV4cG9ydHMudG9rZW5zID0ge307XG4gICAgdmFyIFIgPSAwO1xuXG4gICAgZnVuY3Rpb24gdG9rKG4pIHtcbiAgICAgIHRbbl0gPSBSKys7XG4gICAgfSAvLyBUaGUgZm9sbG93aW5nIFJlZ3VsYXIgRXhwcmVzc2lvbnMgY2FuIGJlIHVzZWQgZm9yIHRva2VuaXppbmcsXG4gICAgLy8gdmFsaWRhdGluZywgYW5kIHBhcnNpbmcgU2VtVmVyIHZlcnNpb24gc3RyaW5ncy5cbiAgICAvLyAjIyBOdW1lcmljIElkZW50aWZpZXJcbiAgICAvLyBBIHNpbmdsZSBgMGAsIG9yIGEgbm9uLXplcm8gZGlnaXQgZm9sbG93ZWQgYnkgemVybyBvciBtb3JlIGRpZ2l0cy5cblxuXG4gICAgdG9rKCdOVU1FUklDSURFTlRJRklFUicpO1xuICAgIHNyY1t0Lk5VTUVSSUNJREVOVElGSUVSXSA9ICcwfFsxLTldXFxcXGQqJztcbiAgICB0b2soJ05VTUVSSUNJREVOVElGSUVSTE9PU0UnKTtcbiAgICBzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXSA9ICdbMC05XSsnOyAvLyAjIyBOb24tbnVtZXJpYyBJZGVudGlmaWVyXG4gICAgLy8gWmVybyBvciBtb3JlIGRpZ2l0cywgZm9sbG93ZWQgYnkgYSBsZXR0ZXIgb3IgaHlwaGVuLCBhbmQgdGhlbiB6ZXJvIG9yXG4gICAgLy8gbW9yZSBsZXR0ZXJzLCBkaWdpdHMsIG9yIGh5cGhlbnMuXG5cbiAgICB0b2soJ05PTk5VTUVSSUNJREVOVElGSUVSJyk7XG4gICAgc3JjW3QuTk9OTlVNRVJJQ0lERU5USUZJRVJdID0gJ1xcXFxkKlthLXpBLVotXVthLXpBLVowLTktXSonOyAvLyAjIyBNYWluIFZlcnNpb25cbiAgICAvLyBUaHJlZSBkb3Qtc2VwYXJhdGVkIG51bWVyaWMgaWRlbnRpZmllcnMuXG5cbiAgICB0b2soJ01BSU5WRVJTSU9OJyk7XG4gICAgc3JjW3QuTUFJTlZFUlNJT05dID0gJygnICsgc3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdICsgJylcXFxcLicgKyAnKCcgKyBzcmNbdC5OVU1FUklDSURFTlRJRklFUl0gKyAnKVxcXFwuJyArICcoJyArIHNyY1t0Lk5VTUVSSUNJREVOVElGSUVSXSArICcpJztcbiAgICB0b2soJ01BSU5WRVJTSU9OTE9PU0UnKTtcbiAgICBzcmNbdC5NQUlOVkVSU0lPTkxPT1NFXSA9ICcoJyArIHNyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdICsgJylcXFxcLicgKyAnKCcgKyBzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXSArICcpXFxcXC4nICsgJygnICsgc3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnKSc7IC8vICMjIFByZS1yZWxlYXNlIFZlcnNpb24gSWRlbnRpZmllclxuICAgIC8vIEEgbnVtZXJpYyBpZGVudGlmaWVyLCBvciBhIG5vbi1udW1lcmljIGlkZW50aWZpZXIuXG5cbiAgICB0b2soJ1BSRVJFTEVBU0VJREVOVElGSUVSJyk7XG4gICAgc3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJdID0gJyg/OicgKyBzcmNbdC5OVU1FUklDSURFTlRJRklFUl0gKyAnfCcgKyBzcmNbdC5OT05OVU1FUklDSURFTlRJRklFUl0gKyAnKSc7XG4gICAgdG9rKCdQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFJyk7XG4gICAgc3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV0gPSAnKD86JyArIHNyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdICsgJ3wnICsgc3JjW3QuTk9OTlVNRVJJQ0lERU5USUZJRVJdICsgJyknOyAvLyAjIyBQcmUtcmVsZWFzZSBWZXJzaW9uXG4gICAgLy8gSHlwaGVuLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBkb3Qtc2VwYXJhdGVkIHByZS1yZWxlYXNlIHZlcnNpb25cbiAgICAvLyBpZGVudGlmaWVycy5cblxuICAgIHRvaygnUFJFUkVMRUFTRScpO1xuICAgIHNyY1t0LlBSRVJFTEVBU0VdID0gJyg/Oi0oJyArIHNyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSXSArICcoPzpcXFxcLicgKyBzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUl0gKyAnKSopKSc7XG4gICAgdG9rKCdQUkVSRUxFQVNFTE9PU0UnKTtcbiAgICBzcmNbdC5QUkVSRUxFQVNFTE9PU0VdID0gJyg/Oi0/KCcgKyBzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXSArICcoPzpcXFxcLicgKyBzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXSArICcpKikpJzsgLy8gIyMgQnVpbGQgTWV0YWRhdGEgSWRlbnRpZmllclxuICAgIC8vIEFueSBjb21iaW5hdGlvbiBvZiBkaWdpdHMsIGxldHRlcnMsIG9yIGh5cGhlbnMuXG5cbiAgICB0b2soJ0JVSUxESURFTlRJRklFUicpO1xuICAgIHNyY1t0LkJVSUxESURFTlRJRklFUl0gPSAnWzAtOUEtWmEtei1dKyc7IC8vICMjIEJ1aWxkIE1ldGFkYXRhXG4gICAgLy8gUGx1cyBzaWduLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBwZXJpb2Qtc2VwYXJhdGVkIGJ1aWxkIG1ldGFkYXRhXG4gICAgLy8gaWRlbnRpZmllcnMuXG5cbiAgICB0b2soJ0JVSUxEJyk7XG4gICAgc3JjW3QuQlVJTERdID0gJyg/OlxcXFwrKCcgKyBzcmNbdC5CVUlMRElERU5USUZJRVJdICsgJyg/OlxcXFwuJyArIHNyY1t0LkJVSUxESURFTlRJRklFUl0gKyAnKSopKSc7IC8vICMjIEZ1bGwgVmVyc2lvbiBTdHJpbmdcbiAgICAvLyBBIG1haW4gdmVyc2lvbiwgZm9sbG93ZWQgb3B0aW9uYWxseSBieSBhIHByZS1yZWxlYXNlIHZlcnNpb24gYW5kXG4gICAgLy8gYnVpbGQgbWV0YWRhdGEuXG4gICAgLy8gTm90ZSB0aGF0IHRoZSBvbmx5IG1ham9yLCBtaW5vciwgcGF0Y2gsIGFuZCBwcmUtcmVsZWFzZSBzZWN0aW9ucyBvZlxuICAgIC8vIHRoZSB2ZXJzaW9uIHN0cmluZyBhcmUgY2FwdHVyaW5nIGdyb3Vwcy4gIFRoZSBidWlsZCBtZXRhZGF0YSBpcyBub3QgYVxuICAgIC8vIGNhcHR1cmluZyBncm91cCwgYmVjYXVzZSBpdCBzaG91bGQgbm90IGV2ZXIgYmUgdXNlZCBpbiB2ZXJzaW9uXG4gICAgLy8gY29tcGFyaXNvbi5cblxuICAgIHRvaygnRlVMTCcpO1xuICAgIHRvaygnRlVMTFBMQUlOJyk7XG4gICAgc3JjW3QuRlVMTFBMQUlOXSA9ICd2PycgKyBzcmNbdC5NQUlOVkVSU0lPTl0gKyBzcmNbdC5QUkVSRUxFQVNFXSArICc/JyArIHNyY1t0LkJVSUxEXSArICc/JztcbiAgICBzcmNbdC5GVUxMXSA9ICdeJyArIHNyY1t0LkZVTExQTEFJTl0gKyAnJCc7IC8vIGxpa2UgZnVsbCwgYnV0IGFsbG93cyB2MS4yLjMgYW5kID0xLjIuMywgd2hpY2ggcGVvcGxlIGRvIHNvbWV0aW1lcy5cbiAgICAvLyBhbHNvLCAxLjAuMGFscGhhMSAocHJlcmVsZWFzZSB3aXRob3V0IHRoZSBoeXBoZW4pIHdoaWNoIGlzIHByZXR0eVxuICAgIC8vIGNvbW1vbiBpbiB0aGUgbnBtIHJlZ2lzdHJ5LlxuXG4gICAgdG9rKCdMT09TRVBMQUlOJyk7XG4gICAgc3JjW3QuTE9PU0VQTEFJTl0gPSAnW3Y9XFxcXHNdKicgKyBzcmNbdC5NQUlOVkVSU0lPTkxPT1NFXSArIHNyY1t0LlBSRVJFTEVBU0VMT09TRV0gKyAnPycgKyBzcmNbdC5CVUlMRF0gKyAnPyc7XG4gICAgdG9rKCdMT09TRScpO1xuICAgIHNyY1t0LkxPT1NFXSA9ICdeJyArIHNyY1t0LkxPT1NFUExBSU5dICsgJyQnO1xuICAgIHRvaygnR1RMVCcpO1xuICAgIHNyY1t0LkdUTFRdID0gJygoPzo8fD4pPz0/KSc7IC8vIFNvbWV0aGluZyBsaWtlIFwiMi4qXCIgb3IgXCIxLjIueFwiLlxuICAgIC8vIE5vdGUgdGhhdCBcIngueFwiIGlzIGEgdmFsaWQgeFJhbmdlIGlkZW50aWZlciwgbWVhbmluZyBcImFueSB2ZXJzaW9uXCJcbiAgICAvLyBPbmx5IHRoZSBmaXJzdCBpdGVtIGlzIHN0cmljdGx5IHJlcXVpcmVkLlxuXG4gICAgdG9rKCdYUkFOR0VJREVOVElGSUVSTE9PU0UnKTtcbiAgICBzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdID0gc3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnfHh8WHxcXFxcKic7XG4gICAgdG9rKCdYUkFOR0VJREVOVElGSUVSJyk7XG4gICAgc3JjW3QuWFJBTkdFSURFTlRJRklFUl0gPSBzcmNbdC5OVU1FUklDSURFTlRJRklFUl0gKyAnfHh8WHxcXFxcKic7XG4gICAgdG9rKCdYUkFOR0VQTEFJTicpO1xuICAgIHNyY1t0LlhSQU5HRVBMQUlOXSA9ICdbdj1cXFxcc10qKCcgKyBzcmNbdC5YUkFOR0VJREVOVElGSUVSXSArICcpJyArICcoPzpcXFxcLignICsgc3JjW3QuWFJBTkdFSURFTlRJRklFUl0gKyAnKScgKyAnKD86XFxcXC4oJyArIHNyY1t0LlhSQU5HRUlERU5USUZJRVJdICsgJyknICsgJyg/OicgKyBzcmNbdC5QUkVSRUxFQVNFXSArICcpPycgKyBzcmNbdC5CVUlMRF0gKyAnPycgKyAnKT8pPyc7XG4gICAgdG9rKCdYUkFOR0VQTEFJTkxPT1NFJyk7XG4gICAgc3JjW3QuWFJBTkdFUExBSU5MT09TRV0gPSAnW3Y9XFxcXHNdKignICsgc3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXSArICcpJyArICcoPzpcXFxcLignICsgc3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXSArICcpJyArICcoPzpcXFxcLignICsgc3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXSArICcpJyArICcoPzonICsgc3JjW3QuUFJFUkVMRUFTRUxPT1NFXSArICcpPycgKyBzcmNbdC5CVUlMRF0gKyAnPycgKyAnKT8pPyc7XG4gICAgdG9rKCdYUkFOR0UnKTtcbiAgICBzcmNbdC5YUkFOR0VdID0gJ14nICsgc3JjW3QuR1RMVF0gKyAnXFxcXHMqJyArIHNyY1t0LlhSQU5HRVBMQUlOXSArICckJztcbiAgICB0b2soJ1hSQU5HRUxPT1NFJyk7XG4gICAgc3JjW3QuWFJBTkdFTE9PU0VdID0gJ14nICsgc3JjW3QuR1RMVF0gKyAnXFxcXHMqJyArIHNyY1t0LlhSQU5HRVBMQUlOTE9PU0VdICsgJyQnOyAvLyBDb2VyY2lvbi5cbiAgICAvLyBFeHRyYWN0IGFueXRoaW5nIHRoYXQgY291bGQgY29uY2VpdmFibHkgYmUgYSBwYXJ0IG9mIGEgdmFsaWQgc2VtdmVyXG5cbiAgICB0b2soJ0NPRVJDRScpO1xuICAgIHNyY1t0LkNPRVJDRV0gPSAnKF58W15cXFxcZF0pJyArICcoXFxcXGR7MSwnICsgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCArICd9KScgKyAnKD86XFxcXC4oXFxcXGR7MSwnICsgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCArICd9KSk/JyArICcoPzpcXFxcLihcXFxcZHsxLCcgKyBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIICsgJ30pKT8nICsgJyg/OiR8W15cXFxcZF0pJztcbiAgICB0b2soJ0NPRVJDRVJUTCcpO1xuICAgIHJlW3QuQ09FUkNFUlRMXSA9IG5ldyBSZWdFeHAoc3JjW3QuQ09FUkNFXSwgJ2cnKTsgLy8gVGlsZGUgcmFuZ2VzLlxuICAgIC8vIE1lYW5pbmcgaXMgXCJyZWFzb25hYmx5IGF0IG9yIGdyZWF0ZXIgdGhhblwiXG5cbiAgICB0b2soJ0xPTkVUSUxERScpO1xuICAgIHNyY1t0LkxPTkVUSUxERV0gPSAnKD86fj4/KSc7XG4gICAgdG9rKCdUSUxERVRSSU0nKTtcbiAgICBzcmNbdC5USUxERVRSSU1dID0gJyhcXFxccyopJyArIHNyY1t0LkxPTkVUSUxERV0gKyAnXFxcXHMrJztcbiAgICByZVt0LlRJTERFVFJJTV0gPSBuZXcgUmVnRXhwKHNyY1t0LlRJTERFVFJJTV0sICdnJyk7XG4gICAgdmFyIHRpbGRlVHJpbVJlcGxhY2UgPSAnJDF+JztcbiAgICB0b2soJ1RJTERFJyk7XG4gICAgc3JjW3QuVElMREVdID0gJ14nICsgc3JjW3QuTE9ORVRJTERFXSArIHNyY1t0LlhSQU5HRVBMQUlOXSArICckJztcbiAgICB0b2soJ1RJTERFTE9PU0UnKTtcbiAgICBzcmNbdC5USUxERUxPT1NFXSA9ICdeJyArIHNyY1t0LkxPTkVUSUxERV0gKyBzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXSArICckJzsgLy8gQ2FyZXQgcmFuZ2VzLlxuICAgIC8vIE1lYW5pbmcgaXMgXCJhdCBsZWFzdCBhbmQgYmFja3dhcmRzIGNvbXBhdGlibGUgd2l0aFwiXG5cbiAgICB0b2soJ0xPTkVDQVJFVCcpO1xuICAgIHNyY1t0LkxPTkVDQVJFVF0gPSAnKD86XFxcXF4pJztcbiAgICB0b2soJ0NBUkVUVFJJTScpO1xuICAgIHNyY1t0LkNBUkVUVFJJTV0gPSAnKFxcXFxzKiknICsgc3JjW3QuTE9ORUNBUkVUXSArICdcXFxccysnO1xuICAgIHJlW3QuQ0FSRVRUUklNXSA9IG5ldyBSZWdFeHAoc3JjW3QuQ0FSRVRUUklNXSwgJ2cnKTtcbiAgICB2YXIgY2FyZXRUcmltUmVwbGFjZSA9ICckMV4nO1xuICAgIHRvaygnQ0FSRVQnKTtcbiAgICBzcmNbdC5DQVJFVF0gPSAnXicgKyBzcmNbdC5MT05FQ0FSRVRdICsgc3JjW3QuWFJBTkdFUExBSU5dICsgJyQnO1xuICAgIHRvaygnQ0FSRVRMT09TRScpO1xuICAgIHNyY1t0LkNBUkVUTE9PU0VdID0gJ14nICsgc3JjW3QuTE9ORUNBUkVUXSArIHNyY1t0LlhSQU5HRVBMQUlOTE9PU0VdICsgJyQnOyAvLyBBIHNpbXBsZSBndC9sdC9lcSB0aGluZywgb3IganVzdCBcIlwiIHRvIGluZGljYXRlIFwiYW55IHZlcnNpb25cIlxuXG4gICAgdG9rKCdDT01QQVJBVE9STE9PU0UnKTtcbiAgICBzcmNbdC5DT01QQVJBVE9STE9PU0VdID0gJ14nICsgc3JjW3QuR1RMVF0gKyAnXFxcXHMqKCcgKyBzcmNbdC5MT09TRVBMQUlOXSArICcpJHxeJCc7XG4gICAgdG9rKCdDT01QQVJBVE9SJyk7XG4gICAgc3JjW3QuQ09NUEFSQVRPUl0gPSAnXicgKyBzcmNbdC5HVExUXSArICdcXFxccyooJyArIHNyY1t0LkZVTExQTEFJTl0gKyAnKSR8XiQnOyAvLyBBbiBleHByZXNzaW9uIHRvIHN0cmlwIGFueSB3aGl0ZXNwYWNlIGJldHdlZW4gdGhlIGd0bHQgYW5kIHRoZSB0aGluZ1xuICAgIC8vIGl0IG1vZGlmaWVzLCBzbyB0aGF0IGA+IDEuMi4zYCA9PT4gYD4xLjIuM2BcblxuICAgIHRvaygnQ09NUEFSQVRPUlRSSU0nKTtcbiAgICBzcmNbdC5DT01QQVJBVE9SVFJJTV0gPSAnKFxcXFxzKiknICsgc3JjW3QuR1RMVF0gKyAnXFxcXHMqKCcgKyBzcmNbdC5MT09TRVBMQUlOXSArICd8JyArIHNyY1t0LlhSQU5HRVBMQUlOXSArICcpJzsgLy8gdGhpcyBvbmUgaGFzIHRvIHVzZSB0aGUgL2cgZmxhZ1xuXG4gICAgcmVbdC5DT01QQVJBVE9SVFJJTV0gPSBuZXcgUmVnRXhwKHNyY1t0LkNPTVBBUkFUT1JUUklNXSwgJ2cnKTtcbiAgICB2YXIgY29tcGFyYXRvclRyaW1SZXBsYWNlID0gJyQxJDIkMyc7IC8vIFNvbWV0aGluZyBsaWtlIGAxLjIuMyAtIDEuMi40YFxuICAgIC8vIE5vdGUgdGhhdCB0aGVzZSBhbGwgdXNlIHRoZSBsb29zZSBmb3JtLCBiZWNhdXNlIHRoZXknbGwgYmVcbiAgICAvLyBjaGVja2VkIGFnYWluc3QgZWl0aGVyIHRoZSBzdHJpY3Qgb3IgbG9vc2UgY29tcGFyYXRvciBmb3JtXG4gICAgLy8gbGF0ZXIuXG5cbiAgICB0b2soJ0hZUEhFTlJBTkdFJyk7XG4gICAgc3JjW3QuSFlQSEVOUkFOR0VdID0gJ15cXFxccyooJyArIHNyY1t0LlhSQU5HRVBMQUlOXSArICcpJyArICdcXFxccystXFxcXHMrJyArICcoJyArIHNyY1t0LlhSQU5HRVBMQUlOXSArICcpJyArICdcXFxccyokJztcbiAgICB0b2soJ0hZUEhFTlJBTkdFTE9PU0UnKTtcbiAgICBzcmNbdC5IWVBIRU5SQU5HRUxPT1NFXSA9ICdeXFxcXHMqKCcgKyBzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXSArICcpJyArICdcXFxccystXFxcXHMrJyArICcoJyArIHNyY1t0LlhSQU5HRVBMQUlOTE9PU0VdICsgJyknICsgJ1xcXFxzKiQnOyAvLyBTdGFyIHJhbmdlcyBiYXNpY2FsbHkganVzdCBhbGxvdyBhbnl0aGluZyBhdCBhbGwuXG5cbiAgICB0b2soJ1NUQVInKTtcbiAgICBzcmNbdC5TVEFSXSA9ICcoPHw+KT89P1xcXFxzKlxcXFwqJzsgLy8gQ29tcGlsZSB0byBhY3R1YWwgcmVnZXhwIG9iamVjdHMuXG4gICAgLy8gQWxsIGFyZSBmbGFnLWZyZWUsIHVubGVzcyB0aGV5IHdlcmUgY3JlYXRlZCBhYm92ZSB3aXRoIGEgZmxhZy5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgUjsgaSsrKSB7XG4gICAgICBkZWJ1ZyhpLCBzcmNbaV0pO1xuXG4gICAgICBpZiAoIXJlW2ldKSB7XG4gICAgICAgIHJlW2ldID0gbmV3IFJlZ0V4cChzcmNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydHMucGFyc2UgPSBwYXJzZTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlKHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucyB8fCBfdHlwZW9mKG9wdGlvbnMpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgIGxvb3NlOiAhIW9wdGlvbnMsXG4gICAgICAgICAgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgICAgIHJldHVybiB2ZXJzaW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LkxPT1NFXSA6IHJlW3QuRlVMTF07XG5cbiAgICAgIGlmICghci50ZXN0KHZlcnNpb24pKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKTtcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydHMudmFsaWQgPSB2YWxpZDtcblxuICAgIGZ1bmN0aW9uIHZhbGlkKHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgICAgIHZhciB2ID0gcGFyc2UodmVyc2lvbiwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdiA/IHYudmVyc2lvbiA6IG51bGw7XG4gICAgfVxuXG4gICAgZXhwb3J0cy5jbGVhbiA9IGNsZWFuO1xuXG4gICAgZnVuY3Rpb24gY2xlYW4odmVyc2lvbiwgb3B0aW9ucykge1xuICAgICAgdmFyIHMgPSBwYXJzZSh2ZXJzaW9uLnRyaW0oKS5yZXBsYWNlKC9eWz12XSsvLCAnJyksIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHMgPyBzLnZlcnNpb24gOiBudWxsO1xuICAgIH1cblxuICAgIGV4cG9ydHMuU2VtVmVyID0gU2VtVmVyO1xuXG4gICAgZnVuY3Rpb24gU2VtVmVyKHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucyB8fCBfdHlwZW9mKG9wdGlvbnMpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgIGxvb3NlOiAhIW9wdGlvbnMsXG4gICAgICAgICAgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgICAgIGlmICh2ZXJzaW9uLmxvb3NlID09PSBvcHRpb25zLmxvb3NlKSB7XG4gICAgICAgICAgcmV0dXJuIHZlcnNpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmVyc2lvbiA9IHZlcnNpb24udmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmVyc2lvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBWZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gICAgICB9XG5cbiAgICAgIGlmICh2ZXJzaW9uLmxlbmd0aCA+IE1BWF9MRU5HVEgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmVyc2lvbiBpcyBsb25nZXIgdGhhbiAnICsgTUFYX0xFTkdUSCArICcgY2hhcmFjdGVycycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgICByZXR1cm4gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgZGVidWcoJ1NlbVZlcicsIHZlcnNpb24sIG9wdGlvbnMpO1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2U7XG4gICAgICB2YXIgbSA9IHZlcnNpb24udHJpbSgpLm1hdGNoKG9wdGlvbnMubG9vc2UgPyByZVt0LkxPT1NFXSA6IHJlW3QuRlVMTF0pO1xuXG4gICAgICBpZiAoIW0pIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBWZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmF3ID0gdmVyc2lvbjsgLy8gdGhlc2UgYXJlIGFjdHVhbGx5IG51bWJlcnNcblxuICAgICAgdGhpcy5tYWpvciA9ICttWzFdO1xuICAgICAgdGhpcy5taW5vciA9ICttWzJdO1xuICAgICAgdGhpcy5wYXRjaCA9ICttWzNdO1xuXG4gICAgICBpZiAodGhpcy5tYWpvciA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5tYWpvciA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtYWpvciB2ZXJzaW9uJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm1pbm9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1pbm9yIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1pbm9yIHZlcnNpb24nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucGF0Y2ggPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMucGF0Y2ggPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcGF0Y2ggdmVyc2lvbicpO1xuICAgICAgfSAvLyBudW1iZXJpZnkgYW55IHByZXJlbGVhc2UgbnVtZXJpYyBpZHNcblxuXG4gICAgICBpZiAoIW1bNF0pIHtcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBtWzRdLnNwbGl0KCcuJykubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgIGlmICgvXlswLTldKyQvLnRlc3QoaWQpKSB7XG4gICAgICAgICAgICB2YXIgbnVtID0gK2lkO1xuXG4gICAgICAgICAgICBpZiAobnVtID49IDAgJiYgbnVtIDwgTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYnVpbGQgPSBtWzVdID8gbVs1XS5zcGxpdCgnLicpIDogW107XG4gICAgICB0aGlzLmZvcm1hdCgpO1xuICAgIH1cblxuICAgIFNlbVZlci5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy52ZXJzaW9uID0gdGhpcy5tYWpvciArICcuJyArIHRoaXMubWlub3IgKyAnLicgKyB0aGlzLnBhdGNoO1xuXG4gICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnZlcnNpb24gKz0gJy0nICsgdGhpcy5wcmVyZWxlYXNlLmpvaW4oJy4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMudmVyc2lvbjtcbiAgICB9O1xuXG4gICAgU2VtVmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZlcnNpb247XG4gICAgfTtcblxuICAgIFNlbVZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgZGVidWcoJ1NlbVZlci5jb21wYXJlJywgdGhpcy52ZXJzaW9uLCB0aGlzLm9wdGlvbnMsIG90aGVyKTtcblxuICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZU1haW4ob3RoZXIpIHx8IHRoaXMuY29tcGFyZVByZShvdGhlcik7XG4gICAgfTtcblxuICAgIFNlbVZlci5wcm90b3R5cGUuY29tcGFyZU1haW4gPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnModGhpcy5tYWpvciwgb3RoZXIubWFqb3IpIHx8IGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLm1pbm9yLCBvdGhlci5taW5vcikgfHwgY29tcGFyZUlkZW50aWZpZXJzKHRoaXMucGF0Y2gsIG90aGVyLnBhdGNoKTtcbiAgICB9O1xuXG4gICAgU2VtVmVyLnByb3RvdHlwZS5jb21wYXJlUHJlID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgfSAvLyBOT1QgaGF2aW5nIGEgcHJlcmVsZWFzZSBpcyA+IGhhdmluZyBvbmVcblxuXG4gICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiBvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLnByZXJlbGVhc2VbaV07XG4gICAgICAgIHZhciBiID0gb3RoZXIucHJlcmVsZWFzZVtpXTtcbiAgICAgICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpO1xuXG4gICAgICAgIGlmIChhID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2UgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgrK2kpO1xuICAgIH07XG5cbiAgICBTZW1WZXIucHJvdG90eXBlLmNvbXBhcmVCdWlsZCA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICBkbyB7XG4gICAgICAgIHZhciBhID0gdGhpcy5idWlsZFtpXTtcbiAgICAgICAgdmFyIGIgPSBvdGhlci5idWlsZFtpXTtcbiAgICAgICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpO1xuXG4gICAgICAgIGlmIChhID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2UgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgrK2kpO1xuICAgIH07IC8vIHByZW1pbm9yIHdpbGwgYnVtcCB0aGUgdmVyc2lvbiB1cCB0byB0aGUgbmV4dCBtaW5vciByZWxlYXNlLCBhbmQgaW1tZWRpYXRlbHlcbiAgICAvLyBkb3duIHRvIHByZS1yZWxlYXNlLiBwcmVtYWpvciBhbmQgcHJlcGF0Y2ggd29yayB0aGUgc2FtZSB3YXkuXG5cblxuICAgIFNlbVZlci5wcm90b3R5cGUuaW5jID0gZnVuY3Rpb24gKHJlbGVhc2UsIGlkZW50aWZpZXIpIHtcbiAgICAgIHN3aXRjaCAocmVsZWFzZSkge1xuICAgICAgICBjYXNlICdwcmVtYWpvcic6XG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDA7XG4gICAgICAgICAgdGhpcy5wYXRjaCA9IDA7XG4gICAgICAgICAgdGhpcy5taW5vciA9IDA7XG4gICAgICAgICAgdGhpcy5tYWpvcisrO1xuICAgICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdwcmVtaW5vcic6XG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDA7XG4gICAgICAgICAgdGhpcy5wYXRjaCA9IDA7XG4gICAgICAgICAgdGhpcy5taW5vcisrO1xuICAgICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdwcmVwYXRjaCc6XG4gICAgICAgICAgLy8gSWYgdGhpcyBpcyBhbHJlYWR5IGEgcHJlcmVsZWFzZSwgaXQgd2lsbCBidW1wIHRvIHRoZSBuZXh0IHZlcnNpb25cbiAgICAgICAgICAvLyBkcm9wIGFueSBwcmVyZWxlYXNlcyB0aGF0IG1pZ2h0IGFscmVhZHkgZXhpc3QsIHNpbmNlIHRoZXkgYXJlIG5vdFxuICAgICAgICAgIC8vIHJlbGV2YW50IGF0IHRoaXMgcG9pbnQuXG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDA7XG4gICAgICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllcik7XG4gICAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBJZiB0aGUgaW5wdXQgaXMgYSBub24tcHJlcmVsZWFzZSB2ZXJzaW9uLCB0aGlzIGFjdHMgdGhlIHNhbWUgYXNcbiAgICAgICAgLy8gcHJlcGF0Y2guXG5cbiAgICAgICAgY2FzZSAncHJlcmVsZWFzZSc6XG4gICAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuaW5jKCdwYXRjaCcsIGlkZW50aWZpZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdtYWpvcic6XG4gICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1tYWpvciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1ham9yIHZlcnNpb24uXG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCBtYWpvci5cbiAgICAgICAgICAvLyAxLjAuMC01IGJ1bXBzIHRvIDEuMC4wXG4gICAgICAgICAgLy8gMS4xLjAgYnVtcHMgdG8gMi4wLjBcbiAgICAgICAgICBpZiAodGhpcy5taW5vciAhPT0gMCB8fCB0aGlzLnBhdGNoICE9PSAwIHx8IHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMubWFqb3IrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm1pbm9yID0gMDtcbiAgICAgICAgICB0aGlzLnBhdGNoID0gMDtcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdtaW5vcic6XG4gICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1taW5vciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1pbm9yIHZlcnNpb24uXG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCBtaW5vci5cbiAgICAgICAgICAvLyAxLjIuMC01IGJ1bXBzIHRvIDEuMi4wXG4gICAgICAgICAgLy8gMS4yLjEgYnVtcHMgdG8gMS4zLjBcbiAgICAgICAgICBpZiAodGhpcy5wYXRjaCAhPT0gMCB8fCB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm1pbm9yKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5wYXRjaCA9IDA7XG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW107XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncGF0Y2gnOlxuICAgICAgICAgIC8vIElmIHRoaXMgaXMgbm90IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiwgaXQgd2lsbCBpbmNyZW1lbnQgdGhlIHBhdGNoLlxuICAgICAgICAgIC8vIElmIGl0IGlzIGEgcHJlLXJlbGVhc2UgaXQgd2lsbCBidW1wIHVwIHRvIHRoZSBzYW1lIHBhdGNoIHZlcnNpb24uXG4gICAgICAgICAgLy8gMS4yLjAtNSBwYXRjaGVzIHRvIDEuMi4wXG4gICAgICAgICAgLy8gMS4yLjAgcGF0Y2hlcyB0byAxLjIuMVxuICAgICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnBhdGNoKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW107XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFRoaXMgcHJvYmFibHkgc2hvdWxkbid0IGJlIHVzZWQgcHVibGljbHkuXG4gICAgICAgIC8vIDEuMC4wIFwicHJlXCIgd291bGQgYmVjb21lIDEuMC4wLTAgd2hpY2ggaXMgdGhlIHdyb25nIGRpcmVjdGlvbi5cblxuICAgICAgICBjYXNlICdwcmUnOlxuICAgICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbMF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5wcmVyZWxlYXNlLmxlbmd0aDtcblxuICAgICAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcmVyZWxlYXNlW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZVtpXSsrO1xuICAgICAgICAgICAgICAgIGkgPSAtMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgLy8gZGlkbid0IGluY3JlbWVudCBhbnl0aGluZ1xuICAgICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UucHVzaCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaWRlbnRpZmllcikge1xuICAgICAgICAgICAgLy8gMS4yLjAtYmV0YS4xIGJ1bXBzIHRvIDEuMi4wLWJldGEuMixcbiAgICAgICAgICAgIC8vIDEuMi4wLWJldGEuZm9vYmx6IG9yIDEuMi4wLWJldGEgYnVtcHMgdG8gMS4yLjAtYmV0YS4wXG4gICAgICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlWzBdID09PSBpZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgIGlmIChpc05hTih0aGlzLnByZXJlbGVhc2VbMV0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW2lkZW50aWZpZXIsIDBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbaWRlbnRpZmllciwgMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5jcmVtZW50IGFyZ3VtZW50OiAnICsgcmVsZWFzZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZm9ybWF0KCk7XG4gICAgICB0aGlzLnJhdyA9IHRoaXMudmVyc2lvbjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBleHBvcnRzLmluYyA9IGluYztcblxuICAgIGZ1bmN0aW9uIGluYyh2ZXJzaW9uLCByZWxlYXNlLCBsb29zZSwgaWRlbnRpZmllcikge1xuICAgICAgaWYgKHR5cGVvZiBsb29zZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWRlbnRpZmllciA9IGxvb3NlO1xuICAgICAgICBsb29zZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgbG9vc2UpLmluYyhyZWxlYXNlLCBpZGVudGlmaWVyKS52ZXJzaW9uO1xuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXhwb3J0cy5kaWZmID0gZGlmZjtcblxuICAgIGZ1bmN0aW9uIGRpZmYodmVyc2lvbjEsIHZlcnNpb24yKSB7XG4gICAgICBpZiAoZXEodmVyc2lvbjEsIHZlcnNpb24yKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2MSA9IHBhcnNlKHZlcnNpb24xKTtcbiAgICAgICAgdmFyIHYyID0gcGFyc2UodmVyc2lvbjIpO1xuICAgICAgICB2YXIgcHJlZml4ID0gJyc7XG5cbiAgICAgICAgaWYgKHYxLnByZXJlbGVhc2UubGVuZ3RoIHx8IHYyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICAgICAgcHJlZml4ID0gJ3ByZSc7XG4gICAgICAgICAgdmFyIGRlZmF1bHRSZXN1bHQgPSAncHJlcmVsZWFzZSc7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdjEpIHtcbiAgICAgICAgICBpZiAoa2V5ID09PSAnbWFqb3InIHx8IGtleSA9PT0gJ21pbm9yJyB8fCBrZXkgPT09ICdwYXRjaCcpIHtcbiAgICAgICAgICAgIGlmICh2MVtrZXldICE9PSB2MltrZXldKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRSZXN1bHQ7IC8vIG1heSBiZSB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICBleHBvcnRzLmNvbXBhcmVJZGVudGlmaWVycyA9IGNvbXBhcmVJZGVudGlmaWVycztcbiAgICB2YXIgbnVtZXJpYyA9IC9eWzAtOV0rJC87XG5cbiAgICBmdW5jdGlvbiBjb21wYXJlSWRlbnRpZmllcnMoYSwgYikge1xuICAgICAgdmFyIGFudW0gPSBudW1lcmljLnRlc3QoYSk7XG4gICAgICB2YXIgYm51bSA9IG51bWVyaWMudGVzdChiKTtcblxuICAgICAgaWYgKGFudW0gJiYgYm51bSkge1xuICAgICAgICBhID0gK2E7XG4gICAgICAgIGIgPSArYjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGEgPT09IGIgPyAwIDogYW51bSAmJiAhYm51bSA/IC0xIDogYm51bSAmJiAhYW51bSA/IDEgOiBhIDwgYiA/IC0xIDogMTtcbiAgICB9XG5cbiAgICBleHBvcnRzLnJjb21wYXJlSWRlbnRpZmllcnMgPSByY29tcGFyZUlkZW50aWZpZXJzO1xuXG4gICAgZnVuY3Rpb24gcmNvbXBhcmVJZGVudGlmaWVycyhhLCBiKSB7XG4gICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGIsIGEpO1xuICAgIH1cblxuICAgIGV4cG9ydHMubWFqb3IgPSBtYWpvcjtcblxuICAgIGZ1bmN0aW9uIG1ham9yKGEsIGxvb3NlKSB7XG4gICAgICByZXR1cm4gbmV3IFNlbVZlcihhLCBsb29zZSkubWFqb3I7XG4gICAgfVxuXG4gICAgZXhwb3J0cy5taW5vciA9IG1pbm9yO1xuXG4gICAgZnVuY3Rpb24gbWlub3IoYSwgbG9vc2UpIHtcbiAgICAgIHJldHVybiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5taW5vcjtcbiAgICB9XG5cbiAgICBleHBvcnRzLnBhdGNoID0gcGF0Y2g7XG5cbiAgICBmdW5jdGlvbiBwYXRjaChhLCBsb29zZSkge1xuICAgICAgcmV0dXJuIG5ldyBTZW1WZXIoYSwgbG9vc2UpLnBhdGNoO1xuICAgIH1cblxuICAgIGV4cG9ydHMuY29tcGFyZSA9IGNvbXBhcmU7XG5cbiAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIsIGxvb3NlKSB7XG4gICAgICByZXR1cm4gbmV3IFNlbVZlcihhLCBsb29zZSkuY29tcGFyZShuZXcgU2VtVmVyKGIsIGxvb3NlKSk7XG4gICAgfVxuXG4gICAgZXhwb3J0cy5jb21wYXJlTG9vc2UgPSBjb21wYXJlTG9vc2U7XG5cbiAgICBmdW5jdGlvbiBjb21wYXJlTG9vc2UoYSwgYikge1xuICAgICAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZXhwb3J0cy5jb21wYXJlQnVpbGQgPSBjb21wYXJlQnVpbGQ7XG5cbiAgICBmdW5jdGlvbiBjb21wYXJlQnVpbGQoYSwgYiwgbG9vc2UpIHtcbiAgICAgIHZhciB2ZXJzaW9uQSA9IG5ldyBTZW1WZXIoYSwgbG9vc2UpO1xuICAgICAgdmFyIHZlcnNpb25CID0gbmV3IFNlbVZlcihiLCBsb29zZSk7XG4gICAgICByZXR1cm4gdmVyc2lvbkEuY29tcGFyZSh2ZXJzaW9uQikgfHwgdmVyc2lvbkEuY29tcGFyZUJ1aWxkKHZlcnNpb25CKTtcbiAgICB9XG5cbiAgICBleHBvcnRzLnJjb21wYXJlID0gcmNvbXBhcmU7XG5cbiAgICBmdW5jdGlvbiByY29tcGFyZShhLCBiLCBsb29zZSkge1xuICAgICAgcmV0dXJuIGNvbXBhcmUoYiwgYSwgbG9vc2UpO1xuICAgIH1cblxuICAgIGV4cG9ydHMuc29ydCA9IHNvcnQ7XG5cbiAgICBmdW5jdGlvbiBzb3J0KGxpc3QsIGxvb3NlKSB7XG4gICAgICByZXR1cm4gbGlzdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmNvbXBhcmVCdWlsZChhLCBiLCBsb29zZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBleHBvcnRzLnJzb3J0ID0gcnNvcnQ7XG5cbiAgICBmdW5jdGlvbiByc29ydChsaXN0LCBsb29zZSkge1xuICAgICAgcmV0dXJuIGxpc3Quc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5jb21wYXJlQnVpbGQoYiwgYSwgbG9vc2UpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZXhwb3J0cy5ndCA9IGd0O1xuXG4gICAgZnVuY3Rpb24gZ3QoYSwgYiwgbG9vc2UpIHtcbiAgICAgIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA+IDA7XG4gICAgfVxuXG4gICAgZXhwb3J0cy5sdCA9IGx0O1xuXG4gICAgZnVuY3Rpb24gbHQoYSwgYiwgbG9vc2UpIHtcbiAgICAgIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8IDA7XG4gICAgfVxuXG4gICAgZXhwb3J0cy5lcSA9IGVxO1xuXG4gICAgZnVuY3Rpb24gZXEoYSwgYiwgbG9vc2UpIHtcbiAgICAgIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA9PT0gMDtcbiAgICB9XG5cbiAgICBleHBvcnRzLm5lcSA9IG5lcTtcblxuICAgIGZ1bmN0aW9uIG5lcShhLCBiLCBsb29zZSkge1xuICAgICAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpICE9PSAwO1xuICAgIH1cblxuICAgIGV4cG9ydHMuZ3RlID0gZ3RlO1xuXG4gICAgZnVuY3Rpb24gZ3RlKGEsIGIsIGxvb3NlKSB7XG4gICAgICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPj0gMDtcbiAgICB9XG5cbiAgICBleHBvcnRzLmx0ZSA9IGx0ZTtcblxuICAgIGZ1bmN0aW9uIGx0ZShhLCBiLCBsb29zZSkge1xuICAgICAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpIDw9IDA7XG4gICAgfVxuXG4gICAgZXhwb3J0cy5jbXAgPSBjbXA7XG5cbiAgICBmdW5jdGlvbiBjbXAoYSwgb3AsIGIsIGxvb3NlKSB7XG4gICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgIGNhc2UgJz09PSc6XG4gICAgICAgICAgaWYgKF90eXBlb2YoYSkgPT09ICdvYmplY3QnKSBhID0gYS52ZXJzaW9uO1xuICAgICAgICAgIGlmIChfdHlwZW9mKGIpID09PSAnb2JqZWN0JykgYiA9IGIudmVyc2lvbjtcbiAgICAgICAgICByZXR1cm4gYSA9PT0gYjtcblxuICAgICAgICBjYXNlICchPT0nOlxuICAgICAgICAgIGlmIChfdHlwZW9mKGEpID09PSAnb2JqZWN0JykgYSA9IGEudmVyc2lvbjtcbiAgICAgICAgICBpZiAoX3R5cGVvZihiKSA9PT0gJ29iamVjdCcpIGIgPSBiLnZlcnNpb247XG4gICAgICAgICAgcmV0dXJuIGEgIT09IGI7XG5cbiAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgY2FzZSAnPSc6XG4gICAgICAgIGNhc2UgJz09JzpcbiAgICAgICAgICByZXR1cm4gZXEoYSwgYiwgbG9vc2UpO1xuXG4gICAgICAgIGNhc2UgJyE9JzpcbiAgICAgICAgICByZXR1cm4gbmVxKGEsIGIsIGxvb3NlKTtcblxuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICByZXR1cm4gZ3QoYSwgYiwgbG9vc2UpO1xuXG4gICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICByZXR1cm4gZ3RlKGEsIGIsIGxvb3NlKTtcblxuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICByZXR1cm4gbHQoYSwgYiwgbG9vc2UpO1xuXG4gICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICByZXR1cm4gbHRlKGEsIGIsIGxvb3NlKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgb3BlcmF0b3I6ICcgKyBvcCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXhwb3J0cy5Db21wYXJhdG9yID0gQ29tcGFyYXRvcjtcblxuICAgIGZ1bmN0aW9uIENvbXBhcmF0b3IoY29tcCwgb3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zIHx8IF90eXBlb2Yob3B0aW9ucykgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgbG9vc2U6ICEhb3B0aW9ucyxcbiAgICAgICAgICBpbmNsdWRlUHJlcmVsZWFzZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXAgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSB7XG4gICAgICAgIGlmIChjb21wLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UpIHtcbiAgICAgICAgICByZXR1cm4gY29tcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21wID0gY29tcC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29tcGFyYXRvcikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wYXJhdG9yKGNvbXAsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBkZWJ1ZygnY29tcGFyYXRvcicsIGNvbXAsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2U7XG4gICAgICB0aGlzLnBhcnNlKGNvbXApO1xuXG4gICAgICBpZiAodGhpcy5zZW12ZXIgPT09IEFOWSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5vcGVyYXRvciArIHRoaXMuc2VtdmVyLnZlcnNpb247XG4gICAgICB9XG5cbiAgICAgIGRlYnVnKCdjb21wJywgdGhpcyk7XG4gICAgfVxuXG4gICAgdmFyIEFOWSA9IHt9O1xuXG4gICAgQ29tcGFyYXRvci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoY29tcCkge1xuICAgICAgdmFyIHIgPSB0aGlzLm9wdGlvbnMubG9vc2UgPyByZVt0LkNPTVBBUkFUT1JMT09TRV0gOiByZVt0LkNPTVBBUkFUT1JdO1xuICAgICAgdmFyIG0gPSBjb21wLm1hdGNoKHIpO1xuXG4gICAgICBpZiAoIW0pIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjb21wYXJhdG9yOiAnICsgY29tcCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMub3BlcmF0b3IgPSBtWzFdICE9PSB1bmRlZmluZWQgPyBtWzFdIDogJyc7XG5cbiAgICAgIGlmICh0aGlzLm9wZXJhdG9yID09PSAnPScpIHtcbiAgICAgICAgdGhpcy5vcGVyYXRvciA9ICcnO1xuICAgICAgfSAvLyBpZiBpdCBsaXRlcmFsbHkgaXMganVzdCAnPicgb3IgJycgdGhlbiBhbGxvdyBhbnl0aGluZy5cblxuXG4gICAgICBpZiAoIW1bMl0pIHtcbiAgICAgICAgdGhpcy5zZW12ZXIgPSBBTlk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlbXZlciA9IG5ldyBTZW1WZXIobVsyXSwgdGhpcy5vcHRpb25zLmxvb3NlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ29tcGFyYXRvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9O1xuXG4gICAgQ29tcGFyYXRvci5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uICh2ZXJzaW9uKSB7XG4gICAgICBkZWJ1ZygnQ29tcGFyYXRvci50ZXN0JywgdmVyc2lvbiwgdGhpcy5vcHRpb25zLmxvb3NlKTtcblxuICAgICAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkgfHwgdmVyc2lvbiA9PT0gQU5ZKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNtcCh2ZXJzaW9uLCB0aGlzLm9wZXJhdG9yLCB0aGlzLnNlbXZlciwgdGhpcy5vcHRpb25zKTtcbiAgICB9O1xuXG4gICAgQ29tcGFyYXRvci5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uIChjb21wLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIShjb21wIGluc3RhbmNlb2YgQ29tcGFyYXRvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYSBDb21wYXJhdG9yIGlzIHJlcXVpcmVkJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghb3B0aW9ucyB8fCBfdHlwZW9mKG9wdGlvbnMpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgIGxvb3NlOiAhIW9wdGlvbnMsXG4gICAgICAgICAgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciByYW5nZVRtcDtcblxuICAgICAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICcnKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSAnJykge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmFuZ2VUbXAgPSBuZXcgUmFuZ2UoY29tcC52YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBzYXRpc2ZpZXModGhpcy52YWx1ZSwgcmFuZ2VUbXAsIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmIChjb21wLm9wZXJhdG9yID09PSAnJykge1xuICAgICAgICBpZiAoY29tcC52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJhbmdlVG1wID0gbmV3IFJhbmdlKHRoaXMudmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gc2F0aXNmaWVzKGNvbXAuc2VtdmVyLCByYW5nZVRtcCwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzYW1lRGlyZWN0aW9uSW5jcmVhc2luZyA9ICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc+JykgJiYgKGNvbXAub3BlcmF0b3IgPT09ICc+PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJz4nKTtcbiAgICAgIHZhciBzYW1lRGlyZWN0aW9uRGVjcmVhc2luZyA9ICh0aGlzLm9wZXJhdG9yID09PSAnPD0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8JykgJiYgKGNvbXAub3BlcmF0b3IgPT09ICc8PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzwnKTtcbiAgICAgIHZhciBzYW1lU2VtVmVyID0gdGhpcy5zZW12ZXIudmVyc2lvbiA9PT0gY29tcC5zZW12ZXIudmVyc2lvbjtcbiAgICAgIHZhciBkaWZmZXJlbnREaXJlY3Rpb25zSW5jbHVzaXZlID0gKHRoaXMub3BlcmF0b3IgPT09ICc+PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJzw9JykgJiYgKGNvbXAub3BlcmF0b3IgPT09ICc+PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzw9Jyk7XG4gICAgICB2YXIgb3Bwb3NpdGVEaXJlY3Rpb25zTGVzc1RoYW4gPSBjbXAodGhpcy5zZW12ZXIsICc8JywgY29tcC5zZW12ZXIsIG9wdGlvbnMpICYmICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc+JykgJiYgKGNvbXAub3BlcmF0b3IgPT09ICc8PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzwnKTtcbiAgICAgIHZhciBvcHBvc2l0ZURpcmVjdGlvbnNHcmVhdGVyVGhhbiA9IGNtcCh0aGlzLnNlbXZlciwgJz4nLCBjb21wLnNlbXZlciwgb3B0aW9ucykgJiYgKHRoaXMub3BlcmF0b3IgPT09ICc8PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJzwnKSAmJiAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPicpO1xuICAgICAgcmV0dXJuIHNhbWVEaXJlY3Rpb25JbmNyZWFzaW5nIHx8IHNhbWVEaXJlY3Rpb25EZWNyZWFzaW5nIHx8IHNhbWVTZW1WZXIgJiYgZGlmZmVyZW50RGlyZWN0aW9uc0luY2x1c2l2ZSB8fCBvcHBvc2l0ZURpcmVjdGlvbnNMZXNzVGhhbiB8fCBvcHBvc2l0ZURpcmVjdGlvbnNHcmVhdGVyVGhhbjtcbiAgICB9O1xuXG4gICAgZXhwb3J0cy5SYW5nZSA9IFJhbmdlO1xuXG4gICAgZnVuY3Rpb24gUmFuZ2UocmFuZ2UsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucyB8fCBfdHlwZW9mKG9wdGlvbnMpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgIGxvb3NlOiAhIW9wdGlvbnMsXG4gICAgICAgICAgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSB7XG4gICAgICAgIGlmIChyYW5nZS5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlICYmIHJhbmdlLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZS5yYXcsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyYW5nZSBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZS52YWx1ZSwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSYW5nZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlO1xuICAgICAgdGhpcy5pbmNsdWRlUHJlcmVsZWFzZSA9ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZTsgLy8gRmlyc3QsIHNwbGl0IGJhc2VkIG9uIGJvb2xlYW4gb3IgfHxcblxuICAgICAgdGhpcy5yYXcgPSByYW5nZTtcbiAgICAgIHRoaXMuc2V0ID0gcmFuZ2Uuc3BsaXQoL1xccypcXHxcXHxcXHMqLykubWFwKGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVJhbmdlKHJhbmdlLnRyaW0oKSk7XG4gICAgICB9LCB0aGlzKS5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgLy8gdGhyb3cgb3V0IGFueSB0aGF0IGFyZSBub3QgcmVsZXZhbnQgZm9yIHdoYXRldmVyIHJlYXNvblxuICAgICAgICByZXR1cm4gYy5sZW5ndGg7XG4gICAgICB9KTtcblxuICAgICAgaWYgKCF0aGlzLnNldC5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBTZW1WZXIgUmFuZ2U6ICcgKyByYW5nZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZm9ybWF0KCk7XG4gICAgfVxuXG4gICAgUmFuZ2UucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnNldC5tYXAoZnVuY3Rpb24gKGNvbXBzKSB7XG4gICAgICAgIHJldHVybiBjb21wcy5qb2luKCcgJykudHJpbSgpO1xuICAgICAgfSkuam9pbignfHwnKS50cmltKCk7XG4gICAgICByZXR1cm4gdGhpcy5yYW5nZTtcbiAgICB9O1xuXG4gICAgUmFuZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmFuZ2U7XG4gICAgfTtcblxuICAgIFJhbmdlLnByb3RvdHlwZS5wYXJzZVJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICB2YXIgbG9vc2UgPSB0aGlzLm9wdGlvbnMubG9vc2U7XG4gICAgICByYW5nZSA9IHJhbmdlLnRyaW0oKTsgLy8gYDEuMi4zIC0gMS4yLjRgID0+IGA+PTEuMi4zIDw9MS4yLjRgXG5cbiAgICAgIHZhciBociA9IGxvb3NlID8gcmVbdC5IWVBIRU5SQU5HRUxPT1NFXSA6IHJlW3QuSFlQSEVOUkFOR0VdO1xuICAgICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKGhyLCBoeXBoZW5SZXBsYWNlKTtcbiAgICAgIGRlYnVnKCdoeXBoZW4gcmVwbGFjZScsIHJhbmdlKTsgLy8gYD4gMS4yLjMgPCAxLjIuNWAgPT4gYD4xLjIuMyA8MS4yLjVgXG5cbiAgICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVt0LkNPTVBBUkFUT1JUUklNXSwgY29tcGFyYXRvclRyaW1SZXBsYWNlKTtcbiAgICAgIGRlYnVnKCdjb21wYXJhdG9yIHRyaW0nLCByYW5nZSwgcmVbdC5DT01QQVJBVE9SVFJJTV0pOyAvLyBgfiAxLjIuM2AgPT4gYH4xLjIuM2BcblxuICAgICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuVElMREVUUklNXSwgdGlsZGVUcmltUmVwbGFjZSk7IC8vIGBeIDEuMi4zYCA9PiBgXjEuMi4zYFxuXG4gICAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbdC5DQVJFVFRSSU1dLCBjYXJldFRyaW1SZXBsYWNlKTsgLy8gbm9ybWFsaXplIHNwYWNlc1xuXG4gICAgICByYW5nZSA9IHJhbmdlLnNwbGl0KC9cXHMrLykuam9pbignICcpOyAvLyBBdCB0aGlzIHBvaW50LCB0aGUgcmFuZ2UgaXMgY29tcGxldGVseSB0cmltbWVkIGFuZFxuICAgICAgLy8gcmVhZHkgdG8gYmUgc3BsaXQgaW50byBjb21wYXJhdG9ycy5cblxuICAgICAgdmFyIGNvbXBSZSA9IGxvb3NlID8gcmVbdC5DT01QQVJBVE9STE9PU0VdIDogcmVbdC5DT01QQVJBVE9SXTtcbiAgICAgIHZhciBzZXQgPSByYW5nZS5zcGxpdCgnICcpLm1hcChmdW5jdGlvbiAoY29tcCkge1xuICAgICAgICByZXR1cm4gcGFyc2VDb21wYXJhdG9yKGNvbXAsIHRoaXMub3B0aW9ucyk7XG4gICAgICB9LCB0aGlzKS5qb2luKCcgJykuc3BsaXQoL1xccysvKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb29zZSkge1xuICAgICAgICAvLyBpbiBsb29zZSBtb2RlLCB0aHJvdyBvdXQgYW55IHRoYXQgYXJlIG5vdCB2YWxpZCBjb21wYXJhdG9yc1xuICAgICAgICBzZXQgPSBzZXQuZmlsdGVyKGZ1bmN0aW9uIChjb21wKSB7XG4gICAgICAgICAgcmV0dXJuICEhY29tcC5tYXRjaChjb21wUmUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgc2V0ID0gc2V0Lm1hcChmdW5jdGlvbiAoY29tcCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBhcmF0b3IoY29tcCwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgcmV0dXJuIHNldDtcbiAgICB9O1xuXG4gICAgUmFuZ2UucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbiAocmFuZ2UsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgUmFuZ2UgaXMgcmVxdWlyZWQnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc2V0LnNvbWUoZnVuY3Rpb24gKHRoaXNDb21wYXJhdG9ycykge1xuICAgICAgICByZXR1cm4gaXNTYXRpc2ZpYWJsZSh0aGlzQ29tcGFyYXRvcnMsIG9wdGlvbnMpICYmIHJhbmdlLnNldC5zb21lKGZ1bmN0aW9uIChyYW5nZUNvbXBhcmF0b3JzKSB7XG4gICAgICAgICAgcmV0dXJuIGlzU2F0aXNmaWFibGUocmFuZ2VDb21wYXJhdG9ycywgb3B0aW9ucykgJiYgdGhpc0NvbXBhcmF0b3JzLmV2ZXJ5KGZ1bmN0aW9uICh0aGlzQ29tcGFyYXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIHJhbmdlQ29tcGFyYXRvcnMuZXZlcnkoZnVuY3Rpb24gKHJhbmdlQ29tcGFyYXRvcikge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpc0NvbXBhcmF0b3IuaW50ZXJzZWN0cyhyYW5nZUNvbXBhcmF0b3IsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTsgLy8gdGFrZSBhIHNldCBvZiBjb21wYXJhdG9ycyBhbmQgZGV0ZXJtaW5lIHdoZXRoZXIgdGhlcmVcbiAgICAvLyBleGlzdHMgYSB2ZXJzaW9uIHdoaWNoIGNhbiBzYXRpc2Z5IGl0XG5cblxuICAgIGZ1bmN0aW9uIGlzU2F0aXNmaWFibGUoY29tcGFyYXRvcnMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgdmFyIHJlbWFpbmluZ0NvbXBhcmF0b3JzID0gY29tcGFyYXRvcnMuc2xpY2UoKTtcbiAgICAgIHZhciB0ZXN0Q29tcGFyYXRvciA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLnBvcCgpO1xuXG4gICAgICB3aGlsZSAocmVzdWx0ICYmIHJlbWFpbmluZ0NvbXBhcmF0b3JzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQgPSByZW1haW5pbmdDb21wYXJhdG9ycy5ldmVyeShmdW5jdGlvbiAob3RoZXJDb21wYXJhdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIHRlc3RDb21wYXJhdG9yLmludGVyc2VjdHMob3RoZXJDb21wYXJhdG9yLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRlc3RDb21wYXJhdG9yID0gcmVtYWluaW5nQ29tcGFyYXRvcnMucG9wKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSAvLyBNb3N0bHkganVzdCBmb3IgdGVzdGluZyBhbmQgbGVnYWN5IEFQSSByZWFzb25zXG5cblxuICAgIGV4cG9ydHMudG9Db21wYXJhdG9ycyA9IHRvQ29tcGFyYXRvcnM7XG5cbiAgICBmdW5jdGlvbiB0b0NvbXBhcmF0b3JzKHJhbmdlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKS5zZXQubWFwKGZ1bmN0aW9uIChjb21wKSB7XG4gICAgICAgIHJldHVybiBjb21wLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIHJldHVybiBjLnZhbHVlO1xuICAgICAgICB9KS5qb2luKCcgJykudHJpbSgpLnNwbGl0KCcgJyk7XG4gICAgICB9KTtcbiAgICB9IC8vIGNvbXByaXNlZCBvZiB4cmFuZ2VzLCB0aWxkZXMsIHN0YXJzLCBhbmQgZ3RsdCdzIGF0IHRoaXMgcG9pbnQuXG4gICAgLy8gYWxyZWFkeSByZXBsYWNlZCB0aGUgaHlwaGVuIHJhbmdlc1xuICAgIC8vIHR1cm4gaW50byBhIHNldCBvZiBKVVNUIGNvbXBhcmF0b3JzLlxuXG5cbiAgICBmdW5jdGlvbiBwYXJzZUNvbXBhcmF0b3IoY29tcCwgb3B0aW9ucykge1xuICAgICAgZGVidWcoJ2NvbXAnLCBjb21wLCBvcHRpb25zKTtcbiAgICAgIGNvbXAgPSByZXBsYWNlQ2FyZXRzKGNvbXAsIG9wdGlvbnMpO1xuICAgICAgZGVidWcoJ2NhcmV0JywgY29tcCk7XG4gICAgICBjb21wID0gcmVwbGFjZVRpbGRlcyhjb21wLCBvcHRpb25zKTtcbiAgICAgIGRlYnVnKCd0aWxkZXMnLCBjb21wKTtcbiAgICAgIGNvbXAgPSByZXBsYWNlWFJhbmdlcyhjb21wLCBvcHRpb25zKTtcbiAgICAgIGRlYnVnKCd4cmFuZ2UnLCBjb21wKTtcbiAgICAgIGNvbXAgPSByZXBsYWNlU3RhcnMoY29tcCwgb3B0aW9ucyk7XG4gICAgICBkZWJ1Zygnc3RhcnMnLCBjb21wKTtcbiAgICAgIHJldHVybiBjb21wO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzWChpZCkge1xuICAgICAgcmV0dXJuICFpZCB8fCBpZC50b0xvd2VyQ2FzZSgpID09PSAneCcgfHwgaWQgPT09ICcqJztcbiAgICB9IC8vIH4sIH4+IC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuICAgIC8vIH4yLCB+Mi54LCB+Mi54LngsIH4+Miwgfj4yLnggfj4yLngueCAtLT4gPj0yLjAuMCA8My4wLjBcbiAgICAvLyB+Mi4wLCB+Mi4wLngsIH4+Mi4wLCB+PjIuMC54IC0tPiA+PTIuMC4wIDwyLjEuMFxuICAgIC8vIH4xLjIsIH4xLjIueCwgfj4xLjIsIH4+MS4yLnggLS0+ID49MS4yLjAgPDEuMy4wXG4gICAgLy8gfjEuMi4zLCB+PjEuMi4zIC0tPiA+PTEuMi4zIDwxLjMuMFxuICAgIC8vIH4xLjIuMCwgfj4xLjIuMCAtLT4gPj0xLjIuMCA8MS4zLjBcblxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZVRpbGRlcyhjb21wLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gY29tcC50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoZnVuY3Rpb24gKGNvbXApIHtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VUaWxkZShjb21wLCBvcHRpb25zKTtcbiAgICAgIH0pLmpvaW4oJyAnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlVGlsZGUoY29tcCwgb3B0aW9ucykge1xuICAgICAgdmFyIHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5USUxERUxPT1NFXSA6IHJlW3QuVElMREVdO1xuICAgICAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCBmdW5jdGlvbiAoXywgTSwgbSwgcCwgcHIpIHtcbiAgICAgICAgZGVidWcoJ3RpbGRlJywgY29tcCwgXywgTSwgbSwgcCwgcHIpO1xuICAgICAgICB2YXIgcmV0O1xuXG4gICAgICAgIGlmIChpc1goTSkpIHtcbiAgICAgICAgICByZXQgPSAnJztcbiAgICAgICAgfSBlbHNlIGlmIChpc1gobSkpIHtcbiAgICAgICAgICByZXQgPSAnPj0nICsgTSArICcuMC4wIDwnICsgKCtNICsgMSkgKyAnLjAuMCc7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNYKHApKSB7XG4gICAgICAgICAgLy8gfjEuMiA9PSA+PTEuMi4wIDwxLjMuMFxuICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuMCA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7XG4gICAgICAgIH0gZWxzZSBpZiAocHIpIHtcbiAgICAgICAgICBkZWJ1ZygncmVwbGFjZVRpbGRlIHByJywgcHIpO1xuICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyAnLScgKyBwciArICcgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIH4xLjIuMyA9PSA+PTEuMi4zIDwxLjMuMFxuICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyAnIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcbiAgICAgICAgfVxuXG4gICAgICAgIGRlYnVnKCd0aWxkZSByZXR1cm4nLCByZXQpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfSk7XG4gICAgfSAvLyBeIC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuICAgIC8vIF4yLCBeMi54LCBeMi54LnggLS0+ID49Mi4wLjAgPDMuMC4wXG4gICAgLy8gXjIuMCwgXjIuMC54IC0tPiA+PTIuMC4wIDwzLjAuMFxuICAgIC8vIF4xLjIsIF4xLjIueCAtLT4gPj0xLjIuMCA8Mi4wLjBcbiAgICAvLyBeMS4yLjMgLS0+ID49MS4yLjMgPDIuMC4wXG4gICAgLy8gXjEuMi4wIC0tPiA+PTEuMi4wIDwyLjAuMFxuXG5cbiAgICBmdW5jdGlvbiByZXBsYWNlQ2FyZXRzKGNvbXAsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcChmdW5jdGlvbiAoY29tcCkge1xuICAgICAgICByZXR1cm4gcmVwbGFjZUNhcmV0KGNvbXAsIG9wdGlvbnMpO1xuICAgICAgfSkuam9pbignICcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VDYXJldChjb21wLCBvcHRpb25zKSB7XG4gICAgICBkZWJ1ZygnY2FyZXQnLCBjb21wLCBvcHRpb25zKTtcbiAgICAgIHZhciByID0gb3B0aW9ucy5sb29zZSA/IHJlW3QuQ0FSRVRMT09TRV0gOiByZVt0LkNBUkVUXTtcbiAgICAgIHJldHVybiBjb21wLnJlcGxhY2UociwgZnVuY3Rpb24gKF8sIE0sIG0sIHAsIHByKSB7XG4gICAgICAgIGRlYnVnKCdjYXJldCcsIGNvbXAsIF8sIE0sIG0sIHAsIHByKTtcbiAgICAgICAgdmFyIHJldDtcblxuICAgICAgICBpZiAoaXNYKE0pKSB7XG4gICAgICAgICAgcmV0ID0gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNYKG0pKSB7XG4gICAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLjAuMCA8JyArICgrTSArIDEpICsgJy4wLjAnO1xuICAgICAgICB9IGVsc2UgaWYgKGlzWChwKSkge1xuICAgICAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuMCA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuMCA8JyArICgrTSArIDEpICsgJy4wLjAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwcikge1xuICAgICAgICAgIGRlYnVnKCdyZXBsYWNlQ2FyZXQgcHInLCBwcik7XG5cbiAgICAgICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgICAgICBpZiAobSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyAnLScgKyBwciArICcgPCcgKyBNICsgJy4nICsgbSArICcuJyArICgrcCArIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArICctJyArIHByICsgJyA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyAnLScgKyBwciArICcgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVidWcoJ25vIHByJyk7XG5cbiAgICAgICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgICAgICBpZiAobSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyAnIDwnICsgTSArICcuJyArIG0gKyAnLicgKyAoK3AgKyAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyAnIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArICcgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkZWJ1ZygnY2FyZXQgcmV0dXJuJywgcmV0KTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VYUmFuZ2VzKGNvbXAsIG9wdGlvbnMpIHtcbiAgICAgIGRlYnVnKCdyZXBsYWNlWFJhbmdlcycsIGNvbXAsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGNvbXAuc3BsaXQoL1xccysvKS5tYXAoZnVuY3Rpb24gKGNvbXApIHtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VYUmFuZ2UoY29tcCwgb3B0aW9ucyk7XG4gICAgICB9KS5qb2luKCcgJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZVhSYW5nZShjb21wLCBvcHRpb25zKSB7XG4gICAgICBjb21wID0gY29tcC50cmltKCk7XG4gICAgICB2YXIgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LlhSQU5HRUxPT1NFXSA6IHJlW3QuWFJBTkdFXTtcbiAgICAgIHJldHVybiBjb21wLnJlcGxhY2UociwgZnVuY3Rpb24gKHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpIHtcbiAgICAgICAgZGVidWcoJ3hSYW5nZScsIGNvbXAsIHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpO1xuICAgICAgICB2YXIgeE0gPSBpc1goTSk7XG4gICAgICAgIHZhciB4bSA9IHhNIHx8IGlzWChtKTtcbiAgICAgICAgdmFyIHhwID0geG0gfHwgaXNYKHApO1xuICAgICAgICB2YXIgYW55WCA9IHhwO1xuXG4gICAgICAgIGlmIChndGx0ID09PSAnPScgJiYgYW55WCkge1xuICAgICAgICAgIGd0bHQgPSAnJztcbiAgICAgICAgfSAvLyBpZiB3ZSdyZSBpbmNsdWRpbmcgcHJlcmVsZWFzZXMgaW4gdGhlIG1hdGNoLCB0aGVuIHdlIG5lZWRcbiAgICAgICAgLy8gdG8gZml4IHRoaXMgdG8gLTAsIHRoZSBsb3dlc3QgcG9zc2libGUgcHJlcmVsZWFzZSB2YWx1ZVxuXG5cbiAgICAgICAgcHIgPSBvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlID8gJy0wJyA6ICcnO1xuXG4gICAgICAgIGlmICh4TSkge1xuICAgICAgICAgIGlmIChndGx0ID09PSAnPicgfHwgZ3RsdCA9PT0gJzwnKSB7XG4gICAgICAgICAgICAvLyBub3RoaW5nIGlzIGFsbG93ZWRcbiAgICAgICAgICAgIHJldCA9ICc8MC4wLjAtMCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgaXMgZm9yYmlkZGVuXG4gICAgICAgICAgICByZXQgPSAnKic7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGd0bHQgJiYgYW55WCkge1xuICAgICAgICAgIC8vIHdlIGtub3cgcGF0Y2ggaXMgYW4geCwgYmVjYXVzZSB3ZSBoYXZlIGFueSB4IGF0IGFsbC5cbiAgICAgICAgICAvLyByZXBsYWNlIFggd2l0aCAwXG4gICAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgICBtID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwID0gMDtcblxuICAgICAgICAgIGlmIChndGx0ID09PSAnPicpIHtcbiAgICAgICAgICAgIC8vID4xID0+ID49Mi4wLjBcbiAgICAgICAgICAgIC8vID4xLjIgPT4gPj0xLjMuMFxuICAgICAgICAgICAgLy8gPjEuMi4zID0+ID49IDEuMi40XG4gICAgICAgICAgICBndGx0ID0gJz49JztcblxuICAgICAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgICAgIE0gPSArTSArIDE7XG4gICAgICAgICAgICAgIG0gPSAwO1xuICAgICAgICAgICAgICBwID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG0gPSArbSArIDE7XG4gICAgICAgICAgICAgIHAgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoZ3RsdCA9PT0gJzw9Jykge1xuICAgICAgICAgICAgLy8gPD0wLjcueCBpcyBhY3R1YWxseSA8MC44LjAsIHNpbmNlIGFueSAwLjcueCBzaG91bGRcbiAgICAgICAgICAgIC8vIHBhc3MuICBTaW1pbGFybHksIDw9Ny54IGlzIGFjdHVhbGx5IDw4LjAuMCwgZXRjLlxuICAgICAgICAgICAgZ3RsdCA9ICc8JztcblxuICAgICAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgICAgIE0gPSArTSArIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtID0gK20gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldCA9IGd0bHQgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyBwcjtcbiAgICAgICAgfSBlbHNlIGlmICh4bSkge1xuICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4wLjAnICsgcHIgKyAnIDwnICsgKCtNICsgMSkgKyAnLjAuMCcgKyBwcjtcbiAgICAgICAgfSBlbHNlIGlmICh4cCkge1xuICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuMCcgKyBwciArICcgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnICsgcHI7XG4gICAgICAgIH1cblxuICAgICAgICBkZWJ1ZygneFJhbmdlIHJldHVybicsIHJldCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9KTtcbiAgICB9IC8vIEJlY2F1c2UgKiBpcyBBTkQtZWQgd2l0aCBldmVyeXRoaW5nIGVsc2UgaW4gdGhlIGNvbXBhcmF0b3IsXG4gICAgLy8gYW5kICcnIG1lYW5zIFwiYW55IHZlcnNpb25cIiwganVzdCByZW1vdmUgdGhlICpzIGVudGlyZWx5LlxuXG5cbiAgICBmdW5jdGlvbiByZXBsYWNlU3RhcnMoY29tcCwgb3B0aW9ucykge1xuICAgICAgZGVidWcoJ3JlcGxhY2VTdGFycycsIGNvbXAsIG9wdGlvbnMpOyAvLyBMb29zZW5lc3MgaXMgaWdub3JlZCBoZXJlLiAgc3RhciBpcyBhbHdheXMgYXMgbG9vc2UgYXMgaXQgZ2V0cyFcblxuICAgICAgcmV0dXJuIGNvbXAudHJpbSgpLnJlcGxhY2UocmVbdC5TVEFSXSwgJycpO1xuICAgIH0gLy8gVGhpcyBmdW5jdGlvbiBpcyBwYXNzZWQgdG8gc3RyaW5nLnJlcGxhY2UocmVbdC5IWVBIRU5SQU5HRV0pXG4gICAgLy8gTSwgbSwgcGF0Y2gsIHByZXJlbGVhc2UsIGJ1aWxkXG4gICAgLy8gMS4yIC0gMy40LjUgPT4gPj0xLjIuMCA8PTMuNC41XG4gICAgLy8gMS4yLjMgLSAzLjQgPT4gPj0xLjIuMCA8My41LjAgQW55IDMuNC54IHdpbGwgZG9cbiAgICAvLyAxLjIgLSAzLjQgPT4gPj0xLjIuMCA8My41LjBcblxuXG4gICAgZnVuY3Rpb24gaHlwaGVuUmVwbGFjZSgkMCwgZnJvbSwgZk0sIGZtLCBmcCwgZnByLCBmYiwgdG8sIHRNLCB0bSwgdHAsIHRwciwgdGIpIHtcbiAgICAgIGlmIChpc1goZk0pKSB7XG4gICAgICAgIGZyb20gPSAnJztcbiAgICAgIH0gZWxzZSBpZiAoaXNYKGZtKSkge1xuICAgICAgICBmcm9tID0gJz49JyArIGZNICsgJy4wLjAnO1xuICAgICAgfSBlbHNlIGlmIChpc1goZnApKSB7XG4gICAgICAgIGZyb20gPSAnPj0nICsgZk0gKyAnLicgKyBmbSArICcuMCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcm9tID0gJz49JyArIGZyb207XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1godE0pKSB7XG4gICAgICAgIHRvID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKGlzWCh0bSkpIHtcbiAgICAgICAgdG8gPSAnPCcgKyAoK3RNICsgMSkgKyAnLjAuMCc7XG4gICAgICB9IGVsc2UgaWYgKGlzWCh0cCkpIHtcbiAgICAgICAgdG8gPSAnPCcgKyB0TSArICcuJyArICgrdG0gKyAxKSArICcuMCc7XG4gICAgICB9IGVsc2UgaWYgKHRwcikge1xuICAgICAgICB0byA9ICc8PScgKyB0TSArICcuJyArIHRtICsgJy4nICsgdHAgKyAnLScgKyB0cHI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0byA9ICc8PScgKyB0bztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChmcm9tICsgJyAnICsgdG8pLnRyaW0oKTtcbiAgICB9IC8vIGlmIEFOWSBvZiB0aGUgc2V0cyBtYXRjaCBBTEwgb2YgaXRzIGNvbXBhcmF0b3JzLCB0aGVuIHBhc3NcblxuXG4gICAgUmFuZ2UucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbiAodmVyc2lvbikge1xuICAgICAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRlc3RTZXQodGhpcy5zZXRbaV0sIHZlcnNpb24sIHRoaXMub3B0aW9ucykpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHRlc3RTZXQoc2V0LCB2ZXJzaW9uLCBvcHRpb25zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXNldFtpXS50ZXN0KHZlcnNpb24pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh2ZXJzaW9uLnByZXJlbGVhc2UubGVuZ3RoICYmICFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIHNldCBvZiB2ZXJzaW9ucyB0aGF0IGFyZSBhbGxvd2VkIHRvIGhhdmUgcHJlcmVsZWFzZXNcbiAgICAgICAgLy8gRm9yIGV4YW1wbGUsIF4xLjIuMy1wci4xIGRlc3VnYXJzIHRvID49MS4yLjMtcHIuMSA8Mi4wLjBcbiAgICAgICAgLy8gVGhhdCBzaG91bGQgYWxsb3cgYDEuMi4zLXByLjJgIHRvIHBhc3MuXG4gICAgICAgIC8vIEhvd2V2ZXIsIGAxLjIuNC1hbHBoYS5ub3RyZWFkeWAgc2hvdWxkIE5PVCBiZSBhbGxvd2VkLFxuICAgICAgICAvLyBldmVuIHRob3VnaCBpdCdzIHdpdGhpbiB0aGUgcmFuZ2Ugc2V0IGJ5IHRoZSBjb21wYXJhdG9ycy5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGRlYnVnKHNldFtpXS5zZW12ZXIpO1xuXG4gICAgICAgICAgaWYgKHNldFtpXS5zZW12ZXIgPT09IEFOWSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNldFtpXS5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgYWxsb3dlZCA9IHNldFtpXS5zZW12ZXI7XG5cbiAgICAgICAgICAgIGlmIChhbGxvd2VkLm1ham9yID09PSB2ZXJzaW9uLm1ham9yICYmIGFsbG93ZWQubWlub3IgPT09IHZlcnNpb24ubWlub3IgJiYgYWxsb3dlZC5wYXRjaCA9PT0gdmVyc2lvbi5wYXRjaCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gVmVyc2lvbiBoYXMgYSAtcHJlLCBidXQgaXQncyBub3Qgb25lIG9mIHRoZSBvbmVzIHdlIGxpa2UuXG5cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGV4cG9ydHMuc2F0aXNmaWVzID0gc2F0aXNmaWVzO1xuXG4gICAgZnVuY3Rpb24gc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSB7XG4gICAgICB0cnkge1xuICAgICAgICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucyk7XG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByYW5nZS50ZXN0KHZlcnNpb24pO1xuICAgIH1cblxuICAgIGV4cG9ydHMubWF4U2F0aXNmeWluZyA9IG1heFNhdGlzZnlpbmc7XG5cbiAgICBmdW5jdGlvbiBtYXhTYXRpc2Z5aW5nKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykge1xuICAgICAgdmFyIG1heCA9IG51bGw7XG4gICAgICB2YXIgbWF4U1YgPSBudWxsO1xuXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmFuZ2VPYmogPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpO1xuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZlcnNpb25zLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHtcbiAgICAgICAgICAvLyBzYXRpc2ZpZXModiwgcmFuZ2UsIG9wdGlvbnMpXG4gICAgICAgICAgaWYgKCFtYXggfHwgbWF4U1YuY29tcGFyZSh2KSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIGNvbXBhcmUobWF4LCB2LCB0cnVlKVxuICAgICAgICAgICAgbWF4ID0gdjtcbiAgICAgICAgICAgIG1heFNWID0gbmV3IFNlbVZlcihtYXgsIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbWF4O1xuICAgIH1cblxuICAgIGV4cG9ydHMubWluU2F0aXNmeWluZyA9IG1pblNhdGlzZnlpbmc7XG5cbiAgICBmdW5jdGlvbiBtaW5TYXRpc2Z5aW5nKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykge1xuICAgICAgdmFyIG1pbiA9IG51bGw7XG4gICAgICB2YXIgbWluU1YgPSBudWxsO1xuXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmFuZ2VPYmogPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpO1xuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZlcnNpb25zLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHtcbiAgICAgICAgICAvLyBzYXRpc2ZpZXModiwgcmFuZ2UsIG9wdGlvbnMpXG4gICAgICAgICAgaWYgKCFtaW4gfHwgbWluU1YuY29tcGFyZSh2KSA9PT0gMSkge1xuICAgICAgICAgICAgLy8gY29tcGFyZShtaW4sIHYsIHRydWUpXG4gICAgICAgICAgICBtaW4gPSB2O1xuICAgICAgICAgICAgbWluU1YgPSBuZXcgU2VtVmVyKG1pbiwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtaW47XG4gICAgfVxuXG4gICAgZXhwb3J0cy5taW5WZXJzaW9uID0gbWluVmVyc2lvbjtcblxuICAgIGZ1bmN0aW9uIG1pblZlcnNpb24ocmFuZ2UsIGxvb3NlKSB7XG4gICAgICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpO1xuICAgICAgdmFyIG1pbnZlciA9IG5ldyBTZW1WZXIoJzAuMC4wJyk7XG5cbiAgICAgIGlmIChyYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICAgICAgcmV0dXJuIG1pbnZlcjtcbiAgICAgIH1cblxuICAgICAgbWludmVyID0gbmV3IFNlbVZlcignMC4wLjAtMCcpO1xuXG4gICAgICBpZiAocmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgICAgIHJldHVybiBtaW52ZXI7XG4gICAgICB9XG5cbiAgICAgIG1pbnZlciA9IG51bGw7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2Uuc2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjb21wYXJhdG9ycyA9IHJhbmdlLnNldFtpXTtcbiAgICAgICAgY29tcGFyYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAoY29tcGFyYXRvcikge1xuICAgICAgICAgIC8vIENsb25lIHRvIGF2b2lkIG1hbmlwdWxhdGluZyB0aGUgY29tcGFyYXRvcidzIHNlbXZlciBvYmplY3QuXG4gICAgICAgICAgdmFyIGNvbXB2ZXIgPSBuZXcgU2VtVmVyKGNvbXBhcmF0b3Iuc2VtdmVyLnZlcnNpb24pO1xuXG4gICAgICAgICAgc3dpdGNoIChjb21wYXJhdG9yLm9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgaWYgKGNvbXB2ZXIucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb21wdmVyLnBhdGNoKys7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcHZlci5wcmVyZWxlYXNlLnB1c2goMCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb21wdmVyLnJhdyA9IGNvbXB2ZXIuZm9ybWF0KCk7XG5cbiAgICAgICAgICAgIC8qIGZhbGx0aHJvdWdoICovXG5cbiAgICAgICAgICAgIGNhc2UgJyc6XG4gICAgICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgICAgIGlmICghbWludmVyIHx8IGd0KG1pbnZlciwgY29tcHZlcikpIHtcbiAgICAgICAgICAgICAgICBtaW52ZXIgPSBjb21wdmVyO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgICAgICAvKiBJZ25vcmUgbWF4aW11bSB2ZXJzaW9ucyAqL1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIG9wZXJhdGlvbjogJyArIGNvbXBhcmF0b3Iub3BlcmF0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtaW52ZXIgJiYgcmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgICAgIHJldHVybiBtaW52ZXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGV4cG9ydHMudmFsaWRSYW5nZSA9IHZhbGlkUmFuZ2U7XG5cbiAgICBmdW5jdGlvbiB2YWxpZFJhbmdlKHJhbmdlLCBvcHRpb25zKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBSZXR1cm4gJyonIGluc3RlYWQgb2YgJycgc28gdGhhdCB0cnV0aGluZXNzIHdvcmtzLlxuICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgaXQncyBpbnZhbGlkIGFueXdheVxuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKS5yYW5nZSB8fCAnKic7XG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IC8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGxlc3MgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZVxuXG5cbiAgICBleHBvcnRzLmx0ciA9IGx0cjtcblxuICAgIGZ1bmN0aW9uIGx0cih2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsICc8Jywgb3B0aW9ucyk7XG4gICAgfSAvLyBEZXRlcm1pbmUgaWYgdmVyc2lvbiBpcyBncmVhdGVyIHRoYW4gYWxsIHRoZSB2ZXJzaW9ucyBwb3NzaWJsZSBpbiB0aGUgcmFuZ2UuXG5cblxuICAgIGV4cG9ydHMuZ3RyID0gZ3RyO1xuXG4gICAgZnVuY3Rpb24gZ3RyKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgJz4nLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBleHBvcnRzLm91dHNpZGUgPSBvdXRzaWRlO1xuXG4gICAgZnVuY3Rpb24gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgaGlsbywgb3B0aW9ucykge1xuICAgICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucyk7XG4gICAgICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucyk7XG4gICAgICB2YXIgZ3RmbiwgbHRlZm4sIGx0Zm4sIGNvbXAsIGVjb21wO1xuXG4gICAgICBzd2l0Y2ggKGhpbG8pIHtcbiAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgZ3RmbiA9IGd0O1xuICAgICAgICAgIGx0ZWZuID0gbHRlO1xuICAgICAgICAgIGx0Zm4gPSBsdDtcbiAgICAgICAgICBjb21wID0gJz4nO1xuICAgICAgICAgIGVjb21wID0gJz49JztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICBndGZuID0gbHQ7XG4gICAgICAgICAgbHRlZm4gPSBndGU7XG4gICAgICAgICAgbHRmbiA9IGd0O1xuICAgICAgICAgIGNvbXAgPSAnPCc7XG4gICAgICAgICAgZWNvbXAgPSAnPD0nO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBwcm92aWRlIGEgaGlsbyB2YWwgb2YgXCI8XCIgb3IgXCI+XCInKTtcbiAgICAgIH0gLy8gSWYgaXQgc2F0aXNpZmVzIHRoZSByYW5nZSBpdCBpcyBub3Qgb3V0c2lkZVxuXG5cbiAgICAgIGlmIChzYXRpc2ZpZXModmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gRnJvbSBub3cgb24sIHZhcmlhYmxlIHRlcm1zIGFyZSBhcyBpZiB3ZSdyZSBpbiBcImd0clwiIG1vZGUuXG4gICAgICAvLyBidXQgbm90ZSB0aGF0IGV2ZXJ5dGhpbmcgaXMgZmxpcHBlZCBmb3IgdGhlIFwibHRyXCIgZnVuY3Rpb24uXG5cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZS5zZXQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldO1xuICAgICAgICB2YXIgaGlnaCA9IG51bGw7XG4gICAgICAgIHZhciBsb3cgPSBudWxsO1xuICAgICAgICBjb21wYXJhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wYXJhdG9yKSB7XG4gICAgICAgICAgaWYgKGNvbXBhcmF0b3Iuc2VtdmVyID09PSBBTlkpIHtcbiAgICAgICAgICAgIGNvbXBhcmF0b3IgPSBuZXcgQ29tcGFyYXRvcignPj0wLjAuMCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGhpZ2ggPSBoaWdoIHx8IGNvbXBhcmF0b3I7XG4gICAgICAgICAgbG93ID0gbG93IHx8IGNvbXBhcmF0b3I7XG5cbiAgICAgICAgICBpZiAoZ3Rmbihjb21wYXJhdG9yLnNlbXZlciwgaGlnaC5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBoaWdoID0gY29tcGFyYXRvcjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGx0Zm4oY29tcGFyYXRvci5zZW12ZXIsIGxvdy5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBsb3cgPSBjb21wYXJhdG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7IC8vIElmIHRoZSBlZGdlIHZlcnNpb24gY29tcGFyYXRvciBoYXMgYSBvcGVyYXRvciB0aGVuIG91ciB2ZXJzaW9uXG4gICAgICAgIC8vIGlzbid0IG91dHNpZGUgaXRcblxuICAgICAgICBpZiAoaGlnaC5vcGVyYXRvciA9PT0gY29tcCB8fCBoaWdoLm9wZXJhdG9yID09PSBlY29tcCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSAvLyBJZiB0aGUgbG93ZXN0IHZlcnNpb24gY29tcGFyYXRvciBoYXMgYW4gb3BlcmF0b3IgYW5kIG91ciB2ZXJzaW9uXG4gICAgICAgIC8vIGlzIGxlc3MgdGhhbiBpdCB0aGVuIGl0IGlzbid0IGhpZ2hlciB0aGFuIHRoZSByYW5nZVxuXG5cbiAgICAgICAgaWYgKCghbG93Lm9wZXJhdG9yIHx8IGxvdy5vcGVyYXRvciA9PT0gY29tcCkgJiYgbHRlZm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAobG93Lm9wZXJhdG9yID09PSBlY29tcCAmJiBsdGZuKHZlcnNpb24sIGxvdy5zZW12ZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGV4cG9ydHMucHJlcmVsZWFzZSA9IHByZXJlbGVhc2U7XG5cbiAgICBmdW5jdGlvbiBwcmVyZWxlYXNlKHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgICAgIHZhciBwYXJzZWQgPSBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBwYXJzZWQgJiYgcGFyc2VkLnByZXJlbGVhc2UubGVuZ3RoID8gcGFyc2VkLnByZXJlbGVhc2UgOiBudWxsO1xuICAgIH1cblxuICAgIGV4cG9ydHMuaW50ZXJzZWN0cyA9IGludGVyc2VjdHM7XG5cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3RzKHIxLCByMiwgb3B0aW9ucykge1xuICAgICAgcjEgPSBuZXcgUmFuZ2UocjEsIG9wdGlvbnMpO1xuICAgICAgcjIgPSBuZXcgUmFuZ2UocjIsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHIxLmludGVyc2VjdHMocjIpO1xuICAgIH1cblxuICAgIGV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuXG4gICAgZnVuY3Rpb24gY29lcmNlKHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgICAgIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgICAgIHJldHVybiB2ZXJzaW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZlcnNpb24gPSBTdHJpbmcodmVyc2lvbik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdmVyc2lvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdmFyIG1hdGNoID0gbnVsbDtcblxuICAgICAgaWYgKCFvcHRpb25zLnJ0bCkge1xuICAgICAgICBtYXRjaCA9IHZlcnNpb24ubWF0Y2gocmVbdC5DT0VSQ0VdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIHJpZ2h0LW1vc3QgY29lcmNpYmxlIHN0cmluZyB0aGF0IGRvZXMgbm90IHNoYXJlXG4gICAgICAgIC8vIGEgdGVybWludXMgd2l0aCBhIG1vcmUgbGVmdC13YXJkIGNvZXJjaWJsZSBzdHJpbmcuXG4gICAgICAgIC8vIEVnLCAnMS4yLjMuNCcgd2FudHMgdG8gY29lcmNlICcyLjMuNCcsIG5vdCAnMy40JyBvciAnNCdcbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2FsayB0aHJvdWdoIHRoZSBzdHJpbmcgY2hlY2tpbmcgd2l0aCBhIC9nIHJlZ2V4cFxuICAgICAgICAvLyBNYW51YWxseSBzZXQgdGhlIGluZGV4IHNvIGFzIHRvIHBpY2sgdXAgb3ZlcmxhcHBpbmcgbWF0Y2hlcy5cbiAgICAgICAgLy8gU3RvcCB3aGVuIHdlIGdldCBhIG1hdGNoIHRoYXQgZW5kcyBhdCB0aGUgc3RyaW5nIGVuZCwgc2luY2Ugbm9cbiAgICAgICAgLy8gY29lcmNpYmxlIHN0cmluZyBjYW4gYmUgbW9yZSByaWdodC13YXJkIHdpdGhvdXQgdGhlIHNhbWUgdGVybWludXMuXG4gICAgICAgIHZhciBuZXh0O1xuXG4gICAgICAgIHdoaWxlICgobmV4dCA9IHJlW3QuQ09FUkNFUlRMXS5leGVjKHZlcnNpb24pKSAmJiAoIW1hdGNoIHx8IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoICE9PSB2ZXJzaW9uLmxlbmd0aCkpIHtcbiAgICAgICAgICBpZiAoIW1hdGNoIHx8IG5leHQuaW5kZXggKyBuZXh0WzBdLmxlbmd0aCAhPT0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1hdGNoID0gbmV4dDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZVt0LkNPRVJDRVJUTF0ubGFzdEluZGV4ID0gbmV4dC5pbmRleCArIG5leHRbMV0ubGVuZ3RoICsgbmV4dFsyXS5sZW5ndGg7XG4gICAgICAgIH0gLy8gbGVhdmUgaXQgaW4gYSBjbGVhbiBzdGF0ZVxuXG5cbiAgICAgICAgcmVbdC5DT0VSQ0VSVExdLmxhc3RJbmRleCA9IC0xO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJzZShtYXRjaFsyXSArICcuJyArIChtYXRjaFszXSB8fCAnMCcpICsgJy4nICsgKG1hdGNoWzRdIHx8ICcwJyksIG9wdGlvbnMpO1xuICAgIH1cbiAgfSk7XG4gIHZhciBzZW12ZXJfMSA9IHNlbXZlci5TRU1WRVJfU1BFQ19WRVJTSU9OO1xuICB2YXIgc2VtdmVyXzIgPSBzZW12ZXIucmU7XG4gIHZhciBzZW12ZXJfMyA9IHNlbXZlci5zcmM7XG4gIHZhciBzZW12ZXJfNCA9IHNlbXZlci50b2tlbnM7XG4gIHZhciBzZW12ZXJfNSA9IHNlbXZlci5wYXJzZTtcbiAgdmFyIHNlbXZlcl82ID0gc2VtdmVyLnZhbGlkO1xuICB2YXIgc2VtdmVyXzcgPSBzZW12ZXIuY2xlYW47XG4gIHZhciBzZW12ZXJfOCA9IHNlbXZlci5TZW1WZXI7XG4gIHZhciBzZW12ZXJfOSA9IHNlbXZlci5pbmM7XG4gIHZhciBzZW12ZXJfMTAgPSBzZW12ZXIuZGlmZjtcbiAgdmFyIHNlbXZlcl8xMSA9IHNlbXZlci5jb21wYXJlSWRlbnRpZmllcnM7XG4gIHZhciBzZW12ZXJfMTIgPSBzZW12ZXIucmNvbXBhcmVJZGVudGlmaWVycztcbiAgdmFyIHNlbXZlcl8xMyA9IHNlbXZlci5tYWpvcjtcbiAgdmFyIHNlbXZlcl8xNCA9IHNlbXZlci5taW5vcjtcbiAgdmFyIHNlbXZlcl8xNSA9IHNlbXZlci5wYXRjaDtcbiAgdmFyIHNlbXZlcl8xNiA9IHNlbXZlci5jb21wYXJlO1xuICB2YXIgc2VtdmVyXzE3ID0gc2VtdmVyLmNvbXBhcmVMb29zZTtcbiAgdmFyIHNlbXZlcl8xOCA9IHNlbXZlci5jb21wYXJlQnVpbGQ7XG4gIHZhciBzZW12ZXJfMTkgPSBzZW12ZXIucmNvbXBhcmU7XG4gIHZhciBzZW12ZXJfMjAgPSBzZW12ZXIuc29ydDtcbiAgdmFyIHNlbXZlcl8yMSA9IHNlbXZlci5yc29ydDtcbiAgdmFyIHNlbXZlcl8yMiA9IHNlbXZlci5ndDtcbiAgdmFyIHNlbXZlcl8yMyA9IHNlbXZlci5sdDtcbiAgdmFyIHNlbXZlcl8yNCA9IHNlbXZlci5lcTtcbiAgdmFyIHNlbXZlcl8yNSA9IHNlbXZlci5uZXE7XG4gIHZhciBzZW12ZXJfMjYgPSBzZW12ZXIuZ3RlO1xuICB2YXIgc2VtdmVyXzI3ID0gc2VtdmVyLmx0ZTtcbiAgdmFyIHNlbXZlcl8yOCA9IHNlbXZlci5jbXA7XG4gIHZhciBzZW12ZXJfMjkgPSBzZW12ZXIuQ29tcGFyYXRvcjtcbiAgdmFyIHNlbXZlcl8zMCA9IHNlbXZlci5SYW5nZTtcbiAgdmFyIHNlbXZlcl8zMSA9IHNlbXZlci50b0NvbXBhcmF0b3JzO1xuICB2YXIgc2VtdmVyXzMyID0gc2VtdmVyLnNhdGlzZmllcztcbiAgdmFyIHNlbXZlcl8zMyA9IHNlbXZlci5tYXhTYXRpc2Z5aW5nO1xuICB2YXIgc2VtdmVyXzM0ID0gc2VtdmVyLm1pblNhdGlzZnlpbmc7XG4gIHZhciBzZW12ZXJfMzUgPSBzZW12ZXIubWluVmVyc2lvbjtcbiAgdmFyIHNlbXZlcl8zNiA9IHNlbXZlci52YWxpZFJhbmdlO1xuICB2YXIgc2VtdmVyXzM3ID0gc2VtdmVyLmx0cjtcbiAgdmFyIHNlbXZlcl8zOCA9IHNlbXZlci5ndHI7XG4gIHZhciBzZW12ZXJfMzkgPSBzZW12ZXIub3V0c2lkZTtcbiAgdmFyIHNlbXZlcl80MCA9IHNlbXZlci5wcmVyZWxlYXNlO1xuICB2YXIgc2VtdmVyXzQxID0gc2VtdmVyLmludGVyc2VjdHM7XG4gIHZhciBzZW12ZXJfNDIgPSBzZW12ZXIuY29lcmNlO1xuXG4gIHZhciBhcnJheWlmeSA9IGZ1bmN0aW9uIGFycmF5aWZ5KG9iamVjdCwga2V5TmFtZSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpLnJlZHVjZShmdW5jdGlvbiAoYXJyYXksIGtleSkge1xuICAgICAgcmV0dXJuIGFycmF5LmNvbmNhdChPYmplY3QuYXNzaWduKF9kZWZpbmVQcm9wZXJ0eSh7fSwga2V5TmFtZSwga2V5KSwgb2JqZWN0W2tleV0pKTtcbiAgICB9LCBbXSk7XG4gIH07XG5cbiAgdmFyIGRlZGVudF8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuXG4gICAgZnVuY3Rpb24gZGVkZW50KHN0cmluZ3MpIHtcbiAgICAgIHZhciByYXcgPSB2b2lkIDA7XG5cbiAgICAgIGlmICh0eXBlb2Ygc3RyaW5ncyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAvLyBkZWRlbnQgY2FuIGJlIHVzZWQgYXMgYSBwbGFpbiBmdW5jdGlvblxuICAgICAgICByYXcgPSBbc3RyaW5nc107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYXcgPSBzdHJpbmdzLnJhdztcbiAgICAgIH0gLy8gZmlyc3QsIHBlcmZvcm0gaW50ZXJwb2xhdGlvblxuXG5cbiAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhdy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gcmF3W2ldLiAvLyBqb2luIGxpbmVzIHdoZW4gdGhlcmUgaXMgYSBzdXBwcmVzc2VkIG5ld2xpbmVcbiAgICAgICAgcmVwbGFjZSgvXFxcXFxcblsgXFx0XSovZywgXCJcIikuIC8vIGhhbmRsZSBlc2NhcGVkIGJhY2t0aWNrc1xuICAgICAgICByZXBsYWNlKC9cXFxcYC9nLCBcImBcIik7XG5cbiAgICAgICAgaWYgKGkgPCAoYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gMCA6IGFyZ3VtZW50cy5sZW5ndGggLSAxKSkge1xuICAgICAgICAgIHJlc3VsdCArPSBhcmd1bWVudHMubGVuZ3RoIDw9IGkgKyAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBub3cgc3RyaXAgaW5kZW50YXRpb25cblxuXG4gICAgICB2YXIgbGluZXMgPSByZXN1bHQuc3BsaXQoXCJcXG5cIik7XG4gICAgICB2YXIgbWluZGVudCA9IG51bGw7XG4gICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgIHZhciBtID0gbC5tYXRjaCgvXihcXHMrKVxcUysvKTtcblxuICAgICAgICBpZiAobSkge1xuICAgICAgICAgIHZhciBpbmRlbnQgPSBtWzFdLmxlbmd0aDtcblxuICAgICAgICAgIGlmICghbWluZGVudCkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgZmlyc3QgaW5kZW50ZWQgbGluZVxuICAgICAgICAgICAgbWluZGVudCA9IGluZGVudDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWluZGVudCA9IE1hdGgubWluKG1pbmRlbnQsIGluZGVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKG1pbmRlbnQgIT09IG51bGwpIHtcbiAgICAgICAgcmVzdWx0ID0gbGluZXMubWFwKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgcmV0dXJuIGxbMF0gPT09IFwiIFwiID8gbC5zbGljZShtaW5kZW50KSA6IGw7XG4gICAgICAgIH0pLmpvaW4oXCJcXG5cIik7XG4gICAgICB9IC8vIGRlZGVudCBlYXRzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UgdG9vXG5cblxuICAgICAgcmVzdWx0ID0gcmVzdWx0LnRyaW0oKTsgLy8gaGFuZGxlIGVzY2FwZWQgbmV3bGluZXMgYXQgdGhlIGVuZCB0byBlbnN1cmUgdGhleSBkb24ndCBnZXQgc3RyaXBwZWQgdG9vXG5cbiAgICAgIHJldHVybiByZXN1bHQucmVwbGFjZSgvXFxcXG4vZywgXCJcXG5cIik7XG4gICAgfVxuXG4gICAge1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWRlbnQ7XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiBfdGVtcGxhdGVPYmplY3Q2KCkge1xuICAgIHZhciBkYXRhID0gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbChbXCJcXG4gICAgICBSZXF1aXJlIGVpdGhlciAnQHByZXR0aWVyJyBvciAnQGZvcm1hdCcgdG8gYmUgcHJlc2VudCBpbiB0aGUgZmlsZSdzIGZpcnN0IGRvY2Jsb2NrIGNvbW1lbnRcXG4gICAgICBpbiBvcmRlciBmb3IgaXQgdG8gYmUgZm9ybWF0dGVkLlxcbiAgICBcIl0pO1xuXG4gICAgX3RlbXBsYXRlT2JqZWN0NiA9IGZ1bmN0aW9uIF90ZW1wbGF0ZU9iamVjdDYoKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBmdW5jdGlvbiBfdGVtcGxhdGVPYmplY3Q1KCkge1xuICAgIHZhciBkYXRhID0gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbChbXCJcXG4gICAgICBGb3JtYXQgY29kZSBzdGFydGluZyBhdCBhIGdpdmVuIGNoYXJhY3RlciBvZmZzZXQuXFxuICAgICAgVGhlIHJhbmdlIHdpbGwgZXh0ZW5kIGJhY2t3YXJkcyB0byB0aGUgc3RhcnQgb2YgdGhlIGZpcnN0IGxpbmUgY29udGFpbmluZyB0aGUgc2VsZWN0ZWQgc3RhdGVtZW50LlxcbiAgICAgIFRoaXMgb3B0aW9uIGNhbm5vdCBiZSB1c2VkIHdpdGggLS1jdXJzb3Itb2Zmc2V0LlxcbiAgICBcIl0pO1xuXG4gICAgX3RlbXBsYXRlT2JqZWN0NSA9IGZ1bmN0aW9uIF90ZW1wbGF0ZU9iamVjdDUoKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBmdW5jdGlvbiBfdGVtcGxhdGVPYmplY3Q0KCkge1xuICAgIHZhciBkYXRhID0gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbChbXCJcXG4gICAgICBGb3JtYXQgY29kZSBlbmRpbmcgYXQgYSBnaXZlbiBjaGFyYWN0ZXIgb2Zmc2V0IChleGNsdXNpdmUpLlxcbiAgICAgIFRoZSByYW5nZSB3aWxsIGV4dGVuZCBmb3J3YXJkcyB0byB0aGUgZW5kIG9mIHRoZSBzZWxlY3RlZCBzdGF0ZW1lbnQuXFxuICAgICAgVGhpcyBvcHRpb24gY2Fubm90IGJlIHVzZWQgd2l0aCAtLWN1cnNvci1vZmZzZXQuXFxuICAgIFwiXSk7XG5cbiAgICBfdGVtcGxhdGVPYmplY3Q0ID0gZnVuY3Rpb24gX3RlbXBsYXRlT2JqZWN0NCgpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90ZW1wbGF0ZU9iamVjdDMoKSB7XG4gICAgdmFyIGRhdGEgPSBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsKFtcIlxcbiAgICAgIEN1c3RvbSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBwcmV0dGllciBwbHVnaW5zIGluIG5vZGVfbW9kdWxlcyBzdWJkaXJlY3RvcnkuXFxuICAgICAgT3ZlcnJpZGVzIGRlZmF1bHQgYmVoYXZpb3Igd2hlbiBwbHVnaW5zIGFyZSBzZWFyY2hlZCByZWxhdGl2ZWx5IHRvIHRoZSBsb2NhdGlvbiBvZiBQcmV0dGllci5cXG4gICAgICBNdWx0aXBsZSB2YWx1ZXMgYXJlIGFjY2VwdGVkLlxcbiAgICBcIl0pO1xuXG4gICAgX3RlbXBsYXRlT2JqZWN0MyA9IGZ1bmN0aW9uIF90ZW1wbGF0ZU9iamVjdDMoKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBmdW5jdGlvbiBfdGVtcGxhdGVPYmplY3QyKCkge1xuICAgIHZhciBkYXRhID0gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbChbXCJcXG4gICAgICAgICAgTWFpbnRhaW4gZXhpc3RpbmdcXG4gICAgICAgICAgKG1peGVkIHZhbHVlcyB3aXRoaW4gb25lIGZpbGUgYXJlIG5vcm1hbGlzZWQgYnkgbG9va2luZyBhdCB3aGF0J3MgdXNlZCBhZnRlciB0aGUgZmlyc3QgbGluZSlcXG4gICAgICAgIFwiXSk7XG5cbiAgICBfdGVtcGxhdGVPYmplY3QyID0gZnVuY3Rpb24gX3RlbXBsYXRlT2JqZWN0MigpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90ZW1wbGF0ZU9iamVjdCgpIHtcbiAgICB2YXIgZGF0YSA9IF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoW1wiXFxuICAgICAgUHJpbnQgKHRvIHN0ZGVycikgd2hlcmUgYSBjdXJzb3IgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIHdvdWxkIG1vdmUgdG8gYWZ0ZXIgZm9ybWF0dGluZy5cXG4gICAgICBUaGlzIG9wdGlvbiBjYW5ub3QgYmUgdXNlZCB3aXRoIC0tcmFuZ2Utc3RhcnQgYW5kIC0tcmFuZ2UtZW5kLlxcbiAgICBcIl0pO1xuXG4gICAgX3RlbXBsYXRlT2JqZWN0ID0gZnVuY3Rpb24gX3RlbXBsYXRlT2JqZWN0KCkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIENBVEVHT1JZX0NPTkZJRyA9IFwiQ29uZmlnXCI7XG4gIHZhciBDQVRFR09SWV9FRElUT1IgPSBcIkVkaXRvclwiO1xuICB2YXIgQ0FURUdPUllfRk9STUFUID0gXCJGb3JtYXRcIjtcbiAgdmFyIENBVEVHT1JZX09USEVSID0gXCJPdGhlclwiO1xuICB2YXIgQ0FURUdPUllfT1VUUFVUID0gXCJPdXRwdXRcIjtcbiAgdmFyIENBVEVHT1JZX0dMT0JBTCA9IFwiR2xvYmFsXCI7XG4gIHZhciBDQVRFR09SWV9TUEVDSUFMID0gXCJTcGVjaWFsXCI7XG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25JbmZvXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc2luY2VdIC0gYXZhaWxhYmxlIHNpbmNlIHZlcnNpb25cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGNhdGVnb3J5XG4gICAqIEBwcm9wZXJ0eSB7J2ludCcgfCAnYm9vbGVhbicgfCAnY2hvaWNlJyB8ICdwYXRoJ30gdHlwZVxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFthcnJheV0gLSBpbmRpY2F0ZSBpdCdzIGFuIGFycmF5IG9mIHRoZSBzcGVjaWZpZWQgdHlwZVxuICAgKiBAcHJvcGVydHkge09wdGlvblZhbHVlSW5mb30gW2RlZmF1bHRdXG4gICAqIEBwcm9wZXJ0eSB7T3B0aW9uUmFuZ2VJbmZvfSBbcmFuZ2VdIC0gZm9yIHR5cGUgaW50XG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXNjcmlwdGlvblxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2RlcHJlY2F0ZWRdIC0gZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uXG4gICAqIEBwcm9wZXJ0eSB7T3B0aW9uUmVkaXJlY3RJbmZvfSBbcmVkaXJlY3RdIC0gcmVkaXJlY3QgZGVwcmVjYXRlZCBvcHRpb25cbiAgICogQHByb3BlcnR5IHsodmFsdWU6IGFueSkgPT4gYm9vbGVhbn0gW2V4Y2VwdGlvbl1cbiAgICogQHByb3BlcnR5IHtPcHRpb25DaG9pY2VJbmZvW119IFtjaG9pY2VzXSAtIGZvciB0eXBlIGNob2ljZVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsaU5hbWVdXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xpQ2F0ZWdvcnldXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xpRGVzY3JpcHRpb25dXG4gICAqXG4gICAqIEB0eXBlZGVmIHtudW1iZXIgfCBib29sZWFuIHwgc3RyaW5nfSBPcHRpb25WYWx1ZVxuICAgKiBAdHlwZWRlZiB7T3B0aW9uVmFsdWUgfCBbeyB2YWx1ZTogT3B0aW9uVmFsdWVbXSB9XSB8IEFycmF5PHsgc2luY2U6IHN0cmluZywgdmFsdWU6IE9wdGlvblZhbHVlfT59IE9wdGlvblZhbHVlSW5mb1xuICAgKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25SZWRpcmVjdEluZm9cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IG9wdGlvblxuICAgKiBAcHJvcGVydHkge09wdGlvblZhbHVlfSB2YWx1ZVxuICAgKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25SYW5nZUluZm9cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHN0YXJ0IC0gcmVjb21tZW5kZWQgcmFuZ2Ugc3RhcnRcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGVuZCAtIHJlY29tbWVuZGVkIHJhbmdlIGVuZFxuICAgKiBAcHJvcGVydHkge251bWJlcn0gc3RlcCAtIHJlY29tbWVuZGVkIHJhbmdlIHN0ZXBcbiAgICpcbiAgICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uQ2hvaWNlSW5mb1xuICAgKiBAcHJvcGVydHkge2Jvb2xlYW4gfCBzdHJpbmd9IHZhbHVlIC0gYm9vbGVhbiBmb3IgdGhlIG9wdGlvbiB0aGF0IGlzIG9yaWdpbmFsbHkgYm9vbGVhbiB0eXBlXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXNjcmlwdGlvblxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NpbmNlXSAtIHVuZGVmaW5lZCBpZiBhdmFpbGFibGUgc2luY2UgdGhlIGZpcnN0IHZlcnNpb24gb2YgdGhlIG9wdGlvblxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2RlcHJlY2F0ZWRdIC0gZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uXG4gICAqIEBwcm9wZXJ0eSB7T3B0aW9uVmFsdWVJbmZvfSBbcmVkaXJlY3RdIC0gcmVkaXJlY3QgZGVwcmVjYXRlZCB2YWx1ZVxuICAgKi9cblxuICAvKiogQHR5cGUge3sgW25hbWU6IHN0cmluZ106IE9wdGlvbkluZm8gfX0gKi9cblxuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBjdXJzb3JPZmZzZXQ6IHtcbiAgICAgIHNpbmNlOiBcIjEuNC4wXCIsXG4gICAgICBjYXRlZ29yeTogQ0FURUdPUllfU1BFQ0lBTCxcbiAgICAgIHR5cGU6IFwiaW50XCIsXG4gICAgICBkZWZhdWx0OiAtMSxcbiAgICAgIHJhbmdlOiB7XG4gICAgICAgIHN0YXJ0OiAtMSxcbiAgICAgICAgZW5kOiBJbmZpbml0eSxcbiAgICAgICAgc3RlcDogMVxuICAgICAgfSxcbiAgICAgIGRlc2NyaXB0aW9uOiBkZWRlbnRfMShfdGVtcGxhdGVPYmplY3QoKSksXG4gICAgICBjbGlDYXRlZ29yeTogQ0FURUdPUllfRURJVE9SXG4gICAgfSxcbiAgICBlbmRPZkxpbmU6IHtcbiAgICAgIHNpbmNlOiBcIjEuMTUuMFwiLFxuICAgICAgY2F0ZWdvcnk6IENBVEVHT1JZX0dMT0JBTCxcbiAgICAgIHR5cGU6IFwiY2hvaWNlXCIsXG4gICAgICBkZWZhdWx0OiBcImF1dG9cIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIldoaWNoIGVuZCBvZiBsaW5lIGNoYXJhY3RlcnMgdG8gYXBwbHkuXCIsXG4gICAgICBjaG9pY2VzOiBbe1xuICAgICAgICB2YWx1ZTogXCJhdXRvXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBkZWRlbnRfMShfdGVtcGxhdGVPYmplY3QyKCkpXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcImxmXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkxpbmUgRmVlZCBvbmx5IChcXFxcbiksIGNvbW1vbiBvbiBMaW51eCBhbmQgbWFjT1MgYXMgd2VsbCBhcyBpbnNpZGUgZ2l0IHJlcG9zXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwiY3JsZlwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJDYXJyaWFnZSBSZXR1cm4gKyBMaW5lIEZlZWQgY2hhcmFjdGVycyAoXFxcXHJcXFxcbiksIGNvbW1vbiBvbiBXaW5kb3dzXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwiY3JcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiQ2FycmlhZ2UgUmV0dXJuIGNoYXJhY3RlciBvbmx5IChcXFxcciksIHVzZWQgdmVyeSByYXJlbHlcIlxuICAgICAgfV1cbiAgICB9LFxuICAgIGZpbGVwYXRoOiB7XG4gICAgICBzaW5jZTogXCIxLjQuMFwiLFxuICAgICAgY2F0ZWdvcnk6IENBVEVHT1JZX1NQRUNJQUwsXG4gICAgICB0eXBlOiBcInBhdGhcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlNwZWNpZnkgdGhlIGlucHV0IGZpbGVwYXRoLiBUaGlzIHdpbGwgYmUgdXNlZCB0byBkbyBwYXJzZXIgaW5mZXJlbmNlLlwiLFxuICAgICAgY2xpTmFtZTogXCJzdGRpbi1maWxlcGF0aFwiLFxuICAgICAgY2xpQ2F0ZWdvcnk6IENBVEVHT1JZX09USEVSLFxuICAgICAgY2xpRGVzY3JpcHRpb246IFwiUGF0aCB0byB0aGUgZmlsZSB0byBwcmV0ZW5kIHRoYXQgc3RkaW4gY29tZXMgZnJvbS5cIlxuICAgIH0sXG4gICAgaW5zZXJ0UHJhZ21hOiB7XG4gICAgICBzaW5jZTogXCIxLjguMFwiLFxuICAgICAgY2F0ZWdvcnk6IENBVEVHT1JZX1NQRUNJQUwsXG4gICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgZGVzY3JpcHRpb246IFwiSW5zZXJ0IEBmb3JtYXQgcHJhZ21hIGludG8gZmlsZSdzIGZpcnN0IGRvY2Jsb2NrIGNvbW1lbnQuXCIsXG4gICAgICBjbGlDYXRlZ29yeTogQ0FURUdPUllfT1RIRVJcbiAgICB9LFxuICAgIHBhcnNlcjoge1xuICAgICAgc2luY2U6IFwiMC4wLjEwXCIsXG4gICAgICBjYXRlZ29yeTogQ0FURUdPUllfR0xPQkFMLFxuICAgICAgdHlwZTogXCJjaG9pY2VcIixcbiAgICAgIGRlZmF1bHQ6IFt7XG4gICAgICAgIHNpbmNlOiBcIjAuMC4xMFwiLFxuICAgICAgICB2YWx1ZTogXCJiYWJ5bG9uXCJcbiAgICAgIH0sIHtcbiAgICAgICAgc2luY2U6IFwiMS4xMy4wXCIsXG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgIH1dLFxuICAgICAgZGVzY3JpcHRpb246IFwiV2hpY2ggcGFyc2VyIHRvIHVzZS5cIixcbiAgICAgIGV4Y2VwdGlvbjogZnVuY3Rpb24gZXhjZXB0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICB9LFxuICAgICAgY2hvaWNlczogW3tcbiAgICAgICAgdmFsdWU6IFwiZmxvd1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJGbG93XCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwiYmFieWxvblwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJKYXZhU2NyaXB0XCIsXG4gICAgICAgIGRlcHJlY2F0ZWQ6IFwiMS4xNi4wXCIsXG4gICAgICAgIHJlZGlyZWN0OiBcImJhYmVsXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwiYmFiZWxcIixcbiAgICAgICAgc2luY2U6IFwiMS4xNi4wXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkphdmFTY3JpcHRcIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJiYWJlbC1mbG93XCIsXG4gICAgICAgIHNpbmNlOiBcIjEuMTYuMFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJGbG93XCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwidHlwZXNjcmlwdFwiLFxuICAgICAgICBzaW5jZTogXCIxLjQuMFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJUeXBlU2NyaXB0XCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwiY3NzXCIsXG4gICAgICAgIHNpbmNlOiBcIjEuNy4xXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkNTU1wiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcInBvc3Rjc3NcIixcbiAgICAgICAgc2luY2U6IFwiMS40LjBcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiQ1NTL0xlc3MvU0NTU1wiLFxuICAgICAgICBkZXByZWNhdGVkOiBcIjEuNy4xXCIsXG4gICAgICAgIHJlZGlyZWN0OiBcImNzc1wiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcImxlc3NcIixcbiAgICAgICAgc2luY2U6IFwiMS43LjFcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiTGVzc1wiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcInNjc3NcIixcbiAgICAgICAgc2luY2U6IFwiMS43LjFcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiU0NTU1wiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcImpzb25cIixcbiAgICAgICAgc2luY2U6IFwiMS41LjBcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiSlNPTlwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcImpzb241XCIsXG4gICAgICAgIHNpbmNlOiBcIjEuMTMuMFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJKU09ONVwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcImpzb24tc3RyaW5naWZ5XCIsXG4gICAgICAgIHNpbmNlOiBcIjEuMTMuMFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJKU09OLnN0cmluZ2lmeVwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcImdyYXBocWxcIixcbiAgICAgICAgc2luY2U6IFwiMS41LjBcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiR3JhcGhRTFwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcIm1hcmtkb3duXCIsXG4gICAgICAgIHNpbmNlOiBcIjEuOC4wXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIk1hcmtkb3duXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwibWR4XCIsXG4gICAgICAgIHNpbmNlOiBcIjEuMTUuMFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJNRFhcIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJ2dWVcIixcbiAgICAgICAgc2luY2U6IFwiMS4xMC4wXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlZ1ZVwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcInlhbWxcIixcbiAgICAgICAgc2luY2U6IFwiMS4xNC4wXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIllBTUxcIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJnbGltbWVyXCIsXG4gICAgICAgIHNpbmNlOiBudWxsLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJIYW5kbGViYXJzXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwiaHRtbFwiLFxuICAgICAgICBzaW5jZTogXCIxLjE1LjBcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiSFRNTFwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcImFuZ3VsYXJcIixcbiAgICAgICAgc2luY2U6IFwiMS4xNS4wXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkFuZ3VsYXJcIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJsd2NcIixcbiAgICAgICAgc2luY2U6IFwiMS4xNy4wXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkxpZ2h0bmluZyBXZWIgQ29tcG9uZW50c1wiXG4gICAgICB9XVxuICAgIH0sXG4gICAgcGx1Z2luczoge1xuICAgICAgc2luY2U6IFwiMS4xMC4wXCIsXG4gICAgICB0eXBlOiBcInBhdGhcIixcbiAgICAgIGFycmF5OiB0cnVlLFxuICAgICAgZGVmYXVsdDogW3tcbiAgICAgICAgdmFsdWU6IFtdXG4gICAgICB9XSxcbiAgICAgIGNhdGVnb3J5OiBDQVRFR09SWV9HTE9CQUwsXG4gICAgICBkZXNjcmlwdGlvbjogXCJBZGQgYSBwbHVnaW4uIE11bHRpcGxlIHBsdWdpbnMgY2FuIGJlIHBhc3NlZCBhcyBzZXBhcmF0ZSBgLS1wbHVnaW5gcy5cIixcbiAgICAgIGV4Y2VwdGlvbjogZnVuY3Rpb24gZXhjZXB0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgX3R5cGVvZih2YWx1ZSkgPT09IFwib2JqZWN0XCI7XG4gICAgICB9LFxuICAgICAgY2xpTmFtZTogXCJwbHVnaW5cIixcbiAgICAgIGNsaUNhdGVnb3J5OiBDQVRFR09SWV9DT05GSUdcbiAgICB9LFxuICAgIHBsdWdpblNlYXJjaERpcnM6IHtcbiAgICAgIHNpbmNlOiBcIjEuMTMuMFwiLFxuICAgICAgdHlwZTogXCJwYXRoXCIsXG4gICAgICBhcnJheTogdHJ1ZSxcbiAgICAgIGRlZmF1bHQ6IFt7XG4gICAgICAgIHZhbHVlOiBbXVxuICAgICAgfV0sXG4gICAgICBjYXRlZ29yeTogQ0FURUdPUllfR0xPQkFMLFxuICAgICAgZGVzY3JpcHRpb246IGRlZGVudF8xKF90ZW1wbGF0ZU9iamVjdDMoKSksXG4gICAgICBleGNlcHRpb246IGZ1bmN0aW9uIGV4Y2VwdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IF90eXBlb2YodmFsdWUpID09PSBcIm9iamVjdFwiO1xuICAgICAgfSxcbiAgICAgIGNsaU5hbWU6IFwicGx1Z2luLXNlYXJjaC1kaXJcIixcbiAgICAgIGNsaUNhdGVnb3J5OiBDQVRFR09SWV9DT05GSUdcbiAgICB9LFxuICAgIHByaW50V2lkdGg6IHtcbiAgICAgIHNpbmNlOiBcIjAuMC4wXCIsXG4gICAgICBjYXRlZ29yeTogQ0FURUdPUllfR0xPQkFMLFxuICAgICAgdHlwZTogXCJpbnRcIixcbiAgICAgIGRlZmF1bHQ6IDgwLFxuICAgICAgZGVzY3JpcHRpb246IFwiVGhlIGxpbmUgbGVuZ3RoIHdoZXJlIFByZXR0aWVyIHdpbGwgdHJ5IHdyYXAuXCIsXG4gICAgICByYW5nZToge1xuICAgICAgICBzdGFydDogMCxcbiAgICAgICAgZW5kOiBJbmZpbml0eSxcbiAgICAgICAgc3RlcDogMVxuICAgICAgfVxuICAgIH0sXG4gICAgcmFuZ2VFbmQ6IHtcbiAgICAgIHNpbmNlOiBcIjEuNC4wXCIsXG4gICAgICBjYXRlZ29yeTogQ0FURUdPUllfU1BFQ0lBTCxcbiAgICAgIHR5cGU6IFwiaW50XCIsXG4gICAgICBkZWZhdWx0OiBJbmZpbml0eSxcbiAgICAgIHJhbmdlOiB7XG4gICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICBlbmQ6IEluZmluaXR5LFxuICAgICAgICBzdGVwOiAxXG4gICAgICB9LFxuICAgICAgZGVzY3JpcHRpb246IGRlZGVudF8xKF90ZW1wbGF0ZU9iamVjdDQoKSksXG4gICAgICBjbGlDYXRlZ29yeTogQ0FURUdPUllfRURJVE9SXG4gICAgfSxcbiAgICByYW5nZVN0YXJ0OiB7XG4gICAgICBzaW5jZTogXCIxLjQuMFwiLFxuICAgICAgY2F0ZWdvcnk6IENBVEVHT1JZX1NQRUNJQUwsXG4gICAgICB0eXBlOiBcImludFwiLFxuICAgICAgZGVmYXVsdDogMCxcbiAgICAgIHJhbmdlOiB7XG4gICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICBlbmQ6IEluZmluaXR5LFxuICAgICAgICBzdGVwOiAxXG4gICAgICB9LFxuICAgICAgZGVzY3JpcHRpb246IGRlZGVudF8xKF90ZW1wbGF0ZU9iamVjdDUoKSksXG4gICAgICBjbGlDYXRlZ29yeTogQ0FURUdPUllfRURJVE9SXG4gICAgfSxcbiAgICByZXF1aXJlUHJhZ21hOiB7XG4gICAgICBzaW5jZTogXCIxLjcuMFwiLFxuICAgICAgY2F0ZWdvcnk6IENBVEVHT1JZX1NQRUNJQUwsXG4gICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgZGVzY3JpcHRpb246IGRlZGVudF8xKF90ZW1wbGF0ZU9iamVjdDYoKSksXG4gICAgICBjbGlDYXRlZ29yeTogQ0FURUdPUllfT1RIRVJcbiAgICB9LFxuICAgIHRhYldpZHRoOiB7XG4gICAgICB0eXBlOiBcImludFwiLFxuICAgICAgY2F0ZWdvcnk6IENBVEVHT1JZX0dMT0JBTCxcbiAgICAgIGRlZmF1bHQ6IDIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJOdW1iZXIgb2Ygc3BhY2VzIHBlciBpbmRlbnRhdGlvbiBsZXZlbC5cIixcbiAgICAgIHJhbmdlOiB7XG4gICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICBlbmQ6IEluZmluaXR5LFxuICAgICAgICBzdGVwOiAxXG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VGbG93UGFyc2VyOiB7XG4gICAgICBzaW5jZTogXCIwLjAuMFwiLFxuICAgICAgY2F0ZWdvcnk6IENBVEVHT1JZX0dMT0JBTCxcbiAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgZGVmYXVsdDogW3tcbiAgICAgICAgc2luY2U6IFwiMC4wLjBcIixcbiAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHNpbmNlOiBcIjEuMTUuMFwiLFxuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICB9XSxcbiAgICAgIGRlcHJlY2F0ZWQ6IFwiMC4wLjEwXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJVc2UgZmxvdyBwYXJzZXIuXCIsXG4gICAgICByZWRpcmVjdDoge1xuICAgICAgICBvcHRpb246IFwicGFyc2VyXCIsXG4gICAgICAgIHZhbHVlOiBcImZsb3dcIlxuICAgICAgfSxcbiAgICAgIGNsaU5hbWU6IFwiZmxvdy1wYXJzZXJcIlxuICAgIH0sXG4gICAgdXNlVGFiczoge1xuICAgICAgc2luY2U6IFwiMS4wLjBcIixcbiAgICAgIGNhdGVnb3J5OiBDQVRFR09SWV9HTE9CQUwsXG4gICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgZGVzY3JpcHRpb246IFwiSW5kZW50IHdpdGggdGFicyBpbnN0ZWFkIG9mIHNwYWNlcy5cIlxuICAgIH1cbiAgfTtcbiAgdmFyIGNvcmVPcHRpb25zID0ge1xuICAgIENBVEVHT1JZX0NPTkZJRzogQ0FURUdPUllfQ09ORklHLFxuICAgIENBVEVHT1JZX0VESVRPUjogQ0FURUdPUllfRURJVE9SLFxuICAgIENBVEVHT1JZX0ZPUk1BVDogQ0FURUdPUllfRk9STUFULFxuICAgIENBVEVHT1JZX09USEVSOiBDQVRFR09SWV9PVEhFUixcbiAgICBDQVRFR09SWV9PVVRQVVQ6IENBVEVHT1JZX09VVFBVVCxcbiAgICBDQVRFR09SWV9HTE9CQUw6IENBVEVHT1JZX0dMT0JBTCxcbiAgICBDQVRFR09SWV9TUEVDSUFMOiBDQVRFR09SWV9TUEVDSUFMLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfTtcblxuICB2YXIgcmVxdWlyZSQkMCA9IGdldENqc0V4cG9ydEZyb21OYW1lc3BhY2UoX3BhY2thZ2UkMSk7XG5cbiAgdmFyIGN1cnJlbnRWZXJzaW9uID0gcmVxdWlyZSQkMC52ZXJzaW9uO1xuICB2YXIgY29yZU9wdGlvbnMkMSA9IGNvcmVPcHRpb25zLm9wdGlvbnM7XG5cbiAgZnVuY3Rpb24gZ2V0U3VwcG9ydEluZm8odmVyc2lvbiwgb3B0cykge1xuICAgIG9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIHBsdWdpbnM6IFtdLFxuICAgICAgc2hvd1VucmVsZWFzZWQ6IGZhbHNlLFxuICAgICAgc2hvd0RlcHJlY2F0ZWQ6IGZhbHNlLFxuICAgICAgc2hvd0ludGVybmFsOiBmYWxzZVxuICAgIH0sIG9wdHMpO1xuXG4gICAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgICAvLyBwcmUtcmVsZWFzZSB2ZXJzaW9uIGlzIHNtYWxsZXIgdGhhbiB0aGUgbm9ybWFsIHZlcnNpb24gaW4gc2VtdmVyLFxuICAgICAgLy8gd2UgbmVlZCB0byB0cmVhdCBpdCBhcyB0aGUgbm9ybWFsIG9uZSBzbyBhcyB0byB0ZXN0IG5ldyBmZWF0dXJlcy5cbiAgICAgIHZlcnNpb24gPSBjdXJyZW50VmVyc2lvbi5zcGxpdChcIi1cIiwgMSlbMF07XG4gICAgfVxuXG4gICAgdmFyIHBsdWdpbnMgPSBvcHRzLnBsdWdpbnM7XG4gICAgdmFyIG9wdGlvbnMgPSBhcnJheWlmeShPYmplY3QuYXNzaWduKHBsdWdpbnMucmVkdWNlKGZ1bmN0aW9uIChjdXJyZW50T3B0aW9ucywgcGx1Z2luKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihjdXJyZW50T3B0aW9ucywgcGx1Z2luLm9wdGlvbnMpO1xuICAgIH0sIHt9KSwgY29yZU9wdGlvbnMkMSksIFwibmFtZVwiKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5uYW1lID09PSBiLm5hbWUgPyAwIDogYS5uYW1lIDwgYi5uYW1lID8gLTEgOiAxO1xuICAgIH0pLmZpbHRlcihmaWx0ZXJTaW5jZSkuZmlsdGVyKGZpbHRlckRlcHJlY2F0ZWQpLm1hcChtYXBEZXByZWNhdGVkKS5tYXAobWFwSW50ZXJuYWwpLm1hcChmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICB2YXIgbmV3T3B0aW9uID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9uKTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobmV3T3B0aW9uLmRlZmF1bHQpKSB7XG4gICAgICAgIG5ld09wdGlvbi5kZWZhdWx0ID0gbmV3T3B0aW9uLmRlZmF1bHQubGVuZ3RoID09PSAxID8gbmV3T3B0aW9uLmRlZmF1bHRbMF0udmFsdWUgOiBuZXdPcHRpb24uZGVmYXVsdC5maWx0ZXIoZmlsdGVyU2luY2UpLnNvcnQoZnVuY3Rpb24gKGluZm8xLCBpbmZvMikge1xuICAgICAgICAgIHJldHVybiBzZW12ZXIuY29tcGFyZShpbmZvMi5zaW5jZSwgaW5mbzEuc2luY2UpO1xuICAgICAgICB9KVswXS52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobmV3T3B0aW9uLmNob2ljZXMpKSB7XG4gICAgICAgIG5ld09wdGlvbi5jaG9pY2VzID0gbmV3T3B0aW9uLmNob2ljZXMuZmlsdGVyKGZpbHRlclNpbmNlKS5maWx0ZXIoZmlsdGVyRGVwcmVjYXRlZCkubWFwKG1hcERlcHJlY2F0ZWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3T3B0aW9uO1xuICAgIH0pLm1hcChmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICB2YXIgZmlsdGVyZWRQbHVnaW5zID0gcGx1Z2lucy5maWx0ZXIoZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICByZXR1cm4gcGx1Z2luLmRlZmF1bHRPcHRpb25zICYmIHBsdWdpbi5kZWZhdWx0T3B0aW9uc1tvcHRpb24ubmFtZV0gIT09IHVuZGVmaW5lZDtcbiAgICAgIH0pO1xuICAgICAgdmFyIHBsdWdpbkRlZmF1bHRzID0gZmlsdGVyZWRQbHVnaW5zLnJlZHVjZShmdW5jdGlvbiAocmVkdWNlZCwgcGx1Z2luKSB7XG4gICAgICAgIHJlZHVjZWRbcGx1Z2luLm5hbWVdID0gcGx1Z2luLmRlZmF1bHRPcHRpb25zW29wdGlvbi5uYW1lXTtcbiAgICAgICAgcmV0dXJuIHJlZHVjZWQ7XG4gICAgICB9LCB7fSk7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihvcHRpb24sIHtcbiAgICAgICAgcGx1Z2luRGVmYXVsdHM6IHBsdWdpbkRlZmF1bHRzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgdXNlUG9zdENzc1BhcnNlciA9IHNlbXZlci5sdCh2ZXJzaW9uLCBcIjEuNy4xXCIpO1xuICAgIHZhciB1c2VCYWJ5bG9uUGFyc2VyID0gc2VtdmVyLmx0KHZlcnNpb24sIFwiMS4xNi4wXCIpO1xuICAgIHZhciBsYW5ndWFnZXMgPSBwbHVnaW5zLnJlZHVjZShmdW5jdGlvbiAoYWxsLCBwbHVnaW4pIHtcbiAgICAgIHJldHVybiBhbGwuY29uY2F0KHBsdWdpbi5sYW5ndWFnZXMgfHwgW10pO1xuICAgIH0sIFtdKS5maWx0ZXIoZmlsdGVyU2luY2UpLm1hcChmdW5jdGlvbiAobGFuZ3VhZ2UpIHtcbiAgICAgIC8vIFByZXZlbnQgYnJlYWtpbmcgY2hhbmdlc1xuICAgICAgaWYgKGxhbmd1YWdlLm5hbWUgPT09IFwiTWFya2Rvd25cIikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbGFuZ3VhZ2UsIHtcbiAgICAgICAgICBwYXJzZXJzOiBbXCJtYXJrZG93blwiXVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxhbmd1YWdlLm5hbWUgPT09IFwiVHlwZVNjcmlwdFwiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBsYW5ndWFnZSwge1xuICAgICAgICAgIHBhcnNlcnM6IFtcInR5cGVzY3JpcHRcIl1cbiAgICAgICAgfSk7XG4gICAgICB9IC8vIFwiYmFieWxvblwiIHdhcyByZW5hbWVkIHRvIFwiYmFiZWxcIiBpbiAxLjE2LjBcblxuXG4gICAgICBpZiAodXNlQmFieWxvblBhcnNlciAmJiBsYW5ndWFnZS5wYXJzZXJzLmluZGV4T2YoXCJiYWJlbFwiKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGxhbmd1YWdlLCB7XG4gICAgICAgICAgcGFyc2VyczogbGFuZ3VhZ2UucGFyc2Vycy5tYXAoZnVuY3Rpb24gKHBhcnNlcikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlciA9PT0gXCJiYWJlbFwiID8gXCJiYWJ5bG9uXCIgOiBwYXJzZXI7XG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh1c2VQb3N0Q3NzUGFyc2VyICYmIChsYW5ndWFnZS5uYW1lID09PSBcIkNTU1wiIHx8IGxhbmd1YWdlLmdyb3VwID09PSBcIkNTU1wiKSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbGFuZ3VhZ2UsIHtcbiAgICAgICAgICBwYXJzZXJzOiBbXCJwb3N0Y3NzXCJdXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGFuZ3VhZ2U7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhbmd1YWdlczogbGFuZ3VhZ2VzLFxuICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBmaWx0ZXJTaW5jZShvYmplY3QpIHtcbiAgICAgIHJldHVybiBvcHRzLnNob3dVbnJlbGVhc2VkIHx8ICEoXCJzaW5jZVwiIGluIG9iamVjdCkgfHwgb2JqZWN0LnNpbmNlICYmIHNlbXZlci5ndGUodmVyc2lvbiwgb2JqZWN0LnNpbmNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWx0ZXJEZXByZWNhdGVkKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9wdHMuc2hvd0RlcHJlY2F0ZWQgfHwgIShcImRlcHJlY2F0ZWRcIiBpbiBvYmplY3QpIHx8IG9iamVjdC5kZXByZWNhdGVkICYmIHNlbXZlci5sdCh2ZXJzaW9uLCBvYmplY3QuZGVwcmVjYXRlZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFwRGVwcmVjYXRlZChvYmplY3QpIHtcbiAgICAgIGlmICghb2JqZWN0LmRlcHJlY2F0ZWQgfHwgb3B0cy5zaG93RGVwcmVjYXRlZCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3T2JqZWN0ID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqZWN0KTtcbiAgICAgIGRlbGV0ZSBuZXdPYmplY3QuZGVwcmVjYXRlZDtcbiAgICAgIGRlbGV0ZSBuZXdPYmplY3QucmVkaXJlY3Q7XG4gICAgICByZXR1cm4gbmV3T2JqZWN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcEludGVybmFsKG9iamVjdCkge1xuICAgICAgaWYgKG9wdHMuc2hvd0ludGVybmFsKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdPYmplY3QgPSBPYmplY3QuYXNzaWduKHt9LCBvYmplY3QpO1xuICAgICAgZGVsZXRlIG5ld09iamVjdC5jbGlOYW1lO1xuICAgICAgZGVsZXRlIG5ld09iamVjdC5jbGlDYXRlZ29yeTtcbiAgICAgIGRlbGV0ZSBuZXdPYmplY3QuY2xpRGVzY3JpcHRpb247XG4gICAgICByZXR1cm4gbmV3T2JqZWN0O1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdXBwb3J0ID0ge1xuICAgIGdldFN1cHBvcnRJbmZvOiBnZXRTdXBwb3J0SW5mb1xuICB9O1xuXG4gIC8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG4gIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbiAgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcbiAgVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gIEtJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuICBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG4gIE1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG4gIFNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG4gIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4gIC8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXG4gIHZhciBfZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIGV4dGVuZFN0YXRpY3MoZCwgYikge1xuICAgIF9leHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHtcbiAgICAgIF9fcHJvdG9fXzogW11cbiAgICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGQuX19wcm90b19fID0gYjtcbiAgICB9IHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGIpIHtcbiAgICAgICAgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gX2V4dGVuZFN0YXRpY3MoZCwgYik7XG4gIH07XG5cbiAgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgICBfZXh0ZW5kU3RhdGljcyhkLCBiKTtcblxuICAgIGZ1bmN0aW9uIF9fKCkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gICAgfVxuXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9XG5cbiAgdmFyIF9hc3NpZ24gPSBmdW5jdGlvbiBfX2Fzc2lnbigpIHtcbiAgICBfYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgICBmb3IgKHZhciBwIGluIHMpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF9hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuXG4gICAgZm9yICh2YXIgcCBpbiBzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApIHRbcF0gPSBzW3BdO1xuICAgIH1cblxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIikgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKSB0W3BbaV1dID0gc1twW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsXG4gICAgICAgIGQ7XG4gICAgaWYgKCh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKFJlZmxlY3QpKSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7ZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICB9XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbiAgfVxuICBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XG4gICAgaWYgKCh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKFJlZmxlY3QpKSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgICB9XG5cbiAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7XG4gICAgICBsYWJlbDogMCxcbiAgICAgIHNlbnQ6IGZ1bmN0aW9uIHNlbnQoKSB7XG4gICAgICAgIGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTtcbiAgICAgICAgcmV0dXJuIHRbMV07XG4gICAgICB9LFxuICAgICAgdHJ5czogW10sXG4gICAgICBvcHM6IFtdXG4gICAgfSxcbiAgICAgICAgZixcbiAgICAgICAgeSxcbiAgICAgICAgdCxcbiAgICAgICAgZztcbiAgICByZXR1cm4gZyA9IHtcbiAgICAgIG5leHQ6IHZlcmIoMCksXG4gICAgICBcInRocm93XCI6IHZlcmIoMSksXG4gICAgICBcInJldHVyblwiOiB2ZXJiKDIpXG4gICAgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KSwgZztcblxuICAgIGZ1bmN0aW9uIHZlcmIobikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBzdGVwKFtuLCB2XSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcblxuICAgICAgd2hpbGUgKF8pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuXG4gICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3BbMV0sXG4gICAgICAgICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICAgIHkgPSBvcFsxXTtcbiAgICAgICAgICAgICAgb3AgPSBbMF07XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIG9wID0gXy5vcHMucG9wKCk7XG5cbiAgICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkge1xuICAgICAgICAgICAgICAgIF8gPSAwO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCBvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkge1xuICAgICAgICAgICAgICAgIF8ubGFiZWwgPSBvcFsxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkge1xuICAgICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzFdO1xuICAgICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7XG4gICAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMl07XG5cbiAgICAgICAgICAgICAgICBfLm9wcy5wdXNoKG9wKTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuXG4gICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcblxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIG9wID0gWzYsIGVdO1xuICAgICAgICAgIHkgPSAwO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGYgPSB0ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkge1xuICAgICAgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gX192YWx1ZXMobykge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSxcbiAgICAgICAgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IG8gJiYgb1tpKytdLFxuICAgICAgICAgIGRvbmU6ICFvXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBfX3JlYWQobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLFxuICAgICAgICByLFxuICAgICAgICBhciA9IFtdLFxuICAgICAgICBlO1xuXG4gICAgdHJ5IHtcbiAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIGFyLnB1c2goci52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGUgPSB7XG4gICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZSkgdGhyb3cgZS5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXI7XG4gIH1cbiAgZnVuY3Rpb24gX19zcHJlYWQoKSB7XG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXI7XG4gIH1cbiAgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKykge1xuICAgICAgICByW2tdID0gYVtqXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfVxuICBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcbiAgfVxuICBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksXG4gICAgICAgIGksXG4gICAgICAgIHEgPSBbXTtcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIGk7XG5cbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHtcbiAgICAgIGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdbbl0odikpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzZXR0bGUocVswXVszXSwgZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7XG4gICAgICByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7XG4gICAgICByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHtcbiAgICAgIHJlc3VtZShcInRocm93XCIsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikge1xuICAgICAgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XG4gICAgdmFyIGksIHA7XG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhyb3cgZTtcbiAgICB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSwgaTtcblxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikge1xuICAgICAgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gKHAgPSAhcCkgPyB7XG4gICAgICAgICAgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksXG4gICAgICAgICAgZG9uZTogbiA9PT0gXCJyZXR1cm5cIlxuICAgICAgICB9IDogZiA/IGYodikgOiB2O1xuICAgICAgfSA6IGY7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSxcbiAgICAgICAgaTtcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSwgaSk7XG5cbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHtcbiAgICAgIGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7XG4gICAgICBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbiAodikge1xuICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICB2YWx1ZTogdixcbiAgICAgICAgICBkb25lOiBkXG4gICAgICAgIH0pO1xuICAgICAgfSwgcmVqZWN0KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7XG4gICAgICAgIHZhbHVlOiByYXdcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb29rZWQucmF3ID0gcmF3O1xuICAgIH1cblxuICAgIHJldHVybiBjb29rZWQ7XG4gIH1cbiAgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIHtcbiAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgfVxuICAgIHJlc3VsdC5kZWZhdWx0ID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xuICAgIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7XG4gICAgICBkZWZhdWx0OiBtb2RcbiAgICB9O1xuICB9XG5cbiAgdmFyIHRzbGliX2VzNiA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgX19leHRlbmRzOiBfX2V4dGVuZHMsXG4gICAgZ2V0IF9fYXNzaWduICgpIHsgcmV0dXJuIF9hc3NpZ247IH0sXG4gICAgX19yZXN0OiBfX3Jlc3QsXG4gICAgX19kZWNvcmF0ZTogX19kZWNvcmF0ZSxcbiAgICBfX3BhcmFtOiBfX3BhcmFtLFxuICAgIF9fbWV0YWRhdGE6IF9fbWV0YWRhdGEsXG4gICAgX19hd2FpdGVyOiBfX2F3YWl0ZXIsXG4gICAgX19nZW5lcmF0b3I6IF9fZ2VuZXJhdG9yLFxuICAgIF9fZXhwb3J0U3RhcjogX19leHBvcnRTdGFyLFxuICAgIF9fdmFsdWVzOiBfX3ZhbHVlcyxcbiAgICBfX3JlYWQ6IF9fcmVhZCxcbiAgICBfX3NwcmVhZDogX19zcHJlYWQsXG4gICAgX19zcHJlYWRBcnJheXM6IF9fc3ByZWFkQXJyYXlzLFxuICAgIF9fYXdhaXQ6IF9fYXdhaXQsXG4gICAgX19hc3luY0dlbmVyYXRvcjogX19hc3luY0dlbmVyYXRvcixcbiAgICBfX2FzeW5jRGVsZWdhdG9yOiBfX2FzeW5jRGVsZWdhdG9yLFxuICAgIF9fYXN5bmNWYWx1ZXM6IF9fYXN5bmNWYWx1ZXMsXG4gICAgX19tYWtlVGVtcGxhdGVPYmplY3Q6IF9fbWFrZVRlbXBsYXRlT2JqZWN0LFxuICAgIF9faW1wb3J0U3RhcjogX19pbXBvcnRTdGFyLFxuICAgIF9faW1wb3J0RGVmYXVsdDogX19pbXBvcnREZWZhdWx0XG4gIH0pO1xuXG4gIHZhciBhcGkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgZXhwb3J0cy5hcGlEZXNjcmlwdG9yID0ge1xuICAgICAga2V5OiBmdW5jdGlvbiBrZXkoX2tleSkge1xuICAgICAgICByZXR1cm4gL15bJF9hLXpBLVpdWyRfYS16QS1aMC05XSokLy50ZXN0KF9rZXkpID8gX2tleSA6IEpTT04uc3RyaW5naWZ5KF9rZXkpO1xuICAgICAgfSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShfdmFsdWUpIHtcbiAgICAgICAgaWYgKF92YWx1ZSA9PT0gbnVsbCB8fCBfdHlwZW9mKF92YWx1ZSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KF92YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShfdmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIFwiW1wiLmNvbmNhdChfdmFsdWUubWFwKGZ1bmN0aW9uIChzdWJWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuYXBpRGVzY3JpcHRvci52YWx1ZShzdWJWYWx1ZSk7XG4gICAgICAgICAgfSkuam9pbignLCAnKSwgXCJdXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhfdmFsdWUpO1xuICAgICAgICByZXR1cm4ga2V5cy5sZW5ndGggPT09IDAgPyAne30nIDogXCJ7IFwiLmNvbmNhdChrZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGV4cG9ydHMuYXBpRGVzY3JpcHRvci5rZXkoa2V5KSwgXCI6IFwiKS5jb25jYXQoZXhwb3J0cy5hcGlEZXNjcmlwdG9yLnZhbHVlKF92YWx1ZVtrZXldKSk7XG4gICAgICAgIH0pLmpvaW4oJywgJyksIFwiIH1cIik7XG4gICAgICB9LFxuICAgICAgcGFpcjogZnVuY3Rpb24gcGFpcihfcmVmKSB7XG4gICAgICAgIHZhciBrZXkgPSBfcmVmLmtleSxcbiAgICAgICAgICAgIHZhbHVlID0gX3JlZi52YWx1ZTtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuYXBpRGVzY3JpcHRvci52YWx1ZShfZGVmaW5lUHJvcGVydHkoe30sIGtleSwgdmFsdWUpKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgdW53cmFwRXhwb3J0cyhhcGkpO1xuICB2YXIgYXBpXzEgPSBhcGkuYXBpRGVzY3JpcHRvcjtcblxuICB2YXIgdHNsaWJfMSA9IGdldENqc0V4cG9ydEZyb21OYW1lc3BhY2UodHNsaWJfZXM2KTtcblxuICB2YXIgZGVzY3JpcHRvcnMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG5cbiAgICB0c2xpYl8xLl9fZXhwb3J0U3RhcihhcGksIGV4cG9ydHMpO1xuICB9KTtcbiAgdW53cmFwRXhwb3J0cyhkZXNjcmlwdG9ycyk7XG5cbiAgdmFyIG1hdGNoT3BlcmF0b3JzUmUgPSAvW3xcXFxce30oKVtcXF1eJCsqPy5dL2c7XG5cbiAgdmFyIGVzY2FwZVN0cmluZ1JlZ2V4cCA9IGZ1bmN0aW9uIGVzY2FwZVN0cmluZ1JlZ2V4cChzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKG1hdGNoT3BlcmF0b3JzUmUsICdcXFxcJCYnKTtcbiAgfTtcblxuICB2YXIgY29sb3JOYW1lID0ge1xuICAgIFwiYWxpY2VibHVlXCI6IFsyNDAsIDI0OCwgMjU1XSxcbiAgICBcImFudGlxdWV3aGl0ZVwiOiBbMjUwLCAyMzUsIDIxNV0sXG4gICAgXCJhcXVhXCI6IFswLCAyNTUsIDI1NV0sXG4gICAgXCJhcXVhbWFyaW5lXCI6IFsxMjcsIDI1NSwgMjEyXSxcbiAgICBcImF6dXJlXCI6IFsyNDAsIDI1NSwgMjU1XSxcbiAgICBcImJlaWdlXCI6IFsyNDUsIDI0NSwgMjIwXSxcbiAgICBcImJpc3F1ZVwiOiBbMjU1LCAyMjgsIDE5Nl0sXG4gICAgXCJibGFja1wiOiBbMCwgMCwgMF0sXG4gICAgXCJibGFuY2hlZGFsbW9uZFwiOiBbMjU1LCAyMzUsIDIwNV0sXG4gICAgXCJibHVlXCI6IFswLCAwLCAyNTVdLFxuICAgIFwiYmx1ZXZpb2xldFwiOiBbMTM4LCA0MywgMjI2XSxcbiAgICBcImJyb3duXCI6IFsxNjUsIDQyLCA0Ml0sXG4gICAgXCJidXJseXdvb2RcIjogWzIyMiwgMTg0LCAxMzVdLFxuICAgIFwiY2FkZXRibHVlXCI6IFs5NSwgMTU4LCAxNjBdLFxuICAgIFwiY2hhcnRyZXVzZVwiOiBbMTI3LCAyNTUsIDBdLFxuICAgIFwiY2hvY29sYXRlXCI6IFsyMTAsIDEwNSwgMzBdLFxuICAgIFwiY29yYWxcIjogWzI1NSwgMTI3LCA4MF0sXG4gICAgXCJjb3JuZmxvd2VyYmx1ZVwiOiBbMTAwLCAxNDksIDIzN10sXG4gICAgXCJjb3Juc2lsa1wiOiBbMjU1LCAyNDgsIDIyMF0sXG4gICAgXCJjcmltc29uXCI6IFsyMjAsIDIwLCA2MF0sXG4gICAgXCJjeWFuXCI6IFswLCAyNTUsIDI1NV0sXG4gICAgXCJkYXJrYmx1ZVwiOiBbMCwgMCwgMTM5XSxcbiAgICBcImRhcmtjeWFuXCI6IFswLCAxMzksIDEzOV0sXG4gICAgXCJkYXJrZ29sZGVucm9kXCI6IFsxODQsIDEzNCwgMTFdLFxuICAgIFwiZGFya2dyYXlcIjogWzE2OSwgMTY5LCAxNjldLFxuICAgIFwiZGFya2dyZWVuXCI6IFswLCAxMDAsIDBdLFxuICAgIFwiZGFya2dyZXlcIjogWzE2OSwgMTY5LCAxNjldLFxuICAgIFwiZGFya2toYWtpXCI6IFsxODksIDE4MywgMTA3XSxcbiAgICBcImRhcmttYWdlbnRhXCI6IFsxMzksIDAsIDEzOV0sXG4gICAgXCJkYXJrb2xpdmVncmVlblwiOiBbODUsIDEwNywgNDddLFxuICAgIFwiZGFya29yYW5nZVwiOiBbMjU1LCAxNDAsIDBdLFxuICAgIFwiZGFya29yY2hpZFwiOiBbMTUzLCA1MCwgMjA0XSxcbiAgICBcImRhcmtyZWRcIjogWzEzOSwgMCwgMF0sXG4gICAgXCJkYXJrc2FsbW9uXCI6IFsyMzMsIDE1MCwgMTIyXSxcbiAgICBcImRhcmtzZWFncmVlblwiOiBbMTQzLCAxODgsIDE0M10sXG4gICAgXCJkYXJrc2xhdGVibHVlXCI6IFs3MiwgNjEsIDEzOV0sXG4gICAgXCJkYXJrc2xhdGVncmF5XCI6IFs0NywgNzksIDc5XSxcbiAgICBcImRhcmtzbGF0ZWdyZXlcIjogWzQ3LCA3OSwgNzldLFxuICAgIFwiZGFya3R1cnF1b2lzZVwiOiBbMCwgMjA2LCAyMDldLFxuICAgIFwiZGFya3Zpb2xldFwiOiBbMTQ4LCAwLCAyMTFdLFxuICAgIFwiZGVlcHBpbmtcIjogWzI1NSwgMjAsIDE0N10sXG4gICAgXCJkZWVwc2t5Ymx1ZVwiOiBbMCwgMTkxLCAyNTVdLFxuICAgIFwiZGltZ3JheVwiOiBbMTA1LCAxMDUsIDEwNV0sXG4gICAgXCJkaW1ncmV5XCI6IFsxMDUsIDEwNSwgMTA1XSxcbiAgICBcImRvZGdlcmJsdWVcIjogWzMwLCAxNDQsIDI1NV0sXG4gICAgXCJmaXJlYnJpY2tcIjogWzE3OCwgMzQsIDM0XSxcbiAgICBcImZsb3JhbHdoaXRlXCI6IFsyNTUsIDI1MCwgMjQwXSxcbiAgICBcImZvcmVzdGdyZWVuXCI6IFszNCwgMTM5LCAzNF0sXG4gICAgXCJmdWNoc2lhXCI6IFsyNTUsIDAsIDI1NV0sXG4gICAgXCJnYWluc2Jvcm9cIjogWzIyMCwgMjIwLCAyMjBdLFxuICAgIFwiZ2hvc3R3aGl0ZVwiOiBbMjQ4LCAyNDgsIDI1NV0sXG4gICAgXCJnb2xkXCI6IFsyNTUsIDIxNSwgMF0sXG4gICAgXCJnb2xkZW5yb2RcIjogWzIxOCwgMTY1LCAzMl0sXG4gICAgXCJncmF5XCI6IFsxMjgsIDEyOCwgMTI4XSxcbiAgICBcImdyZWVuXCI6IFswLCAxMjgsIDBdLFxuICAgIFwiZ3JlZW55ZWxsb3dcIjogWzE3MywgMjU1LCA0N10sXG4gICAgXCJncmV5XCI6IFsxMjgsIDEyOCwgMTI4XSxcbiAgICBcImhvbmV5ZGV3XCI6IFsyNDAsIDI1NSwgMjQwXSxcbiAgICBcImhvdHBpbmtcIjogWzI1NSwgMTA1LCAxODBdLFxuICAgIFwiaW5kaWFucmVkXCI6IFsyMDUsIDkyLCA5Ml0sXG4gICAgXCJpbmRpZ29cIjogWzc1LCAwLCAxMzBdLFxuICAgIFwiaXZvcnlcIjogWzI1NSwgMjU1LCAyNDBdLFxuICAgIFwia2hha2lcIjogWzI0MCwgMjMwLCAxNDBdLFxuICAgIFwibGF2ZW5kZXJcIjogWzIzMCwgMjMwLCAyNTBdLFxuICAgIFwibGF2ZW5kZXJibHVzaFwiOiBbMjU1LCAyNDAsIDI0NV0sXG4gICAgXCJsYXduZ3JlZW5cIjogWzEyNCwgMjUyLCAwXSxcbiAgICBcImxlbW9uY2hpZmZvblwiOiBbMjU1LCAyNTAsIDIwNV0sXG4gICAgXCJsaWdodGJsdWVcIjogWzE3MywgMjE2LCAyMzBdLFxuICAgIFwibGlnaHRjb3JhbFwiOiBbMjQwLCAxMjgsIDEyOF0sXG4gICAgXCJsaWdodGN5YW5cIjogWzIyNCwgMjU1LCAyNTVdLFxuICAgIFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogWzI1MCwgMjUwLCAyMTBdLFxuICAgIFwibGlnaHRncmF5XCI6IFsyMTEsIDIxMSwgMjExXSxcbiAgICBcImxpZ2h0Z3JlZW5cIjogWzE0NCwgMjM4LCAxNDRdLFxuICAgIFwibGlnaHRncmV5XCI6IFsyMTEsIDIxMSwgMjExXSxcbiAgICBcImxpZ2h0cGlua1wiOiBbMjU1LCAxODIsIDE5M10sXG4gICAgXCJsaWdodHNhbG1vblwiOiBbMjU1LCAxNjAsIDEyMl0sXG4gICAgXCJsaWdodHNlYWdyZWVuXCI6IFszMiwgMTc4LCAxNzBdLFxuICAgIFwibGlnaHRza3libHVlXCI6IFsxMzUsIDIwNiwgMjUwXSxcbiAgICBcImxpZ2h0c2xhdGVncmF5XCI6IFsxMTksIDEzNiwgMTUzXSxcbiAgICBcImxpZ2h0c2xhdGVncmV5XCI6IFsxMTksIDEzNiwgMTUzXSxcbiAgICBcImxpZ2h0c3RlZWxibHVlXCI6IFsxNzYsIDE5NiwgMjIyXSxcbiAgICBcImxpZ2h0eWVsbG93XCI6IFsyNTUsIDI1NSwgMjI0XSxcbiAgICBcImxpbWVcIjogWzAsIDI1NSwgMF0sXG4gICAgXCJsaW1lZ3JlZW5cIjogWzUwLCAyMDUsIDUwXSxcbiAgICBcImxpbmVuXCI6IFsyNTAsIDI0MCwgMjMwXSxcbiAgICBcIm1hZ2VudGFcIjogWzI1NSwgMCwgMjU1XSxcbiAgICBcIm1hcm9vblwiOiBbMTI4LCAwLCAwXSxcbiAgICBcIm1lZGl1bWFxdWFtYXJpbmVcIjogWzEwMiwgMjA1LCAxNzBdLFxuICAgIFwibWVkaXVtYmx1ZVwiOiBbMCwgMCwgMjA1XSxcbiAgICBcIm1lZGl1bW9yY2hpZFwiOiBbMTg2LCA4NSwgMjExXSxcbiAgICBcIm1lZGl1bXB1cnBsZVwiOiBbMTQ3LCAxMTIsIDIxOV0sXG4gICAgXCJtZWRpdW1zZWFncmVlblwiOiBbNjAsIDE3OSwgMTEzXSxcbiAgICBcIm1lZGl1bXNsYXRlYmx1ZVwiOiBbMTIzLCAxMDQsIDIzOF0sXG4gICAgXCJtZWRpdW1zcHJpbmdncmVlblwiOiBbMCwgMjUwLCAxNTRdLFxuICAgIFwibWVkaXVtdHVycXVvaXNlXCI6IFs3MiwgMjA5LCAyMDRdLFxuICAgIFwibWVkaXVtdmlvbGV0cmVkXCI6IFsxOTksIDIxLCAxMzNdLFxuICAgIFwibWlkbmlnaHRibHVlXCI6IFsyNSwgMjUsIDExMl0sXG4gICAgXCJtaW50Y3JlYW1cIjogWzI0NSwgMjU1LCAyNTBdLFxuICAgIFwibWlzdHlyb3NlXCI6IFsyNTUsIDIyOCwgMjI1XSxcbiAgICBcIm1vY2Nhc2luXCI6IFsyNTUsIDIyOCwgMTgxXSxcbiAgICBcIm5hdmFqb3doaXRlXCI6IFsyNTUsIDIyMiwgMTczXSxcbiAgICBcIm5hdnlcIjogWzAsIDAsIDEyOF0sXG4gICAgXCJvbGRsYWNlXCI6IFsyNTMsIDI0NSwgMjMwXSxcbiAgICBcIm9saXZlXCI6IFsxMjgsIDEyOCwgMF0sXG4gICAgXCJvbGl2ZWRyYWJcIjogWzEwNywgMTQyLCAzNV0sXG4gICAgXCJvcmFuZ2VcIjogWzI1NSwgMTY1LCAwXSxcbiAgICBcIm9yYW5nZXJlZFwiOiBbMjU1LCA2OSwgMF0sXG4gICAgXCJvcmNoaWRcIjogWzIxOCwgMTEyLCAyMTRdLFxuICAgIFwicGFsZWdvbGRlbnJvZFwiOiBbMjM4LCAyMzIsIDE3MF0sXG4gICAgXCJwYWxlZ3JlZW5cIjogWzE1MiwgMjUxLCAxNTJdLFxuICAgIFwicGFsZXR1cnF1b2lzZVwiOiBbMTc1LCAyMzgsIDIzOF0sXG4gICAgXCJwYWxldmlvbGV0cmVkXCI6IFsyMTksIDExMiwgMTQ3XSxcbiAgICBcInBhcGF5YXdoaXBcIjogWzI1NSwgMjM5LCAyMTNdLFxuICAgIFwicGVhY2hwdWZmXCI6IFsyNTUsIDIxOCwgMTg1XSxcbiAgICBcInBlcnVcIjogWzIwNSwgMTMzLCA2M10sXG4gICAgXCJwaW5rXCI6IFsyNTUsIDE5MiwgMjAzXSxcbiAgICBcInBsdW1cIjogWzIyMSwgMTYwLCAyMjFdLFxuICAgIFwicG93ZGVyYmx1ZVwiOiBbMTc2LCAyMjQsIDIzMF0sXG4gICAgXCJwdXJwbGVcIjogWzEyOCwgMCwgMTI4XSxcbiAgICBcInJlYmVjY2FwdXJwbGVcIjogWzEwMiwgNTEsIDE1M10sXG4gICAgXCJyZWRcIjogWzI1NSwgMCwgMF0sXG4gICAgXCJyb3N5YnJvd25cIjogWzE4OCwgMTQzLCAxNDNdLFxuICAgIFwicm95YWxibHVlXCI6IFs2NSwgMTA1LCAyMjVdLFxuICAgIFwic2FkZGxlYnJvd25cIjogWzEzOSwgNjksIDE5XSxcbiAgICBcInNhbG1vblwiOiBbMjUwLCAxMjgsIDExNF0sXG4gICAgXCJzYW5keWJyb3duXCI6IFsyNDQsIDE2NCwgOTZdLFxuICAgIFwic2VhZ3JlZW5cIjogWzQ2LCAxMzksIDg3XSxcbiAgICBcInNlYXNoZWxsXCI6IFsyNTUsIDI0NSwgMjM4XSxcbiAgICBcInNpZW5uYVwiOiBbMTYwLCA4MiwgNDVdLFxuICAgIFwic2lsdmVyXCI6IFsxOTIsIDE5MiwgMTkyXSxcbiAgICBcInNreWJsdWVcIjogWzEzNSwgMjA2LCAyMzVdLFxuICAgIFwic2xhdGVibHVlXCI6IFsxMDYsIDkwLCAyMDVdLFxuICAgIFwic2xhdGVncmF5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcbiAgICBcInNsYXRlZ3JleVwiOiBbMTEyLCAxMjgsIDE0NF0sXG4gICAgXCJzbm93XCI6IFsyNTUsIDI1MCwgMjUwXSxcbiAgICBcInNwcmluZ2dyZWVuXCI6IFswLCAyNTUsIDEyN10sXG4gICAgXCJzdGVlbGJsdWVcIjogWzcwLCAxMzAsIDE4MF0sXG4gICAgXCJ0YW5cIjogWzIxMCwgMTgwLCAxNDBdLFxuICAgIFwidGVhbFwiOiBbMCwgMTI4LCAxMjhdLFxuICAgIFwidGhpc3RsZVwiOiBbMjE2LCAxOTEsIDIxNl0sXG4gICAgXCJ0b21hdG9cIjogWzI1NSwgOTksIDcxXSxcbiAgICBcInR1cnF1b2lzZVwiOiBbNjQsIDIyNCwgMjA4XSxcbiAgICBcInZpb2xldFwiOiBbMjM4LCAxMzAsIDIzOF0sXG4gICAgXCJ3aGVhdFwiOiBbMjQ1LCAyMjIsIDE3OV0sXG4gICAgXCJ3aGl0ZVwiOiBbMjU1LCAyNTUsIDI1NV0sXG4gICAgXCJ3aGl0ZXNtb2tlXCI6IFsyNDUsIDI0NSwgMjQ1XSxcbiAgICBcInllbGxvd1wiOiBbMjU1LCAyNTUsIDBdLFxuICAgIFwieWVsbG93Z3JlZW5cIjogWzE1NCwgMjA1LCA1MF1cbiAgfTtcblxuICB2YXIgY29udmVyc2lvbnMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgLyogTUlUIGxpY2Vuc2UgKi9cbiAgICAvLyBOT1RFOiBjb252ZXJzaW9ucyBzaG91bGQgb25seSByZXR1cm4gcHJpbWl0aXZlIHZhbHVlcyAoaS5lLiBhcnJheXMsIG9yXG4gICAgLy8gICAgICAgdmFsdWVzIHRoYXQgZ2l2ZSBjb3JyZWN0IGB0eXBlb2ZgIHJlc3VsdHMpLlxuICAgIC8vICAgICAgIGRvIG5vdCB1c2UgYm94IHZhbHVlcyB0eXBlcyAoaS5lLiBOdW1iZXIoKSwgU3RyaW5nKCksIGV0Yy4pXG4gICAgdmFyIHJldmVyc2VLZXl3b3JkcyA9IHt9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIGNvbG9yTmFtZSkge1xuICAgICAgaWYgKGNvbG9yTmFtZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJldmVyc2VLZXl3b3Jkc1tjb2xvck5hbWVba2V5XV0gPSBrZXk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNvbnZlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgIHJnYjoge1xuICAgICAgICBjaGFubmVsczogMyxcbiAgICAgICAgbGFiZWxzOiAncmdiJ1xuICAgICAgfSxcbiAgICAgIGhzbDoge1xuICAgICAgICBjaGFubmVsczogMyxcbiAgICAgICAgbGFiZWxzOiAnaHNsJ1xuICAgICAgfSxcbiAgICAgIGhzdjoge1xuICAgICAgICBjaGFubmVsczogMyxcbiAgICAgICAgbGFiZWxzOiAnaHN2J1xuICAgICAgfSxcbiAgICAgIGh3Yjoge1xuICAgICAgICBjaGFubmVsczogMyxcbiAgICAgICAgbGFiZWxzOiAnaHdiJ1xuICAgICAgfSxcbiAgICAgIGNteWs6IHtcbiAgICAgICAgY2hhbm5lbHM6IDQsXG4gICAgICAgIGxhYmVsczogJ2NteWsnXG4gICAgICB9LFxuICAgICAgeHl6OiB7XG4gICAgICAgIGNoYW5uZWxzOiAzLFxuICAgICAgICBsYWJlbHM6ICd4eXonXG4gICAgICB9LFxuICAgICAgbGFiOiB7XG4gICAgICAgIGNoYW5uZWxzOiAzLFxuICAgICAgICBsYWJlbHM6ICdsYWInXG4gICAgICB9LFxuICAgICAgbGNoOiB7XG4gICAgICAgIGNoYW5uZWxzOiAzLFxuICAgICAgICBsYWJlbHM6ICdsY2gnXG4gICAgICB9LFxuICAgICAgaGV4OiB7XG4gICAgICAgIGNoYW5uZWxzOiAxLFxuICAgICAgICBsYWJlbHM6IFsnaGV4J11cbiAgICAgIH0sXG4gICAgICBrZXl3b3JkOiB7XG4gICAgICAgIGNoYW5uZWxzOiAxLFxuICAgICAgICBsYWJlbHM6IFsna2V5d29yZCddXG4gICAgICB9LFxuICAgICAgYW5zaTE2OiB7XG4gICAgICAgIGNoYW5uZWxzOiAxLFxuICAgICAgICBsYWJlbHM6IFsnYW5zaTE2J11cbiAgICAgIH0sXG4gICAgICBhbnNpMjU2OiB7XG4gICAgICAgIGNoYW5uZWxzOiAxLFxuICAgICAgICBsYWJlbHM6IFsnYW5zaTI1NiddXG4gICAgICB9LFxuICAgICAgaGNnOiB7XG4gICAgICAgIGNoYW5uZWxzOiAzLFxuICAgICAgICBsYWJlbHM6IFsnaCcsICdjJywgJ2cnXVxuICAgICAgfSxcbiAgICAgIGFwcGxlOiB7XG4gICAgICAgIGNoYW5uZWxzOiAzLFxuICAgICAgICBsYWJlbHM6IFsncjE2JywgJ2cxNicsICdiMTYnXVxuICAgICAgfSxcbiAgICAgIGdyYXk6IHtcbiAgICAgICAgY2hhbm5lbHM6IDEsXG4gICAgICAgIGxhYmVsczogWydncmF5J11cbiAgICAgIH1cbiAgICB9OyAvLyBoaWRlIC5jaGFubmVscyBhbmQgLmxhYmVscyBwcm9wZXJ0aWVzXG5cbiAgICBmb3IgKHZhciBtb2RlbCBpbiBjb252ZXJ0KSB7XG4gICAgICBpZiAoY29udmVydC5oYXNPd25Qcm9wZXJ0eShtb2RlbCkpIHtcbiAgICAgICAgaWYgKCEoJ2NoYW5uZWxzJyBpbiBjb252ZXJ0W21vZGVsXSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgY2hhbm5lbHMgcHJvcGVydHk6ICcgKyBtb2RlbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISgnbGFiZWxzJyBpbiBjb252ZXJ0W21vZGVsXSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgY2hhbm5lbCBsYWJlbHMgcHJvcGVydHk6ICcgKyBtb2RlbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udmVydFttb2RlbF0ubGFiZWxzLmxlbmd0aCAhPT0gY29udmVydFttb2RlbF0uY2hhbm5lbHMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoYW5uZWwgYW5kIGxhYmVsIGNvdW50cyBtaXNtYXRjaDogJyArIG1vZGVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGFubmVscyA9IGNvbnZlcnRbbW9kZWxdLmNoYW5uZWxzO1xuICAgICAgICB2YXIgbGFiZWxzID0gY29udmVydFttb2RlbF0ubGFiZWxzO1xuICAgICAgICBkZWxldGUgY29udmVydFttb2RlbF0uY2hhbm5lbHM7XG4gICAgICAgIGRlbGV0ZSBjb252ZXJ0W21vZGVsXS5sYWJlbHM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb252ZXJ0W21vZGVsXSwgJ2NoYW5uZWxzJywge1xuICAgICAgICAgIHZhbHVlOiBjaGFubmVsc1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnZlcnRbbW9kZWxdLCAnbGFiZWxzJywge1xuICAgICAgICAgIHZhbHVlOiBsYWJlbHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29udmVydC5yZ2IuaHNsID0gZnVuY3Rpb24gKHJnYikge1xuICAgICAgdmFyIHIgPSByZ2JbMF0gLyAyNTU7XG4gICAgICB2YXIgZyA9IHJnYlsxXSAvIDI1NTtcbiAgICAgIHZhciBiID0gcmdiWzJdIC8gMjU1O1xuICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgICAgdmFyIGRlbHRhID0gbWF4IC0gbWluO1xuICAgICAgdmFyIGg7XG4gICAgICB2YXIgcztcbiAgICAgIHZhciBsO1xuXG4gICAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgICAgaCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHIgPT09IG1heCkge1xuICAgICAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICAgICAgfSBlbHNlIGlmIChnID09PSBtYXgpIHtcbiAgICAgICAgaCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IG1heCkge1xuICAgICAgICBoID0gNCArIChyIC0gZykgLyBkZWx0YTtcbiAgICAgIH1cblxuICAgICAgaCA9IE1hdGgubWluKGggKiA2MCwgMzYwKTtcblxuICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgIGggKz0gMzYwO1xuICAgICAgfVxuXG4gICAgICBsID0gKG1pbiArIG1heCkgLyAyO1xuXG4gICAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgICAgcyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGwgPD0gMC41KSB7XG4gICAgICAgIHMgPSBkZWx0YSAvIChtYXggKyBtaW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcyA9IGRlbHRhIC8gKDIgLSBtYXggLSBtaW4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW2gsIHMgKiAxMDAsIGwgKiAxMDBdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LnJnYi5oc3YgPSBmdW5jdGlvbiAocmdiKSB7XG4gICAgICB2YXIgciA9IHJnYlswXTtcbiAgICAgIHZhciBnID0gcmdiWzFdO1xuICAgICAgdmFyIGIgPSByZ2JbMl07XG4gICAgICB2YXIgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgICB2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gICAgICB2YXIgZGVsdGEgPSBtYXggLSBtaW47XG4gICAgICB2YXIgaDtcbiAgICAgIHZhciBzO1xuICAgICAgdmFyIHY7XG5cbiAgICAgIGlmIChtYXggPT09IDApIHtcbiAgICAgICAgcyA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzID0gZGVsdGEgLyBtYXggKiAxMDAwIC8gMTA7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXggPT09IG1pbikge1xuICAgICAgICBoID0gMDtcbiAgICAgIH0gZWxzZSBpZiAociA9PT0gbWF4KSB7XG4gICAgICAgIGggPSAoZyAtIGIpIC8gZGVsdGE7XG4gICAgICB9IGVsc2UgaWYgKGcgPT09IG1heCkge1xuICAgICAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gbWF4KSB7XG4gICAgICAgIGggPSA0ICsgKHIgLSBnKSAvIGRlbHRhO1xuICAgICAgfVxuXG4gICAgICBoID0gTWF0aC5taW4oaCAqIDYwLCAzNjApO1xuXG4gICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgaCArPSAzNjA7XG4gICAgICB9XG5cbiAgICAgIHYgPSBtYXggLyAyNTUgKiAxMDAwIC8gMTA7XG4gICAgICByZXR1cm4gW2gsIHMsIHZdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LnJnYi5od2IgPSBmdW5jdGlvbiAocmdiKSB7XG4gICAgICB2YXIgciA9IHJnYlswXTtcbiAgICAgIHZhciBnID0gcmdiWzFdO1xuICAgICAgdmFyIGIgPSByZ2JbMl07XG4gICAgICB2YXIgaCA9IGNvbnZlcnQucmdiLmhzbChyZ2IpWzBdO1xuICAgICAgdmFyIHcgPSAxIC8gMjU1ICogTWF0aC5taW4ociwgTWF0aC5taW4oZywgYikpO1xuICAgICAgYiA9IDEgLSAxIC8gMjU1ICogTWF0aC5tYXgociwgTWF0aC5tYXgoZywgYikpO1xuICAgICAgcmV0dXJuIFtoLCB3ICogMTAwLCBiICogMTAwXTtcbiAgICB9O1xuXG4gICAgY29udmVydC5yZ2IuY215ayA9IGZ1bmN0aW9uIChyZ2IpIHtcbiAgICAgIHZhciByID0gcmdiWzBdIC8gMjU1O1xuICAgICAgdmFyIGcgPSByZ2JbMV0gLyAyNTU7XG4gICAgICB2YXIgYiA9IHJnYlsyXSAvIDI1NTtcbiAgICAgIHZhciBjO1xuICAgICAgdmFyIG07XG4gICAgICB2YXIgeTtcbiAgICAgIHZhciBrO1xuICAgICAgayA9IE1hdGgubWluKDEgLSByLCAxIC0gZywgMSAtIGIpO1xuICAgICAgYyA9ICgxIC0gciAtIGspIC8gKDEgLSBrKSB8fCAwO1xuICAgICAgbSA9ICgxIC0gZyAtIGspIC8gKDEgLSBrKSB8fCAwO1xuICAgICAgeSA9ICgxIC0gYiAtIGspIC8gKDEgLSBrKSB8fCAwO1xuICAgICAgcmV0dXJuIFtjICogMTAwLCBtICogMTAwLCB5ICogMTAwLCBrICogMTAwXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlZSBodHRwczovL2VuLm0ud2lraXBlZGlhLm9yZy93aWtpL0V1Y2xpZGVhbl9kaXN0YW5jZSNTcXVhcmVkX0V1Y2xpZGVhbl9kaXN0YW5jZVxuICAgICAqICovXG5cblxuICAgIGZ1bmN0aW9uIGNvbXBhcmF0aXZlRGlzdGFuY2UoeCwgeSkge1xuICAgICAgcmV0dXJuIE1hdGgucG93KHhbMF0gLSB5WzBdLCAyKSArIE1hdGgucG93KHhbMV0gLSB5WzFdLCAyKSArIE1hdGgucG93KHhbMl0gLSB5WzJdLCAyKTtcbiAgICB9XG5cbiAgICBjb252ZXJ0LnJnYi5rZXl3b3JkID0gZnVuY3Rpb24gKHJnYikge1xuICAgICAgdmFyIHJldmVyc2VkID0gcmV2ZXJzZUtleXdvcmRzW3JnYl07XG5cbiAgICAgIGlmIChyZXZlcnNlZCkge1xuICAgICAgICByZXR1cm4gcmV2ZXJzZWQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50Q2xvc2VzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICB2YXIgY3VycmVudENsb3Nlc3RLZXl3b3JkO1xuXG4gICAgICBmb3IgKHZhciBrZXl3b3JkIGluIGNvbG9yTmFtZSkge1xuICAgICAgICBpZiAoY29sb3JOYW1lLmhhc093blByb3BlcnR5KGtleXdvcmQpKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gY29sb3JOYW1lW2tleXdvcmRdOyAvLyBDb21wdXRlIGNvbXBhcmF0aXZlIGRpc3RhbmNlXG5cbiAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBjb21wYXJhdGl2ZURpc3RhbmNlKHJnYiwgdmFsdWUpOyAvLyBDaGVjayBpZiBpdHMgbGVzcywgaWYgc28gc2V0IGFzIGNsb3Nlc3RcblxuICAgICAgICAgIGlmIChkaXN0YW5jZSA8IGN1cnJlbnRDbG9zZXN0RGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGN1cnJlbnRDbG9zZXN0RGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgICAgIGN1cnJlbnRDbG9zZXN0S2V5d29yZCA9IGtleXdvcmQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdXJyZW50Q2xvc2VzdEtleXdvcmQ7XG4gICAgfTtcblxuICAgIGNvbnZlcnQua2V5d29yZC5yZ2IgPSBmdW5jdGlvbiAoa2V5d29yZCkge1xuICAgICAgcmV0dXJuIGNvbG9yTmFtZVtrZXl3b3JkXTtcbiAgICB9O1xuXG4gICAgY29udmVydC5yZ2IueHl6ID0gZnVuY3Rpb24gKHJnYikge1xuICAgICAgdmFyIHIgPSByZ2JbMF0gLyAyNTU7XG4gICAgICB2YXIgZyA9IHJnYlsxXSAvIDI1NTtcbiAgICAgIHZhciBiID0gcmdiWzJdIC8gMjU1OyAvLyBhc3N1bWUgc1JHQlxuXG4gICAgICByID0gciA+IDAuMDQwNDUgPyBNYXRoLnBvdygociArIDAuMDU1KSAvIDEuMDU1LCAyLjQpIDogciAvIDEyLjkyO1xuICAgICAgZyA9IGcgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKGcgKyAwLjA1NSkgLyAxLjA1NSwgMi40KSA6IGcgLyAxMi45MjtcbiAgICAgIGIgPSBiID4gMC4wNDA0NSA/IE1hdGgucG93KChiICsgMC4wNTUpIC8gMS4wNTUsIDIuNCkgOiBiIC8gMTIuOTI7XG4gICAgICB2YXIgeCA9IHIgKiAwLjQxMjQgKyBnICogMC4zNTc2ICsgYiAqIDAuMTgwNTtcbiAgICAgIHZhciB5ID0gciAqIDAuMjEyNiArIGcgKiAwLjcxNTIgKyBiICogMC4wNzIyO1xuICAgICAgdmFyIHogPSByICogMC4wMTkzICsgZyAqIDAuMTE5MiArIGIgKiAwLjk1MDU7XG4gICAgICByZXR1cm4gW3ggKiAxMDAsIHkgKiAxMDAsIHogKiAxMDBdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LnJnYi5sYWIgPSBmdW5jdGlvbiAocmdiKSB7XG4gICAgICB2YXIgeHl6ID0gY29udmVydC5yZ2IueHl6KHJnYik7XG4gICAgICB2YXIgeCA9IHh5elswXTtcbiAgICAgIHZhciB5ID0geHl6WzFdO1xuICAgICAgdmFyIHogPSB4eXpbMl07XG4gICAgICB2YXIgbDtcbiAgICAgIHZhciBhO1xuICAgICAgdmFyIGI7XG4gICAgICB4IC89IDk1LjA0NztcbiAgICAgIHkgLz0gMTAwO1xuICAgICAgeiAvPSAxMDguODgzO1xuICAgICAgeCA9IHggPiAwLjAwODg1NiA/IE1hdGgucG93KHgsIDEgLyAzKSA6IDcuNzg3ICogeCArIDE2IC8gMTE2O1xuICAgICAgeSA9IHkgPiAwLjAwODg1NiA/IE1hdGgucG93KHksIDEgLyAzKSA6IDcuNzg3ICogeSArIDE2IC8gMTE2O1xuICAgICAgeiA9IHogPiAwLjAwODg1NiA/IE1hdGgucG93KHosIDEgLyAzKSA6IDcuNzg3ICogeiArIDE2IC8gMTE2O1xuICAgICAgbCA9IDExNiAqIHkgLSAxNjtcbiAgICAgIGEgPSA1MDAgKiAoeCAtIHkpO1xuICAgICAgYiA9IDIwMCAqICh5IC0geik7XG4gICAgICByZXR1cm4gW2wsIGEsIGJdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LmhzbC5yZ2IgPSBmdW5jdGlvbiAoaHNsKSB7XG4gICAgICB2YXIgaCA9IGhzbFswXSAvIDM2MDtcbiAgICAgIHZhciBzID0gaHNsWzFdIC8gMTAwO1xuICAgICAgdmFyIGwgPSBoc2xbMl0gLyAxMDA7XG4gICAgICB2YXIgdDE7XG4gICAgICB2YXIgdDI7XG4gICAgICB2YXIgdDM7XG4gICAgICB2YXIgcmdiO1xuICAgICAgdmFyIHZhbDtcblxuICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgdmFsID0gbCAqIDI1NTtcbiAgICAgICAgcmV0dXJuIFt2YWwsIHZhbCwgdmFsXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGwgPCAwLjUpIHtcbiAgICAgICAgdDIgPSBsICogKDEgKyBzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHQyID0gbCArIHMgLSBsICogcztcbiAgICAgIH1cblxuICAgICAgdDEgPSAyICogbCAtIHQyO1xuICAgICAgcmdiID0gWzAsIDAsIDBdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICB0MyA9IGggKyAxIC8gMyAqIC0oaSAtIDEpO1xuXG4gICAgICAgIGlmICh0MyA8IDApIHtcbiAgICAgICAgICB0MysrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHQzID4gMSkge1xuICAgICAgICAgIHQzLS07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoNiAqIHQzIDwgMSkge1xuICAgICAgICAgIHZhbCA9IHQxICsgKHQyIC0gdDEpICogNiAqIHQzO1xuICAgICAgICB9IGVsc2UgaWYgKDIgKiB0MyA8IDEpIHtcbiAgICAgICAgICB2YWwgPSB0MjtcbiAgICAgICAgfSBlbHNlIGlmICgzICogdDMgPCAyKSB7XG4gICAgICAgICAgdmFsID0gdDEgKyAodDIgLSB0MSkgKiAoMiAvIDMgLSB0MykgKiA2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IHQxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmdiW2ldID0gdmFsICogMjU1O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmdiO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LmhzbC5oc3YgPSBmdW5jdGlvbiAoaHNsKSB7XG4gICAgICB2YXIgaCA9IGhzbFswXTtcbiAgICAgIHZhciBzID0gaHNsWzFdIC8gMTAwO1xuICAgICAgdmFyIGwgPSBoc2xbMl0gLyAxMDA7XG4gICAgICB2YXIgc21pbiA9IHM7XG4gICAgICB2YXIgbG1pbiA9IE1hdGgubWF4KGwsIDAuMDEpO1xuICAgICAgdmFyIHN2O1xuICAgICAgdmFyIHY7XG4gICAgICBsICo9IDI7XG4gICAgICBzICo9IGwgPD0gMSA/IGwgOiAyIC0gbDtcbiAgICAgIHNtaW4gKj0gbG1pbiA8PSAxID8gbG1pbiA6IDIgLSBsbWluO1xuICAgICAgdiA9IChsICsgcykgLyAyO1xuICAgICAgc3YgPSBsID09PSAwID8gMiAqIHNtaW4gLyAobG1pbiArIHNtaW4pIDogMiAqIHMgLyAobCArIHMpO1xuICAgICAgcmV0dXJuIFtoLCBzdiAqIDEwMCwgdiAqIDEwMF07XG4gICAgfTtcblxuICAgIGNvbnZlcnQuaHN2LnJnYiA9IGZ1bmN0aW9uIChoc3YpIHtcbiAgICAgIHZhciBoID0gaHN2WzBdIC8gNjA7XG4gICAgICB2YXIgcyA9IGhzdlsxXSAvIDEwMDtcbiAgICAgIHZhciB2ID0gaHN2WzJdIC8gMTAwO1xuICAgICAgdmFyIGhpID0gTWF0aC5mbG9vcihoKSAlIDY7XG4gICAgICB2YXIgZiA9IGggLSBNYXRoLmZsb29yKGgpO1xuICAgICAgdmFyIHAgPSAyNTUgKiB2ICogKDEgLSBzKTtcbiAgICAgIHZhciBxID0gMjU1ICogdiAqICgxIC0gcyAqIGYpO1xuICAgICAgdmFyIHQgPSAyNTUgKiB2ICogKDEgLSBzICogKDEgLSBmKSk7XG4gICAgICB2ICo9IDI1NTtcblxuICAgICAgc3dpdGNoIChoaSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIFt2LCB0LCBwXTtcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIFtxLCB2LCBwXTtcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIFtwLCB2LCB0XTtcblxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcmV0dXJuIFtwLCBxLCB2XTtcblxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIFt0LCBwLCB2XTtcblxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmV0dXJuIFt2LCBwLCBxXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29udmVydC5oc3YuaHNsID0gZnVuY3Rpb24gKGhzdikge1xuICAgICAgdmFyIGggPSBoc3ZbMF07XG4gICAgICB2YXIgcyA9IGhzdlsxXSAvIDEwMDtcbiAgICAgIHZhciB2ID0gaHN2WzJdIC8gMTAwO1xuICAgICAgdmFyIHZtaW4gPSBNYXRoLm1heCh2LCAwLjAxKTtcbiAgICAgIHZhciBsbWluO1xuICAgICAgdmFyIHNsO1xuICAgICAgdmFyIGw7XG4gICAgICBsID0gKDIgLSBzKSAqIHY7XG4gICAgICBsbWluID0gKDIgLSBzKSAqIHZtaW47XG4gICAgICBzbCA9IHMgKiB2bWluO1xuICAgICAgc2wgLz0gbG1pbiA8PSAxID8gbG1pbiA6IDIgLSBsbWluO1xuICAgICAgc2wgPSBzbCB8fCAwO1xuICAgICAgbCAvPSAyO1xuICAgICAgcmV0dXJuIFtoLCBzbCAqIDEwMCwgbCAqIDEwMF07XG4gICAgfTsgLy8gaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3NzLWNvbG9yLyNod2ItdG8tcmdiXG5cblxuICAgIGNvbnZlcnQuaHdiLnJnYiA9IGZ1bmN0aW9uIChod2IpIHtcbiAgICAgIHZhciBoID0gaHdiWzBdIC8gMzYwO1xuICAgICAgdmFyIHdoID0gaHdiWzFdIC8gMTAwO1xuICAgICAgdmFyIGJsID0gaHdiWzJdIC8gMTAwO1xuICAgICAgdmFyIHJhdGlvID0gd2ggKyBibDtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIHY7XG4gICAgICB2YXIgZjtcbiAgICAgIHZhciBuOyAvLyB3aCArIGJsIGNhbnQgYmUgPiAxXG5cbiAgICAgIGlmIChyYXRpbyA+IDEpIHtcbiAgICAgICAgd2ggLz0gcmF0aW87XG4gICAgICAgIGJsIC89IHJhdGlvO1xuICAgICAgfVxuXG4gICAgICBpID0gTWF0aC5mbG9vcig2ICogaCk7XG4gICAgICB2ID0gMSAtIGJsO1xuICAgICAgZiA9IDYgKiBoIC0gaTtcblxuICAgICAgaWYgKChpICYgMHgwMSkgIT09IDApIHtcbiAgICAgICAgZiA9IDEgLSBmO1xuICAgICAgfVxuXG4gICAgICBuID0gd2ggKyBmICogKHYgLSB3aCk7IC8vIGxpbmVhciBpbnRlcnBvbGF0aW9uXG5cbiAgICAgIHZhciByO1xuICAgICAgdmFyIGc7XG4gICAgICB2YXIgYjtcblxuICAgICAgc3dpdGNoIChpKSB7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHIgPSB2O1xuICAgICAgICAgIGcgPSBuO1xuICAgICAgICAgIGIgPSB3aDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgciA9IG47XG4gICAgICAgICAgZyA9IHY7XG4gICAgICAgICAgYiA9IHdoO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByID0gd2g7XG4gICAgICAgICAgZyA9IHY7XG4gICAgICAgICAgYiA9IG47XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHIgPSB3aDtcbiAgICAgICAgICBnID0gbjtcbiAgICAgICAgICBiID0gdjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgciA9IG47XG4gICAgICAgICAgZyA9IHdoO1xuICAgICAgICAgIGIgPSB2O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByID0gdjtcbiAgICAgICAgICBnID0gd2g7XG4gICAgICAgICAgYiA9IG47XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG4gICAgfTtcblxuICAgIGNvbnZlcnQuY215ay5yZ2IgPSBmdW5jdGlvbiAoY215aykge1xuICAgICAgdmFyIGMgPSBjbXlrWzBdIC8gMTAwO1xuICAgICAgdmFyIG0gPSBjbXlrWzFdIC8gMTAwO1xuICAgICAgdmFyIHkgPSBjbXlrWzJdIC8gMTAwO1xuICAgICAgdmFyIGsgPSBjbXlrWzNdIC8gMTAwO1xuICAgICAgdmFyIHI7XG4gICAgICB2YXIgZztcbiAgICAgIHZhciBiO1xuICAgICAgciA9IDEgLSBNYXRoLm1pbigxLCBjICogKDEgLSBrKSArIGspO1xuICAgICAgZyA9IDEgLSBNYXRoLm1pbigxLCBtICogKDEgLSBrKSArIGspO1xuICAgICAgYiA9IDEgLSBNYXRoLm1pbigxLCB5ICogKDEgLSBrKSArIGspO1xuICAgICAgcmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbiAgICB9O1xuXG4gICAgY29udmVydC54eXoucmdiID0gZnVuY3Rpb24gKHh5eikge1xuICAgICAgdmFyIHggPSB4eXpbMF0gLyAxMDA7XG4gICAgICB2YXIgeSA9IHh5elsxXSAvIDEwMDtcbiAgICAgIHZhciB6ID0geHl6WzJdIC8gMTAwO1xuICAgICAgdmFyIHI7XG4gICAgICB2YXIgZztcbiAgICAgIHZhciBiO1xuICAgICAgciA9IHggKiAzLjI0MDYgKyB5ICogLTEuNTM3MiArIHogKiAtMC40OTg2O1xuICAgICAgZyA9IHggKiAtMC45Njg5ICsgeSAqIDEuODc1OCArIHogKiAwLjA0MTU7XG4gICAgICBiID0geCAqIDAuMDU1NyArIHkgKiAtMC4yMDQwICsgeiAqIDEuMDU3MDsgLy8gYXNzdW1lIHNSR0JcblxuICAgICAgciA9IHIgPiAwLjAwMzEzMDggPyAxLjA1NSAqIE1hdGgucG93KHIsIDEuMCAvIDIuNCkgLSAwLjA1NSA6IHIgKiAxMi45MjtcbiAgICAgIGcgPSBnID4gMC4wMDMxMzA4ID8gMS4wNTUgKiBNYXRoLnBvdyhnLCAxLjAgLyAyLjQpIC0gMC4wNTUgOiBnICogMTIuOTI7XG4gICAgICBiID0gYiA+IDAuMDAzMTMwOCA/IDEuMDU1ICogTWF0aC5wb3coYiwgMS4wIC8gMi40KSAtIDAuMDU1IDogYiAqIDEyLjkyO1xuICAgICAgciA9IE1hdGgubWluKE1hdGgubWF4KDAsIHIpLCAxKTtcbiAgICAgIGcgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBnKSwgMSk7XG4gICAgICBiID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgYiksIDEpO1xuICAgICAgcmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbiAgICB9O1xuXG4gICAgY29udmVydC54eXoubGFiID0gZnVuY3Rpb24gKHh5eikge1xuICAgICAgdmFyIHggPSB4eXpbMF07XG4gICAgICB2YXIgeSA9IHh5elsxXTtcbiAgICAgIHZhciB6ID0geHl6WzJdO1xuICAgICAgdmFyIGw7XG4gICAgICB2YXIgYTtcbiAgICAgIHZhciBiO1xuICAgICAgeCAvPSA5NS4wNDc7XG4gICAgICB5IC89IDEwMDtcbiAgICAgIHogLz0gMTA4Ljg4MztcbiAgICAgIHggPSB4ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh4LCAxIC8gMykgOiA3Ljc4NyAqIHggKyAxNiAvIDExNjtcbiAgICAgIHkgPSB5ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh5LCAxIC8gMykgOiA3Ljc4NyAqIHkgKyAxNiAvIDExNjtcbiAgICAgIHogPSB6ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh6LCAxIC8gMykgOiA3Ljc4NyAqIHogKyAxNiAvIDExNjtcbiAgICAgIGwgPSAxMTYgKiB5IC0gMTY7XG4gICAgICBhID0gNTAwICogKHggLSB5KTtcbiAgICAgIGIgPSAyMDAgKiAoeSAtIHopO1xuICAgICAgcmV0dXJuIFtsLCBhLCBiXTtcbiAgICB9O1xuXG4gICAgY29udmVydC5sYWIueHl6ID0gZnVuY3Rpb24gKGxhYikge1xuICAgICAgdmFyIGwgPSBsYWJbMF07XG4gICAgICB2YXIgYSA9IGxhYlsxXTtcbiAgICAgIHZhciBiID0gbGFiWzJdO1xuICAgICAgdmFyIHg7XG4gICAgICB2YXIgeTtcbiAgICAgIHZhciB6O1xuICAgICAgeSA9IChsICsgMTYpIC8gMTE2O1xuICAgICAgeCA9IGEgLyA1MDAgKyB5O1xuICAgICAgeiA9IHkgLSBiIC8gMjAwO1xuICAgICAgdmFyIHkyID0gTWF0aC5wb3coeSwgMyk7XG4gICAgICB2YXIgeDIgPSBNYXRoLnBvdyh4LCAzKTtcbiAgICAgIHZhciB6MiA9IE1hdGgucG93KHosIDMpO1xuICAgICAgeSA9IHkyID4gMC4wMDg4NTYgPyB5MiA6ICh5IC0gMTYgLyAxMTYpIC8gNy43ODc7XG4gICAgICB4ID0geDIgPiAwLjAwODg1NiA/IHgyIDogKHggLSAxNiAvIDExNikgLyA3Ljc4NztcbiAgICAgIHogPSB6MiA+IDAuMDA4ODU2ID8gejIgOiAoeiAtIDE2IC8gMTE2KSAvIDcuNzg3O1xuICAgICAgeCAqPSA5NS4wNDc7XG4gICAgICB5ICo9IDEwMDtcbiAgICAgIHogKj0gMTA4Ljg4MztcbiAgICAgIHJldHVybiBbeCwgeSwgel07XG4gICAgfTtcblxuICAgIGNvbnZlcnQubGFiLmxjaCA9IGZ1bmN0aW9uIChsYWIpIHtcbiAgICAgIHZhciBsID0gbGFiWzBdO1xuICAgICAgdmFyIGEgPSBsYWJbMV07XG4gICAgICB2YXIgYiA9IGxhYlsyXTtcbiAgICAgIHZhciBocjtcbiAgICAgIHZhciBoO1xuICAgICAgdmFyIGM7XG4gICAgICBociA9IE1hdGguYXRhbjIoYiwgYSk7XG4gICAgICBoID0gaHIgKiAzNjAgLyAyIC8gTWF0aC5QSTtcblxuICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgIGggKz0gMzYwO1xuICAgICAgfVxuXG4gICAgICBjID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuICAgICAgcmV0dXJuIFtsLCBjLCBoXTtcbiAgICB9O1xuXG4gICAgY29udmVydC5sY2gubGFiID0gZnVuY3Rpb24gKGxjaCkge1xuICAgICAgdmFyIGwgPSBsY2hbMF07XG4gICAgICB2YXIgYyA9IGxjaFsxXTtcbiAgICAgIHZhciBoID0gbGNoWzJdO1xuICAgICAgdmFyIGE7XG4gICAgICB2YXIgYjtcbiAgICAgIHZhciBocjtcbiAgICAgIGhyID0gaCAvIDM2MCAqIDIgKiBNYXRoLlBJO1xuICAgICAgYSA9IGMgKiBNYXRoLmNvcyhocik7XG4gICAgICBiID0gYyAqIE1hdGguc2luKGhyKTtcbiAgICAgIHJldHVybiBbbCwgYSwgYl07XG4gICAgfTtcblxuICAgIGNvbnZlcnQucmdiLmFuc2kxNiA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICB2YXIgciA9IGFyZ3NbMF07XG4gICAgICB2YXIgZyA9IGFyZ3NbMV07XG4gICAgICB2YXIgYiA9IGFyZ3NbMl07XG4gICAgICB2YXIgdmFsdWUgPSAxIGluIGFyZ3VtZW50cyA/IGFyZ3VtZW50c1sxXSA6IGNvbnZlcnQucmdiLmhzdihhcmdzKVsyXTsgLy8gaHN2IC0+IGFuc2kxNiBvcHRpbWl6YXRpb25cblxuICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlIC8gNTApO1xuXG4gICAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDMwO1xuICAgICAgfVxuXG4gICAgICB2YXIgYW5zaSA9IDMwICsgKE1hdGgucm91bmQoYiAvIDI1NSkgPDwgMiB8IE1hdGgucm91bmQoZyAvIDI1NSkgPDwgMSB8IE1hdGgucm91bmQociAvIDI1NSkpO1xuXG4gICAgICBpZiAodmFsdWUgPT09IDIpIHtcbiAgICAgICAgYW5zaSArPSA2MDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFuc2k7XG4gICAgfTtcblxuICAgIGNvbnZlcnQuaHN2LmFuc2kxNiA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAvLyBvcHRpbWl6YXRpb24gaGVyZTsgd2UgYWxyZWFkeSBrbm93IHRoZSB2YWx1ZSBhbmQgZG9uJ3QgbmVlZCB0byBnZXRcbiAgICAgIC8vIGl0IGNvbnZlcnRlZCBmb3IgdXMuXG4gICAgICByZXR1cm4gY29udmVydC5yZ2IuYW5zaTE2KGNvbnZlcnQuaHN2LnJnYihhcmdzKSwgYXJnc1syXSk7XG4gICAgfTtcblxuICAgIGNvbnZlcnQucmdiLmFuc2kyNTYgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgdmFyIHIgPSBhcmdzWzBdO1xuICAgICAgdmFyIGcgPSBhcmdzWzFdO1xuICAgICAgdmFyIGIgPSBhcmdzWzJdOyAvLyB3ZSB1c2UgdGhlIGV4dGVuZGVkIGdyZXlzY2FsZSBwYWxldHRlIGhlcmUsIHdpdGggdGhlIGV4Y2VwdGlvbiBvZlxuICAgICAgLy8gYmxhY2sgYW5kIHdoaXRlLiBub3JtYWwgcGFsZXR0ZSBvbmx5IGhhcyA0IGdyZXlzY2FsZSBzaGFkZXMuXG5cbiAgICAgIGlmIChyID09PSBnICYmIGcgPT09IGIpIHtcbiAgICAgICAgaWYgKHIgPCA4KSB7XG4gICAgICAgICAgcmV0dXJuIDE2O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHIgPiAyNDgpIHtcbiAgICAgICAgICByZXR1cm4gMjMxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoKHIgLSA4KSAvIDI0NyAqIDI0KSArIDIzMjtcbiAgICAgIH1cblxuICAgICAgdmFyIGFuc2kgPSAxNiArIDM2ICogTWF0aC5yb3VuZChyIC8gMjU1ICogNSkgKyA2ICogTWF0aC5yb3VuZChnIC8gMjU1ICogNSkgKyBNYXRoLnJvdW5kKGIgLyAyNTUgKiA1KTtcbiAgICAgIHJldHVybiBhbnNpO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LmFuc2kxNi5yZ2IgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgdmFyIGNvbG9yID0gYXJncyAlIDEwOyAvLyBoYW5kbGUgZ3JleXNjYWxlXG5cbiAgICAgIGlmIChjb2xvciA9PT0gMCB8fCBjb2xvciA9PT0gNykge1xuICAgICAgICBpZiAoYXJncyA+IDUwKSB7XG4gICAgICAgICAgY29sb3IgKz0gMy41O1xuICAgICAgICB9XG5cbiAgICAgICAgY29sb3IgPSBjb2xvciAvIDEwLjUgKiAyNTU7XG4gICAgICAgIHJldHVybiBbY29sb3IsIGNvbG9yLCBjb2xvcl07XG4gICAgICB9XG5cbiAgICAgIHZhciBtdWx0ID0gKH5+KGFyZ3MgPiA1MCkgKyAxKSAqIDAuNTtcbiAgICAgIHZhciByID0gKGNvbG9yICYgMSkgKiBtdWx0ICogMjU1O1xuICAgICAgdmFyIGcgPSAoY29sb3IgPj4gMSAmIDEpICogbXVsdCAqIDI1NTtcbiAgICAgIHZhciBiID0gKGNvbG9yID4+IDIgJiAxKSAqIG11bHQgKiAyNTU7XG4gICAgICByZXR1cm4gW3IsIGcsIGJdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LmFuc2kyNTYucmdiID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgIC8vIGhhbmRsZSBncmV5c2NhbGVcbiAgICAgIGlmIChhcmdzID49IDIzMikge1xuICAgICAgICB2YXIgYyA9IChhcmdzIC0gMjMyKSAqIDEwICsgODtcbiAgICAgICAgcmV0dXJuIFtjLCBjLCBjXTtcbiAgICAgIH1cblxuICAgICAgYXJncyAtPSAxNjtcbiAgICAgIHZhciByZW07XG4gICAgICB2YXIgciA9IE1hdGguZmxvb3IoYXJncyAvIDM2KSAvIDUgKiAyNTU7XG4gICAgICB2YXIgZyA9IE1hdGguZmxvb3IoKHJlbSA9IGFyZ3MgJSAzNikgLyA2KSAvIDUgKiAyNTU7XG4gICAgICB2YXIgYiA9IHJlbSAlIDYgLyA1ICogMjU1O1xuICAgICAgcmV0dXJuIFtyLCBnLCBiXTtcbiAgICB9O1xuXG4gICAgY29udmVydC5yZ2IuaGV4ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgIHZhciBpbnRlZ2VyID0gKChNYXRoLnJvdW5kKGFyZ3NbMF0pICYgMHhGRikgPDwgMTYpICsgKChNYXRoLnJvdW5kKGFyZ3NbMV0pICYgMHhGRikgPDwgOCkgKyAoTWF0aC5yb3VuZChhcmdzWzJdKSAmIDB4RkYpO1xuICAgICAgdmFyIHN0cmluZyA9IGludGVnZXIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICByZXR1cm4gJzAwMDAwMCcuc3Vic3RyaW5nKHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LmhleC5yZ2IgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgdmFyIG1hdGNoID0gYXJncy50b1N0cmluZygxNikubWF0Y2goL1thLWYwLTldezZ9fFthLWYwLTldezN9L2kpO1xuXG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiBbMCwgMCwgMF07XG4gICAgICB9XG5cbiAgICAgIHZhciBjb2xvclN0cmluZyA9IG1hdGNoWzBdO1xuXG4gICAgICBpZiAobWF0Y2hbMF0ubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIGNvbG9yU3RyaW5nID0gY29sb3JTdHJpbmcuc3BsaXQoJycpLm1hcChmdW5jdGlvbiAoY2hhcikge1xuICAgICAgICAgIHJldHVybiBjaGFyICsgY2hhcjtcbiAgICAgICAgfSkuam9pbignJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbnRlZ2VyID0gcGFyc2VJbnQoY29sb3JTdHJpbmcsIDE2KTtcbiAgICAgIHZhciByID0gaW50ZWdlciA+PiAxNiAmIDB4RkY7XG4gICAgICB2YXIgZyA9IGludGVnZXIgPj4gOCAmIDB4RkY7XG4gICAgICB2YXIgYiA9IGludGVnZXIgJiAweEZGO1xuICAgICAgcmV0dXJuIFtyLCBnLCBiXTtcbiAgICB9O1xuXG4gICAgY29udmVydC5yZ2IuaGNnID0gZnVuY3Rpb24gKHJnYikge1xuICAgICAgdmFyIHIgPSByZ2JbMF0gLyAyNTU7XG4gICAgICB2YXIgZyA9IHJnYlsxXSAvIDI1NTtcbiAgICAgIHZhciBiID0gcmdiWzJdIC8gMjU1O1xuICAgICAgdmFyIG1heCA9IE1hdGgubWF4KE1hdGgubWF4KHIsIGcpLCBiKTtcbiAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihNYXRoLm1pbihyLCBnKSwgYik7XG4gICAgICB2YXIgY2hyb21hID0gbWF4IC0gbWluO1xuICAgICAgdmFyIGdyYXlzY2FsZTtcbiAgICAgIHZhciBodWU7XG5cbiAgICAgIGlmIChjaHJvbWEgPCAxKSB7XG4gICAgICAgIGdyYXlzY2FsZSA9IG1pbiAvICgxIC0gY2hyb21hKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdyYXlzY2FsZSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaHJvbWEgPD0gMCkge1xuICAgICAgICBodWUgPSAwO1xuICAgICAgfSBlbHNlIGlmIChtYXggPT09IHIpIHtcbiAgICAgICAgaHVlID0gKGcgLSBiKSAvIGNocm9tYSAlIDY7XG4gICAgICB9IGVsc2UgaWYgKG1heCA9PT0gZykge1xuICAgICAgICBodWUgPSAyICsgKGIgLSByKSAvIGNocm9tYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGh1ZSA9IDQgKyAociAtIGcpIC8gY2hyb21hICsgNDtcbiAgICAgIH1cblxuICAgICAgaHVlIC89IDY7XG4gICAgICBodWUgJT0gMTtcbiAgICAgIHJldHVybiBbaHVlICogMzYwLCBjaHJvbWEgKiAxMDAsIGdyYXlzY2FsZSAqIDEwMF07XG4gICAgfTtcblxuICAgIGNvbnZlcnQuaHNsLmhjZyA9IGZ1bmN0aW9uIChoc2wpIHtcbiAgICAgIHZhciBzID0gaHNsWzFdIC8gMTAwO1xuICAgICAgdmFyIGwgPSBoc2xbMl0gLyAxMDA7XG4gICAgICB2YXIgYyA9IDE7XG4gICAgICB2YXIgZiA9IDA7XG5cbiAgICAgIGlmIChsIDwgMC41KSB7XG4gICAgICAgIGMgPSAyLjAgKiBzICogbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGMgPSAyLjAgKiBzICogKDEuMCAtIGwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYyA8IDEuMCkge1xuICAgICAgICBmID0gKGwgLSAwLjUgKiBjKSAvICgxLjAgLSBjKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtoc2xbMF0sIGMgKiAxMDAsIGYgKiAxMDBdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0Lmhzdi5oY2cgPSBmdW5jdGlvbiAoaHN2KSB7XG4gICAgICB2YXIgcyA9IGhzdlsxXSAvIDEwMDtcbiAgICAgIHZhciB2ID0gaHN2WzJdIC8gMTAwO1xuICAgICAgdmFyIGMgPSBzICogdjtcbiAgICAgIHZhciBmID0gMDtcblxuICAgICAgaWYgKGMgPCAxLjApIHtcbiAgICAgICAgZiA9ICh2IC0gYykgLyAoMSAtIGMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW2hzdlswXSwgYyAqIDEwMCwgZiAqIDEwMF07XG4gICAgfTtcblxuICAgIGNvbnZlcnQuaGNnLnJnYiA9IGZ1bmN0aW9uIChoY2cpIHtcbiAgICAgIHZhciBoID0gaGNnWzBdIC8gMzYwO1xuICAgICAgdmFyIGMgPSBoY2dbMV0gLyAxMDA7XG4gICAgICB2YXIgZyA9IGhjZ1syXSAvIDEwMDtcblxuICAgICAgaWYgKGMgPT09IDAuMCkge1xuICAgICAgICByZXR1cm4gW2cgKiAyNTUsIGcgKiAyNTUsIGcgKiAyNTVdO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHVyZSA9IFswLCAwLCAwXTtcbiAgICAgIHZhciBoaSA9IGggJSAxICogNjtcbiAgICAgIHZhciB2ID0gaGkgJSAxO1xuICAgICAgdmFyIHcgPSAxIC0gdjtcbiAgICAgIHZhciBtZyA9IDA7XG5cbiAgICAgIHN3aXRjaCAoTWF0aC5mbG9vcihoaSkpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHB1cmVbMF0gPSAxO1xuICAgICAgICAgIHB1cmVbMV0gPSB2O1xuICAgICAgICAgIHB1cmVbMl0gPSAwO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBwdXJlWzBdID0gdztcbiAgICAgICAgICBwdXJlWzFdID0gMTtcbiAgICAgICAgICBwdXJlWzJdID0gMDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcHVyZVswXSA9IDA7XG4gICAgICAgICAgcHVyZVsxXSA9IDE7XG4gICAgICAgICAgcHVyZVsyXSA9IHY7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHB1cmVbMF0gPSAwO1xuICAgICAgICAgIHB1cmVbMV0gPSB3O1xuICAgICAgICAgIHB1cmVbMl0gPSAxO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBwdXJlWzBdID0gdjtcbiAgICAgICAgICBwdXJlWzFdID0gMDtcbiAgICAgICAgICBwdXJlWzJdID0gMTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1cmVbMF0gPSAxO1xuICAgICAgICAgIHB1cmVbMV0gPSAwO1xuICAgICAgICAgIHB1cmVbMl0gPSB3O1xuICAgICAgfVxuXG4gICAgICBtZyA9ICgxLjAgLSBjKSAqIGc7XG4gICAgICByZXR1cm4gWyhjICogcHVyZVswXSArIG1nKSAqIDI1NSwgKGMgKiBwdXJlWzFdICsgbWcpICogMjU1LCAoYyAqIHB1cmVbMl0gKyBtZykgKiAyNTVdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LmhjZy5oc3YgPSBmdW5jdGlvbiAoaGNnKSB7XG4gICAgICB2YXIgYyA9IGhjZ1sxXSAvIDEwMDtcbiAgICAgIHZhciBnID0gaGNnWzJdIC8gMTAwO1xuICAgICAgdmFyIHYgPSBjICsgZyAqICgxLjAgLSBjKTtcbiAgICAgIHZhciBmID0gMDtcblxuICAgICAgaWYgKHYgPiAwLjApIHtcbiAgICAgICAgZiA9IGMgLyB2O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW2hjZ1swXSwgZiAqIDEwMCwgdiAqIDEwMF07XG4gICAgfTtcblxuICAgIGNvbnZlcnQuaGNnLmhzbCA9IGZ1bmN0aW9uIChoY2cpIHtcbiAgICAgIHZhciBjID0gaGNnWzFdIC8gMTAwO1xuICAgICAgdmFyIGcgPSBoY2dbMl0gLyAxMDA7XG4gICAgICB2YXIgbCA9IGcgKiAoMS4wIC0gYykgKyAwLjUgKiBjO1xuICAgICAgdmFyIHMgPSAwO1xuXG4gICAgICBpZiAobCA+IDAuMCAmJiBsIDwgMC41KSB7XG4gICAgICAgIHMgPSBjIC8gKDIgKiBsKTtcbiAgICAgIH0gZWxzZSBpZiAobCA+PSAwLjUgJiYgbCA8IDEuMCkge1xuICAgICAgICBzID0gYyAvICgyICogKDEgLSBsKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbaGNnWzBdLCBzICogMTAwLCBsICogMTAwXTtcbiAgICB9O1xuXG4gICAgY29udmVydC5oY2cuaHdiID0gZnVuY3Rpb24gKGhjZykge1xuICAgICAgdmFyIGMgPSBoY2dbMV0gLyAxMDA7XG4gICAgICB2YXIgZyA9IGhjZ1syXSAvIDEwMDtcbiAgICAgIHZhciB2ID0gYyArIGcgKiAoMS4wIC0gYyk7XG4gICAgICByZXR1cm4gW2hjZ1swXSwgKHYgLSBjKSAqIDEwMCwgKDEgLSB2KSAqIDEwMF07XG4gICAgfTtcblxuICAgIGNvbnZlcnQuaHdiLmhjZyA9IGZ1bmN0aW9uIChod2IpIHtcbiAgICAgIHZhciB3ID0gaHdiWzFdIC8gMTAwO1xuICAgICAgdmFyIGIgPSBod2JbMl0gLyAxMDA7XG4gICAgICB2YXIgdiA9IDEgLSBiO1xuICAgICAgdmFyIGMgPSB2IC0gdztcbiAgICAgIHZhciBnID0gMDtcblxuICAgICAgaWYgKGMgPCAxKSB7XG4gICAgICAgIGcgPSAodiAtIGMpIC8gKDEgLSBjKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtod2JbMF0sIGMgKiAxMDAsIGcgKiAxMDBdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LmFwcGxlLnJnYiA9IGZ1bmN0aW9uIChhcHBsZSkge1xuICAgICAgcmV0dXJuIFthcHBsZVswXSAvIDY1NTM1ICogMjU1LCBhcHBsZVsxXSAvIDY1NTM1ICogMjU1LCBhcHBsZVsyXSAvIDY1NTM1ICogMjU1XTtcbiAgICB9O1xuXG4gICAgY29udmVydC5yZ2IuYXBwbGUgPSBmdW5jdGlvbiAocmdiKSB7XG4gICAgICByZXR1cm4gW3JnYlswXSAvIDI1NSAqIDY1NTM1LCByZ2JbMV0gLyAyNTUgKiA2NTUzNSwgcmdiWzJdIC8gMjU1ICogNjU1MzVdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LmdyYXkucmdiID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgIHJldHVybiBbYXJnc1swXSAvIDEwMCAqIDI1NSwgYXJnc1swXSAvIDEwMCAqIDI1NSwgYXJnc1swXSAvIDEwMCAqIDI1NV07XG4gICAgfTtcblxuICAgIGNvbnZlcnQuZ3JheS5oc2wgPSBjb252ZXJ0LmdyYXkuaHN2ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgIHJldHVybiBbMCwgMCwgYXJnc1swXV07XG4gICAgfTtcblxuICAgIGNvbnZlcnQuZ3JheS5od2IgPSBmdW5jdGlvbiAoZ3JheSkge1xuICAgICAgcmV0dXJuIFswLCAxMDAsIGdyYXlbMF1dO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LmdyYXkuY215ayA9IGZ1bmN0aW9uIChncmF5KSB7XG4gICAgICByZXR1cm4gWzAsIDAsIDAsIGdyYXlbMF1dO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LmdyYXkubGFiID0gZnVuY3Rpb24gKGdyYXkpIHtcbiAgICAgIHJldHVybiBbZ3JheVswXSwgMCwgMF07XG4gICAgfTtcblxuICAgIGNvbnZlcnQuZ3JheS5oZXggPSBmdW5jdGlvbiAoZ3JheSkge1xuICAgICAgdmFyIHZhbCA9IE1hdGgucm91bmQoZ3JheVswXSAvIDEwMCAqIDI1NSkgJiAweEZGO1xuICAgICAgdmFyIGludGVnZXIgPSAodmFsIDw8IDE2KSArICh2YWwgPDwgOCkgKyB2YWw7XG4gICAgICB2YXIgc3RyaW5nID0gaW50ZWdlci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgIHJldHVybiAnMDAwMDAwJy5zdWJzdHJpbmcoc3RyaW5nLmxlbmd0aCkgKyBzdHJpbmc7XG4gICAgfTtcblxuICAgIGNvbnZlcnQucmdiLmdyYXkgPSBmdW5jdGlvbiAocmdiKSB7XG4gICAgICB2YXIgdmFsID0gKHJnYlswXSArIHJnYlsxXSArIHJnYlsyXSkgLyAzO1xuICAgICAgcmV0dXJuIFt2YWwgLyAyNTUgKiAxMDBdO1xuICAgIH07XG4gIH0pO1xuICB2YXIgY29udmVyc2lvbnNfMSA9IGNvbnZlcnNpb25zLnJnYjtcbiAgdmFyIGNvbnZlcnNpb25zXzIgPSBjb252ZXJzaW9ucy5oc2w7XG4gIHZhciBjb252ZXJzaW9uc18zID0gY29udmVyc2lvbnMuaHN2O1xuICB2YXIgY29udmVyc2lvbnNfNCA9IGNvbnZlcnNpb25zLmh3YjtcbiAgdmFyIGNvbnZlcnNpb25zXzUgPSBjb252ZXJzaW9ucy5jbXlrO1xuICB2YXIgY29udmVyc2lvbnNfNiA9IGNvbnZlcnNpb25zLnh5ejtcbiAgdmFyIGNvbnZlcnNpb25zXzcgPSBjb252ZXJzaW9ucy5sYWI7XG4gIHZhciBjb252ZXJzaW9uc184ID0gY29udmVyc2lvbnMubGNoO1xuICB2YXIgY29udmVyc2lvbnNfOSA9IGNvbnZlcnNpb25zLmhleDtcbiAgdmFyIGNvbnZlcnNpb25zXzEwID0gY29udmVyc2lvbnMua2V5d29yZDtcbiAgdmFyIGNvbnZlcnNpb25zXzExID0gY29udmVyc2lvbnMuYW5zaTE2O1xuICB2YXIgY29udmVyc2lvbnNfMTIgPSBjb252ZXJzaW9ucy5hbnNpMjU2O1xuICB2YXIgY29udmVyc2lvbnNfMTMgPSBjb252ZXJzaW9ucy5oY2c7XG4gIHZhciBjb252ZXJzaW9uc18xNCA9IGNvbnZlcnNpb25zLmFwcGxlO1xuICB2YXIgY29udmVyc2lvbnNfMTUgPSBjb252ZXJzaW9ucy5ncmF5O1xuXG4gIC8qXG4gIFx0dGhpcyBmdW5jdGlvbiByb3V0ZXMgYSBtb2RlbCB0byBhbGwgb3RoZXIgbW9kZWxzLlxuXG4gIFx0YWxsIGZ1bmN0aW9ucyB0aGF0IGFyZSByb3V0ZWQgaGF2ZSBhIHByb3BlcnR5IGAuY29udmVyc2lvbmAgYXR0YWNoZWRcbiAgXHR0byB0aGUgcmV0dXJuZWQgc3ludGhldGljIGZ1bmN0aW9uLiBUaGlzIHByb3BlcnR5IGlzIGFuIGFycmF5XG4gIFx0b2Ygc3RyaW5ncywgZWFjaCB3aXRoIHRoZSBzdGVwcyBpbiBiZXR3ZWVuIHRoZSAnZnJvbScgYW5kICd0bydcbiAgXHRjb2xvciBtb2RlbHMgKGluY2x1c2l2ZSkuXG5cbiAgXHRjb252ZXJzaW9ucyB0aGF0IGFyZSBub3QgcG9zc2libGUgc2ltcGx5IGFyZSBub3QgaW5jbHVkZWQuXG4gICovXG4gIC8vIGh0dHBzOi8vanNwZXJmLmNvbS9vYmplY3Qta2V5cy12cy1mb3ItaW4td2l0aC1jbG9zdXJlLzNcblxuICB2YXIgbW9kZWxzID0gT2JqZWN0LmtleXMoY29udmVyc2lvbnMpO1xuXG4gIGZ1bmN0aW9uIGJ1aWxkR3JhcGgoKSB7XG4gICAgdmFyIGdyYXBoID0ge307XG5cbiAgICBmb3IgKHZhciBsZW4gPSBtb2RlbHMubGVuZ3RoLCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBncmFwaFttb2RlbHNbaV1dID0ge1xuICAgICAgICAvLyBodHRwOi8vanNwZXJmLmNvbS8xLXZzLWluZmluaXR5XG4gICAgICAgIC8vIG1pY3JvLW9wdCwgYnV0IHRoaXMgaXMgc2ltcGxlLlxuICAgICAgICBkaXN0YW5jZTogLTEsXG4gICAgICAgIHBhcmVudDogbnVsbFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ3JhcGg7XG4gIH0gLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnJlYWR0aC1maXJzdF9zZWFyY2hcblxuXG4gIGZ1bmN0aW9uIGRlcml2ZUJGUyhmcm9tTW9kZWwpIHtcbiAgICB2YXIgZ3JhcGggPSBidWlsZEdyYXBoKCk7XG4gICAgdmFyIHF1ZXVlID0gW2Zyb21Nb2RlbF07IC8vIHVuc2hpZnQgLT4gcXVldWUgLT4gcG9wXG5cbiAgICBncmFwaFtmcm9tTW9kZWxdLmRpc3RhbmNlID0gMDtcblxuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gcXVldWUucG9wKCk7XG4gICAgICB2YXIgYWRqYWNlbnRzID0gT2JqZWN0LmtleXMoY29udmVyc2lvbnNbY3VycmVudF0pO1xuXG4gICAgICBmb3IgKHZhciBsZW4gPSBhZGphY2VudHMubGVuZ3RoLCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBhZGphY2VudCA9IGFkamFjZW50c1tpXTtcbiAgICAgICAgdmFyIG5vZGUgPSBncmFwaFthZGphY2VudF07XG5cbiAgICAgICAgaWYgKG5vZGUuZGlzdGFuY2UgPT09IC0xKSB7XG4gICAgICAgICAgbm9kZS5kaXN0YW5jZSA9IGdyYXBoW2N1cnJlbnRdLmRpc3RhbmNlICsgMTtcbiAgICAgICAgICBub2RlLnBhcmVudCA9IGN1cnJlbnQ7XG4gICAgICAgICAgcXVldWUudW5zaGlmdChhZGphY2VudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZ3JhcGg7XG4gIH1cblxuICBmdW5jdGlvbiBsaW5rKGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICByZXR1cm4gdG8oZnJvbShhcmdzKSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBDb252ZXJzaW9uKHRvTW9kZWwsIGdyYXBoKSB7XG4gICAgdmFyIHBhdGggPSBbZ3JhcGhbdG9Nb2RlbF0ucGFyZW50LCB0b01vZGVsXTtcbiAgICB2YXIgZm4gPSBjb252ZXJzaW9uc1tncmFwaFt0b01vZGVsXS5wYXJlbnRdW3RvTW9kZWxdO1xuICAgIHZhciBjdXIgPSBncmFwaFt0b01vZGVsXS5wYXJlbnQ7XG5cbiAgICB3aGlsZSAoZ3JhcGhbY3VyXS5wYXJlbnQpIHtcbiAgICAgIHBhdGgudW5zaGlmdChncmFwaFtjdXJdLnBhcmVudCk7XG4gICAgICBmbiA9IGxpbmsoY29udmVyc2lvbnNbZ3JhcGhbY3VyXS5wYXJlbnRdW2N1cl0sIGZuKTtcbiAgICAgIGN1ciA9IGdyYXBoW2N1cl0ucGFyZW50O1xuICAgIH1cblxuICAgIGZuLmNvbnZlcnNpb24gPSBwYXRoO1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciByb3V0ZSA9IGZ1bmN0aW9uIHJvdXRlKGZyb21Nb2RlbCkge1xuICAgIHZhciBncmFwaCA9IGRlcml2ZUJGUyhmcm9tTW9kZWwpO1xuICAgIHZhciBjb252ZXJzaW9uID0ge307XG4gICAgdmFyIG1vZGVscyA9IE9iamVjdC5rZXlzKGdyYXBoKTtcblxuICAgIGZvciAodmFyIGxlbiA9IG1vZGVscy5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciB0b01vZGVsID0gbW9kZWxzW2ldO1xuICAgICAgdmFyIG5vZGUgPSBncmFwaFt0b01vZGVsXTtcblxuICAgICAgaWYgKG5vZGUucGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgIC8vIG5vIHBvc3NpYmxlIGNvbnZlcnNpb24sIG9yIHRoaXMgbm9kZSBpcyB0aGUgc291cmNlIG1vZGVsLlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29udmVyc2lvblt0b01vZGVsXSA9IHdyYXBDb252ZXJzaW9uKHRvTW9kZWwsIGdyYXBoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udmVyc2lvbjtcbiAgfTtcblxuICB2YXIgY29udmVydCA9IHt9O1xuICB2YXIgbW9kZWxzJDEgPSBPYmplY3Qua2V5cyhjb252ZXJzaW9ucyk7XG5cbiAgZnVuY3Rpb24gd3JhcFJhdyhmbikge1xuICAgIHZhciB3cmFwcGVkRm4gPSBmdW5jdGlvbiB3cmFwcGVkRm4oYXJncykge1xuICAgICAgaWYgKGFyZ3MgPT09IHVuZGVmaW5lZCB8fCBhcmdzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmbihhcmdzKTtcbiAgICB9OyAvLyBwcmVzZXJ2ZSAuY29udmVyc2lvbiBwcm9wZXJ0eSBpZiB0aGVyZSBpcyBvbmVcblxuXG4gICAgaWYgKCdjb252ZXJzaW9uJyBpbiBmbikge1xuICAgICAgd3JhcHBlZEZuLmNvbnZlcnNpb24gPSBmbi5jb252ZXJzaW9uO1xuICAgIH1cblxuICAgIHJldHVybiB3cmFwcGVkRm47XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwUm91bmRlZChmbikge1xuICAgIHZhciB3cmFwcGVkRm4gPSBmdW5jdGlvbiB3cmFwcGVkRm4oYXJncykge1xuICAgICAgaWYgKGFyZ3MgPT09IHVuZGVmaW5lZCB8fCBhcmdzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBmbihhcmdzKTsgLy8gd2UncmUgYXNzdW1pbmcgdGhlIHJlc3VsdCBpcyBhbiBhcnJheSBoZXJlLlxuICAgICAgLy8gc2VlIG5vdGljZSBpbiBjb252ZXJzaW9ucy5qczsgZG9uJ3QgdXNlIGJveCB0eXBlc1xuICAgICAgLy8gaW4gY29udmVyc2lvbiBmdW5jdGlvbnMuXG5cbiAgICAgIGlmIChfdHlwZW9mKHJlc3VsdCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAodmFyIGxlbiA9IHJlc3VsdC5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICByZXN1bHRbaV0gPSBNYXRoLnJvdW5kKHJlc3VsdFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9OyAvLyBwcmVzZXJ2ZSAuY29udmVyc2lvbiBwcm9wZXJ0eSBpZiB0aGVyZSBpcyBvbmVcblxuXG4gICAgaWYgKCdjb252ZXJzaW9uJyBpbiBmbikge1xuICAgICAgd3JhcHBlZEZuLmNvbnZlcnNpb24gPSBmbi5jb252ZXJzaW9uO1xuICAgIH1cblxuICAgIHJldHVybiB3cmFwcGVkRm47XG4gIH1cblxuICBtb2RlbHMkMS5mb3JFYWNoKGZ1bmN0aW9uIChmcm9tTW9kZWwpIHtcbiAgICBjb252ZXJ0W2Zyb21Nb2RlbF0gPSB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udmVydFtmcm9tTW9kZWxdLCAnY2hhbm5lbHMnLCB7XG4gICAgICB2YWx1ZTogY29udmVyc2lvbnNbZnJvbU1vZGVsXS5jaGFubmVsc1xuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb252ZXJ0W2Zyb21Nb2RlbF0sICdsYWJlbHMnLCB7XG4gICAgICB2YWx1ZTogY29udmVyc2lvbnNbZnJvbU1vZGVsXS5sYWJlbHNcbiAgICB9KTtcbiAgICB2YXIgcm91dGVzID0gcm91dGUoZnJvbU1vZGVsKTtcbiAgICB2YXIgcm91dGVNb2RlbHMgPSBPYmplY3Qua2V5cyhyb3V0ZXMpO1xuICAgIHJvdXRlTW9kZWxzLmZvckVhY2goZnVuY3Rpb24gKHRvTW9kZWwpIHtcbiAgICAgIHZhciBmbiA9IHJvdXRlc1t0b01vZGVsXTtcbiAgICAgIGNvbnZlcnRbZnJvbU1vZGVsXVt0b01vZGVsXSA9IHdyYXBSb3VuZGVkKGZuKTtcbiAgICAgIGNvbnZlcnRbZnJvbU1vZGVsXVt0b01vZGVsXS5yYXcgPSB3cmFwUmF3KGZuKTtcbiAgICB9KTtcbiAgfSk7XG4gIHZhciBjb2xvckNvbnZlcnQgPSBjb252ZXJ0O1xuXG4gIHZhciBhbnNpU3R5bGVzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuXG4gICAgdmFyIHdyYXBBbnNpMTYgPSBmdW5jdGlvbiB3cmFwQW5zaTE2KGZuLCBvZmZzZXQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb2RlID0gZm4uYXBwbHkoY29sb3JDb252ZXJ0LCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gXCJcXHgxQltcIi5jb25jYXQoY29kZSArIG9mZnNldCwgXCJtXCIpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIHdyYXBBbnNpMjU2ID0gZnVuY3Rpb24gd3JhcEFuc2kyNTYoZm4sIG9mZnNldCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvZGUgPSBmbi5hcHBseShjb2xvckNvbnZlcnQsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBcIlxceDFCW1wiLmNvbmNhdCgzOCArIG9mZnNldCwgXCI7NTtcIikuY29uY2F0KGNvZGUsIFwibVwiKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciB3cmFwQW5zaTE2bSA9IGZ1bmN0aW9uIHdyYXBBbnNpMTZtKGZuLCBvZmZzZXQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZ2IgPSBmbi5hcHBseShjb2xvckNvbnZlcnQsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBcIlxceDFCW1wiLmNvbmNhdCgzOCArIG9mZnNldCwgXCI7MjtcIikuY29uY2F0KHJnYlswXSwgXCI7XCIpLmNvbmNhdChyZ2JbMV0sIFwiO1wiKS5jb25jYXQocmdiWzJdLCBcIm1cIik7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBhc3NlbWJsZVN0eWxlcygpIHtcbiAgICAgIHZhciBjb2RlcyA9IG5ldyBNYXAoKTtcbiAgICAgIHZhciBzdHlsZXMgPSB7XG4gICAgICAgIG1vZGlmaWVyOiB7XG4gICAgICAgICAgcmVzZXQ6IFswLCAwXSxcbiAgICAgICAgICAvLyAyMSBpc24ndCB3aWRlbHkgc3VwcG9ydGVkIGFuZCAyMiBkb2VzIHRoZSBzYW1lIHRoaW5nXG4gICAgICAgICAgYm9sZDogWzEsIDIyXSxcbiAgICAgICAgICBkaW06IFsyLCAyMl0sXG4gICAgICAgICAgaXRhbGljOiBbMywgMjNdLFxuICAgICAgICAgIHVuZGVybGluZTogWzQsIDI0XSxcbiAgICAgICAgICBpbnZlcnNlOiBbNywgMjddLFxuICAgICAgICAgIGhpZGRlbjogWzgsIDI4XSxcbiAgICAgICAgICBzdHJpa2V0aHJvdWdoOiBbOSwgMjldXG4gICAgICAgIH0sXG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgYmxhY2s6IFszMCwgMzldLFxuICAgICAgICAgIHJlZDogWzMxLCAzOV0sXG4gICAgICAgICAgZ3JlZW46IFszMiwgMzldLFxuICAgICAgICAgIHllbGxvdzogWzMzLCAzOV0sXG4gICAgICAgICAgYmx1ZTogWzM0LCAzOV0sXG4gICAgICAgICAgbWFnZW50YTogWzM1LCAzOV0sXG4gICAgICAgICAgY3lhbjogWzM2LCAzOV0sXG4gICAgICAgICAgd2hpdGU6IFszNywgMzldLFxuICAgICAgICAgIGdyYXk6IFs5MCwgMzldLFxuICAgICAgICAgIC8vIEJyaWdodCBjb2xvclxuICAgICAgICAgIHJlZEJyaWdodDogWzkxLCAzOV0sXG4gICAgICAgICAgZ3JlZW5CcmlnaHQ6IFs5MiwgMzldLFxuICAgICAgICAgIHllbGxvd0JyaWdodDogWzkzLCAzOV0sXG4gICAgICAgICAgYmx1ZUJyaWdodDogWzk0LCAzOV0sXG4gICAgICAgICAgbWFnZW50YUJyaWdodDogWzk1LCAzOV0sXG4gICAgICAgICAgY3lhbkJyaWdodDogWzk2LCAzOV0sXG4gICAgICAgICAgd2hpdGVCcmlnaHQ6IFs5NywgMzldXG4gICAgICAgIH0sXG4gICAgICAgIGJnQ29sb3I6IHtcbiAgICAgICAgICBiZ0JsYWNrOiBbNDAsIDQ5XSxcbiAgICAgICAgICBiZ1JlZDogWzQxLCA0OV0sXG4gICAgICAgICAgYmdHcmVlbjogWzQyLCA0OV0sXG4gICAgICAgICAgYmdZZWxsb3c6IFs0MywgNDldLFxuICAgICAgICAgIGJnQmx1ZTogWzQ0LCA0OV0sXG4gICAgICAgICAgYmdNYWdlbnRhOiBbNDUsIDQ5XSxcbiAgICAgICAgICBiZ0N5YW46IFs0NiwgNDldLFxuICAgICAgICAgIGJnV2hpdGU6IFs0NywgNDldLFxuICAgICAgICAgIC8vIEJyaWdodCBjb2xvclxuICAgICAgICAgIGJnQmxhY2tCcmlnaHQ6IFsxMDAsIDQ5XSxcbiAgICAgICAgICBiZ1JlZEJyaWdodDogWzEwMSwgNDldLFxuICAgICAgICAgIGJnR3JlZW5CcmlnaHQ6IFsxMDIsIDQ5XSxcbiAgICAgICAgICBiZ1llbGxvd0JyaWdodDogWzEwMywgNDldLFxuICAgICAgICAgIGJnQmx1ZUJyaWdodDogWzEwNCwgNDldLFxuICAgICAgICAgIGJnTWFnZW50YUJyaWdodDogWzEwNSwgNDldLFxuICAgICAgICAgIGJnQ3lhbkJyaWdodDogWzEwNiwgNDldLFxuICAgICAgICAgIGJnV2hpdGVCcmlnaHQ6IFsxMDcsIDQ5XVxuICAgICAgICB9XG4gICAgICB9OyAvLyBGaXggaHVtYW5zXG5cbiAgICAgIHN0eWxlcy5jb2xvci5ncmV5ID0gc3R5bGVzLmNvbG9yLmdyYXk7XG5cbiAgICAgIGZvciAodmFyIF9pID0gMCwgX09iamVjdCRrZXlzID0gT2JqZWN0LmtleXMoc3R5bGVzKTsgX2kgPCBfT2JqZWN0JGtleXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBncm91cE5hbWUgPSBfT2JqZWN0JGtleXNbX2ldO1xuICAgICAgICB2YXIgZ3JvdXAgPSBzdHlsZXNbZ3JvdXBOYW1lXTtcblxuICAgICAgICBmb3IgKHZhciBfaTMgPSAwLCBfT2JqZWN0JGtleXMzID0gT2JqZWN0LmtleXMoZ3JvdXApOyBfaTMgPCBfT2JqZWN0JGtleXMzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgICB2YXIgc3R5bGVOYW1lID0gX09iamVjdCRrZXlzM1tfaTNdO1xuICAgICAgICAgIHZhciBzdHlsZSA9IGdyb3VwW3N0eWxlTmFtZV07XG4gICAgICAgICAgc3R5bGVzW3N0eWxlTmFtZV0gPSB7XG4gICAgICAgICAgICBvcGVuOiBcIlxceDFCW1wiLmNvbmNhdChzdHlsZVswXSwgXCJtXCIpLFxuICAgICAgICAgICAgY2xvc2U6IFwiXFx4MUJbXCIuY29uY2F0KHN0eWxlWzFdLCBcIm1cIilcbiAgICAgICAgICB9O1xuICAgICAgICAgIGdyb3VwW3N0eWxlTmFtZV0gPSBzdHlsZXNbc3R5bGVOYW1lXTtcbiAgICAgICAgICBjb2Rlcy5zZXQoc3R5bGVbMF0sIHN0eWxlWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdHlsZXMsIGdyb3VwTmFtZSwge1xuICAgICAgICAgIHZhbHVlOiBncm91cCxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN0eWxlcywgJ2NvZGVzJywge1xuICAgICAgICAgIHZhbHVlOiBjb2RlcyxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFuc2kyYW5zaSA9IGZ1bmN0aW9uIGFuc2kyYW5zaShuKSB7XG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfTtcblxuICAgICAgdmFyIHJnYjJyZ2IgPSBmdW5jdGlvbiByZ2IycmdiKHIsIGcsIGIpIHtcbiAgICAgICAgcmV0dXJuIFtyLCBnLCBiXTtcbiAgICAgIH07XG5cbiAgICAgIHN0eWxlcy5jb2xvci5jbG9zZSA9IFwiXFx4MUJbMzltXCI7XG4gICAgICBzdHlsZXMuYmdDb2xvci5jbG9zZSA9IFwiXFx4MUJbNDltXCI7XG4gICAgICBzdHlsZXMuY29sb3IuYW5zaSA9IHtcbiAgICAgICAgYW5zaTogd3JhcEFuc2kxNihhbnNpMmFuc2ksIDApXG4gICAgICB9O1xuICAgICAgc3R5bGVzLmNvbG9yLmFuc2kyNTYgPSB7XG4gICAgICAgIGFuc2kyNTY6IHdyYXBBbnNpMjU2KGFuc2kyYW5zaSwgMClcbiAgICAgIH07XG4gICAgICBzdHlsZXMuY29sb3IuYW5zaTE2bSA9IHtcbiAgICAgICAgcmdiOiB3cmFwQW5zaTE2bShyZ2IycmdiLCAwKVxuICAgICAgfTtcbiAgICAgIHN0eWxlcy5iZ0NvbG9yLmFuc2kgPSB7XG4gICAgICAgIGFuc2k6IHdyYXBBbnNpMTYoYW5zaTJhbnNpLCAxMClcbiAgICAgIH07XG4gICAgICBzdHlsZXMuYmdDb2xvci5hbnNpMjU2ID0ge1xuICAgICAgICBhbnNpMjU2OiB3cmFwQW5zaTI1NihhbnNpMmFuc2ksIDEwKVxuICAgICAgfTtcbiAgICAgIHN0eWxlcy5iZ0NvbG9yLmFuc2kxNm0gPSB7XG4gICAgICAgIHJnYjogd3JhcEFuc2kxNm0ocmdiMnJnYiwgMTApXG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBfaTIgPSAwLCBfT2JqZWN0JGtleXMyID0gT2JqZWN0LmtleXMoY29sb3JDb252ZXJ0KTsgX2kyIDwgX09iamVjdCRrZXlzMi5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHZhciBrZXkgPSBfT2JqZWN0JGtleXMyW19pMl07XG5cbiAgICAgICAgaWYgKF90eXBlb2YoY29sb3JDb252ZXJ0W2tleV0pICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN1aXRlID0gY29sb3JDb252ZXJ0W2tleV07XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ2Fuc2kxNicpIHtcbiAgICAgICAgICBrZXkgPSAnYW5zaSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ2Fuc2kxNicgaW4gc3VpdGUpIHtcbiAgICAgICAgICBzdHlsZXMuY29sb3IuYW5zaVtrZXldID0gd3JhcEFuc2kxNihzdWl0ZS5hbnNpMTYsIDApO1xuICAgICAgICAgIHN0eWxlcy5iZ0NvbG9yLmFuc2lba2V5XSA9IHdyYXBBbnNpMTYoc3VpdGUuYW5zaTE2LCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ2Fuc2kyNTYnIGluIHN1aXRlKSB7XG4gICAgICAgICAgc3R5bGVzLmNvbG9yLmFuc2kyNTZba2V5XSA9IHdyYXBBbnNpMjU2KHN1aXRlLmFuc2kyNTYsIDApO1xuICAgICAgICAgIHN0eWxlcy5iZ0NvbG9yLmFuc2kyNTZba2V5XSA9IHdyYXBBbnNpMjU2KHN1aXRlLmFuc2kyNTYsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgncmdiJyBpbiBzdWl0ZSkge1xuICAgICAgICAgIHN0eWxlcy5jb2xvci5hbnNpMTZtW2tleV0gPSB3cmFwQW5zaTE2bShzdWl0ZS5yZ2IsIDApO1xuICAgICAgICAgIHN0eWxlcy5iZ0NvbG9yLmFuc2kxNm1ba2V5XSA9IHdyYXBBbnNpMTZtKHN1aXRlLnJnYiwgMTApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgfSAvLyBNYWtlIHRoZSBleHBvcnQgaW1tdXRhYmxlXG5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsICdleHBvcnRzJywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogYXNzZW1ibGVTdHlsZXNcbiAgICB9KTtcbiAgfSk7XG5cbiAgdmFyIHJlcXVpcmUkJDAkMSA9IHtcbiAgICBFT0w6IFwiXFxuXCJcbiAgfTtcblxuICB2YXIgaGFzRmxhZyA9IGZ1bmN0aW9uIGhhc0ZsYWcoZmxhZywgYXJndikge1xuICAgIGFyZ3YgPSBhcmd2IHx8IHByb2Nlc3MuYXJndjtcbiAgICB2YXIgcHJlZml4ID0gZmxhZy5zdGFydHNXaXRoKCctJykgPyAnJyA6IGZsYWcubGVuZ3RoID09PSAxID8gJy0nIDogJy0tJztcbiAgICB2YXIgcG9zID0gYXJndi5pbmRleE9mKHByZWZpeCArIGZsYWcpO1xuICAgIHZhciB0ZXJtaW5hdG9yUG9zID0gYXJndi5pbmRleE9mKCctLScpO1xuICAgIHJldHVybiBwb3MgIT09IC0xICYmICh0ZXJtaW5hdG9yUG9zID09PSAtMSA/IHRydWUgOiBwb3MgPCB0ZXJtaW5hdG9yUG9zKTtcbiAgfTtcblxuICB2YXIgZW52JDEgPSBwcm9jZXNzLmVudjtcbiAgdmFyIGZvcmNlQ29sb3I7XG5cbiAgaWYgKGhhc0ZsYWcoJ25vLWNvbG9yJykgfHwgaGFzRmxhZygnbm8tY29sb3JzJykgfHwgaGFzRmxhZygnY29sb3I9ZmFsc2UnKSkge1xuICAgIGZvcmNlQ29sb3IgPSBmYWxzZTtcbiAgfSBlbHNlIGlmIChoYXNGbGFnKCdjb2xvcicpIHx8IGhhc0ZsYWcoJ2NvbG9ycycpIHx8IGhhc0ZsYWcoJ2NvbG9yPXRydWUnKSB8fCBoYXNGbGFnKCdjb2xvcj1hbHdheXMnKSkge1xuICAgIGZvcmNlQ29sb3IgPSB0cnVlO1xuICB9XG5cbiAgaWYgKCdGT1JDRV9DT0xPUicgaW4gZW52JDEpIHtcbiAgICBmb3JjZUNvbG9yID0gZW52JDEuRk9SQ0VfQ09MT1IubGVuZ3RoID09PSAwIHx8IHBhcnNlSW50KGVudiQxLkZPUkNFX0NPTE9SLCAxMCkgIT09IDA7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2xhdGVMZXZlbChsZXZlbCkge1xuICAgIGlmIChsZXZlbCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsZXZlbDogbGV2ZWwsXG4gICAgICBoYXNCYXNpYzogdHJ1ZSxcbiAgICAgIGhhczI1NjogbGV2ZWwgPj0gMixcbiAgICAgIGhhczE2bTogbGV2ZWwgPj0gM1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzdXBwb3J0c0NvbG9yKHN0cmVhbSkge1xuICAgIGlmIChmb3JjZUNvbG9yID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKGhhc0ZsYWcoJ2NvbG9yPTE2bScpIHx8IGhhc0ZsYWcoJ2NvbG9yPWZ1bGwnKSB8fCBoYXNGbGFnKCdjb2xvcj10cnVlY29sb3InKSkge1xuICAgICAgcmV0dXJuIDM7XG4gICAgfVxuXG4gICAgaWYgKGhhc0ZsYWcoJ2NvbG9yPTI1NicpKSB7XG4gICAgICByZXR1cm4gMjtcbiAgICB9XG5cbiAgICBpZiAoc3RyZWFtICYmICFzdHJlYW0uaXNUVFkgJiYgZm9yY2VDb2xvciAhPT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIG1pbiA9IGZvcmNlQ29sb3IgPyAxIDogMDtcblxuICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICAvLyBOb2RlLmpzIDcuNS4wIGlzIHRoZSBmaXJzdCB2ZXJzaW9uIG9mIE5vZGUuanMgdG8gaW5jbHVkZSBhIHBhdGNoIHRvXG4gICAgICAvLyBsaWJ1diB0aGF0IGVuYWJsZXMgMjU2IGNvbG9yIG91dHB1dCBvbiBXaW5kb3dzLiBBbnl0aGluZyBlYXJsaWVyIGFuZCBpdFxuICAgICAgLy8gd29uJ3Qgd29yay4gSG93ZXZlciwgaGVyZSB3ZSB0YXJnZXQgTm9kZS5qcyA4IGF0IG1pbmltdW0gYXMgaXQgaXMgYW4gTFRTXG4gICAgICAvLyByZWxlYXNlLCBhbmQgTm9kZS5qcyA3IGlzIG5vdC4gV2luZG93cyAxMCBidWlsZCAxMDU4NiBpcyB0aGUgZmlyc3QgV2luZG93c1xuICAgICAgLy8gcmVsZWFzZSB0aGF0IHN1cHBvcnRzIDI1NiBjb2xvcnMuIFdpbmRvd3MgMTAgYnVpbGQgMTQ5MzEgaXMgdGhlIGZpcnN0IHJlbGVhc2VcbiAgICAgIC8vIHRoYXQgc3VwcG9ydHMgMTZtL1RydWVDb2xvci5cbiAgICAgIHZhciBvc1JlbGVhc2UgPSByZXF1aXJlJCQwJDEucmVsZWFzZSgpLnNwbGl0KCcuJyk7XG5cbiAgICAgIGlmIChOdW1iZXIocHJvY2Vzcy52ZXJzaW9ucy5ub2RlLnNwbGl0KCcuJylbMF0pID49IDggJiYgTnVtYmVyKG9zUmVsZWFzZVswXSkgPj0gMTAgJiYgTnVtYmVyKG9zUmVsZWFzZVsyXSkgPj0gMTA1ODYpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcihvc1JlbGVhc2VbMl0pID49IDE0OTMxID8gMyA6IDI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGlmICgnQ0knIGluIGVudiQxKSB7XG4gICAgICBpZiAoWydUUkFWSVMnLCAnQ0lSQ0xFQ0knLCAnQVBQVkVZT1InLCAnR0lUTEFCX0NJJ10uc29tZShmdW5jdGlvbiAoc2lnbikge1xuICAgICAgICByZXR1cm4gc2lnbiBpbiBlbnYkMTtcbiAgICAgIH0pIHx8IGVudiQxLkNJX05BTUUgPT09ICdjb2Rlc2hpcCcpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtaW47XG4gICAgfVxuXG4gICAgaWYgKCdURUFNQ0lUWV9WRVJTSU9OJyBpbiBlbnYkMSkge1xuICAgICAgcmV0dXJuIC9eKDlcXC4oMCpbMS05XVxcZCopXFwufFxcZHsyLH1cXC4pLy50ZXN0KGVudiQxLlRFQU1DSVRZX1ZFUlNJT04pID8gMSA6IDA7XG4gICAgfVxuXG4gICAgaWYgKGVudiQxLkNPTE9SVEVSTSA9PT0gJ3RydWVjb2xvcicpIHtcbiAgICAgIHJldHVybiAzO1xuICAgIH1cblxuICAgIGlmICgnVEVSTV9QUk9HUkFNJyBpbiBlbnYkMSkge1xuICAgICAgdmFyIHZlcnNpb24gPSBwYXJzZUludCgoZW52JDEuVEVSTV9QUk9HUkFNX1ZFUlNJT04gfHwgJycpLnNwbGl0KCcuJylbMF0sIDEwKTtcblxuICAgICAgc3dpdGNoIChlbnYkMS5URVJNX1BST0dSQU0pIHtcbiAgICAgICAgY2FzZSAnaVRlcm0uYXBwJzpcbiAgICAgICAgICByZXR1cm4gdmVyc2lvbiA+PSAzID8gMyA6IDI7XG5cbiAgICAgICAgY2FzZSAnQXBwbGVfVGVybWluYWwnOlxuICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAvLyBObyBkZWZhdWx0XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKC8tMjU2KGNvbG9yKT8kL2kudGVzdChlbnYkMS5URVJNKSkge1xuICAgICAgcmV0dXJuIDI7XG4gICAgfVxuXG4gICAgaWYgKC9ec2NyZWVufF54dGVybXxednQxMDB8XnZ0MjIwfF5yeHZ0fGNvbG9yfGFuc2l8Y3lnd2lufGxpbnV4L2kudGVzdChlbnYkMS5URVJNKSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgaWYgKCdDT0xPUlRFUk0nIGluIGVudiQxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAoZW52JDEuVEVSTSA9PT0gJ2R1bWInKSB7XG4gICAgICByZXR1cm4gbWluO1xuICAgIH1cblxuICAgIHJldHVybiBtaW47XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTdXBwb3J0TGV2ZWwoc3RyZWFtKSB7XG4gICAgdmFyIGxldmVsID0gc3VwcG9ydHNDb2xvcihzdHJlYW0pO1xuICAgIHJldHVybiB0cmFuc2xhdGVMZXZlbChsZXZlbCk7XG4gIH1cblxuICB2YXIgc3VwcG9ydHNDb2xvcl8xID0ge1xuICAgIHN1cHBvcnRzQ29sb3I6IGdldFN1cHBvcnRMZXZlbCxcbiAgICBzdGRvdXQ6IGdldFN1cHBvcnRMZXZlbChwcm9jZXNzLnN0ZG91dCksXG4gICAgc3RkZXJyOiBnZXRTdXBwb3J0TGV2ZWwocHJvY2Vzcy5zdGRlcnIpXG4gIH07XG5cbiAgdmFyIFRFTVBMQVRFX1JFR0VYID0gLyg/OlxcXFwodVthLWZcXGRdezR9fHhbYS1mXFxkXXsyfXwuKSl8KD86XFx7KH4pPyhcXHcrKD86XFwoW14pXSpcXCkpPyg/OlxcLlxcdysoPzpcXChbXildKlxcKSk/KSopKD86WyBcXHRdfCg/PVxccj9cXG4pKSl8KFxcfSl8KCg/Oi58W1xcclxcblxcZl0pKz8pL2dpO1xuICB2YXIgU1RZTEVfUkVHRVggPSAvKD86XnxcXC4pKFxcdyspKD86XFwoKFteKV0qKVxcKSk/L2c7XG4gIHZhciBTVFJJTkdfUkVHRVggPSAvXihbJ1wiXSkoKD86XFxcXC58KD8hXFwxKVteXFxcXF0pKilcXDEkLztcbiAgdmFyIEVTQ0FQRV9SRUdFWCA9IC9cXFxcKHVbYS1mXFxkXXs0fXx4W2EtZlxcZF17Mn18Lil8KFteXFxcXF0pL2dpO1xuICB2YXIgRVNDQVBFUyA9IG5ldyBNYXAoW1snbicsICdcXG4nXSwgWydyJywgJ1xcciddLCBbJ3QnLCAnXFx0J10sIFsnYicsICdcXGInXSwgWydmJywgJ1xcZiddLCBbJ3YnLCAnXFx2J10sIFsnMCcsICdcXDAnXSwgWydcXFxcJywgJ1xcXFwnXSwgWydlJywgXCJcXHgxQlwiXSwgWydhJywgXCJcXHgwN1wiXV0pO1xuXG4gIGZ1bmN0aW9uIHVuZXNjYXBlKGMpIHtcbiAgICBpZiAoY1swXSA9PT0gJ3UnICYmIGMubGVuZ3RoID09PSA1IHx8IGNbMF0gPT09ICd4JyAmJiBjLmxlbmd0aCA9PT0gMykge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoYy5zbGljZSgxKSwgMTYpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gRVNDQVBFUy5nZXQoYykgfHwgYztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlQXJndW1lbnRzKG5hbWUsIGFyZ3MpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHZhciBjaHVua3MgPSBhcmdzLnRyaW0oKS5zcGxpdCgvXFxzKixcXHMqL2cpO1xuICAgIHZhciBtYXRjaGVzO1xuICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gY2h1bmtzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICB2YXIgY2h1bmsgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICBpZiAoIWlzTmFOKGNodW5rKSkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChOdW1iZXIoY2h1bmspKTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVzID0gY2h1bmsubWF0Y2goU1RSSU5HX1JFR0VYKSkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChtYXRjaGVzWzJdLnJlcGxhY2UoRVNDQVBFX1JFR0VYLCBmdW5jdGlvbiAobSwgZXNjYXBlLCBjaHIpIHtcbiAgICAgICAgICAgIHJldHVybiBlc2NhcGUgPyB1bmVzY2FwZShlc2NhcGUpIDogY2hyO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIENoYWxrIHRlbXBsYXRlIHN0eWxlIGFyZ3VtZW50OiBcIi5jb25jYXQoY2h1bmssIFwiIChpbiBzdHlsZSAnXCIpLmNvbmNhdChuYW1lLCBcIicpXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0eWxlKHN0eWxlKSB7XG4gICAgU1RZTEVfUkVHRVgubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHZhciBtYXRjaGVzO1xuXG4gICAgd2hpbGUgKChtYXRjaGVzID0gU1RZTEVfUkVHRVguZXhlYyhzdHlsZSkpICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmFtZSA9IG1hdGNoZXNbMV07XG5cbiAgICAgIGlmIChtYXRjaGVzWzJdKSB7XG4gICAgICAgIHZhciBhcmdzID0gcGFyc2VBcmd1bWVudHMobmFtZSwgbWF0Y2hlc1syXSk7XG4gICAgICAgIHJlc3VsdHMucHVzaChbbmFtZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChbbmFtZV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRTdHlsZShjaGFsaywgc3R5bGVzKSB7XG4gICAgdmFyIGVuYWJsZWQgPSB7fTtcbiAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBzdHlsZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcbiAgICAgICAgdmFyIGxheWVyID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlO1xuICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IzID0gZmFsc2U7XG4gICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjMgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gbGF5ZXIuc3R5bGVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAzOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gKF9zdGVwMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBfc3RlcDMudmFsdWU7XG4gICAgICAgICAgICBlbmFibGVkW3N0eWxlWzBdXSA9IGxheWVyLmludmVyc2UgPyBudWxsIDogc3R5bGUuc2xpY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjMgPSB0cnVlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yMyA9IGVycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyAmJiBfaXRlcmF0b3IzLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjMucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICAgIF9pdGVyYXRvckVycm9yMiA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjdXJyZW50ID0gY2hhbGs7XG5cbiAgICBmb3IgKHZhciBfaSA9IDAsIF9PYmplY3Qka2V5cyA9IE9iamVjdC5rZXlzKGVuYWJsZWQpOyBfaSA8IF9PYmplY3Qka2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBzdHlsZU5hbWUgPSBfT2JqZWN0JGtleXNbX2ldO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShlbmFibGVkW3N0eWxlTmFtZV0pKSB7XG4gICAgICAgIGlmICghKHN0eWxlTmFtZSBpbiBjdXJyZW50KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gQ2hhbGsgc3R5bGU6IFwiLmNvbmNhdChzdHlsZU5hbWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmFibGVkW3N0eWxlTmFtZV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50W3N0eWxlTmFtZV0uYXBwbHkoY3VycmVudCwgZW5hYmxlZFtzdHlsZU5hbWVdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudFtzdHlsZU5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cblxuICB2YXIgdGVtcGxhdGVzID0gZnVuY3Rpb24gdGVtcGxhdGVzKGNoYWxrLCB0bXApIHtcbiAgICB2YXIgc3R5bGVzID0gW107XG4gICAgdmFyIGNodW5rcyA9IFtdO1xuICAgIHZhciBjaHVuayA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xuXG4gICAgdG1wLnJlcGxhY2UoVEVNUExBVEVfUkVHRVgsIGZ1bmN0aW9uIChtLCBlc2NhcGVDaGFyLCBpbnZlcnNlLCBzdHlsZSwgY2xvc2UsIGNocikge1xuICAgICAgaWYgKGVzY2FwZUNoYXIpIHtcbiAgICAgICAgY2h1bmsucHVzaCh1bmVzY2FwZShlc2NhcGVDaGFyKSk7XG4gICAgICB9IGVsc2UgaWYgKHN0eWxlKSB7XG4gICAgICAgIHZhciBzdHIgPSBjaHVuay5qb2luKCcnKTtcbiAgICAgICAgY2h1bmsgPSBbXTtcbiAgICAgICAgY2h1bmtzLnB1c2goc3R5bGVzLmxlbmd0aCA9PT0gMCA/IHN0ciA6IGJ1aWxkU3R5bGUoY2hhbGssIHN0eWxlcykoc3RyKSk7XG4gICAgICAgIHN0eWxlcy5wdXNoKHtcbiAgICAgICAgICBpbnZlcnNlOiBpbnZlcnNlLFxuICAgICAgICAgIHN0eWxlczogcGFyc2VTdHlsZShzdHlsZSlcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGNsb3NlKSB7XG4gICAgICAgIGlmIChzdHlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCBleHRyYW5lb3VzIH0gaW4gQ2hhbGsgdGVtcGxhdGUgbGl0ZXJhbCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2h1bmtzLnB1c2goYnVpbGRTdHlsZShjaGFsaywgc3R5bGVzKShjaHVuay5qb2luKCcnKSkpO1xuICAgICAgICBjaHVuayA9IFtdO1xuICAgICAgICBzdHlsZXMucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaHVuay5wdXNoKGNocik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY2h1bmtzLnB1c2goY2h1bmsuam9pbignJykpO1xuXG4gICAgaWYgKHN0eWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgZXJyTXNnID0gXCJDaGFsayB0ZW1wbGF0ZSBsaXRlcmFsIGlzIG1pc3NpbmcgXCIuY29uY2F0KHN0eWxlcy5sZW5ndGgsIFwiIGNsb3NpbmcgYnJhY2tldFwiKS5jb25jYXQoc3R5bGVzLmxlbmd0aCA9PT0gMSA/ICcnIDogJ3MnLCBcIiAoYH1gKVwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgIH1cblxuICAgIHJldHVybiBjaHVua3Muam9pbignJyk7XG4gIH07XG5cbiAgdmFyIGNoYWxrID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuXG4gICAgdmFyIHN0ZG91dENvbG9yID0gc3VwcG9ydHNDb2xvcl8xLnN0ZG91dDtcbiAgICB2YXIgaXNTaW1wbGVXaW5kb3dzVGVybSA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgJiYgIShwcm9jZXNzLmVudi5URVJNIHx8ICcnKS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ3h0ZXJtJyk7IC8vIGBzdXBwb3J0c0NvbG9yLmxldmVsYCDihpIgYGFuc2lTdHlsZXMuY29sb3JbbmFtZV1gIG1hcHBpbmdcblxuICAgIHZhciBsZXZlbE1hcHBpbmcgPSBbJ2Fuc2knLCAnYW5zaScsICdhbnNpMjU2JywgJ2Fuc2kxNm0nXTsgLy8gYGNvbG9yLWNvbnZlcnRgIG1vZGVscyB0byBleGNsdWRlIGZyb20gdGhlIENoYWxrIEFQSSBkdWUgdG8gY29uZmxpY3RzIGFuZCBzdWNoXG5cbiAgICB2YXIgc2tpcE1vZGVscyA9IG5ldyBTZXQoWydncmF5J10pO1xuICAgIHZhciBzdHlsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgZnVuY3Rpb24gYXBwbHlPcHRpb25zKG9iaiwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIERldGVjdCBsZXZlbCBpZiBub3Qgc2V0IG1hbnVhbGx5XG5cbiAgICAgIHZhciBzY0xldmVsID0gc3Rkb3V0Q29sb3IgPyBzdGRvdXRDb2xvci5sZXZlbCA6IDA7XG4gICAgICBvYmoubGV2ZWwgPSBvcHRpb25zLmxldmVsID09PSB1bmRlZmluZWQgPyBzY0xldmVsIDogb3B0aW9ucy5sZXZlbDtcbiAgICAgIG9iai5lbmFibGVkID0gJ2VuYWJsZWQnIGluIG9wdGlvbnMgPyBvcHRpb25zLmVuYWJsZWQgOiBvYmoubGV2ZWwgPiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIENoYWxrKG9wdGlvbnMpIHtcbiAgICAgIC8vIFdlIGNoZWNrIGZvciB0aGlzLnRlbXBsYXRlIGhlcmUgc2luY2UgY2FsbGluZyBgY2hhbGsuY29uc3RydWN0b3IoKWBcbiAgICAgIC8vIGJ5IGl0c2VsZiB3aWxsIGhhdmUgYSBgdGhpc2Agb2YgYSBwcmV2aW91c2x5IGNvbnN0cnVjdGVkIGNoYWxrIG9iamVjdFxuICAgICAgaWYgKCF0aGlzIHx8ICEodGhpcyBpbnN0YW5jZW9mIENoYWxrKSB8fCB0aGlzLnRlbXBsYXRlKSB7XG4gICAgICAgIHZhciBfY2hhbGsgPSB7fTtcbiAgICAgICAgYXBwbHlPcHRpb25zKF9jaGFsaywgb3B0aW9ucyk7XG5cbiAgICAgICAgX2NoYWxrLnRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgIHJldHVybiBjaGFsa1RhZy5hcHBseShudWxsLCBbX2NoYWxrLnRlbXBsYXRlXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9O1xuXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfY2hhbGssIENoYWxrLnByb3RvdHlwZSk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfY2hhbGsudGVtcGxhdGUsIF9jaGFsayk7XG4gICAgICAgIF9jaGFsay50ZW1wbGF0ZS5jb25zdHJ1Y3RvciA9IENoYWxrO1xuICAgICAgICByZXR1cm4gX2NoYWxrLnRlbXBsYXRlO1xuICAgICAgfVxuXG4gICAgICBhcHBseU9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgfSAvLyBVc2UgYnJpZ2h0IGJsdWUgb24gV2luZG93cyBhcyB0aGUgbm9ybWFsIGJsdWUgY29sb3IgaXMgaWxsZWdpYmxlXG5cblxuICAgIGlmIChpc1NpbXBsZVdpbmRvd3NUZXJtKSB7XG4gICAgICBhbnNpU3R5bGVzLmJsdWUub3BlbiA9IFwiXFx4MUJbOTRtXCI7XG4gICAgfVxuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICB2YXIga2V5ID0gX09iamVjdCRrZXlzW19pXTtcbiAgICAgIGFuc2lTdHlsZXNba2V5XS5jbG9zZVJlID0gbmV3IFJlZ0V4cChlc2NhcGVTdHJpbmdSZWdleHAoYW5zaVN0eWxlc1trZXldLmNsb3NlKSwgJ2cnKTtcbiAgICAgIHN0eWxlc1trZXldID0ge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICB2YXIgY29kZXMgPSBhbnNpU3R5bGVzW2tleV07XG4gICAgICAgICAgcmV0dXJuIGJ1aWxkLmNhbGwodGhpcywgdGhpcy5fc3R5bGVzID8gdGhpcy5fc3R5bGVzLmNvbmNhdChjb2RlcykgOiBbY29kZXNdLCB0aGlzLl9lbXB0eSwga2V5KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgX2kgPSAwLCBfT2JqZWN0JGtleXMgPSBPYmplY3Qua2V5cyhhbnNpU3R5bGVzKTsgX2kgPCBfT2JqZWN0JGtleXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBfbG9vcCgpO1xuICAgIH1cblxuICAgIHN0eWxlcy52aXNpYmxlID0ge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBidWlsZC5jYWxsKHRoaXMsIHRoaXMuX3N0eWxlcyB8fCBbXSwgdHJ1ZSwgJ3Zpc2libGUnKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGFuc2lTdHlsZXMuY29sb3IuY2xvc2VSZSA9IG5ldyBSZWdFeHAoZXNjYXBlU3RyaW5nUmVnZXhwKGFuc2lTdHlsZXMuY29sb3IuY2xvc2UpLCAnZycpO1xuXG4gICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMigpIHtcbiAgICAgIHZhciBtb2RlbCA9IF9PYmplY3Qka2V5czJbX2kyXTtcblxuICAgICAgaWYgKHNraXBNb2RlbHMuaGFzKG1vZGVsKSkge1xuICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgfVxuXG4gICAgICBzdHlsZXNbbW9kZWxdID0ge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLmxldmVsO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3BlbiA9IGFuc2lTdHlsZXMuY29sb3JbbGV2ZWxNYXBwaW5nW2xldmVsXV1bbW9kZWxdLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB2YXIgY29kZXMgPSB7XG4gICAgICAgICAgICAgIG9wZW46IG9wZW4sXG4gICAgICAgICAgICAgIGNsb3NlOiBhbnNpU3R5bGVzLmNvbG9yLmNsb3NlLFxuICAgICAgICAgICAgICBjbG9zZVJlOiBhbnNpU3R5bGVzLmNvbG9yLmNsb3NlUmVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gYnVpbGQuY2FsbCh0aGlzLCB0aGlzLl9zdHlsZXMgPyB0aGlzLl9zdHlsZXMuY29uY2F0KGNvZGVzKSA6IFtjb2Rlc10sIHRoaXMuX2VtcHR5LCBtb2RlbCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgX2kyID0gMCwgX09iamVjdCRrZXlzMiA9IE9iamVjdC5rZXlzKGFuc2lTdHlsZXMuY29sb3IuYW5zaSk7IF9pMiA8IF9PYmplY3Qka2V5czIubGVuZ3RoOyBfaTIrKykge1xuICAgICAgdmFyIF9yZXQgPSBfbG9vcDIoKTtcblxuICAgICAgaWYgKF9yZXQgPT09IFwiY29udGludWVcIikgY29udGludWU7XG4gICAgfVxuXG4gICAgYW5zaVN0eWxlcy5iZ0NvbG9yLmNsb3NlUmUgPSBuZXcgUmVnRXhwKGVzY2FwZVN0cmluZ1JlZ2V4cChhbnNpU3R5bGVzLmJnQ29sb3IuY2xvc2UpLCAnZycpO1xuXG4gICAgdmFyIF9sb29wMyA9IGZ1bmN0aW9uIF9sb29wMygpIHtcbiAgICAgIHZhciBtb2RlbCA9IF9PYmplY3Qka2V5czNbX2kzXTtcblxuICAgICAgaWYgKHNraXBNb2RlbHMuaGFzKG1vZGVsKSkge1xuICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmdNb2RlbCA9ICdiZycgKyBtb2RlbFswXS50b1VwcGVyQ2FzZSgpICsgbW9kZWwuc2xpY2UoMSk7XG4gICAgICBzdHlsZXNbYmdNb2RlbF0gPSB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHZhciBsZXZlbCA9IHRoaXMubGV2ZWw7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvcGVuID0gYW5zaVN0eWxlcy5iZ0NvbG9yW2xldmVsTWFwcGluZ1tsZXZlbF1dW21vZGVsXS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIGNvZGVzID0ge1xuICAgICAgICAgICAgICBvcGVuOiBvcGVuLFxuICAgICAgICAgICAgICBjbG9zZTogYW5zaVN0eWxlcy5iZ0NvbG9yLmNsb3NlLFxuICAgICAgICAgICAgICBjbG9zZVJlOiBhbnNpU3R5bGVzLmJnQ29sb3IuY2xvc2VSZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBidWlsZC5jYWxsKHRoaXMsIHRoaXMuX3N0eWxlcyA/IHRoaXMuX3N0eWxlcy5jb25jYXQoY29kZXMpIDogW2NvZGVzXSwgdGhpcy5fZW1wdHksIG1vZGVsKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBfaTMgPSAwLCBfT2JqZWN0JGtleXMzID0gT2JqZWN0LmtleXMoYW5zaVN0eWxlcy5iZ0NvbG9yLmFuc2kpOyBfaTMgPCBfT2JqZWN0JGtleXMzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgIHZhciBfcmV0MiA9IF9sb29wMygpO1xuXG4gICAgICBpZiAoX3JldDIgPT09IFwiY29udGludWVcIikgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZnVuY3Rpb24gKCkge30sIHN0eWxlcyk7XG5cbiAgICBmdW5jdGlvbiBidWlsZChfc3R5bGVzLCBfZW1wdHksIGtleSkge1xuICAgICAgdmFyIGJ1aWxkZXIgPSBmdW5jdGlvbiBidWlsZGVyKCkge1xuICAgICAgICByZXR1cm4gYXBwbHlTdHlsZS5hcHBseShidWlsZGVyLCBhcmd1bWVudHMpO1xuICAgICAgfTtcblxuICAgICAgYnVpbGRlci5fc3R5bGVzID0gX3N0eWxlcztcbiAgICAgIGJ1aWxkZXIuX2VtcHR5ID0gX2VtcHR5O1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGJ1aWxkZXIsICdsZXZlbCcsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYubGV2ZWw7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGxldmVsKSB7XG4gICAgICAgICAgc2VsZi5sZXZlbCA9IGxldmVsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShidWlsZGVyLCAnZW5hYmxlZCcsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuZW5hYmxlZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZW5hYmxlZCkge1xuICAgICAgICAgIHNlbGYuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBTZWUgYmVsb3cgZm9yIGZpeCByZWdhcmRpbmcgaW52aXNpYmxlIGdyZXkvZGltIGNvbWJpbmF0aW9uIG9uIFdpbmRvd3NcblxuICAgICAgYnVpbGRlci5oYXNHcmV5ID0gdGhpcy5oYXNHcmV5IHx8IGtleSA9PT0gJ2dyYXknIHx8IGtleSA9PT0gJ2dyZXknOyAvLyBgX19wcm90b19fYCBpcyB1c2VkIGJlY2F1c2Ugd2UgbXVzdCByZXR1cm4gYSBmdW5jdGlvbiwgYnV0IHRoZXJlIGlzXG4gICAgICAvLyBubyB3YXkgdG8gY3JlYXRlIGEgZnVuY3Rpb24gd2l0aCBhIGRpZmZlcmVudCBwcm90b3R5cGVcblxuICAgICAgYnVpbGRlci5fX3Byb3RvX18gPSBwcm90bzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xuXG4gICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseVN0eWxlKCkge1xuICAgICAgLy8gU3VwcG9ydCB2YXJhZ3MsIGJ1dCBzaW1wbHkgY2FzdCB0byBzdHJpbmcgaW4gY2FzZSB0aGVyZSdzIG9ubHkgb25lIGFyZ1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgYXJnc0xlbiA9IGFyZ3MubGVuZ3RoO1xuICAgICAgdmFyIHN0ciA9IFN0cmluZyhhcmd1bWVudHNbMF0pO1xuXG4gICAgICBpZiAoYXJnc0xlbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmdzTGVuID4gMSkge1xuICAgICAgICAvLyBEb24ndCBzbGljZSBgYXJndW1lbnRzYCwgaXQgcHJldmVudHMgVjggb3B0aW1pemF0aW9uc1xuICAgICAgICBmb3IgKHZhciBhID0gMTsgYSA8IGFyZ3NMZW47IGErKykge1xuICAgICAgICAgIHN0ciArPSAnICcgKyBhcmdzW2FdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5lbmFibGVkIHx8IHRoaXMubGV2ZWwgPD0gMCB8fCAhc3RyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbXB0eSA/ICcnIDogc3RyO1xuICAgICAgfSAvLyBUdXJucyBvdXQgdGhhdCBvbiBXaW5kb3dzIGRpbW1lZCBncmF5IHRleHQgYmVjb21lcyBpbnZpc2libGUgaW4gY21kLmV4ZSxcbiAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhbGsvY2hhbGsvaXNzdWVzLzU4XG4gICAgICAvLyBJZiB3ZSdyZSBvbiBXaW5kb3dzIGFuZCB3ZSdyZSBkZWFsaW5nIHdpdGggYSBncmF5IGNvbG9yLCB0ZW1wb3JhcmlseSBtYWtlICdkaW0nIGEgbm9vcC5cblxuXG4gICAgICB2YXIgb3JpZ2luYWxEaW0gPSBhbnNpU3R5bGVzLmRpbS5vcGVuO1xuXG4gICAgICBpZiAoaXNTaW1wbGVXaW5kb3dzVGVybSAmJiB0aGlzLmhhc0dyZXkpIHtcbiAgICAgICAgYW5zaVN0eWxlcy5kaW0ub3BlbiA9ICcnO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdGhpcy5fc3R5bGVzLnNsaWNlKCkucmV2ZXJzZSgpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBjb2RlID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgLy8gUmVwbGFjZSBhbnkgaW5zdGFuY2VzIGFscmVhZHkgcHJlc2VudCB3aXRoIGEgcmUtb3BlbmluZyBjb2RlXG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIG9ubHkgdGhlIHBhcnQgb2YgdGhlIHN0cmluZyB1bnRpbCBzYWlkIGNsb3NpbmcgY29kZVxuICAgICAgICAgIC8vIHdpbGwgYmUgY29sb3JlZCwgYW5kIHRoZSByZXN0IHdpbGwgc2ltcGx5IGJlICdwbGFpbicuXG4gICAgICAgICAgc3RyID0gY29kZS5vcGVuICsgc3RyLnJlcGxhY2UoY29kZS5jbG9zZVJlLCBjb2RlLm9wZW4pICsgY29kZS5jbG9zZTsgLy8gQ2xvc2UgdGhlIHN0eWxpbmcgYmVmb3JlIGEgbGluZWJyZWFrIGFuZCByZW9wZW5cbiAgICAgICAgICAvLyBhZnRlciBuZXh0IGxpbmUgdG8gZml4IGEgYmxlZWQgaXNzdWUgb24gbWFjT1NcbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhbGsvY2hhbGsvcHVsbC85MlxuXG4gICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoL1xccj9cXG4vZywgXCJcIi5jb25jYXQoY29kZS5jbG9zZSwgXCIkJlwiKS5jb25jYXQoY29kZS5vcGVuKSk7XG4gICAgICAgIH0gLy8gUmVzZXQgdGhlIG9yaWdpbmFsIGBkaW1gIGlmIHdlIGNoYW5nZWQgaXQgdG8gd29yayBhcm91bmQgdGhlIFdpbmRvd3MgZGltbWVkIGdyYXkgaXNzdWVcblxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYW5zaVN0eWxlcy5kaW0ub3BlbiA9IG9yaWdpbmFsRGltO1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGFsa1RhZyhjaGFsaywgc3RyaW5ncykge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHN0cmluZ3MpKSB7XG4gICAgICAgIC8vIElmIGNoYWxrKCkgd2FzIGNhbGxlZCBieSBpdHNlbGYgb3Igd2l0aCBhIHN0cmluZyxcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBzdHJpbmcgaXRzZWxmIGFzIGEgc3RyaW5nLlxuICAgICAgICByZXR1cm4gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLmpvaW4oJyAnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICB2YXIgcGFydHMgPSBbc3RyaW5ncy5yYXdbMF1dO1xuXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHN0cmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGFydHMucHVzaChTdHJpbmcoYXJnc1tpIC0gMV0pLnJlcGxhY2UoL1t7fVxcXFxdL2csICdcXFxcJCYnKSk7XG4gICAgICAgIHBhcnRzLnB1c2goU3RyaW5nKHN0cmluZ3MucmF3W2ldKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ZW1wbGF0ZXMoY2hhbGssIHBhcnRzLmpvaW4oJycpKTtcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhDaGFsay5wcm90b3R5cGUsIHN0eWxlcyk7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDaGFsaygpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcblxuICAgIG1vZHVsZS5leHBvcnRzLnN1cHBvcnRzQ29sb3IgPSBzdGRvdXRDb2xvcjtcbiAgICBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHM7IC8vIEZvciBUeXBlU2NyaXB0XG4gIH0pO1xuICB2YXIgY2hhbGtfMSA9IGNoYWxrLnN1cHBvcnRzQ29sb3I7XG5cbiAgdmFyIGNvbW1vbiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcblxuICAgIGV4cG9ydHMuY29tbW9uRGVwcmVjYXRlZEhhbmRsZXIgPSBmdW5jdGlvbiAoa2V5T3JQYWlyLCByZWRpcmVjdFRvLCBfcmVmKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IF9yZWYuZGVzY3JpcHRvcjtcbiAgICAgIHZhciBtZXNzYWdlcyA9IFtcIlwiLmNvbmNhdChjaGFsay5kZWZhdWx0LnllbGxvdyh0eXBlb2Yga2V5T3JQYWlyID09PSAnc3RyaW5nJyA/IGRlc2NyaXB0b3Iua2V5KGtleU9yUGFpcikgOiBkZXNjcmlwdG9yLnBhaXIoa2V5T3JQYWlyKSksIFwiIGlzIGRlcHJlY2F0ZWRcIildO1xuXG4gICAgICBpZiAocmVkaXJlY3RUbykge1xuICAgICAgICBtZXNzYWdlcy5wdXNoKFwid2Ugbm93IHRyZWF0IGl0IGFzIFwiLmNvbmNhdChjaGFsay5kZWZhdWx0LmJsdWUodHlwZW9mIHJlZGlyZWN0VG8gPT09ICdzdHJpbmcnID8gZGVzY3JpcHRvci5rZXkocmVkaXJlY3RUbykgOiBkZXNjcmlwdG9yLnBhaXIocmVkaXJlY3RUbykpKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZXNzYWdlcy5qb2luKCc7ICcpICsgJy4nO1xuICAgIH07XG4gIH0pO1xuICB1bndyYXBFeHBvcnRzKGNvbW1vbik7XG4gIHZhciBjb21tb25fMSA9IGNvbW1vbi5jb21tb25EZXByZWNhdGVkSGFuZGxlcjtcblxuICB2YXIgZGVwcmVjYXRlZCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcblxuICAgIHRzbGliXzEuX19leHBvcnRTdGFyKGNvbW1vbiwgZXhwb3J0cyk7XG4gIH0pO1xuICB1bndyYXBFeHBvcnRzKGRlcHJlY2F0ZWQpO1xuXG4gIHZhciBjb21tb24kMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcblxuICAgIGV4cG9ydHMuY29tbW9uSW52YWxpZEhhbmRsZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgdXRpbHMpIHtcbiAgICAgIHJldHVybiBbXCJJbnZhbGlkIFwiLmNvbmNhdChjaGFsay5kZWZhdWx0LnJlZCh1dGlscy5kZXNjcmlwdG9yLmtleShrZXkpKSwgXCIgdmFsdWUuXCIpLCBcIkV4cGVjdGVkIFwiLmNvbmNhdChjaGFsay5kZWZhdWx0LmJsdWUodXRpbHMuc2NoZW1hc1trZXldLmV4cGVjdGVkKHV0aWxzKSksIFwiLFwiKSwgXCJidXQgcmVjZWl2ZWQgXCIuY29uY2F0KGNoYWxrLmRlZmF1bHQucmVkKHV0aWxzLmRlc2NyaXB0b3IudmFsdWUodmFsdWUpKSwgXCIuXCIpXS5qb2luKCcgJyk7XG4gICAgfTtcbiAgfSk7XG4gIHVud3JhcEV4cG9ydHMoY29tbW9uJDEpO1xuICB2YXIgY29tbW9uXzEkMSA9IGNvbW1vbiQxLmNvbW1vbkludmFsaWRIYW5kbGVyO1xuXG4gIHZhciBpbnZhbGlkID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgdHNsaWJfMS5fX2V4cG9ydFN0YXIoY29tbW9uJDEsIGV4cG9ydHMpO1xuICB9KTtcbiAgdW53cmFwRXhwb3J0cyhpbnZhbGlkKTtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXN0ZWQtdGVybmFyeSAqL1xuXG4gIHZhciBhcnIgPSBbXTtcbiAgdmFyIGNoYXJDb2RlQ2FjaGUgPSBbXTtcblxuICB2YXIgbGV2ZW4gPSBmdW5jdGlvbiBsZXZlbihhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciBzd2FwID0gYTsgLy8gU3dhcHBpbmcgdGhlIHN0cmluZ3MgaWYgYGFgIGlzIGxvbmdlciB0aGFuIGBiYCBzbyB3ZSBrbm93IHdoaWNoIG9uZSBpcyB0aGVcbiAgICAvLyBzaG9ydGVzdCAmIHdoaWNoIG9uZSBpcyB0aGUgbG9uZ2VzdFxuXG4gICAgaWYgKGEubGVuZ3RoID4gYi5sZW5ndGgpIHtcbiAgICAgIGEgPSBiO1xuICAgICAgYiA9IHN3YXA7XG4gICAgfVxuXG4gICAgdmFyIGFMZW4gPSBhLmxlbmd0aDtcbiAgICB2YXIgYkxlbiA9IGIubGVuZ3RoO1xuXG4gICAgaWYgKGFMZW4gPT09IDApIHtcbiAgICAgIHJldHVybiBiTGVuO1xuICAgIH1cblxuICAgIGlmIChiTGVuID09PSAwKSB7XG4gICAgICByZXR1cm4gYUxlbjtcbiAgICB9IC8vIFBlcmZvcm1pbmcgc3VmZml4IHRyaW1taW5nOlxuICAgIC8vIFdlIGNhbiBsaW5lYXJseSBkcm9wIHN1ZmZpeCBjb21tb24gdG8gYm90aCBzdHJpbmdzIHNpbmNlIHRoZXlcbiAgICAvLyBkb24ndCBpbmNyZWFzZSBkaXN0YW5jZSBhdCBhbGxcbiAgICAvLyBOb3RlOiBgfi1gIGlzIHRoZSBiaXR3aXNlIHdheSB0byBwZXJmb3JtIGEgYC0gMWAgb3BlcmF0aW9uXG5cblxuICAgIHdoaWxlIChhTGVuID4gMCAmJiBhLmNoYXJDb2RlQXQofi1hTGVuKSA9PT0gYi5jaGFyQ29kZUF0KH4tYkxlbikpIHtcbiAgICAgIGFMZW4tLTtcbiAgICAgIGJMZW4tLTtcbiAgICB9XG5cbiAgICBpZiAoYUxlbiA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJMZW47XG4gICAgfSAvLyBQZXJmb3JtaW5nIHByZWZpeCB0cmltbWluZ1xuICAgIC8vIFdlIGNhbiBsaW5lYXJseSBkcm9wIHByZWZpeCBjb21tb24gdG8gYm90aCBzdHJpbmdzIHNpbmNlIHRoZXlcbiAgICAvLyBkb24ndCBpbmNyZWFzZSBkaXN0YW5jZSBhdCBhbGxcblxuXG4gICAgdmFyIHN0YXJ0ID0gMDtcblxuICAgIHdoaWxlIChzdGFydCA8IGFMZW4gJiYgYS5jaGFyQ29kZUF0KHN0YXJ0KSA9PT0gYi5jaGFyQ29kZUF0KHN0YXJ0KSkge1xuICAgICAgc3RhcnQrKztcbiAgICB9XG5cbiAgICBhTGVuIC09IHN0YXJ0O1xuICAgIGJMZW4gLT0gc3RhcnQ7XG5cbiAgICBpZiAoYUxlbiA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJMZW47XG4gICAgfVxuXG4gICAgdmFyIGJDaGFyQ29kZTtcbiAgICB2YXIgcmV0O1xuICAgIHZhciB0bXA7XG4gICAgdmFyIHRtcDI7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBqID0gMDtcblxuICAgIHdoaWxlIChpIDwgYUxlbikge1xuICAgICAgY2hhckNvZGVDYWNoZVtzdGFydCArIGldID0gYS5jaGFyQ29kZUF0KHN0YXJ0ICsgaSk7XG4gICAgICBhcnJbaV0gPSArK2k7XG4gICAgfVxuXG4gICAgd2hpbGUgKGogPCBiTGVuKSB7XG4gICAgICBiQ2hhckNvZGUgPSBiLmNoYXJDb2RlQXQoc3RhcnQgKyBqKTtcbiAgICAgIHRtcCA9IGorKztcbiAgICAgIHJldCA9IGo7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhTGVuOyBpKyspIHtcbiAgICAgICAgdG1wMiA9IGJDaGFyQ29kZSA9PT0gY2hhckNvZGVDYWNoZVtzdGFydCArIGldID8gdG1wIDogdG1wICsgMTtcbiAgICAgICAgdG1wID0gYXJyW2ldO1xuICAgICAgICByZXQgPSBhcnJbaV0gPSB0bXAgPiByZXQgPyB0bXAyID4gcmV0ID8gcmV0ICsgMSA6IHRtcDIgOiB0bXAyID4gdG1wID8gdG1wICsgMSA6IHRtcDI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICB2YXIgbGV2ZW5fMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcblxuICAgIGV4cG9ydHMubGV2ZW5Vbmtub3duSGFuZGxlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBfcmVmKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IF9yZWYuZGVzY3JpcHRvcixcbiAgICAgICAgICBsb2dnZXIgPSBfcmVmLmxvZ2dlcixcbiAgICAgICAgICBzY2hlbWFzID0gX3JlZi5zY2hlbWFzO1xuICAgICAgdmFyIG1lc3NhZ2VzID0gW1wiSWdub3JlZCB1bmtub3duIG9wdGlvbiBcIi5jb25jYXQoY2hhbGsuZGVmYXVsdC55ZWxsb3coZGVzY3JpcHRvci5wYWlyKHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSkpLCBcIi5cIildO1xuICAgICAgdmFyIHN1Z2dlc3Rpb24gPSBPYmplY3Qua2V5cyhzY2hlbWFzKS5zb3J0KCkuZmluZChmdW5jdGlvbiAoa25vd25LZXkpIHtcbiAgICAgICAgcmV0dXJuIGxldmVuKGtleSwga25vd25LZXkpIDwgMztcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc3VnZ2VzdGlvbikge1xuICAgICAgICBtZXNzYWdlcy5wdXNoKFwiRGlkIHlvdSBtZWFuIFwiLmNvbmNhdChjaGFsay5kZWZhdWx0LmJsdWUoZGVzY3JpcHRvci5rZXkoc3VnZ2VzdGlvbikpLCBcIj9cIikpO1xuICAgICAgfVxuXG4gICAgICBsb2dnZXIud2FybihtZXNzYWdlcy5qb2luKCcgJykpO1xuICAgIH07XG4gIH0pO1xuICB1bndyYXBFeHBvcnRzKGxldmVuXzEpO1xuICB2YXIgbGV2ZW5fMiA9IGxldmVuXzEubGV2ZW5Vbmtub3duSGFuZGxlcjtcblxuICB2YXIgdW5rbm93biA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcblxuICAgIHRzbGliXzEuX19leHBvcnRTdGFyKGxldmVuXzEsIGV4cG9ydHMpO1xuICB9KTtcbiAgdW53cmFwRXhwb3J0cyh1bmtub3duKTtcblxuICB2YXIgaGFuZGxlcnMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG5cbiAgICB0c2xpYl8xLl9fZXhwb3J0U3RhcihkZXByZWNhdGVkLCBleHBvcnRzKTtcblxuICAgIHRzbGliXzEuX19leHBvcnRTdGFyKGludmFsaWQsIGV4cG9ydHMpO1xuXG4gICAgdHNsaWJfMS5fX2V4cG9ydFN0YXIodW5rbm93biwgZXhwb3J0cyk7XG4gIH0pO1xuICB1bndyYXBFeHBvcnRzKGhhbmRsZXJzKTtcblxuICB2YXIgc2NoZW1hID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIHZhciBIQU5ETEVSX0tFWVMgPSBbJ2RlZmF1bHQnLCAnZXhwZWN0ZWQnLCAndmFsaWRhdGUnLCAnZGVwcmVjYXRlZCcsICdmb3J3YXJkJywgJ3JlZGlyZWN0JywgJ292ZXJsYXAnLCAncHJlcHJvY2VzcycsICdwb3N0cHJvY2VzcyddO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlU2NoZW1hKFNjaGVtYUNvbnN0cnVjdG9yLCBwYXJhbWV0ZXJzKSB7XG4gICAgICB2YXIgc2NoZW1hID0gbmV3IFNjaGVtYUNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpO1xuICAgICAgdmFyIHN1YlNjaGVtYSA9IE9iamVjdC5jcmVhdGUoc2NoZW1hKTtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBIQU5ETEVSX0tFWVNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGhhbmRsZXJLZXkgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIGlmIChoYW5kbGVyS2V5IGluIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIHN1YlNjaGVtYVtoYW5kbGVyS2V5XSA9IG5vcm1hbGl6ZUhhbmRsZXIocGFyYW1ldGVyc1toYW5kbGVyS2V5XSwgc2NoZW1hLCBTY2hlbWEucHJvdG90eXBlW2hhbmRsZXJLZXldLmxlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3ViU2NoZW1hO1xuICAgIH1cblxuICAgIGV4cG9ydHMuY3JlYXRlU2NoZW1hID0gY3JlYXRlU2NoZW1hO1xuXG4gICAgdmFyIFNjaGVtYSA9XG4gICAgLyojX19QVVJFX18qL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFNjaGVtYShwYXJhbWV0ZXJzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTY2hlbWEpO1xuXG4gICAgICAgIHRoaXMubmFtZSA9IHBhcmFtZXRlcnMubmFtZTtcbiAgICAgIH1cblxuICAgICAgX2NyZWF0ZUNsYXNzKFNjaGVtYSwgW3tcbiAgICAgICAga2V5OiBcImRlZmF1bHRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWZhdWx0KF91dGlscykge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0gLy8gaXN0YW5idWwgaWdub3JlIG5leHQ6IHRoaXMgaXMgYWN0dWFsbHkgYW4gYWJzdHJhY3QgbWV0aG9kIGJ1dCB3ZSBuZWVkIGEgcGxhY2Vob2xkZXIgdG8gZ2V0IGBmdW5jdGlvbi5sZW5ndGhgXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcImV4cGVjdGVkXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBleHBlY3RlZChfdXRpbHMpIHtcbiAgICAgICAgICByZXR1cm4gJ25vdGhpbmcnO1xuICAgICAgICB9IC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiB0aGlzIGlzIGFjdHVhbGx5IGFuIGFic3RyYWN0IG1ldGhvZCBidXQgd2UgbmVlZCBhIHBsYWNlaG9sZGVyIHRvIGdldCBgZnVuY3Rpb24ubGVuZ3RoYFxuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJ2YWxpZGF0ZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGUoX3ZhbHVlLCBfdXRpbHMpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcImRlcHJlY2F0ZWRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlcHJlY2F0ZWQoX3ZhbHVlLCBfdXRpbHMpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcImZvcndhcmRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZvcndhcmQoX3ZhbHVlLCBfdXRpbHMpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJyZWRpcmVjdFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVkaXJlY3QoX3ZhbHVlLCBfdXRpbHMpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJvdmVybGFwXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvdmVybGFwKGN1cnJlbnRWYWx1ZSwgX25ld1ZhbHVlLCBfdXRpbHMpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJwcmVwcm9jZXNzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVwcm9jZXNzKHZhbHVlLCBfdXRpbHMpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcInBvc3Rwcm9jZXNzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwb3N0cHJvY2Vzcyh2YWx1ZSwgX3V0aWxzKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XSwgW3tcbiAgICAgICAga2V5OiBcImNyZWF0ZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlOiBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzU4NjNcbiAgICAgICAgICByZXR1cm4gY3JlYXRlU2NoZW1hKHRoaXMsIHBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBTY2hlbWE7XG4gICAgfSgpO1xuXG4gICAgZXhwb3J0cy5TY2hlbWEgPSBTY2hlbWE7XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVIYW5kbGVyKGhhbmRsZXIsIHN1cGVyU2NoZW1hLCBoYW5kbGVyQXJndW1lbnRzTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGFuZGxlci5hcHBseSh2b2lkIDAsIF90b0NvbnN1bWFibGVBcnJheShhcmdzLnNsaWNlKDAsIGhhbmRsZXJBcmd1bWVudHNMZW5ndGggLSAxKSkuY29uY2F0KFtzdXBlclNjaGVtYV0sIF90b0NvbnN1bWFibGVBcnJheShhcmdzLnNsaWNlKGhhbmRsZXJBcmd1bWVudHNMZW5ndGggLSAxKSkpKTtcbiAgICAgIH0gOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyO1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICB1bndyYXBFeHBvcnRzKHNjaGVtYSk7XG4gIHZhciBzY2hlbWFfMSA9IHNjaGVtYS5jcmVhdGVTY2hlbWE7XG4gIHZhciBzY2hlbWFfMiA9IHNjaGVtYS5TY2hlbWE7XG5cbiAgdmFyIGFsaWFzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgdmFyIEFsaWFzU2NoZW1hID1cbiAgICAvKiNfX1BVUkVfXyovXG4gICAgZnVuY3Rpb24gKF9zY2hlbWFfMSRTY2hlbWEpIHtcbiAgICAgIF9pbmhlcml0cyhBbGlhc1NjaGVtYSwgX3NjaGVtYV8xJFNjaGVtYSk7XG5cbiAgICAgIGZ1bmN0aW9uIEFsaWFzU2NoZW1hKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgdmFyIF90aGlzO1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBbGlhc1NjaGVtYSk7XG5cbiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQWxpYXNTY2hlbWEpLmNhbGwodGhpcywgcGFyYW1ldGVycykpO1xuICAgICAgICBfdGhpcy5fc291cmNlTmFtZSA9IHBhcmFtZXRlcnMuc291cmNlTmFtZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfVxuXG4gICAgICBfY3JlYXRlQ2xhc3MoQWxpYXNTY2hlbWEsIFt7XG4gICAgICAgIGtleTogXCJleHBlY3RlZFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZXhwZWN0ZWQodXRpbHMpIHtcbiAgICAgICAgICByZXR1cm4gdXRpbHMuc2NoZW1hc1t0aGlzLl9zb3VyY2VOYW1lXS5leHBlY3RlZCh1dGlscyk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcInZhbGlkYXRlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0ZSh2YWx1ZSwgdXRpbHMpIHtcbiAgICAgICAgICByZXR1cm4gdXRpbHMuc2NoZW1hc1t0aGlzLl9zb3VyY2VOYW1lXS52YWxpZGF0ZSh2YWx1ZSwgdXRpbHMpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJyZWRpcmVjdFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVkaXJlY3QoX3ZhbHVlLCBfdXRpbHMpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlTmFtZTtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuXG4gICAgICByZXR1cm4gQWxpYXNTY2hlbWE7XG4gICAgfShzY2hlbWEuU2NoZW1hKTtcblxuICAgIGV4cG9ydHMuQWxpYXNTY2hlbWEgPSBBbGlhc1NjaGVtYTtcbiAgfSk7XG4gIHVud3JhcEV4cG9ydHMoYWxpYXMpO1xuICB2YXIgYWxpYXNfMSA9IGFsaWFzLkFsaWFzU2NoZW1hO1xuXG4gIHZhciBhbnkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG5cbiAgICB2YXIgQW55U2NoZW1hID1cbiAgICAvKiNfX1BVUkVfXyovXG4gICAgZnVuY3Rpb24gKF9zY2hlbWFfMSRTY2hlbWEpIHtcbiAgICAgIF9pbmhlcml0cyhBbnlTY2hlbWEsIF9zY2hlbWFfMSRTY2hlbWEpO1xuXG4gICAgICBmdW5jdGlvbiBBbnlTY2hlbWEoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBbnlTY2hlbWEpO1xuXG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQW55U2NoZW1hKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgIH1cblxuICAgICAgX2NyZWF0ZUNsYXNzKEFueVNjaGVtYSwgW3tcbiAgICAgICAga2V5OiBcImV4cGVjdGVkXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBleHBlY3RlZCgpIHtcbiAgICAgICAgICByZXR1cm4gJ2FueXRoaW5nJztcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwidmFsaWRhdGVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlKCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBBbnlTY2hlbWE7XG4gICAgfShzY2hlbWEuU2NoZW1hKTtcblxuICAgIGV4cG9ydHMuQW55U2NoZW1hID0gQW55U2NoZW1hO1xuICB9KTtcbiAgdW53cmFwRXhwb3J0cyhhbnkpO1xuICB2YXIgYW55XzEgPSBhbnkuQW55U2NoZW1hO1xuXG4gIHZhciBhcnJheSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcblxuICAgIHZhciBBcnJheVNjaGVtYSA9XG4gICAgLyojX19QVVJFX18qL1xuICAgIGZ1bmN0aW9uIChfc2NoZW1hXzEkU2NoZW1hKSB7XG4gICAgICBfaW5oZXJpdHMoQXJyYXlTY2hlbWEsIF9zY2hlbWFfMSRTY2hlbWEpO1xuXG4gICAgICBmdW5jdGlvbiBBcnJheVNjaGVtYShfYSkge1xuICAgICAgICB2YXIgX3RoaXM7XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFycmF5U2NoZW1hKTtcblxuICAgICAgICB2YXIgdmFsdWVTY2hlbWEgPSBfYS52YWx1ZVNjaGVtYSxcbiAgICAgICAgICAgIF9hJG5hbWUgPSBfYS5uYW1lLFxuICAgICAgICAgICAgbmFtZSA9IF9hJG5hbWUgPT09IHZvaWQgMCA/IHZhbHVlU2NoZW1hLm5hbWUgOiBfYSRuYW1lLFxuICAgICAgICAgICAgaGFuZGxlcnMgPSB0c2xpYl8xLl9fcmVzdChfYSwgW1widmFsdWVTY2hlbWFcIiwgXCJuYW1lXCJdKTtcblxuICAgICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBcnJheVNjaGVtYSkuY2FsbCh0aGlzLCBPYmplY3QuYXNzaWduKHt9LCBoYW5kbGVycywge1xuICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfSkpKTtcbiAgICAgICAgX3RoaXMuX3ZhbHVlU2NoZW1hID0gdmFsdWVTY2hlbWE7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH1cblxuICAgICAgX2NyZWF0ZUNsYXNzKEFycmF5U2NoZW1hLCBbe1xuICAgICAgICBrZXk6IFwiZXhwZWN0ZWRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGV4cGVjdGVkKHV0aWxzKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYW4gYXJyYXkgb2YgXCIuY29uY2F0KHRoaXMuX3ZhbHVlU2NoZW1hLmV4cGVjdGVkKHV0aWxzKSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcInZhbGlkYXRlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0ZSh2YWx1ZSwgdXRpbHMpIHtcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGludmFsaWRWYWx1ZXMgPSBbXTtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHZhbHVlW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgICAgICB2YXIgc3ViVmFsdWUgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgdmFyIHN1YlZhbGlkYXRlUmVzdWx0ID0gdXRpbHMubm9ybWFsaXplVmFsaWRhdGVSZXN1bHQodGhpcy5fdmFsdWVTY2hlbWEudmFsaWRhdGUoc3ViVmFsdWUsIHV0aWxzKSwgc3ViVmFsdWUpO1xuXG4gICAgICAgICAgICAgIGlmIChzdWJWYWxpZGF0ZVJlc3VsdCAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGludmFsaWRWYWx1ZXMucHVzaChzdWJWYWxpZGF0ZVJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBpbnZhbGlkVmFsdWVzLmxlbmd0aCA9PT0gMCA/IHRydWUgOiB7XG4gICAgICAgICAgICB2YWx1ZTogaW52YWxpZFZhbHVlc1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcImRlcHJlY2F0ZWRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlcHJlY2F0ZWQodmFsdWUsIHV0aWxzKSB7XG4gICAgICAgICAgdmFyIGRlcHJlY2F0ZWRSZXN1bHQgPSBbXTtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSB2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgICAgICAgICB2YXIgc3ViVmFsdWUgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgICAgIHZhciBzdWJEZXByZWNhdGVkUmVzdWx0ID0gdXRpbHMubm9ybWFsaXplRGVwcmVjYXRlZFJlc3VsdCh0aGlzLl92YWx1ZVNjaGVtYS5kZXByZWNhdGVkKHN1YlZhbHVlLCB1dGlscyksIHN1YlZhbHVlKTtcblxuICAgICAgICAgICAgICBpZiAoc3ViRGVwcmVjYXRlZFJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBkZXByZWNhdGVkUmVzdWx0LnB1c2guYXBwbHkoZGVwcmVjYXRlZFJlc3VsdCwgX3RvQ29uc3VtYWJsZUFycmF5KHN1YkRlcHJlY2F0ZWRSZXN1bHQubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZGVwcmVjYXRlZFZhbHVlID0gX3JlZi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBbZGVwcmVjYXRlZFZhbHVlXVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGRlcHJlY2F0ZWRSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcImZvcndhcmRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZvcndhcmQodmFsdWUsIHV0aWxzKSB7XG4gICAgICAgICAgdmFyIGZvcndhcmRSZXN1bHQgPSBbXTtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlO1xuICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjMgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IzID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSB2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkge1xuICAgICAgICAgICAgICB2YXIgc3ViVmFsdWUgPSBfc3RlcDMudmFsdWU7XG4gICAgICAgICAgICAgIHZhciBzdWJGb3J3YXJkUmVzdWx0ID0gdXRpbHMubm9ybWFsaXplRm9yd2FyZFJlc3VsdCh0aGlzLl92YWx1ZVNjaGVtYS5mb3J3YXJkKHN1YlZhbHVlLCB1dGlscyksIHN1YlZhbHVlKTtcbiAgICAgICAgICAgICAgZm9yd2FyZFJlc3VsdC5wdXNoLmFwcGx5KGZvcndhcmRSZXN1bHQsIF90b0NvbnN1bWFibGVBcnJheShzdWJGb3J3YXJkUmVzdWx0Lm1hcCh3cmFwVHJhbnNmZXJSZXN1bHQpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjMgPSB0cnVlO1xuICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IzID0gZXJyO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IzLnJldHVybigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZvcndhcmRSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcInJlZGlyZWN0XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWRpcmVjdCh2YWx1ZSwgdXRpbHMpIHtcbiAgICAgICAgICB2YXIgcmVtYWluID0gW107XG4gICAgICAgICAgdmFyIHJlZGlyZWN0ID0gW107XG4gICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3I0ID0gZmFsc2U7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yNCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I0ID0gdmFsdWVbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDQ7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSAoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgdmFyIHN1YlZhbHVlID0gX3N0ZXA0LnZhbHVlO1xuICAgICAgICAgICAgICB2YXIgc3ViUmVkaXJlY3RSZXN1bHQgPSB1dGlscy5ub3JtYWxpemVSZWRpcmVjdFJlc3VsdCh0aGlzLl92YWx1ZVNjaGVtYS5yZWRpcmVjdChzdWJWYWx1ZSwgdXRpbHMpLCBzdWJWYWx1ZSk7XG5cbiAgICAgICAgICAgICAgaWYgKCdyZW1haW4nIGluIHN1YlJlZGlyZWN0UmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmVtYWluLnB1c2goc3ViUmVkaXJlY3RSZXN1bHQucmVtYWluKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJlZGlyZWN0LnB1c2guYXBwbHkocmVkaXJlY3QsIF90b0NvbnN1bWFibGVBcnJheShzdWJSZWRpcmVjdFJlc3VsdC5yZWRpcmVjdC5tYXAod3JhcFRyYW5zZmVyUmVzdWx0KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I0ID0gdHJ1ZTtcbiAgICAgICAgICAgIF9pdGVyYXRvckVycm9yNCA9IGVycjtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCAmJiBfaXRlcmF0b3I0LnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yNC5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNCkge1xuICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZW1haW4ubGVuZ3RoID09PSAwID8ge1xuICAgICAgICAgICAgcmVkaXJlY3Q6IHJlZGlyZWN0XG4gICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgIHJlZGlyZWN0OiByZWRpcmVjdCxcbiAgICAgICAgICAgIHJlbWFpbjogcmVtYWluXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwib3ZlcmxhcFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb3ZlcmxhcChjdXJyZW50VmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZS5jb25jYXQobmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBBcnJheVNjaGVtYTtcbiAgICB9KHNjaGVtYS5TY2hlbWEpO1xuXG4gICAgZXhwb3J0cy5BcnJheVNjaGVtYSA9IEFycmF5U2NoZW1hO1xuXG4gICAgZnVuY3Rpb24gd3JhcFRyYW5zZmVyUmVzdWx0KF9yZWYyKSB7XG4gICAgICB2YXIgZnJvbSA9IF9yZWYyLmZyb20sXG4gICAgICAgICAgdG8gPSBfcmVmMi50bztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZyb206IFtmcm9tXSxcbiAgICAgICAgdG86IHRvXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG4gIHVud3JhcEV4cG9ydHMoYXJyYXkpO1xuICB2YXIgYXJyYXlfMSA9IGFycmF5LkFycmF5U2NoZW1hO1xuXG4gIHZhciBib29sZWFuXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG5cbiAgICB2YXIgQm9vbGVhblNjaGVtYSA9XG4gICAgLyojX19QVVJFX18qL1xuICAgIGZ1bmN0aW9uIChfc2NoZW1hXzEkU2NoZW1hKSB7XG4gICAgICBfaW5oZXJpdHMoQm9vbGVhblNjaGVtYSwgX3NjaGVtYV8xJFNjaGVtYSk7XG5cbiAgICAgIGZ1bmN0aW9uIEJvb2xlYW5TY2hlbWEoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCb29sZWFuU2NoZW1hKTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEJvb2xlYW5TY2hlbWEpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgfVxuXG4gICAgICBfY3JlYXRlQ2xhc3MoQm9vbGVhblNjaGVtYSwgW3tcbiAgICAgICAga2V5OiBcImV4cGVjdGVkXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBleHBlY3RlZCgpIHtcbiAgICAgICAgICByZXR1cm4gJ3RydWUgb3IgZmFsc2UnO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJ2YWxpZGF0ZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIEJvb2xlYW5TY2hlbWE7XG4gICAgfShzY2hlbWEuU2NoZW1hKTtcblxuICAgIGV4cG9ydHMuQm9vbGVhblNjaGVtYSA9IEJvb2xlYW5TY2hlbWE7XG4gIH0pO1xuICB1bndyYXBFeHBvcnRzKGJvb2xlYW5fMSk7XG4gIHZhciBib29sZWFuXzIgPSBib29sZWFuXzEuQm9vbGVhblNjaGVtYTtcblxuICB2YXIgdXRpbHMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiByZWNvcmRGcm9tQXJyYXkoYXJyYXksIG1haW5LZXkpIHtcbiAgICAgIHZhciByZWNvcmQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGFycmF5W1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIHZhciBrZXkgPSB2YWx1ZVttYWluS2V5XTsgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcblxuICAgICAgICAgIGlmIChyZWNvcmRba2V5XSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIFwiLmNvbmNhdChtYWluS2V5LCBcIiBcIikuY29uY2F0KEpTT04uc3RyaW5naWZ5KGtleSkpKTtcbiAgICAgICAgICB9IC8vIEB0cy1pZ25vcmVcblxuXG4gICAgICAgICAgcmVjb3JkW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICB9XG5cbiAgICBleHBvcnRzLnJlY29yZEZyb21BcnJheSA9IHJlY29yZEZyb21BcnJheTtcblxuICAgIGZ1bmN0aW9uIG1hcEZyb21BcnJheShhcnJheSwgbWFpbktleSkge1xuICAgICAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gYXJyYXlbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgdmFyIGtleSA9IHZhbHVlW21haW5LZXldOyAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuXG4gICAgICAgICAgaWYgKG1hcC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIFwiLmNvbmNhdChtYWluS2V5LCBcIiBcIikuY29uY2F0KEpTT04uc3RyaW5naWZ5KGtleSkpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG5cbiAgICBleHBvcnRzLm1hcEZyb21BcnJheSA9IG1hcEZyb21BcnJheTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUF1dG9DaGVja2xpc3QoKSB7XG4gICAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIGlkU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoaWQpO1xuXG4gICAgICAgIGlmIChtYXBbaWRTdHJpbmddKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBtYXBbaWRTdHJpbmddID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBleHBvcnRzLmNyZWF0ZUF1dG9DaGVja2xpc3QgPSBjcmVhdGVBdXRvQ2hlY2tsaXN0O1xuXG4gICAgZnVuY3Rpb24gcGFydGl0aW9uKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciB0cnVlQXJyYXkgPSBbXTtcbiAgICAgIHZhciBmYWxzZUFycmF5ID0gW107XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IGFycmF5W1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAzOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gKF9zdGVwMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRydWVBcnJheS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmFsc2VBcnJheS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjMgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvcjMgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMy5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMykge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3RydWVBcnJheSwgZmFsc2VBcnJheV07XG4gICAgfVxuXG4gICAgZXhwb3J0cy5wYXJ0aXRpb24gPSBwYXJ0aXRpb247XG5cbiAgICBmdW5jdGlvbiBpc0ludCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICB9XG5cbiAgICBleHBvcnRzLmlzSW50ID0gaXNJbnQ7XG5cbiAgICBmdW5jdGlvbiBjb21wYXJlUHJpbWl0aXZlKGEsIGIpIHtcbiAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZW9mQSA9IF90eXBlb2YoYSk7XG5cbiAgICAgIHZhciB0eXBlb2ZCID0gX3R5cGVvZihiKTtcblxuICAgICAgdmFyIG9yZGVycyA9IFsndW5kZWZpbmVkJywgJ29iamVjdCcsICdib29sZWFuJywgJ251bWJlcicsICdzdHJpbmcnXTtcblxuICAgICAgaWYgKHR5cGVvZkEgIT09IHR5cGVvZkIpIHtcbiAgICAgICAgcmV0dXJuIG9yZGVycy5pbmRleE9mKHR5cGVvZkEpIC0gb3JkZXJzLmluZGV4T2YodHlwZW9mQik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2ZBICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gTnVtYmVyKGEpIC0gTnVtYmVyKGIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYS5sb2NhbGVDb21wYXJlKGIpO1xuICAgIH1cblxuICAgIGV4cG9ydHMuY29tcGFyZVByaW1pdGl2ZSA9IGNvbXBhcmVQcmltaXRpdmU7XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVEZWZhdWx0UmVzdWx0KHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8ge30gOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZXhwb3J0cy5ub3JtYWxpemVEZWZhdWx0UmVzdWx0ID0gbm9ybWFsaXplRGVmYXVsdFJlc3VsdDtcblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVZhbGlkYXRlUmVzdWx0KHJlc3VsdCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHRydWUgPyB0cnVlIDogcmVzdWx0ID09PSBmYWxzZSA/IHtcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9IDogcmVzdWx0O1xuICAgIH1cblxuICAgIGV4cG9ydHMubm9ybWFsaXplVmFsaWRhdGVSZXN1bHQgPSBub3JtYWxpemVWYWxpZGF0ZVJlc3VsdDtcblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZURlcHJlY2F0ZWRSZXN1bHQocmVzdWx0LCB2YWx1ZSkge1xuICAgICAgdmFyIGRvTm90Tm9ybWFsaXplVHJ1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSBmYWxzZSA/IGZhbHNlIDogcmVzdWx0ID09PSB0cnVlID8gZG9Ob3ROb3JtYWxpemVUcnVlID8gdHJ1ZSA6IFt7XG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfV0gOiAndmFsdWUnIGluIHJlc3VsdCA/IFtyZXN1bHRdIDogcmVzdWx0Lmxlbmd0aCA9PT0gMCA/IGZhbHNlIDogcmVzdWx0O1xuICAgIH1cblxuICAgIGV4cG9ydHMubm9ybWFsaXplRGVwcmVjYXRlZFJlc3VsdCA9IG5vcm1hbGl6ZURlcHJlY2F0ZWRSZXN1bHQ7XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVUcmFuc2ZlclJlc3VsdChyZXN1bHQsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycgfHwgJ2tleScgaW4gcmVzdWx0ID8ge1xuICAgICAgICBmcm9tOiB2YWx1ZSxcbiAgICAgICAgdG86IHJlc3VsdFxuICAgICAgfSA6ICdmcm9tJyBpbiByZXN1bHQgPyB7XG4gICAgICAgIGZyb206IHJlc3VsdC5mcm9tLFxuICAgICAgICB0bzogcmVzdWx0LnRvXG4gICAgICB9IDoge1xuICAgICAgICBmcm9tOiB2YWx1ZSxcbiAgICAgICAgdG86IHJlc3VsdC50b1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBleHBvcnRzLm5vcm1hbGl6ZVRyYW5zZmVyUmVzdWx0ID0gbm9ybWFsaXplVHJhbnNmZXJSZXN1bHQ7XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVGb3J3YXJkUmVzdWx0KHJlc3VsdCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IFtdIDogQXJyYXkuaXNBcnJheShyZXN1bHQpID8gcmVzdWx0Lm1hcChmdW5jdGlvbiAodHJhbnNmZXJSZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVRyYW5zZmVyUmVzdWx0KHRyYW5zZmVyUmVzdWx0LCB2YWx1ZSk7XG4gICAgICB9KSA6IFtub3JtYWxpemVUcmFuc2ZlclJlc3VsdChyZXN1bHQsIHZhbHVlKV07XG4gICAgfVxuXG4gICAgZXhwb3J0cy5ub3JtYWxpemVGb3J3YXJkUmVzdWx0ID0gbm9ybWFsaXplRm9yd2FyZFJlc3VsdDtcblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVJlZGlyZWN0UmVzdWx0KHJlc3VsdCwgdmFsdWUpIHtcbiAgICAgIHZhciByZWRpcmVjdCA9IG5vcm1hbGl6ZUZvcndhcmRSZXN1bHQoX3R5cGVvZihyZXN1bHQpID09PSAnb2JqZWN0JyAmJiAncmVkaXJlY3QnIGluIHJlc3VsdCA/IHJlc3VsdC5yZWRpcmVjdCA6IHJlc3VsdCwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHJlZGlyZWN0Lmxlbmd0aCA9PT0gMCA/IHtcbiAgICAgICAgcmVtYWluOiB2YWx1ZSxcbiAgICAgICAgcmVkaXJlY3Q6IHJlZGlyZWN0XG4gICAgICB9IDogX3R5cGVvZihyZXN1bHQpID09PSAnb2JqZWN0JyAmJiAncmVtYWluJyBpbiByZXN1bHQgPyB7XG4gICAgICAgIHJlbWFpbjogcmVzdWx0LnJlbWFpbixcbiAgICAgICAgcmVkaXJlY3Q6IHJlZGlyZWN0XG4gICAgICB9IDoge1xuICAgICAgICByZWRpcmVjdDogcmVkaXJlY3RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZXhwb3J0cy5ub3JtYWxpemVSZWRpcmVjdFJlc3VsdCA9IG5vcm1hbGl6ZVJlZGlyZWN0UmVzdWx0O1xuICB9KTtcbiAgdW53cmFwRXhwb3J0cyh1dGlscyk7XG4gIHZhciB1dGlsc18xID0gdXRpbHMucmVjb3JkRnJvbUFycmF5O1xuICB2YXIgdXRpbHNfMiA9IHV0aWxzLm1hcEZyb21BcnJheTtcbiAgdmFyIHV0aWxzXzMgPSB1dGlscy5jcmVhdGVBdXRvQ2hlY2tsaXN0O1xuICB2YXIgdXRpbHNfNCA9IHV0aWxzLnBhcnRpdGlvbjtcbiAgdmFyIHV0aWxzXzUgPSB1dGlscy5pc0ludDtcbiAgdmFyIHV0aWxzXzYgPSB1dGlscy5jb21wYXJlUHJpbWl0aXZlO1xuICB2YXIgdXRpbHNfNyA9IHV0aWxzLm5vcm1hbGl6ZURlZmF1bHRSZXN1bHQ7XG4gIHZhciB1dGlsc184ID0gdXRpbHMubm9ybWFsaXplVmFsaWRhdGVSZXN1bHQ7XG4gIHZhciB1dGlsc185ID0gdXRpbHMubm9ybWFsaXplRGVwcmVjYXRlZFJlc3VsdDtcbiAgdmFyIHV0aWxzXzEwID0gdXRpbHMubm9ybWFsaXplVHJhbnNmZXJSZXN1bHQ7XG4gIHZhciB1dGlsc18xMSA9IHV0aWxzLm5vcm1hbGl6ZUZvcndhcmRSZXN1bHQ7XG4gIHZhciB1dGlsc18xMiA9IHV0aWxzLm5vcm1hbGl6ZVJlZGlyZWN0UmVzdWx0O1xuXG4gIHZhciBjaG9pY2UgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG5cbiAgICB2YXIgQ2hvaWNlU2NoZW1hID1cbiAgICAvKiNfX1BVUkVfXyovXG4gICAgZnVuY3Rpb24gKF9zY2hlbWFfMSRTY2hlbWEpIHtcbiAgICAgIF9pbmhlcml0cyhDaG9pY2VTY2hlbWEsIF9zY2hlbWFfMSRTY2hlbWEpO1xuXG4gICAgICBmdW5jdGlvbiBDaG9pY2VTY2hlbWEocGFyYW1ldGVycykge1xuICAgICAgICB2YXIgX3RoaXM7XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENob2ljZVNjaGVtYSk7XG5cbiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQ2hvaWNlU2NoZW1hKS5jYWxsKHRoaXMsIHBhcmFtZXRlcnMpKTtcbiAgICAgICAgX3RoaXMuX2Nob2ljZXMgPSB1dGlscy5tYXBGcm9tQXJyYXkocGFyYW1ldGVycy5jaG9pY2VzLm1hcChmdW5jdGlvbiAoY2hvaWNlKSB7XG4gICAgICAgICAgcmV0dXJuIGNob2ljZSAmJiBfdHlwZW9mKGNob2ljZSkgPT09ICdvYmplY3QnID8gY2hvaWNlIDoge1xuICAgICAgICAgICAgdmFsdWU6IGNob2ljZVxuICAgICAgICAgIH07XG4gICAgICAgIH0pLCAndmFsdWUnKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfVxuXG4gICAgICBfY3JlYXRlQ2xhc3MoQ2hvaWNlU2NoZW1hLCBbe1xuICAgICAgICBrZXk6IFwiZXhwZWN0ZWRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGV4cGVjdGVkKF9yZWYpIHtcbiAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gX3JlZi5kZXNjcmlwdG9yO1xuICAgICAgICAgIHZhciBjaG9pY2VWYWx1ZXMgPSBBcnJheS5mcm9tKHRoaXMuX2Nob2ljZXMua2V5cygpKS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLl9jaG9pY2VzLmdldCh2YWx1ZSk7XG4gICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChjaG9pY2VJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gIWNob2ljZUluZm8uZGVwcmVjYXRlZDtcbiAgICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKGNob2ljZUluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBjaG9pY2VJbmZvLnZhbHVlO1xuICAgICAgICAgIH0pLnNvcnQodXRpbHMuY29tcGFyZVByaW1pdGl2ZSkubWFwKGRlc2NyaXB0b3IudmFsdWUpO1xuICAgICAgICAgIHZhciBoZWFkID0gY2hvaWNlVmFsdWVzLnNsaWNlKDAsIC0yKTtcbiAgICAgICAgICB2YXIgdGFpbCA9IGNob2ljZVZhbHVlcy5zbGljZSgtMik7XG4gICAgICAgICAgcmV0dXJuIGhlYWQuY29uY2F0KHRhaWwuam9pbignIG9yICcpKS5qb2luKCcsICcpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJ2YWxpZGF0ZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY2hvaWNlcy5oYXModmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJkZXByZWNhdGVkXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXByZWNhdGVkKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGNob2ljZUluZm8gPSB0aGlzLl9jaG9pY2VzLmdldCh2YWx1ZSk7XG5cbiAgICAgICAgICByZXR1cm4gY2hvaWNlSW5mbyAmJiBjaG9pY2VJbmZvLmRlcHJlY2F0ZWQgPyB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9IDogZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcImZvcndhcmRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZvcndhcmQodmFsdWUpIHtcbiAgICAgICAgICB2YXIgY2hvaWNlSW5mbyA9IHRoaXMuX2Nob2ljZXMuZ2V0KHZhbHVlKTtcblxuICAgICAgICAgIHJldHVybiBjaG9pY2VJbmZvID8gY2hvaWNlSW5mby5mb3J3YXJkIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogXCJyZWRpcmVjdFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVkaXJlY3QodmFsdWUpIHtcbiAgICAgICAgICB2YXIgY2hvaWNlSW5mbyA9IHRoaXMuX2Nob2ljZXMuZ2V0KHZhbHVlKTtcblxuICAgICAgICAgIHJldHVybiBjaG9pY2VJbmZvID8gY2hvaWNlSW5mby5yZWRpcmVjdCA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuXG4gICAgICByZXR1cm4gQ2hvaWNlU2NoZW1hO1xuICAgIH0oc2NoZW1hLlNjaGVtYSk7XG5cbiAgICBleHBvcnRzLkNob2ljZVNjaGVtYSA9IENob2ljZVNjaGVtYTtcbiAgfSk7XG4gIHVud3JhcEV4cG9ydHMoY2hvaWNlKTtcbiAgdmFyIGNob2ljZV8xID0gY2hvaWNlLkNob2ljZVNjaGVtYTtcblxuICB2YXIgbnVtYmVyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgdmFyIE51bWJlclNjaGVtYSA9XG4gICAgLyojX19QVVJFX18qL1xuICAgIGZ1bmN0aW9uIChfc2NoZW1hXzEkU2NoZW1hKSB7XG4gICAgICBfaW5oZXJpdHMoTnVtYmVyU2NoZW1hLCBfc2NoZW1hXzEkU2NoZW1hKTtcblxuICAgICAgZnVuY3Rpb24gTnVtYmVyU2NoZW1hKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTnVtYmVyU2NoZW1hKTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKE51bWJlclNjaGVtYSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICB9XG5cbiAgICAgIF9jcmVhdGVDbGFzcyhOdW1iZXJTY2hlbWEsIFt7XG4gICAgICAgIGtleTogXCJleHBlY3RlZFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZXhwZWN0ZWQoKSB7XG4gICAgICAgICAgcmV0dXJuICdhIG51bWJlcic7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcInZhbGlkYXRlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0ZSh2YWx1ZSwgX3V0aWxzKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIE51bWJlclNjaGVtYTtcbiAgICB9KHNjaGVtYS5TY2hlbWEpO1xuXG4gICAgZXhwb3J0cy5OdW1iZXJTY2hlbWEgPSBOdW1iZXJTY2hlbWE7XG4gIH0pO1xuICB1bndyYXBFeHBvcnRzKG51bWJlcik7XG4gIHZhciBudW1iZXJfMSA9IG51bWJlci5OdW1iZXJTY2hlbWE7XG5cbiAgdmFyIGludGVnZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG5cbiAgICB2YXIgSW50ZWdlclNjaGVtYSA9XG4gICAgLyojX19QVVJFX18qL1xuICAgIGZ1bmN0aW9uIChfbnVtYmVyXzEkTnVtYmVyU2NoZW0pIHtcbiAgICAgIF9pbmhlcml0cyhJbnRlZ2VyU2NoZW1hLCBfbnVtYmVyXzEkTnVtYmVyU2NoZW0pO1xuXG4gICAgICBmdW5jdGlvbiBJbnRlZ2VyU2NoZW1hKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW50ZWdlclNjaGVtYSk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihJbnRlZ2VyU2NoZW1hKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgIH1cblxuICAgICAgX2NyZWF0ZUNsYXNzKEludGVnZXJTY2hlbWEsIFt7XG4gICAgICAgIGtleTogXCJleHBlY3RlZFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZXhwZWN0ZWQoKSB7XG4gICAgICAgICAgcmV0dXJuICdhbiBpbnRlZ2VyJztcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwidmFsaWRhdGVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlLCB1dGlscyQxKSB7XG4gICAgICAgICAgcmV0dXJuIHV0aWxzJDEubm9ybWFsaXplVmFsaWRhdGVSZXN1bHQoX2dldChfZ2V0UHJvdG90eXBlT2YoSW50ZWdlclNjaGVtYS5wcm90b3R5cGUpLCBcInZhbGlkYXRlXCIsIHRoaXMpLmNhbGwodGhpcywgdmFsdWUsIHV0aWxzJDEpLCB2YWx1ZSkgPT09IHRydWUgJiYgdXRpbHMuaXNJbnQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBJbnRlZ2VyU2NoZW1hO1xuICAgIH0obnVtYmVyLk51bWJlclNjaGVtYSk7XG5cbiAgICBleHBvcnRzLkludGVnZXJTY2hlbWEgPSBJbnRlZ2VyU2NoZW1hO1xuICB9KTtcbiAgdW53cmFwRXhwb3J0cyhpbnRlZ2VyKTtcbiAgdmFyIGludGVnZXJfMSA9IGludGVnZXIuSW50ZWdlclNjaGVtYTtcblxuICB2YXIgc3RyaW5nID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgdmFyIFN0cmluZ1NjaGVtYSA9XG4gICAgLyojX19QVVJFX18qL1xuICAgIGZ1bmN0aW9uIChfc2NoZW1hXzEkU2NoZW1hKSB7XG4gICAgICBfaW5oZXJpdHMoU3RyaW5nU2NoZW1hLCBfc2NoZW1hXzEkU2NoZW1hKTtcblxuICAgICAgZnVuY3Rpb24gU3RyaW5nU2NoZW1hKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RyaW5nU2NoZW1hKTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFN0cmluZ1NjaGVtYSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICB9XG5cbiAgICAgIF9jcmVhdGVDbGFzcyhTdHJpbmdTY2hlbWEsIFt7XG4gICAgICAgIGtleTogXCJleHBlY3RlZFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZXhwZWN0ZWQoKSB7XG4gICAgICAgICAgcmV0dXJuICdhIHN0cmluZyc7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcInZhbGlkYXRlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBTdHJpbmdTY2hlbWE7XG4gICAgfShzY2hlbWEuU2NoZW1hKTtcblxuICAgIGV4cG9ydHMuU3RyaW5nU2NoZW1hID0gU3RyaW5nU2NoZW1hO1xuICB9KTtcbiAgdW53cmFwRXhwb3J0cyhzdHJpbmcpO1xuICB2YXIgc3RyaW5nXzEgPSBzdHJpbmcuU3RyaW5nU2NoZW1hO1xuXG4gIHZhciBzY2hlbWFzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgdHNsaWJfMS5fX2V4cG9ydFN0YXIoYWxpYXMsIGV4cG9ydHMpO1xuXG4gICAgdHNsaWJfMS5fX2V4cG9ydFN0YXIoYW55LCBleHBvcnRzKTtcblxuICAgIHRzbGliXzEuX19leHBvcnRTdGFyKGFycmF5LCBleHBvcnRzKTtcblxuICAgIHRzbGliXzEuX19leHBvcnRTdGFyKGJvb2xlYW5fMSwgZXhwb3J0cyk7XG5cbiAgICB0c2xpYl8xLl9fZXhwb3J0U3RhcihjaG9pY2UsIGV4cG9ydHMpO1xuXG4gICAgdHNsaWJfMS5fX2V4cG9ydFN0YXIoaW50ZWdlciwgZXhwb3J0cyk7XG5cbiAgICB0c2xpYl8xLl9fZXhwb3J0U3RhcihudW1iZXIsIGV4cG9ydHMpO1xuXG4gICAgdHNsaWJfMS5fX2V4cG9ydFN0YXIoc3RyaW5nLCBleHBvcnRzKTtcbiAgfSk7XG4gIHVud3JhcEV4cG9ydHMoc2NoZW1hcyk7XG5cbiAgdmFyIGRlZmF1bHRzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGV4cG9ydHMuZGVmYXVsdERlc2NyaXB0b3IgPSBhcGkuYXBpRGVzY3JpcHRvcjtcbiAgICBleHBvcnRzLmRlZmF1bHRVbmtub3duSGFuZGxlciA9IGxldmVuXzEubGV2ZW5Vbmtub3duSGFuZGxlcjtcbiAgICBleHBvcnRzLmRlZmF1bHRJbnZhbGlkSGFuZGxlciA9IGludmFsaWQuY29tbW9uSW52YWxpZEhhbmRsZXI7XG4gICAgZXhwb3J0cy5kZWZhdWx0RGVwcmVjYXRlZEhhbmRsZXIgPSBjb21tb24uY29tbW9uRGVwcmVjYXRlZEhhbmRsZXI7XG4gIH0pO1xuICB1bndyYXBFeHBvcnRzKGRlZmF1bHRzKTtcbiAgdmFyIGRlZmF1bHRzXzEgPSBkZWZhdWx0cy5kZWZhdWx0RGVzY3JpcHRvcjtcbiAgdmFyIGRlZmF1bHRzXzIgPSBkZWZhdWx0cy5kZWZhdWx0VW5rbm93bkhhbmRsZXI7XG4gIHZhciBkZWZhdWx0c18zID0gZGVmYXVsdHMuZGVmYXVsdEludmFsaWRIYW5kbGVyO1xuICB2YXIgZGVmYXVsdHNfNCA9IGRlZmF1bHRzLmRlZmF1bHREZXByZWNhdGVkSGFuZGxlcjtcblxuICB2YXIgbm9ybWFsaXplID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucywgc2NoZW1hcywgb3B0cykge1xuICAgICAgcmV0dXJuIG5ldyBOb3JtYWxpemVyKHNjaGVtYXMsIG9wdHMpLm5vcm1hbGl6ZShvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgdmFyIE5vcm1hbGl6ZXIgPVxuICAgIC8qI19fUFVSRV9fKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBOb3JtYWxpemVyKHNjaGVtYXMsIG9wdHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vcm1hbGl6ZXIpO1xuXG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgIHZhciBfcmVmID0gb3B0cyB8fCB7fSxcbiAgICAgICAgICAgIF9yZWYkbG9nZ2VyID0gX3JlZi5sb2dnZXIsXG4gICAgICAgICAgICBsb2dnZXIgPSBfcmVmJGxvZ2dlciA9PT0gdm9pZCAwID8gY29uc29sZSA6IF9yZWYkbG9nZ2VyLFxuICAgICAgICAgICAgX3JlZiRkZXNjcmlwdG9yID0gX3JlZi5kZXNjcmlwdG9yLFxuICAgICAgICAgICAgZGVzY3JpcHRvciA9IF9yZWYkZGVzY3JpcHRvciA9PT0gdm9pZCAwID8gZGVmYXVsdHMuZGVmYXVsdERlc2NyaXB0b3IgOiBfcmVmJGRlc2NyaXB0b3IsXG4gICAgICAgICAgICBfcmVmJHVua25vd24gPSBfcmVmLnVua25vd24sXG4gICAgICAgICAgICB1bmtub3duID0gX3JlZiR1bmtub3duID09PSB2b2lkIDAgPyBkZWZhdWx0cy5kZWZhdWx0VW5rbm93bkhhbmRsZXIgOiBfcmVmJHVua25vd24sXG4gICAgICAgICAgICBfcmVmJGludmFsaWQgPSBfcmVmLmludmFsaWQsXG4gICAgICAgICAgICBpbnZhbGlkID0gX3JlZiRpbnZhbGlkID09PSB2b2lkIDAgPyBkZWZhdWx0cy5kZWZhdWx0SW52YWxpZEhhbmRsZXIgOiBfcmVmJGludmFsaWQsXG4gICAgICAgICAgICBfcmVmJGRlcHJlY2F0ZWQgPSBfcmVmLmRlcHJlY2F0ZWQsXG4gICAgICAgICAgICBkZXByZWNhdGVkID0gX3JlZiRkZXByZWNhdGVkID09PSB2b2lkIDAgPyBkZWZhdWx0cy5kZWZhdWx0RGVwcmVjYXRlZEhhbmRsZXIgOiBfcmVmJGRlcHJlY2F0ZWQ7XG5cbiAgICAgICAgdGhpcy5fdXRpbHMgPSB7XG4gICAgICAgICAgZGVzY3JpcHRvcjogZGVzY3JpcHRvcixcbiAgICAgICAgICBsb2dnZXI6XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICBsb2dnZXIgfHwge1xuICAgICAgICAgICAgd2FybjogZnVuY3Rpb24gd2FybigpIHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzY2hlbWFzOiB1dGlscy5yZWNvcmRGcm9tQXJyYXkoc2NoZW1hcywgJ25hbWUnKSxcbiAgICAgICAgICBub3JtYWxpemVEZWZhdWx0UmVzdWx0OiB1dGlscy5ub3JtYWxpemVEZWZhdWx0UmVzdWx0LFxuICAgICAgICAgIG5vcm1hbGl6ZURlcHJlY2F0ZWRSZXN1bHQ6IHV0aWxzLm5vcm1hbGl6ZURlcHJlY2F0ZWRSZXN1bHQsXG4gICAgICAgICAgbm9ybWFsaXplRm9yd2FyZFJlc3VsdDogdXRpbHMubm9ybWFsaXplRm9yd2FyZFJlc3VsdCxcbiAgICAgICAgICBub3JtYWxpemVSZWRpcmVjdFJlc3VsdDogdXRpbHMubm9ybWFsaXplUmVkaXJlY3RSZXN1bHQsXG4gICAgICAgICAgbm9ybWFsaXplVmFsaWRhdGVSZXN1bHQ6IHV0aWxzLm5vcm1hbGl6ZVZhbGlkYXRlUmVzdWx0XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3Vua25vd25IYW5kbGVyID0gdW5rbm93bjtcbiAgICAgICAgdGhpcy5faW52YWxpZEhhbmRsZXIgPSBpbnZhbGlkO1xuICAgICAgICB0aGlzLl9kZXByZWNhdGVkSGFuZGxlciA9IGRlcHJlY2F0ZWQ7XG4gICAgICAgIHRoaXMuY2xlYW5IaXN0b3J5KCk7XG4gICAgICB9XG5cbiAgICAgIF9jcmVhdGVDbGFzcyhOb3JtYWxpemVyLCBbe1xuICAgICAgICBrZXk6IFwiY2xlYW5IaXN0b3J5XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhbkhpc3RvcnkoKSB7XG4gICAgICAgICAgdGhpcy5faGFzRGVwcmVjYXRpb25XYXJuZWQgPSB1dGlscy5jcmVhdGVBdXRvQ2hlY2tsaXN0KCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiBcIm5vcm1hbGl6ZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbm9ybWFsaXplKG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSB7fTtcbiAgICAgICAgICB2YXIgcmVzdE9wdGlvbnNBcnJheSA9IFtvcHRpb25zXTtcblxuICAgICAgICAgIHZhciBhcHBseU5vcm1hbGl6YXRpb24gPSBmdW5jdGlvbiBhcHBseU5vcm1hbGl6YXRpb24oKSB7XG4gICAgICAgICAgICB3aGlsZSAocmVzdE9wdGlvbnNBcnJheS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnRPcHRpb25zID0gcmVzdE9wdGlvbnNBcnJheS5zaGlmdCgpO1xuXG4gICAgICAgICAgICAgIHZhciB0cmFuc2ZlcnJlZE9wdGlvbnNBcnJheSA9IF90aGlzLl9hcHBseU5vcm1hbGl6YXRpb24oY3VycmVudE9wdGlvbnMsIG5vcm1hbGl6ZWQpO1xuXG4gICAgICAgICAgICAgIHJlc3RPcHRpb25zQXJyYXkucHVzaC5hcHBseShyZXN0T3B0aW9uc0FycmF5LCBfdG9Db25zdW1hYmxlQXJyYXkodHJhbnNmZXJyZWRPcHRpb25zQXJyYXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgYXBwbHlOb3JtYWxpemF0aW9uKCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9PYmplY3Qka2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX3V0aWxzLnNjaGVtYXMpOyBfaSA8IF9PYmplY3Qka2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBfT2JqZWN0JGtleXNbX2ldO1xuICAgICAgICAgICAgdmFyIHNjaGVtYSA9IHRoaXMuX3V0aWxzLnNjaGVtYXNba2V5XTtcblxuICAgICAgICAgICAgaWYgKCEoa2V5IGluIG5vcm1hbGl6ZWQpKSB7XG4gICAgICAgICAgICAgIHZhciBkZWZhdWx0UmVzdWx0ID0gdXRpbHMubm9ybWFsaXplRGVmYXVsdFJlc3VsdChzY2hlbWEuZGVmYXVsdCh0aGlzLl91dGlscykpO1xuXG4gICAgICAgICAgICAgIGlmICgndmFsdWUnIGluIGRlZmF1bHRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXN0T3B0aW9uc0FycmF5LnB1c2goX2RlZmluZVByb3BlcnR5KHt9LCBrZXksIGRlZmF1bHRSZXN1bHQudmFsdWUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGFwcGx5Tm9ybWFsaXphdGlvbigpO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2kyID0gMCwgX09iamVjdCRrZXlzMiA9IE9iamVjdC5rZXlzKHRoaXMuX3V0aWxzLnNjaGVtYXMpOyBfaTIgPCBfT2JqZWN0JGtleXMyLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICAgIHZhciBfa2V5ID0gX09iamVjdCRrZXlzMltfaTJdO1xuICAgICAgICAgICAgdmFyIF9zY2hlbWEgPSB0aGlzLl91dGlscy5zY2hlbWFzW19rZXldO1xuXG4gICAgICAgICAgICBpZiAoX2tleSBpbiBub3JtYWxpemVkKSB7XG4gICAgICAgICAgICAgIG5vcm1hbGl6ZWRbX2tleV0gPSBfc2NoZW1hLnBvc3Rwcm9jZXNzKG5vcm1hbGl6ZWRbX2tleV0sIHRoaXMuX3V0aWxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6IFwiX2FwcGx5Tm9ybWFsaXphdGlvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2FwcGx5Tm9ybWFsaXphdGlvbihvcHRpb25zLCBub3JtYWxpemVkKSB7XG4gICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICB2YXIgdHJhbnNmZXJyZWRPcHRpb25zQXJyYXkgPSBbXTtcblxuICAgICAgICAgIHZhciBfdXRpbHNfMSRwYXJ0aXRpb24gPSB1dGlscy5wYXJ0aXRpb24oT2JqZWN0LmtleXMob3B0aW9ucyksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXkgaW4gX3RoaXMyLl91dGlscy5zY2hlbWFzO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBfdXRpbHNfMSRwYXJ0aXRpb24yID0gX3NsaWNlZFRvQXJyYXkoX3V0aWxzXzEkcGFydGl0aW9uLCAyKSxcbiAgICAgICAgICAgICAga25vd25PcHRpb25OYW1lcyA9IF91dGlsc18xJHBhcnRpdGlvbjJbMF0sXG4gICAgICAgICAgICAgIHVua25vd25PcHRpb25OYW1lcyA9IF91dGlsc18xJHBhcnRpdGlvbjJbMV07XG5cbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgICAgICAgICB2YXIga2V5ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIHZhciBzY2hlbWEgPSBfdGhpczIuX3V0aWxzLnNjaGVtYXNba2V5XTtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc2NoZW1hLnByZXByb2Nlc3Mob3B0aW9uc1trZXldLCBfdGhpczIuX3V0aWxzKTtcbiAgICAgICAgICAgICAgdmFyIHZhbGlkYXRlUmVzdWx0ID0gdXRpbHMubm9ybWFsaXplVmFsaWRhdGVSZXN1bHQoc2NoZW1hLnZhbGlkYXRlKHZhbHVlLCBfdGhpczIuX3V0aWxzKSwgdmFsdWUpO1xuXG4gICAgICAgICAgICAgIGlmICh2YWxpZGF0ZVJlc3VsdCAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBpbnZhbGlkVmFsdWUgPSB2YWxpZGF0ZVJlc3VsdC52YWx1ZTtcblxuICAgICAgICAgICAgICAgIHZhciBlcnJvck1lc3NhZ2VPckVycm9yID0gX3RoaXMyLl9pbnZhbGlkSGFuZGxlcihrZXksIGludmFsaWRWYWx1ZSwgX3RoaXMyLl91dGlscyk7XG5cbiAgICAgICAgICAgICAgICB0aHJvdyB0eXBlb2YgZXJyb3JNZXNzYWdlT3JFcnJvciA9PT0gJ3N0cmluZycgPyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlT3JFcnJvcikgOlxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0Ki9cbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2VPckVycm9yO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGFwcGVuZFRyYW5zZmVycmVkT3B0aW9ucyA9IGZ1bmN0aW9uIGFwcGVuZFRyYW5zZmVycmVkT3B0aW9ucyhfcmVmMikge1xuICAgICAgICAgICAgICAgIHZhciBmcm9tID0gX3JlZjIuZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgdG8gPSBfcmVmMi50bztcbiAgICAgICAgICAgICAgICB0cmFuc2ZlcnJlZE9wdGlvbnNBcnJheS5wdXNoKHR5cGVvZiB0byA9PT0gJ3N0cmluZycgPyBfZGVmaW5lUHJvcGVydHkoe30sIHRvLCBmcm9tKSA6IF9kZWZpbmVQcm9wZXJ0eSh7fSwgdG8ua2V5LCB0by52YWx1ZSkpO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHZhciB3YXJuRGVwcmVjYXRlZCA9IGZ1bmN0aW9uIHdhcm5EZXByZWNhdGVkKF9yZWY1KSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IF9yZWY1LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdFRvID0gX3JlZjUucmVkaXJlY3RUbztcbiAgICAgICAgICAgICAgICB2YXIgZGVwcmVjYXRlZFJlc3VsdCA9IHV0aWxzLm5vcm1hbGl6ZURlcHJlY2F0ZWRSZXN1bHQoc2NoZW1hLmRlcHJlY2F0ZWQoY3VycmVudFZhbHVlLCBfdGhpczIuX3V0aWxzKSwgdmFsdWUsXG4gICAgICAgICAgICAgICAgLyogZG9Ob3ROb3JtYWxpemVUcnVlICovXG4gICAgICAgICAgICAgICAgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGVwcmVjYXRlZFJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGVwcmVjYXRlZFJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpczIuX2hhc0RlcHJlY2F0aW9uV2FybmVkKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMyLl91dGlscy5sb2dnZXIud2FybihfdGhpczIuX2RlcHJlY2F0ZWRIYW5kbGVyKGtleSwgcmVkaXJlY3RUbywgX3RoaXMyLl91dGlscykpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IGRlcHJlY2F0ZWRSZXN1bHRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDM7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSAoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVwcmVjYXRlZFZhbHVlID0gX3N0ZXAzLnZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBwYWlyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZGVwcmVjYXRlZFZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMyLl9oYXNEZXByZWNhdGlvbldhcm5lZChwYWlyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZGlyZWN0VG9QYWlyID0gdHlwZW9mIHJlZGlyZWN0VG8gPT09ICdzdHJpbmcnID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHJlZGlyZWN0VG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkZXByZWNhdGVkVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gOiByZWRpcmVjdFRvO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpczIuX3V0aWxzLmxvZ2dlci53YXJuKF90aGlzMi5fZGVwcmVjYXRlZEhhbmRsZXIocGFpciwgcmVkaXJlY3RUb1BhaXIsIF90aGlzMi5fdXRpbHMpKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjMgPSBlcnI7XG4gICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IzO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB2YXIgZm9yd2FyZFJlc3VsdCA9IHV0aWxzLm5vcm1hbGl6ZUZvcndhcmRSZXN1bHQoc2NoZW1hLmZvcndhcmQodmFsdWUsIF90aGlzMi5fdXRpbHMpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIGZvcndhcmRSZXN1bHQuZm9yRWFjaChhcHBlbmRUcmFuc2ZlcnJlZE9wdGlvbnMpO1xuICAgICAgICAgICAgICB2YXIgcmVkaXJlY3RSZXN1bHQgPSB1dGlscy5ub3JtYWxpemVSZWRpcmVjdFJlc3VsdChzY2hlbWEucmVkaXJlY3QodmFsdWUsIF90aGlzMi5fdXRpbHMpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIHJlZGlyZWN0UmVzdWx0LnJlZGlyZWN0LmZvckVhY2goYXBwZW5kVHJhbnNmZXJyZWRPcHRpb25zKTtcblxuICAgICAgICAgICAgICBpZiAoJ3JlbWFpbicgaW4gcmVkaXJlY3RSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVtYWluaW5nVmFsdWUgPSByZWRpcmVjdFJlc3VsdC5yZW1haW47XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFtrZXldID0ga2V5IGluIG5vcm1hbGl6ZWQgPyBzY2hlbWEub3ZlcmxhcChub3JtYWxpemVkW2tleV0sIHJlbWFpbmluZ1ZhbHVlLCBfdGhpczIuX3V0aWxzKSA6IHJlbWFpbmluZ1ZhbHVlO1xuICAgICAgICAgICAgICAgIHdhcm5EZXByZWNhdGVkKHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiByZW1haW5pbmdWYWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNCA9IGZhbHNlO1xuICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I0ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNCA9IHJlZGlyZWN0UmVzdWx0LnJlZGlyZWN0W1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA0OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gKF9zdGVwNCA9IF9pdGVyYXRvcjQubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX3N0ZXA0JHZhbHVlID0gX3N0ZXA0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgIGZyb20gPSBfc3RlcDQkdmFsdWUuZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgICB0byA9IF9zdGVwNCR2YWx1ZS50bztcbiAgICAgICAgICAgICAgICAgIHdhcm5EZXByZWNhdGVkKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZyb20sXG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0VG86IHRvXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yNCA9IHRydWU7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3I0ID0gZXJyO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ICYmIF9pdGVyYXRvcjQucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yNC5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBrbm93bk9wdGlvbk5hbWVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgICAgICBfbG9vcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gdW5rbm93bk9wdGlvbk5hbWVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG4gICAgICAgICAgICAgIHZhciBrZXkgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9wdGlvbnNba2V5XTtcblxuICAgICAgICAgICAgICB2YXIgdW5rbm93blJlc3VsdCA9IHRoaXMuX3Vua25vd25IYW5kbGVyKGtleSwgdmFsdWUsIHRoaXMuX3V0aWxzKTtcblxuICAgICAgICAgICAgICBpZiAodW5rbm93blJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMyA9IDAsIF9PYmplY3Qka2V5czMgPSBPYmplY3Qua2V5cyh1bmtub3duUmVzdWx0KTsgX2kzIDwgX09iamVjdCRrZXlzMy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdW5rbm93bktleSA9IF9PYmplY3Qka2V5czNbX2kzXTtcblxuICAgICAgICAgICAgICAgICAgdmFyIHVua25vd25PcHRpb24gPSBfZGVmaW5lUHJvcGVydHkoe30sIHVua25vd25LZXksIHVua25vd25SZXN1bHRbdW5rbm93bktleV0pO1xuXG4gICAgICAgICAgICAgICAgICBpZiAodW5rbm93bktleSBpbiB0aGlzLl91dGlscy5zY2hlbWFzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZmVycmVkT3B0aW9uc0FycmF5LnB1c2godW5rbm93bk9wdGlvbik7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG5vcm1hbGl6ZWQsIHVua25vd25PcHRpb24pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICAgICAgICAgIF9pdGVyYXRvckVycm9yMiA9IGVycjtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cmFuc2ZlcnJlZE9wdGlvbnNBcnJheTtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuXG4gICAgICByZXR1cm4gTm9ybWFsaXplcjtcbiAgICB9KCk7XG5cbiAgICBleHBvcnRzLk5vcm1hbGl6ZXIgPSBOb3JtYWxpemVyO1xuICB9KTtcbiAgdW53cmFwRXhwb3J0cyhub3JtYWxpemUpO1xuICB2YXIgbm9ybWFsaXplXzEgPSBub3JtYWxpemUubm9ybWFsaXplO1xuICB2YXIgbm9ybWFsaXplXzIgPSBub3JtYWxpemUuTm9ybWFsaXplcjtcblxuICB2YXIgbGliID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgdHNsaWJfMS5fX2V4cG9ydFN0YXIoZGVzY3JpcHRvcnMsIGV4cG9ydHMpO1xuXG4gICAgdHNsaWJfMS5fX2V4cG9ydFN0YXIoaGFuZGxlcnMsIGV4cG9ydHMpO1xuXG4gICAgdHNsaWJfMS5fX2V4cG9ydFN0YXIoc2NoZW1hcywgZXhwb3J0cyk7XG5cbiAgICB0c2xpYl8xLl9fZXhwb3J0U3Rhcihub3JtYWxpemUsIGV4cG9ydHMpO1xuXG4gICAgdHNsaWJfMS5fX2V4cG9ydFN0YXIoc2NoZW1hLCBleHBvcnRzKTtcbiAgfSk7XG4gIHVud3JhcEV4cG9ydHMobGliKTtcblxuICB2YXIgYXJyYXkkMSA9IFtdO1xuICB2YXIgY2hhckNvZGVDYWNoZSQxID0gW107XG5cbiAgdmFyIGxldmVuJDEgPSBmdW5jdGlvbiBsZXZlbihsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0ID09PSByaWdodCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIHN3YXAgPSBsZWZ0OyAvLyBTd2FwcGluZyB0aGUgc3RyaW5ncyBpZiBgYWAgaXMgbG9uZ2VyIHRoYW4gYGJgIHNvIHdlIGtub3cgd2hpY2ggb25lIGlzIHRoZVxuICAgIC8vIHNob3J0ZXN0ICYgd2hpY2ggb25lIGlzIHRoZSBsb25nZXN0XG5cbiAgICBpZiAobGVmdC5sZW5ndGggPiByaWdodC5sZW5ndGgpIHtcbiAgICAgIGxlZnQgPSByaWdodDtcbiAgICAgIHJpZ2h0ID0gc3dhcDtcbiAgICB9XG5cbiAgICB2YXIgbGVmdExlbmd0aCA9IGxlZnQubGVuZ3RoO1xuICAgIHZhciByaWdodExlbmd0aCA9IHJpZ2h0Lmxlbmd0aDsgLy8gUGVyZm9ybWluZyBzdWZmaXggdHJpbW1pbmc6XG4gICAgLy8gV2UgY2FuIGxpbmVhcmx5IGRyb3Agc3VmZml4IGNvbW1vbiB0byBib3RoIHN0cmluZ3Mgc2luY2UgdGhleVxuICAgIC8vIGRvbid0IGluY3JlYXNlIGRpc3RhbmNlIGF0IGFsbFxuICAgIC8vIE5vdGU6IGB+LWAgaXMgdGhlIGJpdHdpc2Ugd2F5IHRvIHBlcmZvcm0gYSBgLSAxYCBvcGVyYXRpb25cblxuICAgIHdoaWxlIChsZWZ0TGVuZ3RoID4gMCAmJiBsZWZ0LmNoYXJDb2RlQXQofi1sZWZ0TGVuZ3RoKSA9PT0gcmlnaHQuY2hhckNvZGVBdCh+LXJpZ2h0TGVuZ3RoKSkge1xuICAgICAgbGVmdExlbmd0aC0tO1xuICAgICAgcmlnaHRMZW5ndGgtLTtcbiAgICB9IC8vIFBlcmZvcm1pbmcgcHJlZml4IHRyaW1taW5nXG4gICAgLy8gV2UgY2FuIGxpbmVhcmx5IGRyb3AgcHJlZml4IGNvbW1vbiB0byBib3RoIHN0cmluZ3Mgc2luY2UgdGhleVxuICAgIC8vIGRvbid0IGluY3JlYXNlIGRpc3RhbmNlIGF0IGFsbFxuXG5cbiAgICB2YXIgc3RhcnQgPSAwO1xuXG4gICAgd2hpbGUgKHN0YXJ0IDwgbGVmdExlbmd0aCAmJiBsZWZ0LmNoYXJDb2RlQXQoc3RhcnQpID09PSByaWdodC5jaGFyQ29kZUF0KHN0YXJ0KSkge1xuICAgICAgc3RhcnQrKztcbiAgICB9XG5cbiAgICBsZWZ0TGVuZ3RoIC09IHN0YXJ0O1xuICAgIHJpZ2h0TGVuZ3RoIC09IHN0YXJ0O1xuXG4gICAgaWYgKGxlZnRMZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiByaWdodExlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgYkNoYXJDb2RlO1xuICAgIHZhciByZXN1bHQ7XG4gICAgdmFyIHRlbXA7XG4gICAgdmFyIHRlbXAyO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgaiA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IGxlZnRMZW5ndGgpIHtcbiAgICAgIGNoYXJDb2RlQ2FjaGUkMVtpXSA9IGxlZnQuY2hhckNvZGVBdChzdGFydCArIGkpO1xuICAgICAgYXJyYXkkMVtpXSA9ICsraTtcbiAgICB9XG5cbiAgICB3aGlsZSAoaiA8IHJpZ2h0TGVuZ3RoKSB7XG4gICAgICBiQ2hhckNvZGUgPSByaWdodC5jaGFyQ29kZUF0KHN0YXJ0ICsgaik7XG4gICAgICB0ZW1wID0gaisrO1xuICAgICAgcmVzdWx0ID0gajtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlZnRMZW5ndGg7IGkrKykge1xuICAgICAgICB0ZW1wMiA9IGJDaGFyQ29kZSA9PT0gY2hhckNvZGVDYWNoZSQxW2ldID8gdGVtcCA6IHRlbXAgKyAxO1xuICAgICAgICB0ZW1wID0gYXJyYXkkMVtpXTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW11bHRpLWFzc2lnblxuXG4gICAgICAgIHJlc3VsdCA9IGFycmF5JDFbaV0gPSB0ZW1wID4gcmVzdWx0ID8gdGVtcDIgPiByZXN1bHQgPyByZXN1bHQgKyAxIDogdGVtcDIgOiB0ZW1wMiA+IHRlbXAgPyB0ZW1wICsgMSA6IHRlbXAyO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIGxldmVuXzEkMSA9IGxldmVuJDE7IC8vIFRPRE86IFJlbW92ZSB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG5cbiAgdmFyIGRlZmF1bHRfMSA9IGxldmVuJDE7XG4gIGxldmVuXzEkMS5kZWZhdWx0ID0gZGVmYXVsdF8xO1xuXG4gIHZhciBjbGlEZXNjcmlwdG9yID0ge1xuICAgIGtleTogZnVuY3Rpb24ga2V5KF9rZXkpIHtcbiAgICAgIHJldHVybiBfa2V5Lmxlbmd0aCA9PT0gMSA/IFwiLVwiLmNvbmNhdChfa2V5KSA6IFwiLS1cIi5jb25jYXQoX2tleSk7XG4gICAgfSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoX3ZhbHVlKSB7XG4gICAgICByZXR1cm4gbGliLmFwaURlc2NyaXB0b3IudmFsdWUoX3ZhbHVlKTtcbiAgICB9LFxuICAgIHBhaXI6IGZ1bmN0aW9uIHBhaXIoX3JlZikge1xuICAgICAgdmFyIGtleSA9IF9yZWYua2V5LFxuICAgICAgICAgIHZhbHVlID0gX3JlZi52YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gZmFsc2UgPyBcIi0tbm8tXCIuY29uY2F0KGtleSkgOiB2YWx1ZSA9PT0gdHJ1ZSA/IGNsaURlc2NyaXB0b3Iua2V5KGtleSkgOiB2YWx1ZSA9PT0gXCJcIiA/IFwiXCIuY29uY2F0KGNsaURlc2NyaXB0b3Iua2V5KGtleSksIFwiIHdpdGhvdXQgYW4gYXJndW1lbnRcIikgOiBcIlwiLmNvbmNhdChjbGlEZXNjcmlwdG9yLmtleShrZXkpLCBcIj1cIikuY29uY2F0KHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIEZsYWdTY2hlbWEgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfdm5vcHRzJENob2ljZVNjaGVtYSkge1xuICAgIF9pbmhlcml0cyhGbGFnU2NoZW1hLCBfdm5vcHRzJENob2ljZVNjaGVtYSk7XG5cbiAgICBmdW5jdGlvbiBGbGFnU2NoZW1hKF9yZWYyKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIHZhciBuYW1lID0gX3JlZjIubmFtZSxcbiAgICAgICAgICBmbGFncyA9IF9yZWYyLmZsYWdzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmxhZ1NjaGVtYSk7XG5cbiAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEZsYWdTY2hlbWEpLmNhbGwodGhpcywge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBjaG9pY2VzOiBmbGFnc1xuICAgICAgfSkpO1xuICAgICAgX3RoaXMuX2ZsYWdzID0gZmxhZ3Muc2xpY2UoKS5zb3J0KCk7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEZsYWdTY2hlbWEsIFt7XG4gICAgICBrZXk6IFwicHJlcHJvY2Vzc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByZXByb2Nlc3ModmFsdWUsIHV0aWxzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUubGVuZ3RoICE9PSAwICYmIHRoaXMuX2ZsYWdzLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgICAgICAgIHZhciBzdWdnZXN0aW9uID0gdGhpcy5fZmxhZ3MuZmluZChmdW5jdGlvbiAoZmxhZykge1xuICAgICAgICAgICAgcmV0dXJuIGxldmVuXzEkMShmbGFnLCB2YWx1ZSkgPCAzO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHN1Z2dlc3Rpb24pIHtcbiAgICAgICAgICAgIHV0aWxzLmxvZ2dlci53YXJuKFtcIlVua25vd24gZmxhZyBcIi5jb25jYXQoY2hhbGsueWVsbG93KHV0aWxzLmRlc2NyaXB0b3IudmFsdWUodmFsdWUpKSwgXCIsXCIpLCBcImRpZCB5b3UgbWVhbiBcIi5jb25jYXQoY2hhbGsuYmx1ZSh1dGlscy5kZXNjcmlwdG9yLnZhbHVlKHN1Z2dlc3Rpb24pKSwgXCI/XCIpXS5qb2luKFwiIFwiKSk7XG4gICAgICAgICAgICByZXR1cm4gc3VnZ2VzdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImV4cGVjdGVkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZXhwZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiBcImEgZmxhZ1wiO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBGbGFnU2NoZW1hO1xuICB9KGxpYi5DaG9pY2VTY2hlbWEpO1xuXG4gIHZhciBoYXNEZXByZWNhdGlvbldhcm5lZDtcblxuICBmdW5jdGlvbiBub3JtYWxpemVPcHRpb25zKG9wdGlvbnMsIG9wdGlvbkluZm9zKSB7XG4gICAgdmFyIF9yZWYzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fSxcbiAgICAgICAgbG9nZ2VyID0gX3JlZjMubG9nZ2VyLFxuICAgICAgICBfcmVmMyRpc0NMSSA9IF9yZWYzLmlzQ0xJLFxuICAgICAgICBpc0NMSSA9IF9yZWYzJGlzQ0xJID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYzJGlzQ0xJLFxuICAgICAgICBfcmVmMyRwYXNzVGhyb3VnaCA9IF9yZWYzLnBhc3NUaHJvdWdoLFxuICAgICAgICBwYXNzVGhyb3VnaCA9IF9yZWYzJHBhc3NUaHJvdWdoID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYzJHBhc3NUaHJvdWdoO1xuXG4gICAgdmFyIHVua25vd24gPSAhcGFzc1Rocm91Z2ggPyBsaWIubGV2ZW5Vbmtub3duSGFuZGxlciA6IEFycmF5LmlzQXJyYXkocGFzc1Rocm91Z2gpID8gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBwYXNzVGhyb3VnaC5pbmRleE9mKGtleSkgPT09IC0xID8gdW5kZWZpbmVkIDogX2RlZmluZVByb3BlcnR5KHt9LCBrZXksIHZhbHVlKTtcbiAgICB9IDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBfZGVmaW5lUHJvcGVydHkoe30sIGtleSwgdmFsdWUpO1xuICAgIH07XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBpc0NMSSA/IGNsaURlc2NyaXB0b3IgOiBsaWIuYXBpRGVzY3JpcHRvcjtcbiAgICB2YXIgc2NoZW1hcyA9IG9wdGlvbkluZm9zVG9TY2hlbWFzKG9wdGlvbkluZm9zLCB7XG4gICAgICBpc0NMSTogaXNDTElcbiAgICB9KTtcbiAgICB2YXIgbm9ybWFsaXplciA9IG5ldyBsaWIuTm9ybWFsaXplcihzY2hlbWFzLCB7XG4gICAgICBsb2dnZXI6IGxvZ2dlcixcbiAgICAgIHVua25vd246IHVua25vd24sXG4gICAgICBkZXNjcmlwdG9yOiBkZXNjcmlwdG9yXG4gICAgfSk7XG4gICAgdmFyIHNob3VsZFN1cHByZXNzRHVwbGljYXRlRGVwcmVjYXRpb25XYXJuaW5ncyA9IGxvZ2dlciAhPT0gZmFsc2U7XG5cbiAgICBpZiAoc2hvdWxkU3VwcHJlc3NEdXBsaWNhdGVEZXByZWNhdGlvbldhcm5pbmdzICYmIGhhc0RlcHJlY2F0aW9uV2FybmVkKSB7XG4gICAgICBub3JtYWxpemVyLl9oYXNEZXByZWNhdGlvbldhcm5lZCA9IGhhc0RlcHJlY2F0aW9uV2FybmVkO1xuICAgIH1cblxuICAgIHZhciBub3JtYWxpemVkID0gbm9ybWFsaXplci5ub3JtYWxpemUob3B0aW9ucyk7XG5cbiAgICBpZiAoc2hvdWxkU3VwcHJlc3NEdXBsaWNhdGVEZXByZWNhdGlvbldhcm5pbmdzKSB7XG4gICAgICBoYXNEZXByZWNhdGlvbldhcm5lZCA9IG5vcm1hbGl6ZXIuX2hhc0RlcHJlY2F0aW9uV2FybmVkO1xuICAgIH1cblxuICAgIHJldHVybiBub3JtYWxpemVkO1xuICB9XG5cbiAgZnVuY3Rpb24gb3B0aW9uSW5mb3NUb1NjaGVtYXMob3B0aW9uSW5mb3MsIF9yZWY2KSB7XG4gICAgdmFyIGlzQ0xJID0gX3JlZjYuaXNDTEk7XG4gICAgdmFyIHNjaGVtYXMgPSBbXTtcblxuICAgIGlmIChpc0NMSSkge1xuICAgICAgc2NoZW1hcy5wdXNoKGxpYi5BbnlTY2hlbWEuY3JlYXRlKHtcbiAgICAgICAgbmFtZTogXCJfXCJcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IG9wdGlvbkluZm9zW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICB2YXIgb3B0aW9uSW5mbyA9IF9zdGVwLnZhbHVlO1xuICAgICAgICBzY2hlbWFzLnB1c2gob3B0aW9uSW5mb1RvU2NoZW1hKG9wdGlvbkluZm8sIHtcbiAgICAgICAgICBpc0NMSTogaXNDTEksXG4gICAgICAgICAgb3B0aW9uSW5mb3M6IG9wdGlvbkluZm9zXG4gICAgICAgIH0pKTtcblxuICAgICAgICBpZiAob3B0aW9uSW5mby5hbGlhcyAmJiBpc0NMSSkge1xuICAgICAgICAgIHNjaGVtYXMucHVzaChsaWIuQWxpYXNTY2hlbWEuY3JlYXRlKHtcbiAgICAgICAgICAgIG5hbWU6IG9wdGlvbkluZm8uYWxpYXMsXG4gICAgICAgICAgICBzb3VyY2VOYW1lOiBvcHRpb25JbmZvLm5hbWVcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzY2hlbWFzO1xuICB9XG5cbiAgZnVuY3Rpb24gb3B0aW9uSW5mb1RvU2NoZW1hKG9wdGlvbkluZm8sIF9yZWY3KSB7XG4gICAgdmFyIGlzQ0xJID0gX3JlZjcuaXNDTEksXG4gICAgICAgIG9wdGlvbkluZm9zID0gX3JlZjcub3B0aW9uSW5mb3M7XG4gICAgdmFyIFNjaGVtYUNvbnN0cnVjdG9yO1xuICAgIHZhciBwYXJhbWV0ZXJzID0ge1xuICAgICAgbmFtZTogb3B0aW9uSW5mby5uYW1lXG4gICAgfTtcbiAgICB2YXIgaGFuZGxlcnMgPSB7fTtcblxuICAgIHN3aXRjaCAob3B0aW9uSW5mby50eXBlKSB7XG4gICAgICBjYXNlIFwiaW50XCI6XG4gICAgICAgIFNjaGVtYUNvbnN0cnVjdG9yID0gbGliLkludGVnZXJTY2hlbWE7XG5cbiAgICAgICAgaWYgKGlzQ0xJKSB7XG4gICAgICAgICAgcGFyYW1ldGVycy5wcmVwcm9jZXNzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgU2NoZW1hQ29uc3RydWN0b3IgPSBsaWIuU3RyaW5nU2NoZW1hO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcImNob2ljZVwiOlxuICAgICAgICBTY2hlbWFDb25zdHJ1Y3RvciA9IGxpYi5DaG9pY2VTY2hlbWE7XG4gICAgICAgIHBhcmFtZXRlcnMuY2hvaWNlcyA9IG9wdGlvbkluZm8uY2hvaWNlcy5tYXAoZnVuY3Rpb24gKGNob2ljZUluZm8pIHtcbiAgICAgICAgICByZXR1cm4gX3R5cGVvZihjaG9pY2VJbmZvKSA9PT0gXCJvYmplY3RcIiAmJiBjaG9pY2VJbmZvLnJlZGlyZWN0ID8gT2JqZWN0LmFzc2lnbih7fSwgY2hvaWNlSW5mbywge1xuICAgICAgICAgICAgcmVkaXJlY3Q6IHtcbiAgICAgICAgICAgICAgdG86IHtcbiAgICAgICAgICAgICAgICBrZXk6IG9wdGlvbkluZm8ubmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogY2hvaWNlSW5mby5yZWRpcmVjdFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkgOiBjaG9pY2VJbmZvO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIFNjaGVtYUNvbnN0cnVjdG9yID0gbGliLkJvb2xlYW5TY2hlbWE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiZmxhZ1wiOlxuICAgICAgICBTY2hlbWFDb25zdHJ1Y3RvciA9IEZsYWdTY2hlbWE7XG4gICAgICAgIHBhcmFtZXRlcnMuZmxhZ3MgPSBvcHRpb25JbmZvcy5tYXAoZnVuY3Rpb24gKG9wdGlvbkluZm8pIHtcbiAgICAgICAgICByZXR1cm4gW10uY29uY2F0KG9wdGlvbkluZm8uYWxpYXMgfHwgW10sIG9wdGlvbkluZm8uZGVzY3JpcHRpb24gPyBvcHRpb25JbmZvLm5hbWUgOiBbXSwgb3B0aW9uSW5mby5vcHBvc2l0ZURlc2NyaXB0aW9uID8gXCJuby1cIi5jb25jYXQob3B0aW9uSW5mby5uYW1lKSA6IFtdKTtcbiAgICAgICAgfSkucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwicGF0aFwiOlxuICAgICAgICBTY2hlbWFDb25zdHJ1Y3RvciA9IGxpYi5TdHJpbmdTY2hlbWE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHR5cGUgXCIuY29uY2F0KG9wdGlvbkluZm8udHlwZSkpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25JbmZvLmV4Y2VwdGlvbikge1xuICAgICAgcGFyYW1ldGVycy52YWxpZGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgc2NoZW1hLCB1dGlscykge1xuICAgICAgICByZXR1cm4gb3B0aW9uSW5mby5leGNlcHRpb24odmFsdWUpIHx8IHNjaGVtYS52YWxpZGF0ZSh2YWx1ZSwgdXRpbHMpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyYW1ldGVycy52YWxpZGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgc2NoZW1hLCB1dGlscykge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzY2hlbWEudmFsaWRhdGUodmFsdWUsIHV0aWxzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbkluZm8ucmVkaXJlY3QpIHtcbiAgICAgIGhhbmRsZXJzLnJlZGlyZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUgPyB1bmRlZmluZWQgOiB7XG4gICAgICAgICAgdG86IHtcbiAgICAgICAgICAgIGtleTogb3B0aW9uSW5mby5yZWRpcmVjdC5vcHRpb24sXG4gICAgICAgICAgICB2YWx1ZTogb3B0aW9uSW5mby5yZWRpcmVjdC52YWx1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbkluZm8uZGVwcmVjYXRlZCkge1xuICAgICAgaGFuZGxlcnMuZGVwcmVjYXRlZCA9IHRydWU7XG4gICAgfSAvLyBhbGxvdyBDTEkgb3ZlcnJpZGluZywgZS5nLiwgcHJldHRpZXIgcGFja2FnZS5qc29uIC0tdGFiLXdpZHRoIDEgLS10YWItd2lkdGggMlxuXG5cbiAgICBpZiAoaXNDTEkgJiYgIW9wdGlvbkluZm8uYXJyYXkpIHtcbiAgICAgIHZhciBvcmlnaW5hbFByZXByb2Nlc3MgPSBwYXJhbWV0ZXJzLnByZXByb2Nlc3MgfHwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9O1xuXG4gICAgICBwYXJhbWV0ZXJzLnByZXByb2Nlc3MgPSBmdW5jdGlvbiAodmFsdWUsIHNjaGVtYSwgdXRpbHMpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5wcmVwcm9jZXNzKG9yaWdpbmFsUHJlcHJvY2VzcyhBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdIDogdmFsdWUpLCB1dGlscyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBvcHRpb25JbmZvLmFycmF5ID8gbGliLkFycmF5U2NoZW1hLmNyZWF0ZShPYmplY3QuYXNzaWduKGlzQ0xJID8ge1xuICAgICAgcHJlcHJvY2VzczogZnVuY3Rpb24gcHJlcHJvY2Vzcyh2KSB7XG4gICAgICAgIHJldHVybiBbXS5jb25jYXQodik7XG4gICAgICB9XG4gICAgfSA6IHt9LCBoYW5kbGVycywge1xuICAgICAgdmFsdWVTY2hlbWE6IFNjaGVtYUNvbnN0cnVjdG9yLmNyZWF0ZShwYXJhbWV0ZXJzKVxuICAgIH0pKSA6IFNjaGVtYUNvbnN0cnVjdG9yLmNyZWF0ZShPYmplY3QuYXNzaWduKHt9LCBwYXJhbWV0ZXJzLCBoYW5kbGVycykpO1xuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplQXBpT3B0aW9ucyhvcHRpb25zLCBvcHRpb25JbmZvcywgb3B0cykge1xuICAgIHJldHVybiBub3JtYWxpemVPcHRpb25zKG9wdGlvbnMsIG9wdGlvbkluZm9zLCBvcHRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUNsaU9wdGlvbnMob3B0aW9ucywgb3B0aW9uSW5mb3MsIG9wdHMpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplT3B0aW9ucyhvcHRpb25zLCBvcHRpb25JbmZvcywgT2JqZWN0LmFzc2lnbih7XG4gICAgICBpc0NMSTogdHJ1ZVxuICAgIH0sIG9wdHMpKTtcbiAgfVxuXG4gIHZhciBvcHRpb25zTm9ybWFsaXplciA9IHtcbiAgICBub3JtYWxpemVBcGlPcHRpb25zOiBub3JtYWxpemVBcGlPcHRpb25zLFxuICAgIG5vcm1hbGl6ZUNsaU9wdGlvbnM6IG5vcm1hbGl6ZUNsaU9wdGlvbnNcbiAgfTtcblxuICB2YXIgZ2V0TGFzdCA9IGZ1bmN0aW9uIGdldExhc3QoYXJyKSB7XG4gICAgcmV0dXJuIGFyci5sZW5ndGggPiAwID8gYXJyW2Fyci5sZW5ndGggLSAxXSA6IG51bGw7XG4gIH07XG5cbiAgZnVuY3Rpb24gbG9jU3RhcnQobm9kZSwgb3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9OyAvLyBIYW5kbGUgbm9kZXMgd2l0aCBkZWNvcmF0b3JzLiBUaGV5IHNob3VsZCBzdGFydCBhdCB0aGUgZmlyc3QgZGVjb3JhdG9yXG5cbiAgICBpZiAoIW9wdHMuaWdub3JlRGVjb3JhdG9ycyAmJiBub2RlLmRlY2xhcmF0aW9uICYmIG5vZGUuZGVjbGFyYXRpb24uZGVjb3JhdG9ycyAmJiBub2RlLmRlY2xhcmF0aW9uLmRlY29yYXRvcnMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGxvY1N0YXJ0KG5vZGUuZGVjbGFyYXRpb24uZGVjb3JhdG9yc1swXSk7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRzLmlnbm9yZURlY29yYXRvcnMgJiYgbm9kZS5kZWNvcmF0b3JzICYmIG5vZGUuZGVjb3JhdG9ycy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gbG9jU3RhcnQobm9kZS5kZWNvcmF0b3JzWzBdKTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5fX2xvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gbm9kZS5fX2xvY2F0aW9uLnN0YXJ0T2Zmc2V0O1xuICAgIH1cblxuICAgIGlmIChub2RlLnJhbmdlKSB7XG4gICAgICByZXR1cm4gbm9kZS5yYW5nZVswXTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5vZGUuc3RhcnQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBub2RlLnN0YXJ0O1xuICAgIH1cblxuICAgIGlmIChub2RlLmxvYykge1xuICAgICAgcmV0dXJuIG5vZGUubG9jLnN0YXJ0O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gbG9jRW5kKG5vZGUpIHtcbiAgICB2YXIgZW5kTm9kZSA9IG5vZGUubm9kZXMgJiYgZ2V0TGFzdChub2RlLm5vZGVzKTtcblxuICAgIGlmIChlbmROb2RlICYmIG5vZGUuc291cmNlICYmICFub2RlLnNvdXJjZS5lbmQpIHtcbiAgICAgIG5vZGUgPSBlbmROb2RlO1xuICAgIH1cblxuICAgIGlmIChub2RlLl9fbG9jYXRpb24pIHtcbiAgICAgIHJldHVybiBub2RlLl9fbG9jYXRpb24uZW5kT2Zmc2V0O1xuICAgIH1cblxuICAgIHZhciBsb2MgPSBub2RlLnJhbmdlID8gbm9kZS5yYW5nZVsxXSA6IHR5cGVvZiBub2RlLmVuZCA9PT0gXCJudW1iZXJcIiA/IG5vZGUuZW5kIDogbnVsbDtcblxuICAgIGlmIChub2RlLnR5cGVBbm5vdGF0aW9uKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgobG9jLCBsb2NFbmQobm9kZS50eXBlQW5ub3RhdGlvbikpO1xuICAgIH1cblxuICAgIGlmIChub2RlLmxvYyAmJiAhbG9jKSB7XG4gICAgICByZXR1cm4gbm9kZS5sb2MuZW5kO1xuICAgIH1cblxuICAgIHJldHVybiBsb2M7XG4gIH1cblxuICB2YXIgbG9jID0ge1xuICAgIGxvY1N0YXJ0OiBsb2NTdGFydCxcbiAgICBsb2NFbmQ6IGxvY0VuZFxuICB9O1xuXG4gIHZhciBqc1Rva2VucyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAvLyBDb3B5cmlnaHQgMjAxNCwgMjAxNSwgMjAxNiwgMjAxNywgMjAxOCBTaW1vbiBMeWRlbGxcbiAgICAvLyBMaWNlbnNlOiBNSVQuIChTZWUgTElDRU5TRS4pXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pOyAvLyBUaGlzIHJlZ2V4IGNvbWVzIGZyb20gcmVnZXguY29mZmVlLCBhbmQgaXMgaW5zZXJ0ZWQgaGVyZSBieSBnZW5lcmF0ZS1pbmRleC5qc1xuICAgIC8vIChydW4gYG5wbSBydW4gYnVpbGRgKS5cblxuICAgIGV4cG9ydHMuZGVmYXVsdCA9IC8oKFsnXCJdKSg/Oig/IVxcMnxcXFxcKS58XFxcXCg/OlxcclxcbnxbXFxzXFxTXSkpKihcXDIpP3xgKD86W15gXFxcXCRdfFxcXFxbXFxzXFxTXXxcXCQoPyFcXHspfFxcJFxceyg/Oltee31dfFxce1tefV0qXFx9PykqXFx9PykqKGApPyl8KFxcL1xcLy4qKXwoXFwvXFwqKD86W14qXXxcXCooPyFcXC8pKSooXFwqXFwvKT8pfChcXC8oPyFcXCopKD86XFxbKD86KD8hW1xcXVxcXFxdKS58XFxcXC4pKlxcXXwoPyFbXFwvXFxdXFxcXF0pLnxcXFxcLikrXFwvKD86KD8hXFxzKig/OlxcYnxbXFx1MDA4MC1cXHVGRkZGJFxcXFwnXCJ+KHtdfFsrXFwtIV0oPyE9KXxcXC4/XFxkKSl8W2dtaXl1c117MSw2fVxcYig/IVtcXHUwMDgwLVxcdUZGRkYkXFxcXF18XFxzKig/OlsrXFwtKiUmfF48PiE9Pyh7XXxcXC8oPyFbXFwvKl0pKSkpKXwoMFt4WF1bXFxkYS1mQS1GXSt8MFtvT11bMC03XSt8MFtiQl1bMDFdK3woPzpcXGQqXFwuXFxkK3xcXGQrXFwuPykoPzpbZUVdWystXT9cXGQrKT8pfCgoPyFcXGQpKD86KD8hXFxzKVskXFx3XFx1MDA4MC1cXHVGRkZGXXxcXFxcdVtcXGRhLWZBLUZdezR9fFxcXFx1XFx7W1xcZGEtZkEtRl0rXFx9KSspfCgtLXxcXCtcXCt8JiZ8XFx8XFx8fD0+fFxcLnszfXwoPzpbK1xcLVxcLyUmfF5dfFxcKnsxLDJ9fDx7MSwyfXw+ezEsM318IT0/fD17MSwyfSk9P3xbP34uLDo7W1xcXSgpe31dKXwoXFxzKyl8KF4kfFtcXHNcXFNdKS9nO1xuXG4gICAgZXhwb3J0cy5tYXRjaFRvVG9rZW4gPSBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgIHZhciB0b2tlbiA9IHtcbiAgICAgICAgdHlwZTogXCJpbnZhbGlkXCIsXG4gICAgICAgIHZhbHVlOiBtYXRjaFswXSxcbiAgICAgICAgY2xvc2VkOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgICBpZiAobWF0Y2hbMV0pIHRva2VuLnR5cGUgPSBcInN0cmluZ1wiLCB0b2tlbi5jbG9zZWQgPSAhIShtYXRjaFszXSB8fCBtYXRjaFs0XSk7ZWxzZSBpZiAobWF0Y2hbNV0pIHRva2VuLnR5cGUgPSBcImNvbW1lbnRcIjtlbHNlIGlmIChtYXRjaFs2XSkgdG9rZW4udHlwZSA9IFwiY29tbWVudFwiLCB0b2tlbi5jbG9zZWQgPSAhIW1hdGNoWzddO2Vsc2UgaWYgKG1hdGNoWzhdKSB0b2tlbi50eXBlID0gXCJyZWdleFwiO2Vsc2UgaWYgKG1hdGNoWzldKSB0b2tlbi50eXBlID0gXCJudW1iZXJcIjtlbHNlIGlmIChtYXRjaFsxMF0pIHRva2VuLnR5cGUgPSBcIm5hbWVcIjtlbHNlIGlmIChtYXRjaFsxMV0pIHRva2VuLnR5cGUgPSBcInB1bmN0dWF0b3JcIjtlbHNlIGlmIChtYXRjaFsxMl0pIHRva2VuLnR5cGUgPSBcIndoaXRlc3BhY2VcIjtcbiAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9O1xuICB9KTtcbiAgdW53cmFwRXhwb3J0cyhqc1Rva2Vucyk7XG4gIHZhciBqc1Rva2Vuc18xID0ganNUb2tlbnMubWF0Y2hUb1Rva2VuO1xuXG4gIHZhciBhc3QgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgLypcbiAgICAgIENvcHlyaWdodCAoQykgMjAxMyBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG4gICAgXG4gICAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICAgIFxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gICAgXG4gICAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTICdBUyBJUydcbiAgICAgIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICAgIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gICAgICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4gICAgICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAgICAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICAgICAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gICAgICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAgICAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gICAgICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICAgICovXG4gICAgKGZ1bmN0aW9uICgpIHtcblxuICAgICAgZnVuY3Rpb24gaXNFeHByZXNzaW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnQXJyYXlFeHByZXNzaW9uJzpcbiAgICAgICAgICBjYXNlICdBc3NpZ25tZW50RXhwcmVzc2lvbic6XG4gICAgICAgICAgY2FzZSAnQmluYXJ5RXhwcmVzc2lvbic6XG4gICAgICAgICAgY2FzZSAnQ2FsbEV4cHJlc3Npb24nOlxuICAgICAgICAgIGNhc2UgJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbic6XG4gICAgICAgICAgY2FzZSAnRnVuY3Rpb25FeHByZXNzaW9uJzpcbiAgICAgICAgICBjYXNlICdJZGVudGlmaWVyJzpcbiAgICAgICAgICBjYXNlICdMaXRlcmFsJzpcbiAgICAgICAgICBjYXNlICdMb2dpY2FsRXhwcmVzc2lvbic6XG4gICAgICAgICAgY2FzZSAnTWVtYmVyRXhwcmVzc2lvbic6XG4gICAgICAgICAgY2FzZSAnTmV3RXhwcmVzc2lvbic6XG4gICAgICAgICAgY2FzZSAnT2JqZWN0RXhwcmVzc2lvbic6XG4gICAgICAgICAgY2FzZSAnU2VxdWVuY2VFeHByZXNzaW9uJzpcbiAgICAgICAgICBjYXNlICdUaGlzRXhwcmVzc2lvbic6XG4gICAgICAgICAgY2FzZSAnVW5hcnlFeHByZXNzaW9uJzpcbiAgICAgICAgICBjYXNlICdVcGRhdGVFeHByZXNzaW9uJzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc0l0ZXJhdGlvblN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ0RvV2hpbGVTdGF0ZW1lbnQnOlxuICAgICAgICAgIGNhc2UgJ0ZvckluU3RhdGVtZW50JzpcbiAgICAgICAgICBjYXNlICdGb3JTdGF0ZW1lbnQnOlxuICAgICAgICAgIGNhc2UgJ1doaWxlU3RhdGVtZW50JzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc1N0YXRlbWVudChub2RlKSB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ0Jsb2NrU3RhdGVtZW50JzpcbiAgICAgICAgICBjYXNlICdCcmVha1N0YXRlbWVudCc6XG4gICAgICAgICAgY2FzZSAnQ29udGludWVTdGF0ZW1lbnQnOlxuICAgICAgICAgIGNhc2UgJ0RlYnVnZ2VyU3RhdGVtZW50JzpcbiAgICAgICAgICBjYXNlICdEb1doaWxlU3RhdGVtZW50JzpcbiAgICAgICAgICBjYXNlICdFbXB0eVN0YXRlbWVudCc6XG4gICAgICAgICAgY2FzZSAnRXhwcmVzc2lvblN0YXRlbWVudCc6XG4gICAgICAgICAgY2FzZSAnRm9ySW5TdGF0ZW1lbnQnOlxuICAgICAgICAgIGNhc2UgJ0ZvclN0YXRlbWVudCc6XG4gICAgICAgICAgY2FzZSAnSWZTdGF0ZW1lbnQnOlxuICAgICAgICAgIGNhc2UgJ0xhYmVsZWRTdGF0ZW1lbnQnOlxuICAgICAgICAgIGNhc2UgJ1JldHVyblN0YXRlbWVudCc6XG4gICAgICAgICAgY2FzZSAnU3dpdGNoU3RhdGVtZW50JzpcbiAgICAgICAgICBjYXNlICdUaHJvd1N0YXRlbWVudCc6XG4gICAgICAgICAgY2FzZSAnVHJ5U3RhdGVtZW50JzpcbiAgICAgICAgICBjYXNlICdWYXJpYWJsZURlY2xhcmF0aW9uJzpcbiAgICAgICAgICBjYXNlICdXaGlsZVN0YXRlbWVudCc6XG4gICAgICAgICAgY2FzZSAnV2l0aFN0YXRlbWVudCc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNTb3VyY2VFbGVtZW50KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RhdGVtZW50KG5vZGUpIHx8IG5vZGUgIT0gbnVsbCAmJiBub2RlLnR5cGUgPT09ICdGdW5jdGlvbkRlY2xhcmF0aW9uJztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdHJhaWxpbmdTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ0lmU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGlmIChub2RlLmFsdGVybmF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBub2RlLmFsdGVybmF0ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY29uc2VxdWVudDtcblxuICAgICAgICAgIGNhc2UgJ0xhYmVsZWRTdGF0ZW1lbnQnOlxuICAgICAgICAgIGNhc2UgJ0ZvclN0YXRlbWVudCc6XG4gICAgICAgICAgY2FzZSAnRm9ySW5TdGF0ZW1lbnQnOlxuICAgICAgICAgIGNhc2UgJ1doaWxlU3RhdGVtZW50JzpcbiAgICAgICAgICBjYXNlICdXaXRoU3RhdGVtZW50JzpcbiAgICAgICAgICAgIHJldHVybiBub2RlLmJvZHk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNQcm9ibGVtYXRpY0lmU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQ7XG5cbiAgICAgICAgaWYgKG5vZGUudHlwZSAhPT0gJ0lmU3RhdGVtZW50Jykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLmFsdGVybmF0ZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCA9IG5vZGUuY29uc2VxdWVudDtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgaWYgKGN1cnJlbnQudHlwZSA9PT0gJ0lmU3RhdGVtZW50Jykge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQuYWx0ZXJuYXRlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudCA9IHRyYWlsaW5nU3RhdGVtZW50KGN1cnJlbnQpO1xuICAgICAgICB9IHdoaWxlIChjdXJyZW50KTtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBpc0V4cHJlc3Npb246IGlzRXhwcmVzc2lvbixcbiAgICAgICAgaXNTdGF0ZW1lbnQ6IGlzU3RhdGVtZW50LFxuICAgICAgICBpc0l0ZXJhdGlvblN0YXRlbWVudDogaXNJdGVyYXRpb25TdGF0ZW1lbnQsXG4gICAgICAgIGlzU291cmNlRWxlbWVudDogaXNTb3VyY2VFbGVtZW50LFxuICAgICAgICBpc1Byb2JsZW1hdGljSWZTdGF0ZW1lbnQ6IGlzUHJvYmxlbWF0aWNJZlN0YXRlbWVudCxcbiAgICAgICAgdHJhaWxpbmdTdGF0ZW1lbnQ6IHRyYWlsaW5nU3RhdGVtZW50XG4gICAgICB9O1xuICAgIH0pKCk7XG4gICAgLyogdmltOiBzZXQgc3c9NCB0cz00IGV0IHR3PTgwIDogKi9cblxuICB9KTtcbiAgdmFyIGFzdF8xID0gYXN0LmlzRXhwcmVzc2lvbjtcbiAgdmFyIGFzdF8yID0gYXN0LmlzU3RhdGVtZW50O1xuICB2YXIgYXN0XzMgPSBhc3QuaXNJdGVyYXRpb25TdGF0ZW1lbnQ7XG4gIHZhciBhc3RfNCA9IGFzdC5pc1NvdXJjZUVsZW1lbnQ7XG4gIHZhciBhc3RfNSA9IGFzdC5pc1Byb2JsZW1hdGljSWZTdGF0ZW1lbnQ7XG4gIHZhciBhc3RfNiA9IGFzdC50cmFpbGluZ1N0YXRlbWVudDtcblxuICB2YXIgY29kZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAvKlxuICAgICAgQ29weXJpZ2h0IChDKSAyMDEzLTIwMTQgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuICAgICAgQ29weXJpZ2h0IChDKSAyMDE0IEl2YW4gTmlrdWxpbiA8aWZhYWFuQGdtYWlsLmNvbT5cbiAgICBcbiAgICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gICAgXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAgICBcbiAgICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gICAgICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gICAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICAgICAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICAgICAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgICAgIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAgICAgIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICAgICAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgICAgIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxuICAgICAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAgICAqL1xuICAgIChmdW5jdGlvbiAoKSB7XG5cbiAgICAgIHZhciBFUzZSZWdleCwgRVM1UmVnZXgsIE5PTl9BU0NJSV9XSElURVNQQUNFUywgSURFTlRJRklFUl9TVEFSVCwgSURFTlRJRklFUl9QQVJULCBjaDsgLy8gU2VlIGB0b29scy9nZW5lcmF0ZS1pZGVudGlmaWVyLXJlZ2V4LmpzYC5cblxuICAgICAgRVM1UmVnZXggPSB7XG4gICAgICAgIC8vIEVDTUFTY3JpcHQgNS4xL1VuaWNvZGUgdjkuMC4wIE5vbkFzY2lpSWRlbnRpZmllclN0YXJ0OlxuICAgICAgICBOb25Bc2NpaUlkZW50aWZpZXJTdGFydDogL1tcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYyMC1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4QTAtXFx1MDhCNFxcdTA4QjYtXFx1MDhCRFxcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RjBcXHUwOUYxXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEFGOVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNTgtXFx1MEM1QVxcdTBDNjBcXHUwQzYxXFx1MEM4MFxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ1NC1cXHUwRDU2XFx1MEQ1Ri1cXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxODg0XFx1MTg4Ny1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDODAtXFx1MUM4OFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkUyRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZENVxcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjlEXFx1QTZBMC1cXHVBNkVGXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0FFXFx1QTdCMC1cXHVBN0I3XFx1QTdGNy1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOTBBLVxcdUE5MjVcXHVBOTMwLVxcdUE5NDZcXHVBOTYwLVxcdUE5N0NcXHVBOTg0LVxcdUE5QjJcXHVBOUNGXFx1QTlFMC1cXHVBOUU0XFx1QTlFNi1cXHVBOUVGXFx1QTlGQS1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVBXFx1QUFGMi1cXHVBQUY0XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY1XFx1QUI3MC1cXHVBQkUyXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXS8sXG4gICAgICAgIC8vIEVDTUFTY3JpcHQgNS4xL1VuaWNvZGUgdjkuMC4wIE5vbkFzY2lpSWRlbnRpZmllclBhcnQ6XG4gICAgICAgIE5vbkFzY2lpSWRlbnRpZmllclBhcnQ6IC9bXFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzMDAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4My1cXHUwNDg3XFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MTAtXFx1MDYxQVxcdTA2MjAtXFx1MDY2OVxcdTA2NkUtXFx1MDZEM1xcdTA2RDUtXFx1MDZEQ1xcdTA2REYtXFx1MDZFOFxcdTA2RUEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwLVxcdTA3NEFcXHUwNzRELVxcdTA3QjFcXHUwN0MwLVxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODJEXFx1MDg0MC1cXHUwODVCXFx1MDhBMC1cXHUwOEI0XFx1MDhCNi1cXHUwOEJEXFx1MDhENC1cXHUwOEUxXFx1MDhFMy1cXHUwOTYzXFx1MDk2Ni1cXHUwOTZGXFx1MDk3MS1cXHUwOTgzXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCQy1cXHUwOUM0XFx1MDlDN1xcdTA5QzhcXHUwOUNCLVxcdTA5Q0VcXHUwOUQ3XFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTNcXHUwOUU2LVxcdTA5RjFcXHUwQTAxLVxcdTBBMDNcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBM0NcXHUwQTNFLVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE2Ni1cXHUwQTc1XFx1MEE4MS1cXHUwQTgzXFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJDLVxcdTBBQzVcXHUwQUM3LVxcdTBBQzlcXHUwQUNCLVxcdTBBQ0RcXHUwQUQwXFx1MEFFMC1cXHUwQUUzXFx1MEFFNi1cXHUwQUVGXFx1MEFGOVxcdTBCMDEtXFx1MEIwM1xcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNDLVxcdTBCNDRcXHUwQjQ3XFx1MEI0OFxcdTBCNEItXFx1MEI0RFxcdTBCNTZcXHUwQjU3XFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjNcXHUwQjY2LVxcdTBCNkZcXHUwQjcxXFx1MEI4MlxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJCRS1cXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNEXFx1MEJEMFxcdTBCRDdcXHUwQkU2LVxcdTBCRUZcXHUwQzAwLVxcdTBDMDNcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNELVxcdTBDNDRcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNTgtXFx1MEM1QVxcdTBDNjAtXFx1MEM2M1xcdTBDNjYtXFx1MEM2RlxcdTBDODAtXFx1MEM4M1xcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkMtXFx1MENDNFxcdTBDQzYtXFx1MENDOFxcdTBDQ0EtXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENERVxcdTBDRTAtXFx1MENFM1xcdTBDRTYtXFx1MENFRlxcdTBDRjFcXHUwQ0YyXFx1MEQwMS1cXHUwRDAzXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRC1cXHUwRDQ0XFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRFXFx1MEQ1NC1cXHUwRDU3XFx1MEQ1Ri1cXHUwRDYzXFx1MEQ2Ni1cXHUwRDZGXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4MlxcdTBEODNcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MERDQVxcdTBEQ0YtXFx1MERENFxcdTBERDZcXHUwREQ4LVxcdTBEREZcXHUwREU2LVxcdTBERUZcXHUwREYyXFx1MERGM1xcdTBFMDEtXFx1MEUzQVxcdTBFNDAtXFx1MEU0RVxcdTBFNTAtXFx1MEU1OVxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUI5XFx1MEVCQi1cXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFQzgtXFx1MEVDRFxcdTBFRDAtXFx1MEVEOVxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjE4XFx1MEYxOVxcdTBGMjAtXFx1MEYyOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGM0UtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGNzEtXFx1MEY4NFxcdTBGODYtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDAwLVxcdTEwNDlcXHUxMDUwLVxcdTEwOURcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM1RC1cXHUxMzVGXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y1XFx1MTNGOC1cXHUxM0ZEXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzE0XFx1MTcyMC1cXHUxNzM0XFx1MTc0MC1cXHUxNzUzXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc3MlxcdTE3NzNcXHUxNzgwLVxcdTE3RDNcXHUxN0Q3XFx1MTdEQ1xcdTE3RERcXHUxN0UwLVxcdTE3RTlcXHUxODBCLVxcdTE4MERcXHUxODEwLVxcdTE4MTlcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTIwLVxcdTE5MkJcXHUxOTMwLVxcdTE5M0JcXHUxOTQ2LVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxOUQwLVxcdTE5RDlcXHUxQTAwLVxcdTFBMUJcXHUxQTIwLVxcdTFBNUVcXHUxQTYwLVxcdTFBN0NcXHUxQTdGLVxcdTFBODlcXHUxQTkwLVxcdTFBOTlcXHUxQUE3XFx1MUFCMC1cXHUxQUJEXFx1MUIwMC1cXHUxQjRCXFx1MUI1MC1cXHUxQjU5XFx1MUI2Qi1cXHUxQjczXFx1MUI4MC1cXHUxQkYzXFx1MUMwMC1cXHUxQzM3XFx1MUM0MC1cXHUxQzQ5XFx1MUM0RC1cXHUxQzdEXFx1MUM4MC1cXHUxQzg4XFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0Y2XFx1MUNGOFxcdTFDRjlcXHUxRDAwLVxcdTFERjVcXHUxREZCLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjAwQ1xcdTIwMERcXHUyMDNGXFx1MjA0MFxcdTIwNTRcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIwRDAtXFx1MjBEQ1xcdTIwRTFcXHUyMEU1LVxcdTIwRjBcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ3Ri1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkRFMC1cXHUyREZGXFx1MkUyRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyRlxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOTlcXHUzMDlBXFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkQ1XFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjJCXFx1QTY0MC1cXHVBNjZGXFx1QTY3NC1cXHVBNjdEXFx1QTY3Ri1cXHVBNkYxXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0FFXFx1QTdCMC1cXHVBN0I3XFx1QTdGNy1cXHVBODI3XFx1QTg0MC1cXHVBODczXFx1QTg4MC1cXHVBOEM1XFx1QThEMC1cXHVBOEQ5XFx1QThFMC1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOTAwLVxcdUE5MkRcXHVBOTMwLVxcdUE5NTNcXHVBOTYwLVxcdUE5N0NcXHVBOTgwLVxcdUE5QzBcXHVBOUNGLVxcdUE5RDlcXHVBOUUwLVxcdUE5RkVcXHVBQTAwLVxcdUFBMzZcXHVBQTQwLVxcdUFBNERcXHVBQTUwLVxcdUFBNTlcXHVBQTYwLVxcdUFBNzZcXHVBQTdBLVxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUZcXHVBQUYyLVxcdUFBRjZcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNjVcXHVBQjcwLVxcdUFCRUFcXHVBQkVDXFx1QUJFRFxcdUFCRjAtXFx1QUJGOVxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMUQtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJGXFx1RkUzM1xcdUZFMzRcXHVGRTRELVxcdUZFNEZcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjEwLVxcdUZGMTlcXHVGRjIxLVxcdUZGM0FcXHVGRjNGXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXS9cbiAgICAgIH07XG4gICAgICBFUzZSZWdleCA9IHtcbiAgICAgICAgLy8gRUNNQVNjcmlwdCA2L1VuaWNvZGUgdjkuMC4wIE5vbkFzY2lpSWRlbnRpZmllclN0YXJ0OlxuICAgICAgICBOb25Bc2NpaUlkZW50aWZpZXJTdGFydDogL1tcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYyMC1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4QTAtXFx1MDhCNFxcdTA4QjYtXFx1MDhCRFxcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RjBcXHUwOUYxXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEFGOVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNTgtXFx1MEM1QVxcdTBDNjBcXHUwQzYxXFx1MEM4MFxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ1NC1cXHUwRDU2XFx1MEQ1Ri1cXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDODAtXFx1MUM4OFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5Qi1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkQ1XFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjQwLVxcdUE2NkVcXHVBNjdGLVxcdUE2OURcXHVBNkEwLVxcdUE2RUZcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3QUVcXHVBN0IwLVxcdUE3QjdcXHVBN0Y3LVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0ZcXHVBOUUwLVxcdUE5RTRcXHVBOUU2LVxcdUE5RUZcXHVBOUZBLVxcdUE5RkVcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE3RS1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUFcXHVBQUYyLVxcdUFBRjRcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNjVcXHVBQjcwLVxcdUFCRTJcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjIxLVxcdUZGM0FcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdfFxcdUQ4MDBbXFx1REMwMC1cXHVEQzBCXFx1REMwRC1cXHVEQzI2XFx1REMyOC1cXHVEQzNBXFx1REMzQ1xcdURDM0RcXHVEQzNGLVxcdURDNERcXHVEQzUwLVxcdURDNURcXHVEQzgwLVxcdURDRkFcXHVERDQwLVxcdURENzRcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERjAwLVxcdURGMUZcXHVERjMwLVxcdURGNEFcXHVERjUwLVxcdURGNzVcXHVERjgwLVxcdURGOURcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGQ0ZcXHVERkQxLVxcdURGRDVdfFxcdUQ4MDFbXFx1REMwMC1cXHVEQzlEXFx1RENCMC1cXHVEQ0QzXFx1RENEOC1cXHVEQ0ZCXFx1REQwMC1cXHVERDI3XFx1REQzMC1cXHVERDYzXFx1REUwMC1cXHVERjM2XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjY3XXxcXHVEODAyW1xcdURDMDAtXFx1REMwNVxcdURDMDhcXHVEQzBBLVxcdURDMzVcXHVEQzM3XFx1REMzOFxcdURDM0NcXHVEQzNGLVxcdURDNTVcXHVEQzYwLVxcdURDNzZcXHVEQzgwLVxcdURDOUVcXHVEQ0UwLVxcdURDRjJcXHVEQ0Y0XFx1RENGNVxcdUREMDAtXFx1REQxNVxcdUREMjAtXFx1REQzOVxcdUREODAtXFx1RERCN1xcdUREQkVcXHVEREJGXFx1REUwMFxcdURFMTAtXFx1REUxM1xcdURFMTUtXFx1REUxN1xcdURFMTktXFx1REUzM1xcdURFNjAtXFx1REU3Q1xcdURFODAtXFx1REU5Q1xcdURFQzAtXFx1REVDN1xcdURFQzktXFx1REVFNFxcdURGMDAtXFx1REYzNVxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY3MlxcdURGODAtXFx1REY5MV18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhcXHVEQzgwLVxcdURDQjJcXHVEQ0MwLVxcdURDRjJdfFxcdUQ4MDRbXFx1REMwMy1cXHVEQzM3XFx1REM4My1cXHVEQ0FGXFx1RENEMC1cXHVEQ0U4XFx1REQwMy1cXHVERDI2XFx1REQ1MC1cXHVERDcyXFx1REQ3NlxcdUREODMtXFx1RERCMlxcdUREQzEtXFx1RERDNFxcdUREREFcXHVERERDXFx1REUwMC1cXHVERTExXFx1REUxMy1cXHVERTJCXFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOFxcdURFQjAtXFx1REVERVxcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNEXFx1REY1MFxcdURGNUQtXFx1REY2MV18XFx1RDgwNVtcXHVEQzAwLVxcdURDMzRcXHVEQzQ3LVxcdURDNEFcXHVEQzgwLVxcdURDQUZcXHVEQ0M0XFx1RENDNVxcdURDQzdcXHVERDgwLVxcdUREQUVcXHVEREQ4LVxcdUREREJcXHVERTAwLVxcdURFMkZcXHVERTQ0XFx1REU4MC1cXHVERUFBXFx1REYwMC1cXHVERjE5XXxcXHVEODA2W1xcdURDQTAtXFx1RENERlxcdURDRkZcXHVERUMwLVxcdURFRjhdfFxcdUQ4MDdbXFx1REMwMC1cXHVEQzA4XFx1REMwQS1cXHVEQzJFXFx1REM0MFxcdURDNzItXFx1REM4Rl18XFx1RDgwOFtcXHVEQzAwLVxcdURGOTldfFxcdUQ4MDlbXFx1REMwMC1cXHVEQzZFXFx1REM4MC1cXHVERDQzXXxbXFx1RDgwQ1xcdUQ4MUMtXFx1RDgyMFxcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q1xcdUQ4NkYtXFx1RDg3Ml1bXFx1REMwMC1cXHVERkZGXXxcXHVEODBEW1xcdURDMDAtXFx1REMyRV18XFx1RDgxMVtcXHVEQzAwLVxcdURFNDZdfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REVEMC1cXHVERUVEXFx1REYwMC1cXHVERjJGXFx1REY0MC1cXHVERjQzXFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODFCW1xcdURGMDAtXFx1REY0NFxcdURGNTBcXHVERjkzLVxcdURGOUZcXHVERkUwXXxcXHVEODIxW1xcdURDMDAtXFx1REZFQ118XFx1RDgyMltcXHVEQzAwLVxcdURFRjJdfFxcdUQ4MkNbXFx1REMwMFxcdURDMDFdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XXxcXHVEODM1W1xcdURDMDAtXFx1REM1NFxcdURDNTYtXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMUUtXFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDUyLVxcdURFQTVcXHVERUE4LVxcdURFQzBcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRkFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMzRcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNkVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGQThcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQ0JdfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XFx1REQwMC1cXHVERDQzXXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzAwLVxcdURDMURcXHVEQzIwLVxcdURGRkZdfFxcdUQ4NzNbXFx1REMwMC1cXHVERUExXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF0vLFxuICAgICAgICAvLyBFQ01BU2NyaXB0IDYvVW5pY29kZSB2OS4wLjAgTm9uQXNjaWlJZGVudGlmaWVyUGFydDpcbiAgICAgICAgTm9uQXNjaWlJZGVudGlmaWVyUGFydDogL1tcXHhBQVxceEI1XFx4QjdcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzAwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4My1cXHUwNDg3XFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MTAtXFx1MDYxQVxcdTA2MjAtXFx1MDY2OVxcdTA2NkUtXFx1MDZEM1xcdTA2RDUtXFx1MDZEQ1xcdTA2REYtXFx1MDZFOFxcdTA2RUEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwLVxcdTA3NEFcXHUwNzRELVxcdTA3QjFcXHUwN0MwLVxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODJEXFx1MDg0MC1cXHUwODVCXFx1MDhBMC1cXHUwOEI0XFx1MDhCNi1cXHUwOEJEXFx1MDhENC1cXHUwOEUxXFx1MDhFMy1cXHUwOTYzXFx1MDk2Ni1cXHUwOTZGXFx1MDk3MS1cXHUwOTgzXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCQy1cXHUwOUM0XFx1MDlDN1xcdTA5QzhcXHUwOUNCLVxcdTA5Q0VcXHUwOUQ3XFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTNcXHUwOUU2LVxcdTA5RjFcXHUwQTAxLVxcdTBBMDNcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBM0NcXHUwQTNFLVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE2Ni1cXHUwQTc1XFx1MEE4MS1cXHUwQTgzXFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJDLVxcdTBBQzVcXHUwQUM3LVxcdTBBQzlcXHUwQUNCLVxcdTBBQ0RcXHUwQUQwXFx1MEFFMC1cXHUwQUUzXFx1MEFFNi1cXHUwQUVGXFx1MEFGOVxcdTBCMDEtXFx1MEIwM1xcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNDLVxcdTBCNDRcXHUwQjQ3XFx1MEI0OFxcdTBCNEItXFx1MEI0RFxcdTBCNTZcXHUwQjU3XFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjNcXHUwQjY2LVxcdTBCNkZcXHUwQjcxXFx1MEI4MlxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJCRS1cXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNEXFx1MEJEMFxcdTBCRDdcXHUwQkU2LVxcdTBCRUZcXHUwQzAwLVxcdTBDMDNcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNELVxcdTBDNDRcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNTgtXFx1MEM1QVxcdTBDNjAtXFx1MEM2M1xcdTBDNjYtXFx1MEM2RlxcdTBDODAtXFx1MEM4M1xcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkMtXFx1MENDNFxcdTBDQzYtXFx1MENDOFxcdTBDQ0EtXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENERVxcdTBDRTAtXFx1MENFM1xcdTBDRTYtXFx1MENFRlxcdTBDRjFcXHUwQ0YyXFx1MEQwMS1cXHUwRDAzXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRC1cXHUwRDQ0XFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRFXFx1MEQ1NC1cXHUwRDU3XFx1MEQ1Ri1cXHUwRDYzXFx1MEQ2Ni1cXHUwRDZGXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4MlxcdTBEODNcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MERDQVxcdTBEQ0YtXFx1MERENFxcdTBERDZcXHUwREQ4LVxcdTBEREZcXHUwREU2LVxcdTBERUZcXHUwREYyXFx1MERGM1xcdTBFMDEtXFx1MEUzQVxcdTBFNDAtXFx1MEU0RVxcdTBFNTAtXFx1MEU1OVxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUI5XFx1MEVCQi1cXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFQzgtXFx1MEVDRFxcdTBFRDAtXFx1MEVEOVxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjE4XFx1MEYxOVxcdTBGMjAtXFx1MEYyOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGM0UtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGNzEtXFx1MEY4NFxcdTBGODYtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDAwLVxcdTEwNDlcXHUxMDUwLVxcdTEwOURcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM1RC1cXHUxMzVGXFx1MTM2OS1cXHUxMzcxXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y1XFx1MTNGOC1cXHUxM0ZEXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzE0XFx1MTcyMC1cXHUxNzM0XFx1MTc0MC1cXHUxNzUzXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc3MlxcdTE3NzNcXHUxNzgwLVxcdTE3RDNcXHUxN0Q3XFx1MTdEQ1xcdTE3RERcXHUxN0UwLVxcdTE3RTlcXHUxODBCLVxcdTE4MERcXHUxODEwLVxcdTE4MTlcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTIwLVxcdTE5MkJcXHUxOTMwLVxcdTE5M0JcXHUxOTQ2LVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxOUQwLVxcdTE5REFcXHUxQTAwLVxcdTFBMUJcXHUxQTIwLVxcdTFBNUVcXHUxQTYwLVxcdTFBN0NcXHUxQTdGLVxcdTFBODlcXHUxQTkwLVxcdTFBOTlcXHUxQUE3XFx1MUFCMC1cXHUxQUJEXFx1MUIwMC1cXHUxQjRCXFx1MUI1MC1cXHUxQjU5XFx1MUI2Qi1cXHUxQjczXFx1MUI4MC1cXHUxQkYzXFx1MUMwMC1cXHUxQzM3XFx1MUM0MC1cXHUxQzQ5XFx1MUM0RC1cXHUxQzdEXFx1MUM4MC1cXHUxQzg4XFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0Y2XFx1MUNGOFxcdTFDRjlcXHUxRDAwLVxcdTFERjVcXHUxREZCLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjAwQ1xcdTIwMERcXHUyMDNGXFx1MjA0MFxcdTIwNTRcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIwRDAtXFx1MjBEQ1xcdTIwRTFcXHUyMEU1LVxcdTIwRjBcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE4LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ3Ri1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkRFMC1cXHUyREZGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDJGXFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5OS1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkQ1XFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjJCXFx1QTY0MC1cXHVBNjZGXFx1QTY3NC1cXHVBNjdEXFx1QTY3Ri1cXHVBNkYxXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0FFXFx1QTdCMC1cXHVBN0I3XFx1QTdGNy1cXHVBODI3XFx1QTg0MC1cXHVBODczXFx1QTg4MC1cXHVBOEM1XFx1QThEMC1cXHVBOEQ5XFx1QThFMC1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOTAwLVxcdUE5MkRcXHVBOTMwLVxcdUE5NTNcXHVBOTYwLVxcdUE5N0NcXHVBOTgwLVxcdUE5QzBcXHVBOUNGLVxcdUE5RDlcXHVBOUUwLVxcdUE5RkVcXHVBQTAwLVxcdUFBMzZcXHVBQTQwLVxcdUFBNERcXHVBQTUwLVxcdUFBNTlcXHVBQTYwLVxcdUFBNzZcXHVBQTdBLVxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUZcXHVBQUYyLVxcdUFBRjZcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNjVcXHVBQjcwLVxcdUFCRUFcXHVBQkVDXFx1QUJFRFxcdUFCRjAtXFx1QUJGOVxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMUQtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJGXFx1RkUzM1xcdUZFMzRcXHVGRTRELVxcdUZFNEZcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjEwLVxcdUZGMTlcXHVGRjIxLVxcdUZGM0FcXHVGRjNGXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXXxcXHVEODAwW1xcdURDMDAtXFx1REMwQlxcdURDMEQtXFx1REMyNlxcdURDMjgtXFx1REMzQVxcdURDM0NcXHVEQzNEXFx1REMzRi1cXHVEQzREXFx1REM1MC1cXHVEQzVEXFx1REM4MC1cXHVEQ0ZBXFx1REQ0MC1cXHVERDc0XFx1RERGRFxcdURFODAtXFx1REU5Q1xcdURFQTAtXFx1REVEMFxcdURFRTBcXHVERjAwLVxcdURGMUZcXHVERjMwLVxcdURGNEFcXHVERjUwLVxcdURGN0FcXHVERjgwLVxcdURGOURcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGQ0ZcXHVERkQxLVxcdURGRDVdfFxcdUQ4MDFbXFx1REMwMC1cXHVEQzlEXFx1RENBMC1cXHVEQ0E5XFx1RENCMC1cXHVEQ0QzXFx1RENEOC1cXHVEQ0ZCXFx1REQwMC1cXHVERDI3XFx1REQzMC1cXHVERDYzXFx1REUwMC1cXHVERjM2XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjY3XXxcXHVEODAyW1xcdURDMDAtXFx1REMwNVxcdURDMDhcXHVEQzBBLVxcdURDMzVcXHVEQzM3XFx1REMzOFxcdURDM0NcXHVEQzNGLVxcdURDNTVcXHVEQzYwLVxcdURDNzZcXHVEQzgwLVxcdURDOUVcXHVEQ0UwLVxcdURDRjJcXHVEQ0Y0XFx1RENGNVxcdUREMDAtXFx1REQxNVxcdUREMjAtXFx1REQzOVxcdUREODAtXFx1RERCN1xcdUREQkVcXHVEREJGXFx1REUwMC1cXHVERTAzXFx1REUwNVxcdURFMDZcXHVERTBDLVxcdURFMTNcXHVERTE1LVxcdURFMTdcXHVERTE5LVxcdURFMzNcXHVERTM4LVxcdURFM0FcXHVERTNGXFx1REU2MC1cXHVERTdDXFx1REU4MC1cXHVERTlDXFx1REVDMC1cXHVERUM3XFx1REVDOS1cXHVERUU2XFx1REYwMC1cXHVERjM1XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjcyXFx1REY4MC1cXHVERjkxXXxcXHVEODAzW1xcdURDMDAtXFx1REM0OFxcdURDODAtXFx1RENCMlxcdURDQzAtXFx1RENGMl18XFx1RDgwNFtcXHVEQzAwLVxcdURDNDZcXHVEQzY2LVxcdURDNkZcXHVEQzdGLVxcdURDQkFcXHVEQ0QwLVxcdURDRThcXHVEQ0YwLVxcdURDRjlcXHVERDAwLVxcdUREMzRcXHVERDM2LVxcdUREM0ZcXHVERDUwLVxcdURENzNcXHVERDc2XFx1REQ4MC1cXHVEREM0XFx1RERDQS1cXHVERENDXFx1REREMC1cXHVERERBXFx1REREQ1xcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUzN1xcdURFM0VcXHVERTgwLVxcdURFODZcXHVERTg4XFx1REU4QS1cXHVERThEXFx1REU4Ri1cXHVERTlEXFx1REU5Ri1cXHVERUE4XFx1REVCMC1cXHVERUVBXFx1REVGMC1cXHVERUY5XFx1REYwMC1cXHVERjAzXFx1REYwNS1cXHVERjBDXFx1REYwRlxcdURGMTBcXHVERjEzLVxcdURGMjhcXHVERjJBLVxcdURGMzBcXHVERjMyXFx1REYzM1xcdURGMzUtXFx1REYzOVxcdURGM0MtXFx1REY0NFxcdURGNDdcXHVERjQ4XFx1REY0Qi1cXHVERjREXFx1REY1MFxcdURGNTdcXHVERjVELVxcdURGNjNcXHVERjY2LVxcdURGNkNcXHVERjcwLVxcdURGNzRdfFxcdUQ4MDVbXFx1REMwMC1cXHVEQzRBXFx1REM1MC1cXHVEQzU5XFx1REM4MC1cXHVEQ0M1XFx1RENDN1xcdURDRDAtXFx1RENEOVxcdUREODAtXFx1RERCNVxcdUREQjgtXFx1RERDMFxcdURERDgtXFx1RERERFxcdURFMDAtXFx1REU0MFxcdURFNDRcXHVERTUwLVxcdURFNTlcXHVERTgwLVxcdURFQjdcXHVERUMwLVxcdURFQzlcXHVERjAwLVxcdURGMTlcXHVERjFELVxcdURGMkJcXHVERjMwLVxcdURGMzldfFxcdUQ4MDZbXFx1RENBMC1cXHVEQ0U5XFx1RENGRlxcdURFQzAtXFx1REVGOF18XFx1RDgwN1tcXHVEQzAwLVxcdURDMDhcXHVEQzBBLVxcdURDMzZcXHVEQzM4LVxcdURDNDBcXHVEQzUwLVxcdURDNTlcXHVEQzcyLVxcdURDOEZcXHVEQzkyLVxcdURDQTdcXHVEQ0E5LVxcdURDQjZdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk5XXxcXHVEODA5W1xcdURDMDAtXFx1REM2RVxcdURDODAtXFx1REQ0M118W1xcdUQ4MENcXHVEODFDLVxcdUQ4MjBcXHVEODQwLVxcdUQ4NjhcXHVEODZBLVxcdUQ4NkNcXHVEODZGLVxcdUQ4NzJdW1xcdURDMDAtXFx1REZGRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4MTFbXFx1REMwMC1cXHVERTQ2XXxcXHVEODFBW1xcdURDMDAtXFx1REUzOFxcdURFNDAtXFx1REU1RVxcdURFNjAtXFx1REU2OVxcdURFRDAtXFx1REVFRFxcdURFRjAtXFx1REVGNFxcdURGMDAtXFx1REYzNlxcdURGNDAtXFx1REY0M1xcdURGNTAtXFx1REY1OVxcdURGNjMtXFx1REY3N1xcdURGN0QtXFx1REY4Rl18XFx1RDgxQltcXHVERjAwLVxcdURGNDRcXHVERjUwLVxcdURGN0VcXHVERjhGLVxcdURGOUZcXHVERkUwXXxcXHVEODIxW1xcdURDMDAtXFx1REZFQ118XFx1RDgyMltcXHVEQzAwLVxcdURFRjJdfFxcdUQ4MkNbXFx1REMwMFxcdURDMDFdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XFx1REM5RFxcdURDOUVdfFxcdUQ4MzRbXFx1REQ2NS1cXHVERDY5XFx1REQ2RC1cXHVERDcyXFx1REQ3Qi1cXHVERDgyXFx1REQ4NS1cXHVERDhCXFx1RERBQS1cXHVEREFEXFx1REU0Mi1cXHVERTQ0XXxcXHVEODM1W1xcdURDMDAtXFx1REM1NFxcdURDNTYtXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMUUtXFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDUyLVxcdURFQTVcXHVERUE4LVxcdURFQzBcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRkFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMzRcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNkVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGQThcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQ0JcXHVERkNFLVxcdURGRkZdfFxcdUQ4MzZbXFx1REUwMC1cXHVERTM2XFx1REUzQi1cXHVERTZDXFx1REU3NVxcdURFODRcXHVERTlCLVxcdURFOUZcXHVERUExLVxcdURFQUZdfFxcdUQ4MzhbXFx1REMwMC1cXHVEQzA2XFx1REMwOC1cXHVEQzE4XFx1REMxQi1cXHVEQzIxXFx1REMyM1xcdURDMjRcXHVEQzI2LVxcdURDMkFdfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XFx1RENEMC1cXHVEQ0Q2XFx1REQwMC1cXHVERDRBXFx1REQ1MC1cXHVERDU5XXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzAwLVxcdURDMURcXHVEQzIwLVxcdURGRkZdfFxcdUQ4NzNbXFx1REMwMC1cXHVERUExXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF18XFx1REI0MFtcXHVERDAwLVxcdURERUZdL1xuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gaXNEZWNpbWFsRGlnaXQoY2gpIHtcbiAgICAgICAgcmV0dXJuIDB4MzAgPD0gY2ggJiYgY2ggPD0gMHgzOTsgLy8gMC4uOVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc0hleERpZ2l0KGNoKSB7XG4gICAgICAgIHJldHVybiAweDMwIDw9IGNoICYmIGNoIDw9IDB4MzkgfHwgLy8gMC4uOVxuICAgICAgICAweDYxIDw9IGNoICYmIGNoIDw9IDB4NjYgfHwgLy8gYS4uZlxuICAgICAgICAweDQxIDw9IGNoICYmIGNoIDw9IDB4NDY7IC8vIEEuLkZcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNPY3RhbERpZ2l0KGNoKSB7XG4gICAgICAgIHJldHVybiBjaCA+PSAweDMwICYmIGNoIDw9IDB4Mzc7IC8vIDAuLjdcbiAgICAgIH0gLy8gNy4yIFdoaXRlIFNwYWNlXG5cblxuICAgICAgTk9OX0FTQ0lJX1dISVRFU1BBQ0VTID0gWzB4MTY4MCwgMHgyMDAwLCAweDIwMDEsIDB4MjAwMiwgMHgyMDAzLCAweDIwMDQsIDB4MjAwNSwgMHgyMDA2LCAweDIwMDcsIDB4MjAwOCwgMHgyMDA5LCAweDIwMEEsIDB4MjAyRiwgMHgyMDVGLCAweDMwMDAsIDB4RkVGRl07XG5cbiAgICAgIGZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjaCkge1xuICAgICAgICByZXR1cm4gY2ggPT09IDB4MjAgfHwgY2ggPT09IDB4MDkgfHwgY2ggPT09IDB4MEIgfHwgY2ggPT09IDB4MEMgfHwgY2ggPT09IDB4QTAgfHwgY2ggPj0gMHgxNjgwICYmIE5PTl9BU0NJSV9XSElURVNQQUNFUy5pbmRleE9mKGNoKSA+PSAwO1xuICAgICAgfSAvLyA3LjMgTGluZSBUZXJtaW5hdG9yc1xuXG5cbiAgICAgIGZ1bmN0aW9uIGlzTGluZVRlcm1pbmF0b3IoY2gpIHtcbiAgICAgICAgcmV0dXJuIGNoID09PSAweDBBIHx8IGNoID09PSAweDBEIHx8IGNoID09PSAweDIwMjggfHwgY2ggPT09IDB4MjAyOTtcbiAgICAgIH0gLy8gNy42IElkZW50aWZpZXIgTmFtZXMgYW5kIElkZW50aWZpZXJzXG5cblxuICAgICAgZnVuY3Rpb24gZnJvbUNvZGVQb2ludChjcCkge1xuICAgICAgICBpZiAoY3AgPD0gMHhGRkZGKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN1MSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoTWF0aC5mbG9vcigoY3AgLSAweDEwMDAwKSAvIDB4NDAwKSArIDB4RDgwMCk7XG4gICAgICAgIHZhciBjdTIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjcCAtIDB4MTAwMDApICUgMHg0MDAgKyAweERDMDApO1xuICAgICAgICByZXR1cm4gY3UxICsgY3UyO1xuICAgICAgfVxuXG4gICAgICBJREVOVElGSUVSX1NUQVJUID0gbmV3IEFycmF5KDB4ODApO1xuXG4gICAgICBmb3IgKGNoID0gMDsgY2ggPCAweDgwOyArK2NoKSB7XG4gICAgICAgIElERU5USUZJRVJfU1RBUlRbY2hdID0gY2ggPj0gMHg2MSAmJiBjaCA8PSAweDdBIHx8IC8vIGEuLnpcbiAgICAgICAgY2ggPj0gMHg0MSAmJiBjaCA8PSAweDVBIHx8IC8vIEEuLlpcbiAgICAgICAgY2ggPT09IDB4MjQgfHwgY2ggPT09IDB4NUY7IC8vICQgKGRvbGxhcikgYW5kIF8gKHVuZGVyc2NvcmUpXG4gICAgICB9XG5cbiAgICAgIElERU5USUZJRVJfUEFSVCA9IG5ldyBBcnJheSgweDgwKTtcblxuICAgICAgZm9yIChjaCA9IDA7IGNoIDwgMHg4MDsgKytjaCkge1xuICAgICAgICBJREVOVElGSUVSX1BBUlRbY2hdID0gY2ggPj0gMHg2MSAmJiBjaCA8PSAweDdBIHx8IC8vIGEuLnpcbiAgICAgICAgY2ggPj0gMHg0MSAmJiBjaCA8PSAweDVBIHx8IC8vIEEuLlpcbiAgICAgICAgY2ggPj0gMHgzMCAmJiBjaCA8PSAweDM5IHx8IC8vIDAuLjlcbiAgICAgICAgY2ggPT09IDB4MjQgfHwgY2ggPT09IDB4NUY7IC8vICQgKGRvbGxhcikgYW5kIF8gKHVuZGVyc2NvcmUpXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0RVM1KGNoKSB7XG4gICAgICAgIHJldHVybiBjaCA8IDB4ODAgPyBJREVOVElGSUVSX1NUQVJUW2NoXSA6IEVTNVJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclN0YXJ0LnRlc3QoZnJvbUNvZGVQb2ludChjaCkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJQYXJ0RVM1KGNoKSB7XG4gICAgICAgIHJldHVybiBjaCA8IDB4ODAgPyBJREVOVElGSUVSX1BBUlRbY2hdIDogRVM1UmVnZXguTm9uQXNjaWlJZGVudGlmaWVyUGFydC50ZXN0KGZyb21Db2RlUG9pbnQoY2gpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnRFUzYoY2gpIHtcbiAgICAgICAgcmV0dXJuIGNoIDwgMHg4MCA/IElERU5USUZJRVJfU1RBUlRbY2hdIDogRVM2UmVnZXguTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQudGVzdChmcm9tQ29kZVBvaW50KGNoKSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllclBhcnRFUzYoY2gpIHtcbiAgICAgICAgcmV0dXJuIGNoIDwgMHg4MCA/IElERU5USUZJRVJfUEFSVFtjaF0gOiBFUzZSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJQYXJ0LnRlc3QoZnJvbUNvZGVQb2ludChjaCkpO1xuICAgICAgfVxuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgaXNEZWNpbWFsRGlnaXQ6IGlzRGVjaW1hbERpZ2l0LFxuICAgICAgICBpc0hleERpZ2l0OiBpc0hleERpZ2l0LFxuICAgICAgICBpc09jdGFsRGlnaXQ6IGlzT2N0YWxEaWdpdCxcbiAgICAgICAgaXNXaGl0ZVNwYWNlOiBpc1doaXRlU3BhY2UsXG4gICAgICAgIGlzTGluZVRlcm1pbmF0b3I6IGlzTGluZVRlcm1pbmF0b3IsXG4gICAgICAgIGlzSWRlbnRpZmllclN0YXJ0RVM1OiBpc0lkZW50aWZpZXJTdGFydEVTNSxcbiAgICAgICAgaXNJZGVudGlmaWVyUGFydEVTNTogaXNJZGVudGlmaWVyUGFydEVTNSxcbiAgICAgICAgaXNJZGVudGlmaWVyU3RhcnRFUzY6IGlzSWRlbnRpZmllclN0YXJ0RVM2LFxuICAgICAgICBpc0lkZW50aWZpZXJQYXJ0RVM2OiBpc0lkZW50aWZpZXJQYXJ0RVM2XG4gICAgICB9O1xuICAgIH0pKCk7XG4gICAgLyogdmltOiBzZXQgc3c9NCB0cz00IGV0IHR3PTgwIDogKi9cblxuICB9KTtcbiAgdmFyIGNvZGVfMSA9IGNvZGUuaXNEZWNpbWFsRGlnaXQ7XG4gIHZhciBjb2RlXzIgPSBjb2RlLmlzSGV4RGlnaXQ7XG4gIHZhciBjb2RlXzMgPSBjb2RlLmlzT2N0YWxEaWdpdDtcbiAgdmFyIGNvZGVfNCA9IGNvZGUuaXNXaGl0ZVNwYWNlO1xuICB2YXIgY29kZV81ID0gY29kZS5pc0xpbmVUZXJtaW5hdG9yO1xuICB2YXIgY29kZV82ID0gY29kZS5pc0lkZW50aWZpZXJTdGFydEVTNTtcbiAgdmFyIGNvZGVfNyA9IGNvZGUuaXNJZGVudGlmaWVyUGFydEVTNTtcbiAgdmFyIGNvZGVfOCA9IGNvZGUuaXNJZGVudGlmaWVyU3RhcnRFUzY7XG4gIHZhciBjb2RlXzkgPSBjb2RlLmlzSWRlbnRpZmllclBhcnRFUzY7XG5cbiAgdmFyIGtleXdvcmQgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgLypcbiAgICAgIENvcHlyaWdodCAoQykgMjAxMyBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG4gICAgXG4gICAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICAgIFxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gICAgXG4gICAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICAgICAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICAgICAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgICAgIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgICAgIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gICAgICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gICAgICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgICAgIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gICAgICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgICAgIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gICAgKi9cbiAgICAoZnVuY3Rpb24gKCkge1xuXG4gICAgICB2YXIgY29kZSQxID0gY29kZTtcblxuICAgICAgZnVuY3Rpb24gaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkRVM2KGlkKSB7XG4gICAgICAgIHN3aXRjaCAoaWQpIHtcbiAgICAgICAgICBjYXNlICdpbXBsZW1lbnRzJzpcbiAgICAgICAgICBjYXNlICdpbnRlcmZhY2UnOlxuICAgICAgICAgIGNhc2UgJ3BhY2thZ2UnOlxuICAgICAgICAgIGNhc2UgJ3ByaXZhdGUnOlxuICAgICAgICAgIGNhc2UgJ3Byb3RlY3RlZCc6XG4gICAgICAgICAgY2FzZSAncHVibGljJzpcbiAgICAgICAgICBjYXNlICdzdGF0aWMnOlxuICAgICAgICAgIGNhc2UgJ2xldCc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNLZXl3b3JkRVM1KGlkLCBzdHJpY3QpIHtcbiAgICAgICAgLy8geWllbGQgc2hvdWxkIG5vdCBiZSB0cmVhdGVkIGFzIGtleXdvcmQgdW5kZXIgbm9uLXN0cmljdCBtb2RlLlxuICAgICAgICBpZiAoIXN0cmljdCAmJiBpZCA9PT0gJ3lpZWxkJykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc0tleXdvcmRFUzYoaWQsIHN0cmljdCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzS2V5d29yZEVTNihpZCwgc3RyaWN0KSB7XG4gICAgICAgIGlmIChzdHJpY3QgJiYgaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkRVM2KGlkKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChpZC5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gaWQgPT09ICdpZicgfHwgaWQgPT09ICdpbicgfHwgaWQgPT09ICdkbyc7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gaWQgPT09ICd2YXInIHx8IGlkID09PSAnZm9yJyB8fCBpZCA9PT0gJ25ldycgfHwgaWQgPT09ICd0cnknO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIGlkID09PSAndGhpcycgfHwgaWQgPT09ICdlbHNlJyB8fCBpZCA9PT0gJ2Nhc2UnIHx8IGlkID09PSAndm9pZCcgfHwgaWQgPT09ICd3aXRoJyB8fCBpZCA9PT0gJ2VudW0nO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmV0dXJuIGlkID09PSAnd2hpbGUnIHx8IGlkID09PSAnYnJlYWsnIHx8IGlkID09PSAnY2F0Y2gnIHx8IGlkID09PSAndGhyb3cnIHx8IGlkID09PSAnY29uc3QnIHx8IGlkID09PSAneWllbGQnIHx8IGlkID09PSAnY2xhc3MnIHx8IGlkID09PSAnc3VwZXInO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcmV0dXJuIGlkID09PSAncmV0dXJuJyB8fCBpZCA9PT0gJ3R5cGVvZicgfHwgaWQgPT09ICdkZWxldGUnIHx8IGlkID09PSAnc3dpdGNoJyB8fCBpZCA9PT0gJ2V4cG9ydCcgfHwgaWQgPT09ICdpbXBvcnQnO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIGlkID09PSAnZGVmYXVsdCcgfHwgaWQgPT09ICdmaW5hbGx5JyB8fCBpZCA9PT0gJ2V4dGVuZHMnO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcmV0dXJuIGlkID09PSAnZnVuY3Rpb24nIHx8IGlkID09PSAnY29udGludWUnIHx8IGlkID09PSAnZGVidWdnZXInO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHJldHVybiBpZCA9PT0gJ2luc3RhbmNlb2YnO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc1Jlc2VydmVkV29yZEVTNShpZCwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBpZCA9PT0gJ251bGwnIHx8IGlkID09PSAndHJ1ZScgfHwgaWQgPT09ICdmYWxzZScgfHwgaXNLZXl3b3JkRVM1KGlkLCBzdHJpY3QpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc1Jlc2VydmVkV29yZEVTNihpZCwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBpZCA9PT0gJ251bGwnIHx8IGlkID09PSAndHJ1ZScgfHwgaWQgPT09ICdmYWxzZScgfHwgaXNLZXl3b3JkRVM2KGlkLCBzdHJpY3QpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc1Jlc3RyaWN0ZWRXb3JkKGlkKSB7XG4gICAgICAgIHJldHVybiBpZCA9PT0gJ2V2YWwnIHx8IGlkID09PSAnYXJndW1lbnRzJztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyTmFtZUVTNShpZCkge1xuICAgICAgICB2YXIgaSwgaXosIGNoO1xuXG4gICAgICAgIGlmIChpZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjaCA9IGlkLmNoYXJDb2RlQXQoMCk7XG5cbiAgICAgICAgaWYgKCFjb2RlJDEuaXNJZGVudGlmaWVyU3RhcnRFUzUoY2gpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMSwgaXogPSBpZC5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgY2ggPSBpZC5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgICAgaWYgKCFjb2RlJDEuaXNJZGVudGlmaWVyUGFydEVTNShjaCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGVjb2RlVXRmMTYobGVhZCwgdHJhaWwpIHtcbiAgICAgICAgcmV0dXJuIChsZWFkIC0gMHhEODAwKSAqIDB4NDAwICsgKHRyYWlsIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllck5hbWVFUzYoaWQpIHtcbiAgICAgICAgdmFyIGksIGl6LCBjaCwgbG93Q2gsIGNoZWNrO1xuXG4gICAgICAgIGlmIChpZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjaGVjayA9IGNvZGUkMS5pc0lkZW50aWZpZXJTdGFydEVTNjtcblxuICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IGlkLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICBjaCA9IGlkLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgICBpZiAoMHhEODAwIDw9IGNoICYmIGNoIDw9IDB4REJGRikge1xuICAgICAgICAgICAgKytpO1xuXG4gICAgICAgICAgICBpZiAoaSA+PSBpeikge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxvd0NoID0gaWQuY2hhckNvZGVBdChpKTtcblxuICAgICAgICAgICAgaWYgKCEoMHhEQzAwIDw9IGxvd0NoICYmIGxvd0NoIDw9IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaCA9IGRlY29kZVV0ZjE2KGNoLCBsb3dDaCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFjaGVjayhjaCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGVjayA9IGNvZGUkMS5pc0lkZW50aWZpZXJQYXJ0RVM2O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllckVTNShpZCwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBpc0lkZW50aWZpZXJOYW1lRVM1KGlkKSAmJiAhaXNSZXNlcnZlZFdvcmRFUzUoaWQsIHN0cmljdCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllckVTNihpZCwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBpc0lkZW50aWZpZXJOYW1lRVM2KGlkKSAmJiAhaXNSZXNlcnZlZFdvcmRFUzYoaWQsIHN0cmljdCk7XG4gICAgICB9XG5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBpc0tleXdvcmRFUzU6IGlzS2V5d29yZEVTNSxcbiAgICAgICAgaXNLZXl3b3JkRVM2OiBpc0tleXdvcmRFUzYsXG4gICAgICAgIGlzUmVzZXJ2ZWRXb3JkRVM1OiBpc1Jlc2VydmVkV29yZEVTNSxcbiAgICAgICAgaXNSZXNlcnZlZFdvcmRFUzY6IGlzUmVzZXJ2ZWRXb3JkRVM2LFxuICAgICAgICBpc1Jlc3RyaWN0ZWRXb3JkOiBpc1Jlc3RyaWN0ZWRXb3JkLFxuICAgICAgICBpc0lkZW50aWZpZXJOYW1lRVM1OiBpc0lkZW50aWZpZXJOYW1lRVM1LFxuICAgICAgICBpc0lkZW50aWZpZXJOYW1lRVM2OiBpc0lkZW50aWZpZXJOYW1lRVM2LFxuICAgICAgICBpc0lkZW50aWZpZXJFUzU6IGlzSWRlbnRpZmllckVTNSxcbiAgICAgICAgaXNJZGVudGlmaWVyRVM2OiBpc0lkZW50aWZpZXJFUzZcbiAgICAgIH07XG4gICAgfSkoKTtcbiAgICAvKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuXG4gIH0pO1xuICB2YXIga2V5d29yZF8xID0ga2V5d29yZC5pc0tleXdvcmRFUzU7XG4gIHZhciBrZXl3b3JkXzIgPSBrZXl3b3JkLmlzS2V5d29yZEVTNjtcbiAgdmFyIGtleXdvcmRfMyA9IGtleXdvcmQuaXNSZXNlcnZlZFdvcmRFUzU7XG4gIHZhciBrZXl3b3JkXzQgPSBrZXl3b3JkLmlzUmVzZXJ2ZWRXb3JkRVM2O1xuICB2YXIga2V5d29yZF81ID0ga2V5d29yZC5pc1Jlc3RyaWN0ZWRXb3JkO1xuICB2YXIga2V5d29yZF82ID0ga2V5d29yZC5pc0lkZW50aWZpZXJOYW1lRVM1O1xuICB2YXIga2V5d29yZF83ID0ga2V5d29yZC5pc0lkZW50aWZpZXJOYW1lRVM2O1xuICB2YXIga2V5d29yZF84ID0ga2V5d29yZC5pc0lkZW50aWZpZXJFUzU7XG4gIHZhciBrZXl3b3JkXzkgPSBrZXl3b3JkLmlzSWRlbnRpZmllckVTNjtcblxuICB2YXIgdXRpbHMkMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAvKlxuICAgICAgQ29weXJpZ2h0IChDKSAyMDEzIFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cbiAgICBcbiAgICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gICAgXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAgICBcbiAgICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gICAgICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gICAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICAgICAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICAgICAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgICAgIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAgICAgIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICAgICAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgICAgIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxuICAgICAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAgICAqL1xuICAgIChmdW5jdGlvbiAoKSB7XG5cbiAgICAgIGV4cG9ydHMuYXN0ID0gYXN0O1xuICAgICAgZXhwb3J0cy5jb2RlID0gY29kZTtcbiAgICAgIGV4cG9ydHMua2V5d29yZCA9IGtleXdvcmQ7XG4gICAgfSkoKTtcbiAgICAvKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuXG4gIH0pO1xuICB2YXIgdXRpbHNfMSQxID0gdXRpbHMkMS5hc3Q7XG4gIHZhciB1dGlsc18yJDEgPSB1dGlscyQxLmNvZGU7XG4gIHZhciB1dGlsc18zJDEgPSB1dGlscyQxLmtleXdvcmQ7XG5cbiAgdmFyIGxpYiQxID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGV4cG9ydHMuc2hvdWxkSGlnaGxpZ2h0ID0gc2hvdWxkSGlnaGxpZ2h0O1xuICAgIGV4cG9ydHMuZ2V0Q2hhbGsgPSBnZXRDaGFsaztcbiAgICBleHBvcnRzLmRlZmF1bHQgPSBoaWdobGlnaHQ7XG5cbiAgICBmdW5jdGlvbiBfanNUb2tlbnMoKSB7XG4gICAgICB2YXIgZGF0YSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGpzVG9rZW5zKTtcblxuICAgICAgX2pzVG9rZW5zID0gZnVuY3Rpb24gX2pzVG9rZW5zKCkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9lc3V0aWxzKCkge1xuICAgICAgdmFyIGRhdGEgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHV0aWxzJDEpO1xuXG4gICAgICBfZXN1dGlscyA9IGZ1bmN0aW9uIF9lc3V0aWxzKCkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jaGFsaygpIHtcbiAgICAgIHZhciBkYXRhID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChjaGFsayk7XG5cbiAgICAgIF9jaGFsayA9IGZ1bmN0aW9uIF9jaGFsaygpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikge1xuICAgICAgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5ld09iaiA9IHt9O1xuXG4gICAgICAgIGlmIChvYmogIT0gbnVsbCkge1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IHt9O1xuXG4gICAgICAgICAgICAgIGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5ld09iai5kZWZhdWx0ID0gb2JqO1xuICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERlZnMoY2hhbGspIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtleXdvcmQ6IGNoYWxrLmN5YW4sXG4gICAgICAgIGNhcGl0YWxpemVkOiBjaGFsay55ZWxsb3csXG4gICAgICAgIGpzeF90YWc6IGNoYWxrLnllbGxvdyxcbiAgICAgICAgcHVuY3R1YXRvcjogY2hhbGsueWVsbG93LFxuICAgICAgICBudW1iZXI6IGNoYWxrLm1hZ2VudGEsXG4gICAgICAgIHN0cmluZzogY2hhbGsuZ3JlZW4sXG4gICAgICAgIHJlZ2V4OiBjaGFsay5tYWdlbnRhLFxuICAgICAgICBjb21tZW50OiBjaGFsay5ncmV5LFxuICAgICAgICBpbnZhbGlkOiBjaGFsay53aGl0ZS5iZ1JlZC5ib2xkXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBORVdMSU5FID0gL1xcclxcbnxbXFxuXFxyXFx1MjAyOFxcdTIwMjldLztcbiAgICB2YXIgSlNYX1RBRyA9IC9eW2Etel1bXFx3LV0qJC9pO1xuICAgIHZhciBCUkFDS0VUID0gL15bKClbXFxde31dJC87XG5cbiAgICBmdW5jdGlvbiBnZXRUb2tlblR5cGUobWF0Y2gpIHtcbiAgICAgIHZhciBfbWF0Y2gkc2xpY2UgPSBtYXRjaC5zbGljZSgtMiksXG4gICAgICAgICAgX21hdGNoJHNsaWNlMiA9IF9zbGljZWRUb0FycmF5KF9tYXRjaCRzbGljZSwgMiksXG4gICAgICAgICAgb2Zmc2V0ID0gX21hdGNoJHNsaWNlMlswXSxcbiAgICAgICAgICB0ZXh0ID0gX21hdGNoJHNsaWNlMlsxXTtcblxuICAgICAgdmFyIHRva2VuID0gKDAsIF9qc1Rva2VucygpLm1hdGNoVG9Ub2tlbikobWF0Y2gpO1xuXG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gXCJuYW1lXCIpIHtcbiAgICAgICAgaWYgKF9lc3V0aWxzKCkuZGVmYXVsdC5rZXl3b3JkLmlzUmVzZXJ2ZWRXb3JkRVM2KHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChKU1hfVEFHLnRlc3QodG9rZW4udmFsdWUpICYmICh0ZXh0W29mZnNldCAtIDFdID09PSBcIjxcIiB8fCB0ZXh0LnN1YnN0cihvZmZzZXQgLSAyLCAyKSA9PSBcIjwvXCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFwianN4X3RhZ1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRva2VuLnZhbHVlWzBdICE9PSB0b2tlbi52YWx1ZVswXS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgcmV0dXJuIFwiY2FwaXRhbGl6ZWRcIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gXCJwdW5jdHVhdG9yXCIgJiYgQlJBQ0tFVC50ZXN0KHRva2VuLnZhbHVlKSkge1xuICAgICAgICByZXR1cm4gXCJicmFja2V0XCI7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi50eXBlID09PSBcImludmFsaWRcIiAmJiAodG9rZW4udmFsdWUgPT09IFwiQFwiIHx8IHRva2VuLnZhbHVlID09PSBcIiNcIikpIHtcbiAgICAgICAgcmV0dXJuIFwicHVuY3R1YXRvclwiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG9rZW4udHlwZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoaWdobGlnaHRUb2tlbnMoZGVmcywgdGV4dCkge1xuICAgICAgcmV0dXJuIHRleHQucmVwbGFjZShfanNUb2tlbnMoKS5kZWZhdWx0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHlwZSA9IGdldFRva2VuVHlwZShhcmdzKTtcbiAgICAgICAgdmFyIGNvbG9yaXplID0gZGVmc1t0eXBlXTtcblxuICAgICAgICBpZiAoY29sb3JpemUpIHtcbiAgICAgICAgICByZXR1cm4gYXJnc1swXS5zcGxpdChORVdMSU5FKS5tYXAoZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbG9yaXplKHN0cik7XG4gICAgICAgICAgfSkuam9pbihcIlxcblwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYXJnc1swXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hvdWxkSGlnaGxpZ2h0KG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBfY2hhbGsoKS5kZWZhdWx0LnN1cHBvcnRzQ29sb3IgfHwgb3B0aW9ucy5mb3JjZUNvbG9yO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENoYWxrKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjaGFsayA9IF9jaGFsaygpLmRlZmF1bHQ7XG5cbiAgICAgIGlmIChvcHRpb25zLmZvcmNlQ29sb3IpIHtcbiAgICAgICAgY2hhbGsgPSBuZXcgKF9jaGFsaygpLmRlZmF1bHQuY29uc3RydWN0b3IpKHtcbiAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgIGxldmVsOiAxXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhbGs7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGlnaGxpZ2h0KGNvZGUpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgaWYgKHNob3VsZEhpZ2hsaWdodChvcHRpb25zKSkge1xuICAgICAgICB2YXIgY2hhbGsgPSBnZXRDaGFsayhvcHRpb25zKTtcbiAgICAgICAgdmFyIGRlZnMgPSBnZXREZWZzKGNoYWxrKTtcbiAgICAgICAgcmV0dXJuIGhpZ2hsaWdodFRva2VucyhkZWZzLCBjb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHVud3JhcEV4cG9ydHMobGliJDEpO1xuICB2YXIgbGliXzEgPSBsaWIkMS5zaG91bGRIaWdobGlnaHQ7XG4gIHZhciBsaWJfMiA9IGxpYiQxLmdldENoYWxrO1xuXG4gIHZhciBsaWIkMiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcbiAgICBleHBvcnRzLmNvZGVGcmFtZUNvbHVtbnMgPSBjb2RlRnJhbWVDb2x1bW5zO1xuICAgIGV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xuXG4gICAgZnVuY3Rpb24gX2hpZ2hsaWdodCgpIHtcbiAgICAgIHZhciBkYXRhID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQobGliJDEpO1xuXG4gICAgICBfaGlnaGxpZ2h0ID0gZnVuY3Rpb24gX2hpZ2hsaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHtcbiAgICAgIGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuZXdPYmogPSB7fTtcblxuICAgICAgICBpZiAob2JqICE9IG51bGwpIHtcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTtcblxuICAgICAgICAgICAgICBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBuZXdPYmouZGVmYXVsdCA9IG9iajtcbiAgICAgICAgcmV0dXJuIG5ld09iajtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVwcmVjYXRpb25XYXJuaW5nU2hvd24gPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGdldERlZnMoY2hhbGspIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGd1dHRlcjogY2hhbGsuZ3JleSxcbiAgICAgICAgbWFya2VyOiBjaGFsay5yZWQuYm9sZCxcbiAgICAgICAgbWVzc2FnZTogY2hhbGsucmVkLmJvbGRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIE5FV0xJTkUgPSAvXFxyXFxufFtcXG5cXHJcXHUyMDI4XFx1MjAyOV0vO1xuXG4gICAgZnVuY3Rpb24gZ2V0TWFya2VyTGluZXMobG9jLCBzb3VyY2UsIG9wdHMpIHtcbiAgICAgIHZhciBzdGFydExvYyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBjb2x1bW46IDAsXG4gICAgICAgIGxpbmU6IC0xXG4gICAgICB9LCBsb2Muc3RhcnQpO1xuICAgICAgdmFyIGVuZExvYyA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXJ0TG9jLCBsb2MuZW5kKTtcblxuICAgICAgdmFyIF9yZWYgPSBvcHRzIHx8IHt9LFxuICAgICAgICAgIF9yZWYkbGluZXNBYm92ZSA9IF9yZWYubGluZXNBYm92ZSxcbiAgICAgICAgICBsaW5lc0Fib3ZlID0gX3JlZiRsaW5lc0Fib3ZlID09PSB2b2lkIDAgPyAyIDogX3JlZiRsaW5lc0Fib3ZlLFxuICAgICAgICAgIF9yZWYkbGluZXNCZWxvdyA9IF9yZWYubGluZXNCZWxvdyxcbiAgICAgICAgICBsaW5lc0JlbG93ID0gX3JlZiRsaW5lc0JlbG93ID09PSB2b2lkIDAgPyAzIDogX3JlZiRsaW5lc0JlbG93O1xuXG4gICAgICB2YXIgc3RhcnRMaW5lID0gc3RhcnRMb2MubGluZTtcbiAgICAgIHZhciBzdGFydENvbHVtbiA9IHN0YXJ0TG9jLmNvbHVtbjtcbiAgICAgIHZhciBlbmRMaW5lID0gZW5kTG9jLmxpbmU7XG4gICAgICB2YXIgZW5kQ29sdW1uID0gZW5kTG9jLmNvbHVtbjtcbiAgICAgIHZhciBzdGFydCA9IE1hdGgubWF4KHN0YXJ0TGluZSAtIChsaW5lc0Fib3ZlICsgMSksIDApO1xuICAgICAgdmFyIGVuZCA9IE1hdGgubWluKHNvdXJjZS5sZW5ndGgsIGVuZExpbmUgKyBsaW5lc0JlbG93KTtcblxuICAgICAgaWYgKHN0YXJ0TGluZSA9PT0gLTEpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5kTGluZSA9PT0gLTEpIHtcbiAgICAgICAgZW5kID0gc291cmNlLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgdmFyIGxpbmVEaWZmID0gZW5kTGluZSAtIHN0YXJ0TGluZTtcbiAgICAgIHZhciBtYXJrZXJMaW5lcyA9IHt9O1xuXG4gICAgICBpZiAobGluZURpZmYpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbGluZURpZmY7IGkrKykge1xuICAgICAgICAgIHZhciBsaW5lTnVtYmVyID0gaSArIHN0YXJ0TGluZTtcblxuICAgICAgICAgIGlmICghc3RhcnRDb2x1bW4pIHtcbiAgICAgICAgICAgIG1hcmtlckxpbmVzW2xpbmVOdW1iZXJdID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2VMZW5ndGggPSBzb3VyY2VbbGluZU51bWJlciAtIDFdLmxlbmd0aDtcbiAgICAgICAgICAgIG1hcmtlckxpbmVzW2xpbmVOdW1iZXJdID0gW3N0YXJ0Q29sdW1uLCBzb3VyY2VMZW5ndGggLSBzdGFydENvbHVtbiArIDFdO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gbGluZURpZmYpIHtcbiAgICAgICAgICAgIG1hcmtlckxpbmVzW2xpbmVOdW1iZXJdID0gWzAsIGVuZENvbHVtbl07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBfc291cmNlTGVuZ3RoID0gc291cmNlW2xpbmVOdW1iZXIgLSBpXS5sZW5ndGg7XG4gICAgICAgICAgICBtYXJrZXJMaW5lc1tsaW5lTnVtYmVyXSA9IFswLCBfc291cmNlTGVuZ3RoXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzdGFydENvbHVtbiA9PT0gZW5kQ29sdW1uKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0Q29sdW1uKSB7XG4gICAgICAgICAgICBtYXJrZXJMaW5lc1tzdGFydExpbmVdID0gW3N0YXJ0Q29sdW1uLCAwXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFya2VyTGluZXNbc3RhcnRMaW5lXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hcmtlckxpbmVzW3N0YXJ0TGluZV0gPSBbc3RhcnRDb2x1bW4sIGVuZENvbHVtbiAtIHN0YXJ0Q29sdW1uXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGVuZDogZW5kLFxuICAgICAgICBtYXJrZXJMaW5lczogbWFya2VyTGluZXNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29kZUZyYW1lQ29sdW1ucyhyYXdMaW5lcywgbG9jKSB7XG4gICAgICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICB2YXIgaGlnaGxpZ2h0ZWQgPSAob3B0cy5oaWdobGlnaHRDb2RlIHx8IG9wdHMuZm9yY2VDb2xvcikgJiYgKDAsIF9oaWdobGlnaHQoKS5zaG91bGRIaWdobGlnaHQpKG9wdHMpO1xuICAgICAgdmFyIGNoYWxrID0gKDAsIF9oaWdobGlnaHQoKS5nZXRDaGFsaykob3B0cyk7XG4gICAgICB2YXIgZGVmcyA9IGdldERlZnMoY2hhbGspO1xuXG4gICAgICB2YXIgbWF5YmVIaWdobGlnaHQgPSBmdW5jdGlvbiBtYXliZUhpZ2hsaWdodChjaGFsa0ZuLCBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGhpZ2hsaWdodGVkID8gY2hhbGtGbihzdHJpbmcpIDogc3RyaW5nO1xuICAgICAgfTtcblxuICAgICAgdmFyIGxpbmVzID0gcmF3TGluZXMuc3BsaXQoTkVXTElORSk7XG5cbiAgICAgIHZhciBfZ2V0TWFya2VyTGluZXMgPSBnZXRNYXJrZXJMaW5lcyhsb2MsIGxpbmVzLCBvcHRzKSxcbiAgICAgICAgICBzdGFydCA9IF9nZXRNYXJrZXJMaW5lcy5zdGFydCxcbiAgICAgICAgICBlbmQgPSBfZ2V0TWFya2VyTGluZXMuZW5kLFxuICAgICAgICAgIG1hcmtlckxpbmVzID0gX2dldE1hcmtlckxpbmVzLm1hcmtlckxpbmVzO1xuXG4gICAgICB2YXIgaGFzQ29sdW1ucyA9IGxvYy5zdGFydCAmJiB0eXBlb2YgbG9jLnN0YXJ0LmNvbHVtbiA9PT0gXCJudW1iZXJcIjtcbiAgICAgIHZhciBudW1iZXJNYXhXaWR0aCA9IFN0cmluZyhlbmQpLmxlbmd0aDtcbiAgICAgIHZhciBoaWdobGlnaHRlZExpbmVzID0gaGlnaGxpZ2h0ZWQgPyAoMCwgX2hpZ2hsaWdodCgpLmRlZmF1bHQpKHJhd0xpbmVzLCBvcHRzKSA6IHJhd0xpbmVzO1xuICAgICAgdmFyIGZyYW1lID0gaGlnaGxpZ2h0ZWRMaW5lcy5zcGxpdChORVdMSU5FKS5zbGljZShzdGFydCwgZW5kKS5tYXAoZnVuY3Rpb24gKGxpbmUsIGluZGV4KSB7XG4gICAgICAgIHZhciBudW1iZXIgPSBzdGFydCArIDEgKyBpbmRleDtcbiAgICAgICAgdmFyIHBhZGRlZE51bWJlciA9IFwiIFwiLmNvbmNhdChudW1iZXIpLnNsaWNlKC1udW1iZXJNYXhXaWR0aCk7XG4gICAgICAgIHZhciBndXR0ZXIgPSBcIiBcIi5jb25jYXQocGFkZGVkTnVtYmVyLCBcIiB8IFwiKTtcbiAgICAgICAgdmFyIGhhc01hcmtlciA9IG1hcmtlckxpbmVzW251bWJlcl07XG4gICAgICAgIHZhciBsYXN0TWFya2VyTGluZSA9ICFtYXJrZXJMaW5lc1tudW1iZXIgKyAxXTtcblxuICAgICAgICBpZiAoaGFzTWFya2VyKSB7XG4gICAgICAgICAgdmFyIG1hcmtlckxpbmUgPSBcIlwiO1xuXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaGFzTWFya2VyKSkge1xuICAgICAgICAgICAgdmFyIG1hcmtlclNwYWNpbmcgPSBsaW5lLnNsaWNlKDAsIE1hdGgubWF4KGhhc01hcmtlclswXSAtIDEsIDApKS5yZXBsYWNlKC9bXlxcdF0vZywgXCIgXCIpO1xuICAgICAgICAgICAgdmFyIG51bWJlck9mTWFya2VycyA9IGhhc01hcmtlclsxXSB8fCAxO1xuICAgICAgICAgICAgbWFya2VyTGluZSA9IFtcIlxcbiBcIiwgbWF5YmVIaWdobGlnaHQoZGVmcy5ndXR0ZXIsIGd1dHRlci5yZXBsYWNlKC9cXGQvZywgXCIgXCIpKSwgbWFya2VyU3BhY2luZywgbWF5YmVIaWdobGlnaHQoZGVmcy5tYXJrZXIsIFwiXlwiKS5yZXBlYXQobnVtYmVyT2ZNYXJrZXJzKV0uam9pbihcIlwiKTtcblxuICAgICAgICAgICAgaWYgKGxhc3RNYXJrZXJMaW5lICYmIG9wdHMubWVzc2FnZSkge1xuICAgICAgICAgICAgICBtYXJrZXJMaW5lICs9IFwiIFwiICsgbWF5YmVIaWdobGlnaHQoZGVmcy5tZXNzYWdlLCBvcHRzLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBbbWF5YmVIaWdobGlnaHQoZGVmcy5tYXJrZXIsIFwiPlwiKSwgbWF5YmVIaWdobGlnaHQoZGVmcy5ndXR0ZXIsIGd1dHRlciksIGxpbmUsIG1hcmtlckxpbmVdLmpvaW4oXCJcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFwiIFwiLmNvbmNhdChtYXliZUhpZ2hsaWdodChkZWZzLmd1dHRlciwgZ3V0dGVyKSkuY29uY2F0KGxpbmUpO1xuICAgICAgICB9XG4gICAgICB9KS5qb2luKFwiXFxuXCIpO1xuXG4gICAgICBpZiAob3B0cy5tZXNzYWdlICYmICFoYXNDb2x1bW5zKSB7XG4gICAgICAgIGZyYW1lID0gXCJcIi5jb25jYXQoXCIgXCIucmVwZWF0KG51bWJlck1heFdpZHRoICsgMSkpLmNvbmNhdChvcHRzLm1lc3NhZ2UsIFwiXFxuXCIpLmNvbmNhdChmcmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoaWdobGlnaHRlZCkge1xuICAgICAgICByZXR1cm4gY2hhbGsucmVzZXQoZnJhbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZyYW1lO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9kZWZhdWx0KHJhd0xpbmVzLCBsaW5lTnVtYmVyLCBjb2xOdW1iZXIpIHtcbiAgICAgIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcblxuICAgICAgaWYgKCFkZXByZWNhdGlvbldhcm5pbmdTaG93bikge1xuICAgICAgICBkZXByZWNhdGlvbldhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICAgIHZhciBtZXNzYWdlID0gXCJQYXNzaW5nIGxpbmVOdW1iZXIgYW5kIGNvbE51bWJlciBpcyBkZXByZWNhdGVkIHRvIEBiYWJlbC9jb2RlLWZyYW1lLiBQbGVhc2UgdXNlIGBjb2RlRnJhbWVDb2x1bW5zYC5cIjtcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbWl0V2FybmluZykge1xuICAgICAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcobWVzc2FnZSwgXCJEZXByZWNhdGlvbldhcm5pbmdcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGRlcHJlY2F0aW9uRXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgZGVwcmVjYXRpb25FcnJvci5uYW1lID0gXCJEZXByZWNhdGlvbldhcm5pbmdcIjtcbiAgICAgICAgICBjb25zb2xlLndhcm4obmV3IEVycm9yKG1lc3NhZ2UpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb2xOdW1iZXIgPSBNYXRoLm1heChjb2xOdW1iZXIsIDApO1xuICAgICAgdmFyIGxvY2F0aW9uID0ge1xuICAgICAgICBzdGFydDoge1xuICAgICAgICAgIGNvbHVtbjogY29sTnVtYmVyLFxuICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXJcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBjb2RlRnJhbWVDb2x1bW5zKHJhd0xpbmVzLCBsb2NhdGlvbiwgb3B0cyk7XG4gICAgfVxuICB9KTtcbiAgdW53cmFwRXhwb3J0cyhsaWIkMik7XG4gIHZhciBsaWJfMSQxID0gbGliJDIuY29kZUZyYW1lQ29sdW1ucztcblxuICB2YXIgQ29uZmlnRXJyb3IkMSA9IGVycm9ycy5Db25maWdFcnJvcjtcbiAgdmFyIGxvY1N0YXJ0JDEgPSBsb2MubG9jU3RhcnQsXG4gICAgICBsb2NFbmQkMSA9IGxvYy5sb2NFbmQ7IC8vIFVzZSBkZWZpbmVQcm9wZXJ0aWVzKCkvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCkgdG8gcHJldmVudFxuICAvLyB0cmlnZ2VyaW5nIHRoZSBwYXJzZXJzIGdldHRlcnMuXG5cbiAgdmFyIG93bk5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG4gIHZhciBvd25EZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuICBmdW5jdGlvbiBnZXRQYXJzZXJzKG9wdGlvbnMpIHtcbiAgICB2YXIgcGFyc2VycyA9IHt9O1xuICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gb3B0aW9ucy5wbHVnaW5zW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICB2YXIgcGx1Z2luID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgaWYgKCFwbHVnaW4ucGFyc2Vycykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IG93bk5hbWVzKHBsdWdpbi5wYXJzZXJzKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFyc2VycywgbmFtZSwgb3duRGVzY3JpcHRvcihwbHVnaW4ucGFyc2VycywgbmFtZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYXJzZXJzO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVBhcnNlcihvcHRzLCBwYXJzZXJzKSB7XG4gICAgcGFyc2VycyA9IHBhcnNlcnMgfHwgZ2V0UGFyc2VycyhvcHRzKTtcblxuICAgIGlmICh0eXBlb2Ygb3B0cy5wYXJzZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgLy8gQ3VzdG9tIHBhcnNlciBBUEkgYWx3YXlzIHdvcmtzIHdpdGggSmF2YVNjcmlwdC5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhcnNlOiBvcHRzLnBhcnNlcixcbiAgICAgICAgYXN0Rm9ybWF0OiBcImVzdHJlZVwiLFxuICAgICAgICBsb2NTdGFydDogbG9jU3RhcnQkMSxcbiAgICAgICAgbG9jRW5kOiBsb2NFbmQkMVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdHMucGFyc2VyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcnNlcnMsIG9wdHMucGFyc2VyKSkge1xuICAgICAgICByZXR1cm4gcGFyc2Vyc1tvcHRzLnBhcnNlcl07XG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG5cbiAgICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IENvbmZpZ0Vycm9yJDEoXCJDb3VsZG4ndCByZXNvbHZlIHBhcnNlciBcXFwiXCIuY29uY2F0KG9wdHMucGFyc2VyLCBcIlxcXCIuIFBhcnNlcnMgbXVzdCBiZSBleHBsaWNpdGx5IGFkZGVkIHRvIHRoZSBzdGFuZGFsb25lIGJ1bmRsZS5cIikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlKHRleHQsIG9wdHMpIHtcbiAgICB2YXIgcGFyc2VycyA9IGdldFBhcnNlcnMob3B0cyk7IC8vIENyZWF0ZSBhIG5ldyBvYmplY3Qge3BhcnNlck5hbWU6IHBhcnNlRm59LiBVc2VzIGRlZmluZVByb3BlcnR5KCkgdG8gb25seSBjYWxsXG4gICAgLy8gdGhlIHBhcnNlcnMgZ2V0dGVycyB3aGVuIGFjdHVhbGx5IGNhbGxpbmcgdGhlIHBhcnNlciBgcGFyc2VgIGZ1bmN0aW9uLlxuXG4gICAgdmFyIHBhcnNlcnNGb3JDdXN0b21QYXJzZXJBcGkgPSBPYmplY3Qua2V5cyhwYXJzZXJzKS5yZWR1Y2UoZnVuY3Rpb24gKG9iamVjdCwgcGFyc2VyTmFtZSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHBhcnNlck5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlcnNbcGFyc2VyTmFtZV0ucGFyc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIHt9KTtcbiAgICB2YXIgcGFyc2VyID0gcmVzb2x2ZVBhcnNlcihvcHRzLCBwYXJzZXJzKTtcblxuICAgIHRyeSB7XG4gICAgICBpZiAocGFyc2VyLnByZXByb2Nlc3MpIHtcbiAgICAgICAgdGV4dCA9IHBhcnNlci5wcmVwcm9jZXNzKHRleHQsIG9wdHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICBhc3Q6IHBhcnNlci5wYXJzZSh0ZXh0LCBwYXJzZXJzRm9yQ3VzdG9tUGFyc2VyQXBpLCBvcHRzKVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdmFyIGxvYyA9IGVycm9yLmxvYztcblxuICAgICAgaWYgKGxvYykge1xuICAgICAgICB2YXIgY29kZUZyYW1lID0gbGliJDI7XG4gICAgICAgIGVycm9yLmNvZGVGcmFtZSA9IGNvZGVGcmFtZS5jb2RlRnJhbWVDb2x1bW5zKHRleHQsIGxvYywge1xuICAgICAgICAgIGhpZ2hsaWdodENvZGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGVycm9yLm1lc3NhZ2UgKz0gXCJcXG5cIiArIGVycm9yLmNvZGVGcmFtZTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG5cbiAgICAgIHRocm93IGVycm9yLnN0YWNrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwYXJzZXIgPSB7XG4gICAgcGFyc2U6IHBhcnNlLFxuICAgIHJlc29sdmVQYXJzZXI6IHJlc29sdmVQYXJzZXJcbiAgfTtcblxuICB2YXIgVW5kZWZpbmVkUGFyc2VyRXJyb3IkMSA9IGVycm9ycy5VbmRlZmluZWRQYXJzZXJFcnJvcjtcbiAgdmFyIGdldFN1cHBvcnRJbmZvJDEgPSBzdXBwb3J0LmdldFN1cHBvcnRJbmZvO1xuICB2YXIgcmVzb2x2ZVBhcnNlciQxID0gcGFyc2VyLnJlc29sdmVQYXJzZXI7XG4gIHZhciBoaWRkZW5EZWZhdWx0cyA9IHtcbiAgICBhc3RGb3JtYXQ6IFwiZXN0cmVlXCIsXG4gICAgcHJpbnRlcjoge30sXG4gICAgb3JpZ2luYWxUZXh0OiB1bmRlZmluZWQsXG4gICAgbG9jU3RhcnQ6IG51bGwsXG4gICAgbG9jRW5kOiBudWxsXG4gIH07IC8vIENvcHkgb3B0aW9ucyBhbmQgZmlsbCBpbiBkZWZhdWx0IHZhbHVlcy5cblxuICBmdW5jdGlvbiBub3JtYWxpemUkMShvcHRpb25zLCBvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgdmFyIHJhd09wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICB2YXIgc3VwcG9ydE9wdGlvbnMgPSBnZXRTdXBwb3J0SW5mbyQxKG51bGwsIHtcbiAgICAgIHBsdWdpbnM6IG9wdGlvbnMucGx1Z2lucyxcbiAgICAgIHNob3dVbnJlbGVhc2VkOiB0cnVlLFxuICAgICAgc2hvd0RlcHJlY2F0ZWQ6IHRydWVcbiAgICB9KS5vcHRpb25zO1xuICAgIHZhciBkZWZhdWx0cyA9IHN1cHBvcnRPcHRpb25zLnJlZHVjZShmdW5jdGlvbiAocmVkdWNlZCwgb3B0aW9uSW5mbykge1xuICAgICAgcmV0dXJuIG9wdGlvbkluZm8uZGVmYXVsdCAhPT0gdW5kZWZpbmVkID8gT2JqZWN0LmFzc2lnbihyZWR1Y2VkLCBfZGVmaW5lUHJvcGVydHkoe30sIG9wdGlvbkluZm8ubmFtZSwgb3B0aW9uSW5mby5kZWZhdWx0KSkgOiByZWR1Y2VkO1xuICAgIH0sIE9iamVjdC5hc3NpZ24oe30sIGhpZGRlbkRlZmF1bHRzKSk7XG5cbiAgICBpZiAoIXJhd09wdGlvbnMucGFyc2VyKSB7XG4gICAgICBpZiAoIXJhd09wdGlvbnMuZmlsZXBhdGgpIHtcbiAgICAgICAgdmFyIGxvZ2dlciA9IG9wdHMubG9nZ2VyIHx8IGNvbnNvbGU7XG4gICAgICAgIGxvZ2dlci53YXJuKFwiTm8gcGFyc2VyIGFuZCBubyBmaWxlcGF0aCBnaXZlbiwgdXNpbmcgJ2JhYmVsJyB0aGUgcGFyc2VyIG5vdyBcIiArIFwiYnV0IHRoaXMgd2lsbCB0aHJvdyBhbiBlcnJvciBpbiB0aGUgZnV0dXJlLiBcIiArIFwiUGxlYXNlIHNwZWNpZnkgYSBwYXJzZXIgb3IgYSBmaWxlcGF0aCBzbyBvbmUgY2FuIGJlIGluZmVycmVkLlwiKTtcbiAgICAgICAgcmF3T3B0aW9ucy5wYXJzZXIgPSBcImJhYmVsXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYXdPcHRpb25zLnBhcnNlciA9IGluZmVyUGFyc2VyKHJhd09wdGlvbnMuZmlsZXBhdGgsIHJhd09wdGlvbnMucGx1Z2lucyk7XG5cbiAgICAgICAgaWYgKCFyYXdPcHRpb25zLnBhcnNlcikge1xuICAgICAgICAgIHRocm93IG5ldyBVbmRlZmluZWRQYXJzZXJFcnJvciQxKFwiTm8gcGFyc2VyIGNvdWxkIGJlIGluZmVycmVkIGZvciBmaWxlOiBcIi5jb25jYXQocmF3T3B0aW9ucy5maWxlcGF0aCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlciA9IHJlc29sdmVQYXJzZXIkMShvcHRpb25zTm9ybWFsaXplci5ub3JtYWxpemVBcGlPcHRpb25zKHJhd09wdGlvbnMsIFtzdXBwb3J0T3B0aW9ucy5maW5kKGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5uYW1lID09PSBcInBhcnNlclwiO1xuICAgIH0pXSwge1xuICAgICAgcGFzc1Rocm91Z2g6IHRydWUsXG4gICAgICBsb2dnZXI6IGZhbHNlXG4gICAgfSkpO1xuICAgIHJhd09wdGlvbnMuYXN0Rm9ybWF0ID0gcGFyc2VyLmFzdEZvcm1hdDtcbiAgICByYXdPcHRpb25zLmxvY0VuZCA9IHBhcnNlci5sb2NFbmQ7XG4gICAgcmF3T3B0aW9ucy5sb2NTdGFydCA9IHBhcnNlci5sb2NTdGFydDtcbiAgICB2YXIgcGx1Z2luID0gZ2V0UGx1Z2luKHJhd09wdGlvbnMpO1xuICAgIHJhd09wdGlvbnMucHJpbnRlciA9IHBsdWdpbi5wcmludGVyc1tyYXdPcHRpb25zLmFzdEZvcm1hdF07XG4gICAgdmFyIHBsdWdpbkRlZmF1bHRzID0gc3VwcG9ydE9wdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChvcHRpb25JbmZvKSB7XG4gICAgICByZXR1cm4gb3B0aW9uSW5mby5wbHVnaW5EZWZhdWx0cyAmJiBvcHRpb25JbmZvLnBsdWdpbkRlZmF1bHRzW3BsdWdpbi5uYW1lXSAhPT0gdW5kZWZpbmVkO1xuICAgIH0pLnJlZHVjZShmdW5jdGlvbiAocmVkdWNlZCwgb3B0aW9uSW5mbykge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocmVkdWNlZCwgX2RlZmluZVByb3BlcnR5KHt9LCBvcHRpb25JbmZvLm5hbWUsIG9wdGlvbkluZm8ucGx1Z2luRGVmYXVsdHNbcGx1Z2luLm5hbWVdKSk7XG4gICAgfSwge30pO1xuICAgIHZhciBtaXhlZERlZmF1bHRzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMsIHBsdWdpbkRlZmF1bHRzKTtcbiAgICBPYmplY3Qua2V5cyhtaXhlZERlZmF1bHRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBpZiAocmF3T3B0aW9uc1trXSA9PSBudWxsKSB7XG4gICAgICAgIHJhd09wdGlvbnNba10gPSBtaXhlZERlZmF1bHRzW2tdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHJhd09wdGlvbnMucGFyc2VyID09PSBcImpzb25cIikge1xuICAgICAgcmF3T3B0aW9ucy50cmFpbGluZ0NvbW1hID0gXCJub25lXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGlvbnNOb3JtYWxpemVyLm5vcm1hbGl6ZUFwaU9wdGlvbnMocmF3T3B0aW9ucywgc3VwcG9ydE9wdGlvbnMsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgcGFzc1Rocm91Z2g6IE9iamVjdC5rZXlzKGhpZGRlbkRlZmF1bHRzKVxuICAgIH0sIG9wdHMpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBsdWdpbihvcHRpb25zKSB7XG4gICAgdmFyIGFzdEZvcm1hdCA9IG9wdGlvbnMuYXN0Rm9ybWF0O1xuXG4gICAgaWYgKCFhc3RGb3JtYXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImdldFBsdWdpbigpIHJlcXVpcmVzIGFzdEZvcm1hdCB0byBiZSBzZXRcIik7XG4gICAgfVxuXG4gICAgdmFyIHByaW50ZXJQbHVnaW4gPSBvcHRpb25zLnBsdWdpbnMuZmluZChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICByZXR1cm4gcGx1Z2luLnByaW50ZXJzICYmIHBsdWdpbi5wcmludGVyc1thc3RGb3JtYXRdO1xuICAgIH0pO1xuXG4gICAgaWYgKCFwcmludGVyUGx1Z2luKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIHBsdWdpbiBmb3IgQVNUIGZvcm1hdCBcXFwiXCIuY29uY2F0KGFzdEZvcm1hdCwgXCJcXFwiXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJpbnRlclBsdWdpbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEludGVycHJldGVyKGZpbGVwYXRoKSB7XG4gICAgaWYgKHR5cGVvZiBmaWxlcGF0aCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgdmFyIGZkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZkID0gZnMub3BlblN5bmMoZmlsZXBhdGgsIFwiclwiKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB2YXIgbGluZXIgPSBuZXcgcmVhZGxpbmVzKGZkKTtcbiAgICAgIHZhciBmaXJzdExpbmUgPSBsaW5lci5uZXh0KCkudG9TdHJpbmcoXCJ1dGY4XCIpOyAvLyAjIS9iaW4vZW52IG5vZGUsICMhL3Vzci9iaW4vZW52IG5vZGVcblxuICAgICAgdmFyIG0xID0gZmlyc3RMaW5lLm1hdGNoKC9eIyFcXC8oPzp1c3JcXC8pP2JpblxcL2VudlxccysoXFxTKykvKTtcblxuICAgICAgaWYgKG0xKSB7XG4gICAgICAgIHJldHVybiBtMVsxXTtcbiAgICAgIH0gLy8gIyEvYmluL25vZGUsICMhL3Vzci9iaW4vbm9kZSwgIyEvdXNyL2xvY2FsL2Jpbi9ub2RlXG5cblxuICAgICAgdmFyIG0yID0gZmlyc3RMaW5lLm1hdGNoKC9eIyFcXC8oPzp1c3JcXC8oPzpsb2NhbFxcLyk/KT9iaW5cXC8oXFxTKykvKTtcblxuICAgICAgaWYgKG0yKSB7XG4gICAgICAgIHJldHVybiBtMlsxXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBUaGVyZSBhcmUgc29tZSB3ZWlyZCBjYXNlcyB3aGVyZSBwYXRocyBhcmUgbWlzc2luZywgY2F1c2luZyBKZXN0XG4gICAgICAvLyBmYWlsdXJlcy4gSXQncyB1bmNsZWFyIHdoYXQgdGhlc2UgY29ycmVzcG9uZCB0byBpbiB0aGUgcmVhbCB3b3JsZC5cbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGVyZSBhcmUgc29tZSB3ZWlyZCBjYXNlcyB3aGVyZSBwYXRocyBhcmUgbWlzc2luZywgY2F1c2luZyBKZXN0XG4gICAgICAgIC8vIGZhaWx1cmVzLiBJdCdzIHVuY2xlYXIgd2hhdCB0aGVzZSBjb3JyZXNwb25kIHRvIGluIHRoZSByZWFsIHdvcmxkLlxuICAgICAgICBmcy5jbG9zZVN5bmMoZmQpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7Ly8gbm9wXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5mZXJQYXJzZXIoZmlsZXBhdGgsIHBsdWdpbnMpIHtcbiAgICB2YXIgZmlsZXBhdGhQYXJ0cyA9IG5vcm1hbGl6ZVBhdGgoZmlsZXBhdGgpLnNwbGl0KFwiL1wiKTtcbiAgICB2YXIgZmlsZW5hbWUgPSBmaWxlcGF0aFBhcnRzW2ZpbGVwYXRoUGFydHMubGVuZ3RoIC0gMV0udG9Mb3dlckNhc2UoKTsgLy8gSWYgdGhlIGZpbGUgaGFzIG5vIGV4dGVuc2lvbiwgd2UgY2FuIHRyeSB0byBpbmZlciB0aGUgbGFuZ3VhZ2UgZnJvbSB0aGVcbiAgICAvLyBpbnRlcnByZXRlciBpbiB0aGUgc2hlYmFuZyBsaW5lLCBpZiBhbnk7IGJ1dCBzaW5jZSB0aGlzIHJlcXVpcmVzIEZTIGFjY2VzcyxcbiAgICAvLyBkbyBpdCBsYXN0LlxuXG4gICAgdmFyIGxhbmd1YWdlID0gZ2V0U3VwcG9ydEluZm8kMShudWxsLCB7XG4gICAgICBwbHVnaW5zOiBwbHVnaW5zXG4gICAgfSkubGFuZ3VhZ2VzLmZpbmQoZnVuY3Rpb24gKGxhbmd1YWdlKSB7XG4gICAgICByZXR1cm4gbGFuZ3VhZ2Uuc2luY2UgIT09IG51bGwgJiYgKGxhbmd1YWdlLmV4dGVuc2lvbnMgJiYgbGFuZ3VhZ2UuZXh0ZW5zaW9ucy5zb21lKGZ1bmN0aW9uIChleHRlbnNpb24pIHtcbiAgICAgICAgcmV0dXJuIGZpbGVuYW1lLmVuZHNXaXRoKGV4dGVuc2lvbik7XG4gICAgICB9KSB8fCBsYW5ndWFnZS5maWxlbmFtZXMgJiYgbGFuZ3VhZ2UuZmlsZW5hbWVzLmZpbmQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gZmlsZW5hbWU7XG4gICAgICB9KSB8fCBmaWxlbmFtZS5pbmRleE9mKFwiLlwiKSA9PT0gLTEgJiYgbGFuZ3VhZ2UuaW50ZXJwcmV0ZXJzICYmIGxhbmd1YWdlLmludGVycHJldGVycy5pbmRleE9mKGdldEludGVycHJldGVyKGZpbGVwYXRoKSkgIT09IC0xKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbGFuZ3VhZ2UgJiYgbGFuZ3VhZ2UucGFyc2Vyc1swXTtcbiAgfVxuXG4gIHZhciBvcHRpb25zJDEgPSB7XG4gICAgbm9ybWFsaXplOiBub3JtYWxpemUkMSxcbiAgICBoaWRkZW5EZWZhdWx0czogaGlkZGVuRGVmYXVsdHMsXG4gICAgaW5mZXJQYXJzZXI6IGluZmVyUGFyc2VyXG4gIH07XG5cbiAgZnVuY3Rpb24gbWFzc2FnZUFTVChhc3QsIG9wdGlvbnMsIHBhcmVudCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFzdCkpIHtcbiAgICAgIHJldHVybiBhc3QubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBtYXNzYWdlQVNUKGUsIG9wdGlvbnMsIHBhcmVudCk7XG4gICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIWFzdCB8fCBfdHlwZW9mKGFzdCkgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuXG4gICAgdmFyIG5ld09iaiA9IHt9O1xuXG4gICAgZm9yICh2YXIgX2kgPSAwLCBfT2JqZWN0JGtleXMgPSBPYmplY3Qua2V5cyhhc3QpOyBfaSA8IF9PYmplY3Qka2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBrZXkgPSBfT2JqZWN0JGtleXNbX2ldO1xuXG4gICAgICBpZiAodHlwZW9mIGFzdFtrZXldICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbmV3T2JqW2tleV0gPSBtYXNzYWdlQVNUKGFzdFtrZXldLCBvcHRpb25zLCBhc3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnByaW50ZXIubWFzc2FnZUFzdE5vZGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBvcHRpb25zLnByaW50ZXIubWFzc2FnZUFzdE5vZGUoYXN0LCBuZXdPYmosIHBhcmVudCk7XG5cbiAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXdPYmo7XG4gIH1cblxuICB2YXIgbWFzc2FnZUFzdCA9IG1hc3NhZ2VBU1Q7XG5cbiAgZnVuY3Rpb24gYXNzZXJ0KCkge31cblxuICBhc3NlcnQub2sgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBhc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAvKipcbiAgICogQHBhcmFtIHtEb2NbXX0gcGFydHNcbiAgICogQHJldHVybnMgRG9jXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gY29uY2F0KHBhcnRzKSB7XG4gICAgLy8gYWNjZXNzIHRoZSBpbnRlcm5hbHMgb2YgYSBkb2N1bWVudCBkaXJlY3RseS5cbiAgICAvLyBpZihwYXJ0cy5sZW5ndGggPT09IDEpIHtcbiAgICAvLyAgIC8vIElmIGl0J3MgYSBzaW5nbGUgZG9jdW1lbnQsIG5vIG5lZWQgdG8gY29uY2F0IGl0LlxuICAgIC8vICAgcmV0dXJuIHBhcnRzWzBdO1xuICAgIC8vIH1cblxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY29uY2F0XCIsXG4gICAgICBwYXJ0czogcGFydHNcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY30gY29udGVudHNcbiAgICogQHJldHVybnMgRG9jXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaW5kZW50KGNvbnRlbnRzKSB7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJpbmRlbnRcIixcbiAgICAgIGNvbnRlbnRzOiBjb250ZW50c1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuXG4gICAqIEBwYXJhbSB7RG9jfSBjb250ZW50c1xuICAgKiBAcmV0dXJucyBEb2NcbiAgICovXG5cblxuICBmdW5jdGlvbiBhbGlnbihuLCBjb250ZW50cykge1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYWxpZ25cIixcbiAgICAgIGNvbnRlbnRzOiBjb250ZW50cyxcbiAgICAgIG46IG5cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY30gY29udGVudHNcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRzXSAtIFRCRCA/Pz9cbiAgICogQHJldHVybnMgRG9jXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ3JvdXAoY29udGVudHMsIG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImdyb3VwXCIsXG4gICAgICBpZDogb3B0cy5pZCxcbiAgICAgIGNvbnRlbnRzOiBjb250ZW50cyxcbiAgICAgIGJyZWFrOiAhIW9wdHMuc2hvdWxkQnJlYWssXG4gICAgICBleHBhbmRlZFN0YXRlczogb3B0cy5leHBhbmRlZFN0YXRlc1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jfSBjb250ZW50c1xuICAgKiBAcmV0dXJucyBEb2NcbiAgICovXG5cblxuICBmdW5jdGlvbiBkZWRlbnRUb1Jvb3QoY29udGVudHMpIHtcbiAgICByZXR1cm4gYWxpZ24oLUluZmluaXR5LCBjb250ZW50cyk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jfSBjb250ZW50c1xuICAgKiBAcmV0dXJucyBEb2NcbiAgICovXG5cblxuICBmdW5jdGlvbiBtYXJrQXNSb290KGNvbnRlbnRzKSB7XG4gICAgLy8gQHRzLWlnbm9yZSAtIFRCRCA/Pz86XG4gICAgcmV0dXJuIGFsaWduKHtcbiAgICAgIHR5cGU6IFwicm9vdFwiXG4gICAgfSwgY29udGVudHMpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY30gY29udGVudHNcbiAgICogQHJldHVybnMgRG9jXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZGVkZW50KGNvbnRlbnRzKSB7XG4gICAgcmV0dXJuIGFsaWduKC0xLCBjb250ZW50cyk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jW119IHN0YXRlc1xuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdHNdIC0gVEJEID8/P1xuICAgKiBAcmV0dXJucyBEb2NcbiAgICovXG5cblxuICBmdW5jdGlvbiBjb25kaXRpb25hbEdyb3VwKHN0YXRlcywgb3B0cykge1xuICAgIHJldHVybiBncm91cChzdGF0ZXNbMF0sIE9iamVjdC5hc3NpZ24ob3B0cyB8fCB7fSwge1xuICAgICAgZXhwYW5kZWRTdGF0ZXM6IHN0YXRlc1xuICAgIH0pKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtEb2NbXX0gcGFydHNcbiAgICogQHJldHVybnMgRG9jXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZmlsbChwYXJ0cykge1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZmlsbFwiLFxuICAgICAgcGFydHM6IHBhcnRzXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtEb2N9IFticmVha0NvbnRlbnRzXVxuICAgKiBAcGFyYW0ge0RvY30gW2ZsYXRDb250ZW50c11cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRzXSAtIFRCRCA/Pz9cbiAgICogQHJldHVybnMgRG9jXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaWZCcmVhayhicmVha0NvbnRlbnRzLCBmbGF0Q29udGVudHMsIG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImlmLWJyZWFrXCIsXG4gICAgICBicmVha0NvbnRlbnRzOiBicmVha0NvbnRlbnRzLFxuICAgICAgZmxhdENvbnRlbnRzOiBmbGF0Q29udGVudHMsXG4gICAgICBncm91cElkOiBvcHRzLmdyb3VwSWRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY30gY29udGVudHNcbiAgICogQHJldHVybnMgRG9jXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gbGluZVN1ZmZpeChjb250ZW50cykge1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibGluZS1zdWZmaXhcIixcbiAgICAgIGNvbnRlbnRzOiBjb250ZW50c1xuICAgIH07XG4gIH1cblxuICB2YXIgbGluZVN1ZmZpeEJvdW5kYXJ5ID0ge1xuICAgIHR5cGU6IFwibGluZS1zdWZmaXgtYm91bmRhcnlcIlxuICB9O1xuICB2YXIgYnJlYWtQYXJlbnQgPSB7XG4gICAgdHlwZTogXCJicmVhay1wYXJlbnRcIlxuICB9O1xuICB2YXIgdHJpbSA9IHtcbiAgICB0eXBlOiBcInRyaW1cIlxuICB9O1xuICB2YXIgbGluZSA9IHtcbiAgICB0eXBlOiBcImxpbmVcIlxuICB9O1xuICB2YXIgc29mdGxpbmUgPSB7XG4gICAgdHlwZTogXCJsaW5lXCIsXG4gICAgc29mdDogdHJ1ZVxuICB9O1xuICB2YXIgaGFyZGxpbmUgPSBjb25jYXQoW3tcbiAgICB0eXBlOiBcImxpbmVcIixcbiAgICBoYXJkOiB0cnVlXG4gIH0sIGJyZWFrUGFyZW50XSk7XG4gIHZhciBsaXRlcmFsbGluZSA9IGNvbmNhdChbe1xuICAgIHR5cGU6IFwibGluZVwiLFxuICAgIGhhcmQ6IHRydWUsXG4gICAgbGl0ZXJhbDogdHJ1ZVxuICB9LCBicmVha1BhcmVudF0pO1xuICB2YXIgY3Vyc29yID0ge1xuICAgIHR5cGU6IFwiY3Vyc29yXCIsXG4gICAgcGxhY2Vob2xkZXI6IFN5bWJvbChcImN1cnNvclwiKVxuICB9O1xuICAvKipcbiAgICogQHBhcmFtIHtEb2N9IHNlcFxuICAgKiBAcGFyYW0ge0RvY1tdfSBhcnJcbiAgICogQHJldHVybnMgRG9jXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGpvaW4oc2VwLCBhcnIpIHtcbiAgICB2YXIgcmVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGkgIT09IDApIHtcbiAgICAgICAgcmVzLnB1c2goc2VwKTtcbiAgICAgIH1cblxuICAgICAgcmVzLnB1c2goYXJyW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uY2F0KHJlcyk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jfSBkb2NcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNpemVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRhYldpZHRoXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYWRkQWxpZ25tZW50VG9Eb2MoZG9jLCBzaXplLCB0YWJXaWR0aCkge1xuICAgIHZhciBhbGlnbmVkID0gZG9jO1xuXG4gICAgaWYgKHNpemUgPiAwKSB7XG4gICAgICAvLyBVc2UgaW5kZW50IHRvIGFkZCB0YWJzIGZvciBhbGwgdGhlIGxldmVscyBvZiB0YWJzIHdlIG5lZWRcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTWF0aC5mbG9vcihzaXplIC8gdGFiV2lkdGgpOyArK2kpIHtcbiAgICAgICAgYWxpZ25lZCA9IGluZGVudChhbGlnbmVkKTtcbiAgICAgIH0gLy8gVXNlIGFsaWduIGZvciBhbGwgdGhlIHNwYWNlcyB0aGF0IGFyZSBuZWVkZWRcblxuXG4gICAgICBhbGlnbmVkID0gYWxpZ24oc2l6ZSAlIHRhYldpZHRoLCBhbGlnbmVkKTsgLy8gc2l6ZSBpcyBhYnNvbHV0ZSBmcm9tIDAgYW5kIG5vdCByZWxhdGl2ZSB0byB0aGUgY3VycmVudFxuICAgICAgLy8gaW5kZW50YXRpb24sIHNvIHdlIHVzZSAtSW5maW5pdHkgdG8gcmVzZXQgdGhlIGluZGVudGF0aW9uIHRvIDBcblxuICAgICAgYWxpZ25lZCA9IGFsaWduKC1JbmZpbml0eSwgYWxpZ25lZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFsaWduZWQ7XG4gIH1cblxuICB2YXIgZG9jQnVpbGRlcnMgPSB7XG4gICAgY29uY2F0OiBjb25jYXQsXG4gICAgam9pbjogam9pbixcbiAgICBsaW5lOiBsaW5lLFxuICAgIHNvZnRsaW5lOiBzb2Z0bGluZSxcbiAgICBoYXJkbGluZTogaGFyZGxpbmUsXG4gICAgbGl0ZXJhbGxpbmU6IGxpdGVyYWxsaW5lLFxuICAgIGdyb3VwOiBncm91cCxcbiAgICBjb25kaXRpb25hbEdyb3VwOiBjb25kaXRpb25hbEdyb3VwLFxuICAgIGZpbGw6IGZpbGwsXG4gICAgbGluZVN1ZmZpeDogbGluZVN1ZmZpeCxcbiAgICBsaW5lU3VmZml4Qm91bmRhcnk6IGxpbmVTdWZmaXhCb3VuZGFyeSxcbiAgICBjdXJzb3I6IGN1cnNvcixcbiAgICBicmVha1BhcmVudDogYnJlYWtQYXJlbnQsXG4gICAgaWZCcmVhazogaWZCcmVhayxcbiAgICB0cmltOiB0cmltLFxuICAgIGluZGVudDogaW5kZW50LFxuICAgIGFsaWduOiBhbGlnbixcbiAgICBhZGRBbGlnbm1lbnRUb0RvYzogYWRkQWxpZ25tZW50VG9Eb2MsXG4gICAgbWFya0FzUm9vdDogbWFya0FzUm9vdCxcbiAgICBkZWRlbnRUb1Jvb3Q6IGRlZGVudFRvUm9vdCxcbiAgICBkZWRlbnQ6IGRlZGVudFxuICB9O1xuXG4gIHZhciBhbnNpUmVnZXggPSBmdW5jdGlvbiBhbnNpUmVnZXgob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIG9ubHlGaXJzdDogZmFsc2VcbiAgICB9LCBvcHRpb25zKTtcbiAgICB2YXIgcGF0dGVybiA9IFtcIltcXFxcdTAwMUJcXFxcdTAwOUJdW1tcXFxcXSgpIzs/XSooPzooPzooPzpbYS16QS1aXFxcXGRdKig/OjtbLWEtekEtWlxcXFxkXFxcXC8jJi46PT8lQH5fXSopKik/XFxcXHUwMDA3KVwiLCAnKD86KD86XFxcXGR7MSw0fSg/OjtcXFxcZHswLDR9KSopP1tcXFxcZEEtUFItVFpjZi1udHFyeT0+PH5dKSknXS5qb2luKCd8Jyk7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiwgb3B0aW9ucy5vbmx5Rmlyc3QgPyB1bmRlZmluZWQgOiAnZycpO1xuICB9O1xuXG4gIHZhciBzdHJpcEFuc2kgPSBmdW5jdGlvbiBzdHJpcEFuc2koc3RyaW5nKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBzdHJpbmcgPT09ICdzdHJpbmcnID8gc3RyaW5nLnJlcGxhY2UoYW5zaVJlZ2V4KCksICcnKSA6IHN0cmluZztcbiAgfTtcblxuICB2YXIgc3RyaXBBbnNpXzEgPSBzdHJpcEFuc2k7XG4gIHZhciBkZWZhdWx0XzEkMSA9IHN0cmlwQW5zaTtcbiAgc3RyaXBBbnNpXzEuZGVmYXVsdCA9IGRlZmF1bHRfMSQxO1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIHlvZGEgKi9cblxuICB2YXIgaXNGdWxsd2lkdGhDb2RlUG9pbnQgPSBmdW5jdGlvbiBpc0Z1bGx3aWR0aENvZGVQb2ludChjb2RlUG9pbnQpIHtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKGNvZGVQb2ludCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIENvZGUgcG9pbnRzIGFyZSBkZXJpdmVkIGZyb206XG4gICAgLy8gaHR0cDovL3d3dy51bml4Lm9yZy9QdWJsaWMvVU5JREFUQS9FYXN0QXNpYW5XaWR0aC50eHRcblxuXG4gICAgaWYgKGNvZGVQb2ludCA+PSAweDExMDAgJiYgKGNvZGVQb2ludCA8PSAweDExNUYgfHwgLy8gSGFuZ3VsIEphbW9cbiAgICBjb2RlUG9pbnQgPT09IDB4MjMyOSB8fCAvLyBMRUZULVBPSU5USU5HIEFOR0xFIEJSQUNLRVRcbiAgICBjb2RlUG9pbnQgPT09IDB4MjMyQSB8fCAvLyBSSUdIVC1QT0lOVElORyBBTkdMRSBCUkFDS0VUXG4gICAgLy8gQ0pLIFJhZGljYWxzIFN1cHBsZW1lbnQgLi4gRW5jbG9zZWQgQ0pLIExldHRlcnMgYW5kIE1vbnRoc1xuICAgIDB4MkU4MCA8PSBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDw9IDB4MzI0NyAmJiBjb2RlUG9pbnQgIT09IDB4MzAzRiB8fCAvLyBFbmNsb3NlZCBDSksgTGV0dGVycyBhbmQgTW9udGhzIC4uIENKSyBVbmlmaWVkIElkZW9ncmFwaHMgRXh0ZW5zaW9uIEFcbiAgICAweDMyNTAgPD0gY29kZVBvaW50ICYmIGNvZGVQb2ludCA8PSAweDREQkYgfHwgLy8gQ0pLIFVuaWZpZWQgSWRlb2dyYXBocyAuLiBZaSBSYWRpY2Fsc1xuICAgIDB4NEUwMCA8PSBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDw9IDB4QTRDNiB8fCAvLyBIYW5ndWwgSmFtbyBFeHRlbmRlZC1BXG4gICAgMHhBOTYwIDw9IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPD0gMHhBOTdDIHx8IC8vIEhhbmd1bCBTeWxsYWJsZXNcbiAgICAweEFDMDAgPD0gY29kZVBvaW50ICYmIGNvZGVQb2ludCA8PSAweEQ3QTMgfHwgLy8gQ0pLIENvbXBhdGliaWxpdHkgSWRlb2dyYXBoc1xuICAgIDB4RjkwMCA8PSBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDw9IDB4RkFGRiB8fCAvLyBWZXJ0aWNhbCBGb3Jtc1xuICAgIDB4RkUxMCA8PSBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDw9IDB4RkUxOSB8fCAvLyBDSksgQ29tcGF0aWJpbGl0eSBGb3JtcyAuLiBTbWFsbCBGb3JtIFZhcmlhbnRzXG4gICAgMHhGRTMwIDw9IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPD0gMHhGRTZCIHx8IC8vIEhhbGZ3aWR0aCBhbmQgRnVsbHdpZHRoIEZvcm1zXG4gICAgMHhGRjAxIDw9IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPD0gMHhGRjYwIHx8IDB4RkZFMCA8PSBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDw9IDB4RkZFNiB8fCAvLyBLYW5hIFN1cHBsZW1lbnRcbiAgICAweDFCMDAwIDw9IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPD0gMHgxQjAwMSB8fCAvLyBFbmNsb3NlZCBJZGVvZ3JhcGhpYyBTdXBwbGVtZW50XG4gICAgMHgxRjIwMCA8PSBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDw9IDB4MUYyNTEgfHwgLy8gQ0pLIFVuaWZpZWQgSWRlb2dyYXBocyBFeHRlbnNpb24gQiAuLiBUZXJ0aWFyeSBJZGVvZ3JhcGhpYyBQbGFuZVxuICAgIDB4MjAwMDAgPD0gY29kZVBvaW50ICYmIGNvZGVQb2ludCA8PSAweDNGRkZEKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHZhciBpc0Z1bGx3aWR0aENvZGVQb2ludF8xID0gaXNGdWxsd2lkdGhDb2RlUG9pbnQ7XG4gIHZhciBkZWZhdWx0XzEkMiA9IGlzRnVsbHdpZHRoQ29kZVBvaW50O1xuICBpc0Z1bGx3aWR0aENvZGVQb2ludF8xLmRlZmF1bHQgPSBkZWZhdWx0XzEkMjtcblxuICB2YXIgZW1vamlSZWdleCA9IGZ1bmN0aW9uIGVtb2ppUmVnZXgoKSB7XG4gICAgLy8gaHR0cHM6Ly9tdGhzLmJlL2Vtb2ppXG4gICAgcmV0dXJuIC9cXHVEODNDXFx1REZGNFxcdURCNDBcXHVEQzY3XFx1REI0MFxcdURDNjIoPzpcXHVEQjQwXFx1REM2NVxcdURCNDBcXHVEQzZFXFx1REI0MFxcdURDNjd8XFx1REI0MFxcdURDNzNcXHVEQjQwXFx1REM2M1xcdURCNDBcXHVEQzc0fFxcdURCNDBcXHVEQzc3XFx1REI0MFxcdURDNkNcXHVEQjQwXFx1REM3MylcXHVEQjQwXFx1REM3RnxcXHVEODNEXFx1REM2OCg/OlxcdUQ4M0NcXHVERkZDXFx1MjAwRCg/OlxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4XFx1RDgzQ1xcdURGRkJ8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NcXHVERkZGXFx1MjAwRCg/OlxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkVdKXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkVcXHUyMDBEKD86XFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjgoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRF0pfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDXFx1REZGRFxcdTIwMEQoPzpcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OCg/OlxcdUQ4M0NbXFx1REZGQlxcdURGRkNdKXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1MjAwRCg/OlxcdTI3NjRcXHVGRTBGXFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCk/XFx1RDgzRFxcdURDNjh8KD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pXFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzY2XFx1MjAwRFxcdUQ4M0RcXHVEQzY2fFxcdUQ4M0RcXHVEQzY3XFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2NlxcdURDNjddKSl8XFx1RDgzRFxcdURDNjZcXHUyMDBEXFx1RDgzRFxcdURDNjZ8XFx1RDgzRFxcdURDNjdcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY2XFx1REM2N10pfCg/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKVxcdTIwMEQoPzpcXHVEODNEW1xcdURDNjZcXHVEQzY3XSl8W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGfFxcdUQ4M0RbXFx1REM2NlxcdURDNjddfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXwoPzpcXHVEODNDXFx1REZGQlxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNDXFx1REZGRlxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNDXFx1REZGRVxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNDXFx1REZGRFxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNDXFx1REZGQ1xcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XSlcXHVGRTBGfFxcdUQ4M0NcXHVERkZCXFx1MjAwRCg/OlxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfCg/OlxcdUQ4M0VcXHVEREQxXFx1RDgzQ1xcdURGRkJcXHUyMDBEXFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRVxcdURERDF8XFx1RDgzRFxcdURDNjlcXHVEODNDXFx1REZGQ1xcdTIwMERcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OSlcXHVEODNDXFx1REZGQnxcXHVEODNFXFx1REREMSg/OlxcdUQ4M0NcXHVERkZGXFx1MjAwRFxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0VcXHVEREQxKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXxcXHUyMDBEXFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRVxcdURERDEpfCg/OlxcdUQ4M0VcXHVEREQxXFx1RDgzQ1xcdURGRkVcXHUyMDBEXFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRVxcdURERDF8XFx1RDgzRFxcdURDNjlcXHVEODNDXFx1REZGRlxcdTIwMERcXHVEODNFXFx1REQxRFxcdTIwMEQoPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSkpKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkVdKXwoPzpcXHVEODNFXFx1REREMVxcdUQ4M0NcXHVERkZDXFx1MjAwRFxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0VcXHVEREQxfFxcdUQ4M0RcXHVEQzY5XFx1RDgzQ1xcdURGRkRcXHUyMDBEXFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjkpKD86XFx1RDgzQ1tcXHVERkZCXFx1REZGQ10pfFxcdUQ4M0RcXHVEQzY5KD86XFx1RDgzQ1xcdURGRkVcXHUyMDBEKD86XFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjgoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRFxcdURGRkZdKXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkNcXHUyMDBEKD86XFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjgoPzpcXHVEODNDW1xcdURGRkJcXHVERkZELVxcdURGRkZdKXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkJcXHUyMDBEKD86XFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjgoPzpcXHVEODNDW1xcdURGRkMtXFx1REZGRl0pfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDXFx1REZGRFxcdTIwMEQoPzpcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OCg/OlxcdUQ4M0NbXFx1REZGQlxcdURGRkNcXHVERkZFXFx1REZGRl0pfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHUyMDBEKD86XFx1Mjc2NFxcdUZFMEZcXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pfFxcdUQ4M0RbXFx1REM2OFxcdURDNjldKXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkZcXHUyMDBEKD86XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pKXxcXHVEODNEXFx1REM2OVxcdTIwMERcXHVEODNEXFx1REM2OVxcdTIwMEQoPzpcXHVEODNEXFx1REM2NlxcdTIwMERcXHVEODNEXFx1REM2NnxcXHVEODNEXFx1REM2N1xcdTIwMEQoPzpcXHVEODNEW1xcdURDNjZcXHVEQzY3XSkpfCg/OlxcdUQ4M0VcXHVEREQxXFx1RDgzQ1xcdURGRkRcXHUyMDBEXFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRVxcdURERDF8XFx1RDgzRFxcdURDNjlcXHVEODNDXFx1REZGRVxcdTIwMERcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRF0pfFxcdUQ4M0RcXHVEQzY5XFx1MjAwRFxcdUQ4M0RcXHVEQzY2XFx1MjAwRFxcdUQ4M0RcXHVEQzY2fFxcdUQ4M0RcXHVEQzY5XFx1MjAwRFxcdUQ4M0RcXHVEQzY5XFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2NlxcdURDNjddKXwoPzpcXHVEODNEXFx1REM0MVxcdUZFMEZcXHUyMDBEXFx1RDgzRFxcdURERTh8XFx1RDgzRFxcdURDNjkoPzpcXHVEODNDXFx1REZGRlxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNDXFx1REZGRVxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNDXFx1REZGQ1xcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNDXFx1REZGQlxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNDXFx1REZGRFxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF0pfCg/Oig/OlxcdTI2Rjl8XFx1RDgzQ1tcXHVERkNCXFx1REZDQ118XFx1RDgzRFxcdURENzUpXFx1RkUwRnxcXHVEODNEXFx1REM2RnxcXHVEODNFW1xcdUREM0NcXHVERERFXFx1RERERl0pXFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml18KD86XFx1MjZGOXxcXHVEODNDW1xcdURGQ0JcXHVERkNDXXxcXHVEODNEXFx1REQ3NSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pXFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml18KD86XFx1RDgzQ1tcXHVERkMzXFx1REZDNFxcdURGQ0FdfFxcdUQ4M0RbXFx1REM2RVxcdURDNzFcXHVEQzczXFx1REM3N1xcdURDODFcXHVEQzgyXFx1REM4NlxcdURDODdcXHVERTQ1LVxcdURFNDdcXHVERTRCXFx1REU0RFxcdURFNEVcXHVERUEzXFx1REVCNC1cXHVERUI2XXxcXHVEODNFW1xcdUREMjZcXHVERDM3LVxcdUREMzlcXHVERDNEXFx1REQzRVxcdUREQjhcXHVEREI5XFx1RERDRC1cXHVERENGXFx1RERENi1cXHVEREREXSkoPzooPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pXFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml18XFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml0pfFxcdUQ4M0NcXHVERkY0XFx1MjAwRFxcdTI2MjApXFx1RkUwRnxcXHVEODNEXFx1REM2OVxcdTIwMERcXHVEODNEXFx1REM2N1xcdTIwMEQoPzpcXHVEODNEW1xcdURDNjZcXHVEQzY3XSl8XFx1RDgzQ1xcdURGRjNcXHVGRTBGXFx1MjAwRFxcdUQ4M0NcXHVERjA4fFxcdUQ4M0RcXHVEQzE1XFx1MjAwRFxcdUQ4M0VcXHVEREJBfFxcdUQ4M0RcXHVEQzY5XFx1MjAwRFxcdUQ4M0RcXHVEQzY2fFxcdUQ4M0RcXHVEQzY5XFx1MjAwRFxcdUQ4M0RcXHVEQzY3fFxcdUQ4M0NcXHVEREZEXFx1RDgzQ1xcdURERjB8XFx1RDgzQ1xcdURERjRcXHVEODNDXFx1RERGMnxcXHVEODNDXFx1RERGNlxcdUQ4M0NcXHVEREU2fFsjXFwqMC05XVxcdUZFMEZcXHUyMEUzfFxcdUQ4M0NcXHVEREU3KD86XFx1RDgzQ1tcXHVEREU2XFx1RERFN1xcdURERTktXFx1RERFRlxcdURERjEtXFx1RERGNFxcdURERjYtXFx1RERGOVxcdURERkJcXHVEREZDXFx1RERGRVxcdURERkZdKXxcXHVEODNDXFx1RERGOSg/OlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREU5XFx1RERFQi1cXHVEREVEXFx1RERFRi1cXHVEREY0XFx1RERGN1xcdURERjlcXHVEREZCXFx1RERGQ1xcdURERkZdKXxcXHVEODNDXFx1RERFQSg/OlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREVBXFx1RERFQ1xcdURERURcXHVEREY3LVxcdURERkFdKXxcXHVEODNFXFx1REREMSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8XFx1RDgzQ1xcdURERjcoPzpcXHVEODNDW1xcdURERUFcXHVEREY0XFx1RERGOFxcdURERkFcXHVEREZDXSl8XFx1RDgzRFxcdURDNjkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfFxcdUQ4M0NcXHVEREYyKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOC1cXHVEREVEXFx1RERGMC1cXHVEREZGXSl8XFx1RDgzQ1xcdURERTYoPzpcXHVEODNDW1xcdURERTgtXFx1RERFQ1xcdURERUVcXHVEREYxXFx1RERGMlxcdURERjRcXHVEREY2LVxcdURERkFcXHVEREZDXFx1RERGRFxcdURERkZdKXxcXHVEODNDXFx1RERGMCg/OlxcdUQ4M0NbXFx1RERFQVxcdURERUMtXFx1RERFRVxcdURERjJcXHVEREYzXFx1RERGNVxcdURERjdcXHVEREZDXFx1RERGRVxcdURERkZdKXxcXHVEODNDXFx1RERFRCg/OlxcdUQ4M0NbXFx1RERGMFxcdURERjJcXHVEREYzXFx1RERGN1xcdURERjlcXHVEREZBXSl8XFx1RDgzQ1xcdURERTkoPzpcXHVEODNDW1xcdURERUFcXHVEREVDXFx1RERFRlxcdURERjBcXHVEREYyXFx1RERGNFxcdURERkZdKXxcXHVEODNDXFx1RERGRSg/OlxcdUQ4M0NbXFx1RERFQVxcdURERjldKXxcXHVEODNDXFx1RERFQyg/OlxcdUQ4M0NbXFx1RERFNlxcdURERTdcXHVEREU5LVxcdURERUVcXHVEREYxLVxcdURERjNcXHVEREY1LVxcdURERkFcXHVEREZDXFx1RERGRV0pfFxcdUQ4M0NcXHVEREY4KD86XFx1RDgzQ1tcXHVEREU2LVxcdURERUFcXHVEREVDLVxcdURERjRcXHVEREY3LVxcdURERjlcXHVEREZCXFx1RERGRC1cXHVEREZGXSl8XFx1RDgzQ1xcdURERUIoPzpcXHVEODNDW1xcdURERUUtXFx1RERGMFxcdURERjJcXHVEREY0XFx1RERGN10pfFxcdUQ4M0NcXHVEREY1KD86XFx1RDgzQ1tcXHVEREU2XFx1RERFQS1cXHVEREVEXFx1RERGMC1cXHVEREYzXFx1RERGNy1cXHVEREY5XFx1RERGQ1xcdURERkVdKXxcXHVEODNDXFx1RERGQig/OlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREVBXFx1RERFQ1xcdURERUVcXHVEREYzXFx1RERGQV0pfFxcdUQ4M0NcXHVEREYzKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERUEtXFx1RERFQ1xcdURERUVcXHVEREYxXFx1RERGNFxcdURERjVcXHVEREY3XFx1RERGQVxcdURERkZdKXxcXHVEODNDXFx1RERFOCg/OlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREU5XFx1RERFQi1cXHVEREVFXFx1RERGMC1cXHVEREY1XFx1RERGN1xcdURERkEtXFx1RERGRl0pfFxcdUQ4M0NcXHVEREYxKD86XFx1RDgzQ1tcXHVEREU2LVxcdURERThcXHVEREVFXFx1RERGMFxcdURERjctXFx1RERGQlxcdURERkVdKXxcXHVEODNDXFx1RERGRig/OlxcdUQ4M0NbXFx1RERFNlxcdURERjJcXHVEREZDXSl8XFx1RDgzQ1xcdURERkMoPzpcXHVEODNDW1xcdURERUJcXHVEREY4XSl8XFx1RDgzQ1xcdURERkEoPzpcXHVEODNDW1xcdURERTZcXHVEREVDXFx1RERGMlxcdURERjNcXHVEREY4XFx1RERGRVxcdURERkZdKXxcXHVEODNDXFx1RERFRSg/OlxcdUQ4M0NbXFx1RERFOC1cXHVEREVBXFx1RERGMS1cXHVEREY0XFx1RERGNi1cXHVEREY5XSl8XFx1RDgzQ1xcdURERUYoPzpcXHVEODNDW1xcdURERUFcXHVEREYyXFx1RERGNFxcdURERjVdKXwoPzpcXHVEODNDW1xcdURGQzNcXHVERkM0XFx1REZDQV18XFx1RDgzRFtcXHVEQzZFXFx1REM3MVxcdURDNzNcXHVEQzc3XFx1REM4MVxcdURDODJcXHVEQzg2XFx1REM4N1xcdURFNDUtXFx1REU0N1xcdURFNEJcXHVERTREXFx1REU0RVxcdURFQTNcXHVERUI0LVxcdURFQjZdfFxcdUQ4M0VbXFx1REQyNlxcdUREMzctXFx1REQzOVxcdUREM0RcXHVERDNFXFx1RERCOFxcdUREQjlcXHVERENELVxcdUREQ0ZcXHVEREQ2LVxcdURERERdKSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8KD86XFx1MjZGOXxcXHVEODNDW1xcdURGQ0JcXHVERkNDXXxcXHVEODNEXFx1REQ3NSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfCg/OltcXHUyNjFEXFx1MjcwQS1cXHUyNzBEXXxcXHVEODNDW1xcdURGODVcXHVERkMyXFx1REZDN118XFx1RDgzRFtcXHVEQzQyXFx1REM0M1xcdURDNDYtXFx1REM1MFxcdURDNjZcXHVEQzY3XFx1REM2Qi1cXHVEQzZEXFx1REM3MFxcdURDNzJcXHVEQzc0LVxcdURDNzZcXHVEQzc4XFx1REM3Q1xcdURDODNcXHVEQzg1XFx1RENBQVxcdURENzRcXHVERDdBXFx1REQ5MFxcdUREOTVcXHVERDk2XFx1REU0Q1xcdURFNEZcXHVERUMwXFx1REVDQ118XFx1RDgzRVtcXHVERDBGXFx1REQxOC1cXHVERDFDXFx1REQxRVxcdUREMUZcXHVERDMwLVxcdUREMzZcXHVEREI1XFx1RERCNlxcdUREQkJcXHVEREQyLVxcdURERDVdKSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8KD86W1xcdTIzMUFcXHUyMzFCXFx1MjNFOS1cXHUyM0VDXFx1MjNGMFxcdTIzRjNcXHUyNUZEXFx1MjVGRVxcdTI2MTRcXHUyNjE1XFx1MjY0OC1cXHUyNjUzXFx1MjY3RlxcdTI2OTNcXHUyNkExXFx1MjZBQVxcdTI2QUJcXHUyNkJEXFx1MjZCRVxcdTI2QzRcXHUyNkM1XFx1MjZDRVxcdTI2RDRcXHUyNkVBXFx1MjZGMlxcdTI2RjNcXHUyNkY1XFx1MjZGQVxcdTI2RkRcXHUyNzA1XFx1MjcwQVxcdTI3MEJcXHUyNzI4XFx1Mjc0Q1xcdTI3NEVcXHUyNzUzLVxcdTI3NTVcXHUyNzU3XFx1Mjc5NS1cXHUyNzk3XFx1MjdCMFxcdTI3QkZcXHUyQjFCXFx1MkIxQ1xcdTJCNTBcXHUyQjU1XXxcXHVEODNDW1xcdURDMDRcXHVEQ0NGXFx1REQ4RVxcdUREOTEtXFx1REQ5QVxcdURERTYtXFx1RERGRlxcdURFMDFcXHVERTFBXFx1REUyRlxcdURFMzItXFx1REUzNlxcdURFMzgtXFx1REUzQVxcdURFNTBcXHVERTUxXFx1REYwMC1cXHVERjIwXFx1REYyRC1cXHVERjM1XFx1REYzNy1cXHVERjdDXFx1REY3RS1cXHVERjkzXFx1REZBMC1cXHVERkNBXFx1REZDRi1cXHVERkQzXFx1REZFMC1cXHVERkYwXFx1REZGNFxcdURGRjgtXFx1REZGRl18XFx1RDgzRFtcXHVEQzAwLVxcdURDM0VcXHVEQzQwXFx1REM0Mi1cXHVEQ0ZDXFx1RENGRi1cXHVERDNEXFx1REQ0Qi1cXHVERDRFXFx1REQ1MC1cXHVERDY3XFx1REQ3QVxcdUREOTVcXHVERDk2XFx1RERBNFxcdURERkItXFx1REU0RlxcdURFODAtXFx1REVDNVxcdURFQ0NcXHVERUQwLVxcdURFRDJcXHVERUQ1XFx1REVFQlxcdURFRUNcXHVERUY0LVxcdURFRkFcXHVERkUwLVxcdURGRUJdfFxcdUQ4M0VbXFx1REQwRC1cXHVERDNBXFx1REQzQy1cXHVERDQ1XFx1REQ0Ny1cXHVERDcxXFx1REQ3My1cXHVERDc2XFx1REQ3QS1cXHVEREEyXFx1RERBNS1cXHVEREFBXFx1RERBRS1cXHVERENBXFx1RERDRC1cXHVEREZGXFx1REU3MC1cXHVERTczXFx1REU3OC1cXHVERTdBXFx1REU4MC1cXHVERTgyXFx1REU5MC1cXHVERTk1XSl8KD86WyNcXCowLTlcXHhBOVxceEFFXFx1MjAzQ1xcdTIwNDlcXHUyMTIyXFx1MjEzOVxcdTIxOTQtXFx1MjE5OVxcdTIxQTlcXHUyMUFBXFx1MjMxQVxcdTIzMUJcXHUyMzI4XFx1MjNDRlxcdTIzRTktXFx1MjNGM1xcdTIzRjgtXFx1MjNGQVxcdTI0QzJcXHUyNUFBXFx1MjVBQlxcdTI1QjZcXHUyNUMwXFx1MjVGQi1cXHUyNUZFXFx1MjYwMC1cXHUyNjA0XFx1MjYwRVxcdTI2MTFcXHUyNjE0XFx1MjYxNVxcdTI2MThcXHUyNjFEXFx1MjYyMFxcdTI2MjJcXHUyNjIzXFx1MjYyNlxcdTI2MkFcXHUyNjJFXFx1MjYyRlxcdTI2MzgtXFx1MjYzQVxcdTI2NDBcXHUyNjQyXFx1MjY0OC1cXHUyNjUzXFx1MjY1RlxcdTI2NjBcXHUyNjYzXFx1MjY2NVxcdTI2NjZcXHUyNjY4XFx1MjY3QlxcdTI2N0VcXHUyNjdGXFx1MjY5Mi1cXHUyNjk3XFx1MjY5OVxcdTI2OUJcXHUyNjlDXFx1MjZBMFxcdTI2QTFcXHUyNkFBXFx1MjZBQlxcdTI2QjBcXHUyNkIxXFx1MjZCRFxcdTI2QkVcXHUyNkM0XFx1MjZDNVxcdTI2QzhcXHUyNkNFXFx1MjZDRlxcdTI2RDFcXHUyNkQzXFx1MjZENFxcdTI2RTlcXHUyNkVBXFx1MjZGMC1cXHUyNkY1XFx1MjZGNy1cXHUyNkZBXFx1MjZGRFxcdTI3MDJcXHUyNzA1XFx1MjcwOC1cXHUyNzBEXFx1MjcwRlxcdTI3MTJcXHUyNzE0XFx1MjcxNlxcdTI3MURcXHUyNzIxXFx1MjcyOFxcdTI3MzNcXHUyNzM0XFx1Mjc0NFxcdTI3NDdcXHUyNzRDXFx1Mjc0RVxcdTI3NTMtXFx1Mjc1NVxcdTI3NTdcXHUyNzYzXFx1Mjc2NFxcdTI3OTUtXFx1Mjc5N1xcdTI3QTFcXHUyN0IwXFx1MjdCRlxcdTI5MzRcXHUyOTM1XFx1MkIwNS1cXHUyQjA3XFx1MkIxQlxcdTJCMUNcXHUyQjUwXFx1MkI1NVxcdTMwMzBcXHUzMDNEXFx1MzI5N1xcdTMyOTldfFxcdUQ4M0NbXFx1REMwNFxcdURDQ0ZcXHVERDcwXFx1REQ3MVxcdUREN0VcXHVERDdGXFx1REQ4RVxcdUREOTEtXFx1REQ5QVxcdURERTYtXFx1RERGRlxcdURFMDFcXHVERTAyXFx1REUxQVxcdURFMkZcXHVERTMyLVxcdURFM0FcXHVERTUwXFx1REU1MVxcdURGMDAtXFx1REYyMVxcdURGMjQtXFx1REY5M1xcdURGOTZcXHVERjk3XFx1REY5OS1cXHVERjlCXFx1REY5RS1cXHVERkYwXFx1REZGMy1cXHVERkY1XFx1REZGNy1cXHVERkZGXXxcXHVEODNEW1xcdURDMDAtXFx1RENGRFxcdURDRkYtXFx1REQzRFxcdURENDktXFx1REQ0RVxcdURENTAtXFx1REQ2N1xcdURENkZcXHVERDcwXFx1REQ3My1cXHVERDdBXFx1REQ4N1xcdUREOEEtXFx1REQ4RFxcdUREOTBcXHVERDk1XFx1REQ5NlxcdUREQTRcXHVEREE1XFx1RERBOFxcdUREQjFcXHVEREIyXFx1RERCQ1xcdUREQzItXFx1RERDNFxcdURERDEtXFx1REREM1xcdUREREMtXFx1RERERVxcdURERTFcXHVEREUzXFx1RERFOFxcdURERUZcXHVEREYzXFx1RERGQS1cXHVERTRGXFx1REU4MC1cXHVERUM1XFx1REVDQi1cXHVERUQyXFx1REVENVxcdURFRTAtXFx1REVFNVxcdURFRTlcXHVERUVCXFx1REVFQ1xcdURFRjBcXHVERUYzLVxcdURFRkFcXHVERkUwLVxcdURGRUJdfFxcdUQ4M0VbXFx1REQwRC1cXHVERDNBXFx1REQzQy1cXHVERDQ1XFx1REQ0Ny1cXHVERDcxXFx1REQ3My1cXHVERDc2XFx1REQ3QS1cXHVEREEyXFx1RERBNS1cXHVEREFBXFx1RERBRS1cXHVERENBXFx1RERDRC1cXHVEREZGXFx1REU3MC1cXHVERTczXFx1REU3OC1cXHVERTdBXFx1REU4MC1cXHVERTgyXFx1REU5MC1cXHVERTk1XSlcXHVGRTBGfCg/OltcXHUyNjFEXFx1MjZGOVxcdTI3MEEtXFx1MjcwRF18XFx1RDgzQ1tcXHVERjg1XFx1REZDMi1cXHVERkM0XFx1REZDN1xcdURGQ0EtXFx1REZDQ118XFx1RDgzRFtcXHVEQzQyXFx1REM0M1xcdURDNDYtXFx1REM1MFxcdURDNjYtXFx1REM3OFxcdURDN0NcXHVEQzgxLVxcdURDODNcXHVEQzg1LVxcdURDODdcXHVEQzhGXFx1REM5MVxcdURDQUFcXHVERDc0XFx1REQ3NVxcdUREN0FcXHVERDkwXFx1REQ5NVxcdUREOTZcXHVERTQ1LVxcdURFNDdcXHVERTRCLVxcdURFNEZcXHVERUEzXFx1REVCNC1cXHVERUI2XFx1REVDMFxcdURFQ0NdfFxcdUQ4M0VbXFx1REQwRlxcdUREMTgtXFx1REQxRlxcdUREMjZcXHVERDMwLVxcdUREMzlcXHVERDNDLVxcdUREM0VcXHVEREI1XFx1RERCNlxcdUREQjhcXHVEREI5XFx1RERCQlxcdUREQ0QtXFx1RERDRlxcdURERDEtXFx1RERERF0pL2c7XG4gIH07XG5cbiAgdmFyIHN0cmluZ1dpZHRoID0gZnVuY3Rpb24gc3RyaW5nV2lkdGgoc3RyaW5nKSB7XG4gICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoZW1vamlSZWdleCgpLCAnICAnKTtcblxuICAgIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJyB8fCBzdHJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBzdHJpbmcgPSBzdHJpcEFuc2lfMShzdHJpbmcpO1xuICAgIHZhciB3aWR0aCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNvZGUgPSBzdHJpbmcuY29kZVBvaW50QXQoaSk7IC8vIElnbm9yZSBjb250cm9sIGNoYXJhY3RlcnNcblxuICAgICAgaWYgKGNvZGUgPD0gMHgxRiB8fCBjb2RlID49IDB4N0YgJiYgY29kZSA8PSAweDlGKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBJZ25vcmUgY29tYmluaW5nIGNoYXJhY3RlcnNcblxuXG4gICAgICBpZiAoY29kZSA+PSAweDMwMCAmJiBjb2RlIDw9IDB4MzZGKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBTdXJyb2dhdGVzXG5cblxuICAgICAgaWYgKGNvZGUgPiAweEZGRkYpIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuXG4gICAgICB3aWR0aCArPSBpc0Z1bGx3aWR0aENvZGVQb2ludF8xKGNvZGUpID8gMiA6IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdpZHRoO1xuICB9O1xuXG4gIHZhciBzdHJpbmdXaWR0aF8xID0gc3RyaW5nV2lkdGg7IC8vIFRPRE86IHJlbW92ZSB0aGlzIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb25cblxuICB2YXIgZGVmYXVsdF8xJDMgPSBzdHJpbmdXaWR0aDtcbiAgc3RyaW5nV2lkdGhfMS5kZWZhdWx0ID0gZGVmYXVsdF8xJDM7XG5cbiAgdmFyIG5vdEFzY2lpUmVnZXggPSAvW15cXHgyMC1cXHg3Rl0vO1xuXG4gIGZ1bmN0aW9uIGlzRXhwb3J0RGVjbGFyYXRpb24obm9kZSkge1xuICAgIGlmIChub2RlKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICBjYXNlIFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCI6XG4gICAgICAgIGNhc2UgXCJFeHBvcnREZWZhdWx0U3BlY2lmaWVyXCI6XG4gICAgICAgIGNhc2UgXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIjpcbiAgICAgICAgY2FzZSBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIjpcbiAgICAgICAgY2FzZSBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCI6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UGFyZW50RXhwb3J0RGVjbGFyYXRpb24ocGF0aCkge1xuICAgIHZhciBwYXJlbnROb2RlID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG5cbiAgICBpZiAocGF0aC5nZXROYW1lKCkgPT09IFwiZGVjbGFyYXRpb25cIiAmJiBpc0V4cG9ydERlY2xhcmF0aW9uKHBhcmVudE5vZGUpKSB7XG4gICAgICByZXR1cm4gcGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBlbnVsdGltYXRlKGFycikge1xuICAgIGlmIChhcnIubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMl07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHt7YmFja3dhcmRzPzogYm9vbGVhbn19IFNraXBPcHRpb25zXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFJlZ0V4cH0gY2hhcnNcbiAgICogQHJldHVybnMgeyh0ZXh0OiBzdHJpbmcsIGluZGV4OiBudW1iZXIgfCBmYWxzZSwgb3B0cz86IFNraXBPcHRpb25zKSA9PiBudW1iZXIgfCBmYWxzZX1cbiAgICovXG5cblxuICBmdW5jdGlvbiBza2lwKGNoYXJzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0ZXh0LCBpbmRleCwgb3B0cykge1xuICAgICAgdmFyIGJhY2t3YXJkcyA9IG9wdHMgJiYgb3B0cy5iYWNrd2FyZHM7IC8vIEFsbG93IGBza2lwYCBmdW5jdGlvbnMgdG8gYmUgdGhyZWFkZWQgdG9nZXRoZXIgd2l0aG91dCBoYXZpbmdcbiAgICAgIC8vIHRvIGNoZWNrIGZvciBmYWlsdXJlcyAoZGlkIHNvbWVvbmUgc2F5IG1vbmFkcz8pLlxuXG4gICAgICBpZiAoaW5kZXggPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbmd0aCA9IHRleHQubGVuZ3RoO1xuICAgICAgdmFyIGN1cnNvciA9IGluZGV4O1xuXG4gICAgICB3aGlsZSAoY3Vyc29yID49IDAgJiYgY3Vyc29yIDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBjID0gdGV4dC5jaGFyQXQoY3Vyc29yKTtcblxuICAgICAgICBpZiAoY2hhcnMgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICBpZiAoIWNoYXJzLnRlc3QoYykpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJzb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNoYXJzLmluZGV4T2YoYykgPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnNvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJhY2t3YXJkcyA/IGN1cnNvci0tIDogY3Vyc29yKys7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJzb3IgPT09IC0xIHx8IGN1cnNvciA9PT0gbGVuZ3RoKSB7XG4gICAgICAgIC8vIElmIHdlIHJlYWNoZWQgdGhlIGJlZ2lubmluZyBvciBlbmQgb2YgdGhlIGZpbGUsIHJldHVybiB0aGVcbiAgICAgICAgLy8gb3V0LW9mLWJvdW5kcyBjdXJzb3IuIEl0J3MgdXAgdG8gdGhlIGNhbGxlciB0byBoYW5kbGUgdGhpc1xuICAgICAgICAvLyBjb3JyZWN0bHkuIFdlIGRvbid0IHdhbnQgdG8gaW5kaWNhdGUgYGZhbHNlYCB0aG91Z2ggaWYgaXRcbiAgICAgICAgLy8gYWN0dWFsbHkgc2tpcHBlZCB2YWxpZCBjaGFyYWN0ZXJzLlxuICAgICAgICByZXR1cm4gY3Vyc29yO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQHR5cGUgeyh0ZXh0OiBzdHJpbmcsIGluZGV4OiBudW1iZXIgfCBmYWxzZSwgb3B0cz86IFNraXBPcHRpb25zKSA9PiBudW1iZXIgfCBmYWxzZX1cbiAgICovXG5cblxuICB2YXIgc2tpcFdoaXRlc3BhY2UgPSBza2lwKC9cXHMvKTtcbiAgLyoqXG4gICAqIEB0eXBlIHsodGV4dDogc3RyaW5nLCBpbmRleDogbnVtYmVyIHwgZmFsc2UsIG9wdHM/OiBTa2lwT3B0aW9ucykgPT4gbnVtYmVyIHwgZmFsc2V9XG4gICAqL1xuXG4gIHZhciBza2lwU3BhY2VzID0gc2tpcChcIiBcXHRcIik7XG4gIC8qKlxuICAgKiBAdHlwZSB7KHRleHQ6IHN0cmluZywgaW5kZXg6IG51bWJlciB8IGZhbHNlLCBvcHRzPzogU2tpcE9wdGlvbnMpID0+IG51bWJlciB8IGZhbHNlfVxuICAgKi9cblxuICB2YXIgc2tpcFRvTGluZUVuZCA9IHNraXAoXCIsOyBcXHRcIik7XG4gIC8qKlxuICAgKiBAdHlwZSB7KHRleHQ6IHN0cmluZywgaW5kZXg6IG51bWJlciB8IGZhbHNlLCBvcHRzPzogU2tpcE9wdGlvbnMpID0+IG51bWJlciB8IGZhbHNlfVxuICAgKi9cblxuICB2YXIgc2tpcEV2ZXJ5dGhpbmdCdXROZXdMaW5lID0gc2tpcCgvW15cXHJcXG5dLyk7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKiBAcGFyYW0ge251bWJlciB8IGZhbHNlfSBpbmRleFxuICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgZmFsc2V9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHNraXBJbmxpbmVDb21tZW50KHRleHQsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0ZXh0LmNoYXJBdChpbmRleCkgPT09IFwiL1wiICYmIHRleHQuY2hhckF0KGluZGV4ICsgMSkgPT09IFwiKlwiKSB7XG4gICAgICBmb3IgKHZhciBpID0gaW5kZXggKyAyOyBpIDwgdGV4dC5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodGV4dC5jaGFyQXQoaSkgPT09IFwiKlwiICYmIHRleHQuY2hhckF0KGkgKyAxKSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICByZXR1cm4gaSArIDI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgZmFsc2V9IGluZGV4XG4gICAqIEByZXR1cm5zIHtudW1iZXIgfCBmYWxzZX1cbiAgICovXG5cblxuICBmdW5jdGlvbiBza2lwVHJhaWxpbmdDb21tZW50KHRleHQsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0ZXh0LmNoYXJBdChpbmRleCkgPT09IFwiL1wiICYmIHRleHQuY2hhckF0KGluZGV4ICsgMSkgPT09IFwiL1wiKSB7XG4gICAgICByZXR1cm4gc2tpcEV2ZXJ5dGhpbmdCdXROZXdMaW5lKHRleHQsIGluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH0gLy8gVGhpcyBvbmUgZG9lc24ndCB1c2UgdGhlIGFib3ZlIGhlbHBlciBmdW5jdGlvbiBiZWNhdXNlIGl0IHdhbnRzIHRvXG4gIC8vIHRlc3QgXFxyXFxuIGluIG9yZGVyIGFuZCBgc2tpcGAgZG9lc24ndCBzdXBwb3J0IG9yZGVyaW5nIGFuZCB3ZSBvbmx5XG4gIC8vIHdhbnQgdG8gc2tpcCBvbmUgbmV3bGluZS4gSXQncyBzaW1wbGUgdG8gaW1wbGVtZW50LlxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKiBAcGFyYW0ge251bWJlciB8IGZhbHNlfSBpbmRleFxuICAgKiBAcGFyYW0ge1NraXBPcHRpb25zPX0gb3B0c1xuICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgZmFsc2V9XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gc2tpcE5ld2xpbmUodGV4dCwgaW5kZXgsIG9wdHMpIHtcbiAgICB2YXIgYmFja3dhcmRzID0gb3B0cyAmJiBvcHRzLmJhY2t3YXJkcztcblxuICAgIGlmIChpbmRleCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgYXRJbmRleCA9IHRleHQuY2hhckF0KGluZGV4KTtcblxuICAgIGlmIChiYWNrd2FyZHMpIHtcbiAgICAgIGlmICh0ZXh0LmNoYXJBdChpbmRleCAtIDEpID09PSBcIlxcclwiICYmIGF0SW5kZXggPT09IFwiXFxuXCIpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4IC0gMjtcbiAgICAgIH1cblxuICAgICAgaWYgKGF0SW5kZXggPT09IFwiXFxuXCIgfHwgYXRJbmRleCA9PT0gXCJcXHJcIiB8fCBhdEluZGV4ID09PSBcIlxcdTIwMjhcIiB8fCBhdEluZGV4ID09PSBcIlxcdTIwMjlcIikge1xuICAgICAgICByZXR1cm4gaW5kZXggLSAxO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXRJbmRleCA9PT0gXCJcXHJcIiAmJiB0ZXh0LmNoYXJBdChpbmRleCArIDEpID09PSBcIlxcblwiKSB7XG4gICAgICAgIHJldHVybiBpbmRleCArIDI7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdEluZGV4ID09PSBcIlxcblwiIHx8IGF0SW5kZXggPT09IFwiXFxyXCIgfHwgYXRJbmRleCA9PT0gXCJcXHUyMDI4XCIgfHwgYXRJbmRleCA9PT0gXCJcXHUyMDI5XCIpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4ICsgMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge1NraXBPcHRpb25zPX0gb3B0c1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG5cblxuICBmdW5jdGlvbiBoYXNOZXdsaW5lKHRleHQsIGluZGV4LCBvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgdmFyIGlkeCA9IHNraXBTcGFjZXModGV4dCwgb3B0cy5iYWNrd2FyZHMgPyBpbmRleCAtIDEgOiBpbmRleCwgb3B0cyk7XG4gICAgdmFyIGlkeDIgPSBza2lwTmV3bGluZSh0ZXh0LCBpZHgsIG9wdHMpO1xuICAgIHJldHVybiBpZHggIT09IGlkeDI7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGhhc05ld2xpbmVJblJhbmdlKHRleHQsIHN0YXJ0LCBlbmQpIHtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgaWYgKHRleHQuY2hhckF0KGkpID09PSBcIlxcblwiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBOb3RlOiB0aGlzIGZ1bmN0aW9uIGRvZXNuJ3QgaWdub3JlIGxlYWRpbmcgY29tbWVudHMgdW5saWtlIGlzTmV4dExpbmVFbXB0eVxuXG4gIC8qKlxuICAgKiBAdGVtcGxhdGUgTlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKiBAcGFyYW0ge059IG5vZGVcbiAgICogQHBhcmFtIHsobm9kZTogTikgPT4gbnVtYmVyfSBsb2NTdGFydFxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGlzUHJldmlvdXNMaW5lRW1wdHkodGV4dCwgbm9kZSwgbG9jU3RhcnQpIHtcbiAgICAvKiogQHR5cGUge251bWJlciB8IGZhbHNlfSAqL1xuICAgIHZhciBpZHggPSBsb2NTdGFydChub2RlKSAtIDE7XG4gICAgaWR4ID0gc2tpcFNwYWNlcyh0ZXh0LCBpZHgsIHtcbiAgICAgIGJhY2t3YXJkczogdHJ1ZVxuICAgIH0pO1xuICAgIGlkeCA9IHNraXBOZXdsaW5lKHRleHQsIGlkeCwge1xuICAgICAgYmFja3dhcmRzOiB0cnVlXG4gICAgfSk7XG4gICAgaWR4ID0gc2tpcFNwYWNlcyh0ZXh0LCBpZHgsIHtcbiAgICAgIGJhY2t3YXJkczogdHJ1ZVxuICAgIH0pO1xuICAgIHZhciBpZHgyID0gc2tpcE5ld2xpbmUodGV4dCwgaWR4LCB7XG4gICAgICBiYWNrd2FyZHM6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gaWR4ICE9PSBpZHgyO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaXNOZXh0TGluZUVtcHR5QWZ0ZXJJbmRleCh0ZXh0LCBpbmRleCkge1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyIHwgZmFsc2V9ICovXG4gICAgdmFyIG9sZElkeCA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtudW1iZXIgfCBmYWxzZX0gKi9cblxuICAgIHZhciBpZHggPSBpbmRleDtcblxuICAgIHdoaWxlIChpZHggIT09IG9sZElkeCkge1xuICAgICAgLy8gV2UgbmVlZCB0byBza2lwIGFsbCB0aGUgcG90ZW50aWFsIHRyYWlsaW5nIGlubGluZSBjb21tZW50c1xuICAgICAgb2xkSWR4ID0gaWR4O1xuICAgICAgaWR4ID0gc2tpcFRvTGluZUVuZCh0ZXh0LCBpZHgpO1xuICAgICAgaWR4ID0gc2tpcElubGluZUNvbW1lbnQodGV4dCwgaWR4KTtcbiAgICAgIGlkeCA9IHNraXBTcGFjZXModGV4dCwgaWR4KTtcbiAgICB9XG5cbiAgICBpZHggPSBza2lwVHJhaWxpbmdDb21tZW50KHRleHQsIGlkeCk7XG4gICAgaWR4ID0gc2tpcE5ld2xpbmUodGV4dCwgaWR4KTtcbiAgICByZXR1cm4gaWR4ICE9PSBmYWxzZSAmJiBoYXNOZXdsaW5lKHRleHQsIGlkeCk7XG4gIH1cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSBOXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqIEBwYXJhbSB7Tn0gbm9kZVxuICAgKiBAcGFyYW0geyhub2RlOiBOKSA9PiBudW1iZXJ9IGxvY0VuZFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG5cblxuICBmdW5jdGlvbiBpc05leHRMaW5lRW1wdHkodGV4dCwgbm9kZSwgbG9jRW5kKSB7XG4gICAgcmV0dXJuIGlzTmV4dExpbmVFbXB0eUFmdGVySW5kZXgodGV4dCwgbG9jRW5kKG5vZGUpKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgZmFsc2V9XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3RlckluZGV4V2l0aFN0YXJ0SW5kZXgodGV4dCwgaWR4KSB7XG4gICAgLyoqIEB0eXBlIHtudW1iZXIgfCBmYWxzZX0gKi9cbiAgICB2YXIgb2xkSWR4ID0gbnVsbDtcbiAgICAvKiogQHR5cGUge251bWJlciB8IGZhbHNlfSAqL1xuXG4gICAgdmFyIG5leHRJZHggPSBpZHg7XG5cbiAgICB3aGlsZSAobmV4dElkeCAhPT0gb2xkSWR4KSB7XG4gICAgICBvbGRJZHggPSBuZXh0SWR4O1xuICAgICAgbmV4dElkeCA9IHNraXBTcGFjZXModGV4dCwgbmV4dElkeCk7XG4gICAgICBuZXh0SWR4ID0gc2tpcElubGluZUNvbW1lbnQodGV4dCwgbmV4dElkeCk7XG4gICAgICBuZXh0SWR4ID0gc2tpcFRyYWlsaW5nQ29tbWVudCh0ZXh0LCBuZXh0SWR4KTtcbiAgICAgIG5leHRJZHggPSBza2lwTmV3bGluZSh0ZXh0LCBuZXh0SWR4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dElkeDtcbiAgfVxuICAvKipcbiAgICogQHRlbXBsYXRlIE5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICogQHBhcmFtIHtOfSBub2RlXG4gICAqIEBwYXJhbSB7KG5vZGU6IE4pID0+IG51bWJlcn0gbG9jRW5kXG4gICAqIEByZXR1cm5zIHtudW1iZXIgfCBmYWxzZX1cbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXROZXh0Tm9uU3BhY2VOb25Db21tZW50Q2hhcmFjdGVySW5kZXgodGV4dCwgbm9kZSwgbG9jRW5kKSB7XG4gICAgcmV0dXJuIGdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXJJbmRleFdpdGhTdGFydEluZGV4KHRleHQsIGxvY0VuZChub2RlKSk7XG4gIH1cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSBOXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqIEBwYXJhbSB7Tn0gbm9kZVxuICAgKiBAcGFyYW0geyhub2RlOiBOKSA9PiBudW1iZXJ9IGxvY0VuZFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXIodGV4dCwgbm9kZSwgbG9jRW5kKSB7XG4gICAgcmV0dXJuIHRleHQuY2hhckF0KCAvLyBAdHMtaWdub3JlID0+IFRCRDogY2FuIHJldHVybiBmYWxzZSwgc2hvdWxkIHdlIGRlZmluZSBhIGZhbGxiYWNrP1xuICAgIGdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXJJbmRleCh0ZXh0LCBub2RlLCBsb2NFbmQpKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7U2tpcE9wdGlvbnM9fSBvcHRzXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGhhc1NwYWNlcyh0ZXh0LCBpbmRleCwgb3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHZhciBpZHggPSBza2lwU3BhY2VzKHRleHQsIG9wdHMuYmFja3dhcmRzID8gaW5kZXggLSAxIDogaW5kZXgsIG9wdHMpO1xuICAgIHJldHVybiBpZHggIT09IGluZGV4O1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge3tyYW5nZT86IFtudW1iZXIsIG51bWJlcl0sIHN0YXJ0PzogbnVtYmVyfX0gbm9kZVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICovXG5cblxuICBmdW5jdGlvbiBzZXRMb2NTdGFydChub2RlLCBpbmRleCkge1xuICAgIGlmIChub2RlLnJhbmdlKSB7XG4gICAgICBub2RlLnJhbmdlWzBdID0gaW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc3RhcnQgPSBpbmRleDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7e3JhbmdlPzogW251bWJlciwgbnVtYmVyXSwgZW5kPzogbnVtYmVyfX0gbm9kZVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICovXG5cblxuICBmdW5jdGlvbiBzZXRMb2NFbmQobm9kZSwgaW5kZXgpIHtcbiAgICBpZiAobm9kZS5yYW5nZSkge1xuICAgICAgbm9kZS5yYW5nZVsxXSA9IGluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmVuZCA9IGluZGV4O1xuICAgIH1cbiAgfVxuXG4gIHZhciBQUkVDRURFTkNFID0ge307XG4gIFtbXCJ8PlwiXSwgW1wiPz9cIl0sIFtcInx8XCJdLCBbXCImJlwiXSwgW1wifFwiXSwgW1wiXlwiXSwgW1wiJlwiXSwgW1wiPT1cIiwgXCI9PT1cIiwgXCIhPVwiLCBcIiE9PVwiXSwgW1wiPFwiLCBcIj5cIiwgXCI8PVwiLCBcIj49XCIsIFwiaW5cIiwgXCJpbnN0YW5jZW9mXCJdLCBbXCI+PlwiLCBcIjw8XCIsIFwiPj4+XCJdLCBbXCIrXCIsIFwiLVwiXSwgW1wiKlwiLCBcIi9cIiwgXCIlXCJdLCBbXCIqKlwiXV0uZm9yRWFjaChmdW5jdGlvbiAodGllciwgaSkge1xuICAgIHRpZXIuZm9yRWFjaChmdW5jdGlvbiAob3ApIHtcbiAgICAgIFBSRUNFREVOQ0Vbb3BdID0gaTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gZ2V0UHJlY2VkZW5jZShvcCkge1xuICAgIHJldHVybiBQUkVDRURFTkNFW29wXTtcbiAgfVxuXG4gIHZhciBlcXVhbGl0eU9wZXJhdG9ycyA9IHtcbiAgICBcIj09XCI6IHRydWUsXG4gICAgXCIhPVwiOiB0cnVlLFxuICAgIFwiPT09XCI6IHRydWUsXG4gICAgXCIhPT1cIjogdHJ1ZVxuICB9O1xuICB2YXIgbXVsdGlwbGljYXRpdmVPcGVyYXRvcnMgPSB7XG4gICAgXCIqXCI6IHRydWUsXG4gICAgXCIvXCI6IHRydWUsXG4gICAgXCIlXCI6IHRydWVcbiAgfTtcbiAgdmFyIGJpdHNoaWZ0T3BlcmF0b3JzID0ge1xuICAgIFwiPj5cIjogdHJ1ZSxcbiAgICBcIj4+PlwiOiB0cnVlLFxuICAgIFwiPDxcIjogdHJ1ZVxuICB9O1xuXG4gIGZ1bmN0aW9uIHNob3VsZEZsYXR0ZW4ocGFyZW50T3AsIG5vZGVPcCkge1xuICAgIGlmIChnZXRQcmVjZWRlbmNlKG5vZGVPcCkgIT09IGdldFByZWNlZGVuY2UocGFyZW50T3ApKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyAqKiBpcyByaWdodC1hc3NvY2lhdGl2ZVxuICAgIC8vIHggKiogeSAqKiB6IC0tPiB4ICoqICh5ICoqIHopXG5cblxuICAgIGlmIChwYXJlbnRPcCA9PT0gXCIqKlwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyB4ID09IHkgPT0geiAtLT4gKHggPT0geSkgPT0gelxuXG5cbiAgICBpZiAoZXF1YWxpdHlPcGVyYXRvcnNbcGFyZW50T3BdICYmIGVxdWFsaXR5T3BlcmF0b3JzW25vZGVPcF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIHggKiB5ICUgeiAtLT4gKHggKiB5KSAlIHpcblxuXG4gICAgaWYgKG5vZGVPcCA9PT0gXCIlXCIgJiYgbXVsdGlwbGljYXRpdmVPcGVyYXRvcnNbcGFyZW50T3BdIHx8IHBhcmVudE9wID09PSBcIiVcIiAmJiBtdWx0aXBsaWNhdGl2ZU9wZXJhdG9yc1tub2RlT3BdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyB4ICogeSAvIHogLS0+ICh4ICogeSkgLyB6XG4gICAgLy8geCAvIHkgKiB6IC0tPiAoeCAvIHkpICogelxuXG5cbiAgICBpZiAobm9kZU9wICE9PSBwYXJlbnRPcCAmJiBtdWx0aXBsaWNhdGl2ZU9wZXJhdG9yc1tub2RlT3BdICYmIG11bHRpcGxpY2F0aXZlT3BlcmF0b3JzW3BhcmVudE9wXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8geCA8PCB5IDw8IHogLS0+ICh4IDw8IHkpIDw8IHpcblxuXG4gICAgaWYgKGJpdHNoaWZ0T3BlcmF0b3JzW3BhcmVudE9wXSAmJiBiaXRzaGlmdE9wZXJhdG9yc1tub2RlT3BdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBpc0JpdHdpc2VPcGVyYXRvcihvcGVyYXRvcikge1xuICAgIHJldHVybiAhIWJpdHNoaWZ0T3BlcmF0b3JzW29wZXJhdG9yXSB8fCBvcGVyYXRvciA9PT0gXCJ8XCIgfHwgb3BlcmF0b3IgPT09IFwiXlwiIHx8IG9wZXJhdG9yID09PSBcIiZcIjtcbiAgfSAvLyBUZXN0cyBpZiBhbiBleHByZXNzaW9uIHN0YXJ0cyB3aXRoIGB7YCwgb3IgKGlmIGZvcmJpZEZ1bmN0aW9uQ2xhc3NBbmREb0V4cHJcbiAgLy8gaG9sZHMpIGBmdW5jdGlvbmAsIGBjbGFzc2AsIG9yIGBkbyB7fWAuIFdpbGwgYmUgb3ZlcnplYWxvdXMgaWYgdGhlcmUnc1xuICAvLyBhbHJlYWR5IG5lY2Vzc2FyeSBncm91cGluZyBwYXJlbnRoZXNlcy5cblxuXG4gIGZ1bmN0aW9uIHN0YXJ0c1dpdGhOb0xvb2thaGVhZFRva2VuKG5vZGUsIGZvcmJpZEZ1bmN0aW9uQ2xhc3NBbmREb0V4cHIpIHtcbiAgICBub2RlID0gZ2V0TGVmdE1vc3Qobm9kZSk7XG5cbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIkNsYXNzRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIkRvRXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gZm9yYmlkRnVuY3Rpb25DbGFzc0FuZERvRXhwcjtcblxuICAgICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiBzdGFydHNXaXRoTm9Mb29rYWhlYWRUb2tlbihub2RlLm9iamVjdCwgZm9yYmlkRnVuY3Rpb25DbGFzc0FuZERvRXhwcik7XG5cbiAgICAgIGNhc2UgXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKG5vZGUudGFnLnR5cGUgPT09IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpIHtcbiAgICAgICAgICAvLyBJSUZFcyBhcmUgYWx3YXlzIGFscmVhZHkgcGFyZW50aGVzaXplZFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdGFydHNXaXRoTm9Mb29rYWhlYWRUb2tlbihub2RlLnRhZywgZm9yYmlkRnVuY3Rpb25DbGFzc0FuZERvRXhwcik7XG5cbiAgICAgIGNhc2UgXCJDYWxsRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKG5vZGUuY2FsbGVlLnR5cGUgPT09IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpIHtcbiAgICAgICAgICAvLyBJSUZFcyBhcmUgYWx3YXlzIGFscmVhZHkgcGFyZW50aGVzaXplZFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdGFydHNXaXRoTm9Mb29rYWhlYWRUb2tlbihub2RlLmNhbGxlZSwgZm9yYmlkRnVuY3Rpb25DbGFzc0FuZERvRXhwcik7XG5cbiAgICAgIGNhc2UgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIHN0YXJ0c1dpdGhOb0xvb2thaGVhZFRva2VuKG5vZGUudGVzdCwgZm9yYmlkRnVuY3Rpb25DbGFzc0FuZERvRXhwcik7XG5cbiAgICAgIGNhc2UgXCJVcGRhdGVFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiAhbm9kZS5wcmVmaXggJiYgc3RhcnRzV2l0aE5vTG9va2FoZWFkVG9rZW4obm9kZS5hcmd1bWVudCwgZm9yYmlkRnVuY3Rpb25DbGFzc0FuZERvRXhwcik7XG5cbiAgICAgIGNhc2UgXCJCaW5kRXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gbm9kZS5vYmplY3QgJiYgc3RhcnRzV2l0aE5vTG9va2FoZWFkVG9rZW4obm9kZS5vYmplY3QsIGZvcmJpZEZ1bmN0aW9uQ2xhc3NBbmREb0V4cHIpO1xuXG4gICAgICBjYXNlIFwiU2VxdWVuY2VFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiBzdGFydHNXaXRoTm9Mb29rYWhlYWRUb2tlbihub2RlLmV4cHJlc3Npb25zWzBdLCBmb3JiaWRGdW5jdGlvbkNsYXNzQW5kRG9FeHByKTtcblxuICAgICAgY2FzZSBcIlRTQXNFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiBzdGFydHNXaXRoTm9Mb29rYWhlYWRUb2tlbihub2RlLmV4cHJlc3Npb24sIGZvcmJpZEZ1bmN0aW9uQ2xhc3NBbmREb0V4cHIpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TGVmdE1vc3Qobm9kZSkge1xuICAgIGlmIChub2RlLmxlZnQpIHtcbiAgICAgIHJldHVybiBnZXRMZWZ0TW9zdChub2RlLmxlZnQpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRhYldpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gc3RhcnRJbmRleFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldEFsaWdubWVudFNpemUodmFsdWUsIHRhYldpZHRoLCBzdGFydEluZGV4KSB7XG4gICAgc3RhcnRJbmRleCA9IHN0YXJ0SW5kZXggfHwgMDtcbiAgICB2YXIgc2l6ZSA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAodmFsdWVbaV0gPT09IFwiXFx0XCIpIHtcbiAgICAgICAgLy8gVGFicyBiZWhhdmUgaW4gYSB3YXkgdGhhdCB0aGV5IGFyZSBhbGlnbmVkIHRvIHRoZSBuZWFyZXN0XG4gICAgICAgIC8vIG11bHRpcGxlIG9mIHRhYldpZHRoOlxuICAgICAgICAvLyAwIC0+IDQsIDEgLT4gNCwgMiAtPiA0LCAzIC0+IDRcbiAgICAgICAgLy8gNCAtPiA4LCA1IC0+IDgsIDYgLT4gOCwgNyAtPiA4IC4uLlxuICAgICAgICBzaXplID0gc2l6ZSArIHRhYldpZHRoIC0gc2l6ZSAlIHRhYldpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2l6ZSsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzaXplO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRhYldpZHRoXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0SW5kZW50U2l6ZSh2YWx1ZSwgdGFiV2lkdGgpIHtcbiAgICB2YXIgbGFzdE5ld2xpbmVJbmRleCA9IHZhbHVlLmxhc3RJbmRleE9mKFwiXFxuXCIpO1xuXG4gICAgaWYgKGxhc3ROZXdsaW5lSW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0QWxpZ25tZW50U2l6ZSggLy8gQWxsIHRoZSBsZWFkaW5nIHdoaXRlc3BhY2VzXG4gICAgdmFsdWUuc2xpY2UobGFzdE5ld2xpbmVJbmRleCArIDEpLm1hdGNoKC9eWyBcXHRdKi8pWzBdLCB0YWJXaWR0aCk7XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHsnXCInIHwgXCInXCJ9IFF1b3RlXG4gICAqL1xuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmF3XG4gICAqIEBwYXJhbSB7UXVvdGV9IHByZWZlcnJlZFF1b3RlXG4gICAqIEByZXR1cm5zIHtRdW90ZX1cbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRQcmVmZXJyZWRRdW90ZShyYXcsIHByZWZlcnJlZFF1b3RlKSB7XG4gICAgLy8gYHJhd0NvbnRlbnRgIGlzIHRoZSBzdHJpbmcgZXhhY3RseSBsaWtlIGl0IGFwcGVhcmVkIGluIHRoZSBpbnB1dCBzb3VyY2VcbiAgICAvLyBjb2RlLCB3aXRob3V0IGl0cyBlbmNsb3NpbmcgcXVvdGVzLlxuICAgIHZhciByYXdDb250ZW50ID0gcmF3LnNsaWNlKDEsIC0xKTtcbiAgICAvKiogQHR5cGUge3sgcXVvdGU6ICdcIicsIHJlZ2V4OiBSZWdFeHAgfX0gKi9cblxuICAgIHZhciBkb3VibGUgPSB7XG4gICAgICBxdW90ZTogJ1wiJyxcbiAgICAgIHJlZ2V4OiAvXCIvZ1xuICAgIH07XG4gICAgLyoqIEB0eXBlIHt7IHF1b3RlOiBcIidcIiwgcmVnZXg6IFJlZ0V4cCB9fSAqL1xuXG4gICAgdmFyIHNpbmdsZSA9IHtcbiAgICAgIHF1b3RlOiBcIidcIixcbiAgICAgIHJlZ2V4OiAvJy9nXG4gICAgfTtcbiAgICB2YXIgcHJlZmVycmVkID0gcHJlZmVycmVkUXVvdGUgPT09IFwiJ1wiID8gc2luZ2xlIDogZG91YmxlO1xuICAgIHZhciBhbHRlcm5hdGUgPSBwcmVmZXJyZWQgPT09IHNpbmdsZSA/IGRvdWJsZSA6IHNpbmdsZTtcbiAgICB2YXIgcmVzdWx0ID0gcHJlZmVycmVkLnF1b3RlOyAvLyBJZiBgcmF3Q29udGVudGAgY29udGFpbnMgYXQgbGVhc3Qgb25lIG9mIHRoZSBxdW90ZSBwcmVmZXJyZWQgZm9yIGVuY2xvc2luZ1xuICAgIC8vIHRoZSBzdHJpbmcsIHdlIG1pZ2h0IHdhbnQgdG8gZW5jbG9zZSB3aXRoIHRoZSBhbHRlcm5hdGUgcXVvdGUgaW5zdGVhZCwgdG9cbiAgICAvLyBtaW5pbWl6ZSB0aGUgbnVtYmVyIG9mIGVzY2FwZWQgcXVvdGVzLlxuXG4gICAgaWYgKHJhd0NvbnRlbnQuaW5jbHVkZXMocHJlZmVycmVkLnF1b3RlKSB8fCByYXdDb250ZW50LmluY2x1ZGVzKGFsdGVybmF0ZS5xdW90ZSkpIHtcbiAgICAgIHZhciBudW1QcmVmZXJyZWRRdW90ZXMgPSAocmF3Q29udGVudC5tYXRjaChwcmVmZXJyZWQucmVnZXgpIHx8IFtdKS5sZW5ndGg7XG4gICAgICB2YXIgbnVtQWx0ZXJuYXRlUXVvdGVzID0gKHJhd0NvbnRlbnQubWF0Y2goYWx0ZXJuYXRlLnJlZ2V4KSB8fCBbXSkubGVuZ3RoO1xuICAgICAgcmVzdWx0ID0gbnVtUHJlZmVycmVkUXVvdGVzID4gbnVtQWx0ZXJuYXRlUXVvdGVzID8gYWx0ZXJuYXRlLnF1b3RlIDogcHJlZmVycmVkLnF1b3RlO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludFN0cmluZyhyYXcsIG9wdGlvbnMsIGlzRGlyZWN0aXZlTGl0ZXJhbCkge1xuICAgIC8vIGByYXdDb250ZW50YCBpcyB0aGUgc3RyaW5nIGV4YWN0bHkgbGlrZSBpdCBhcHBlYXJlZCBpbiB0aGUgaW5wdXQgc291cmNlXG4gICAgLy8gY29kZSwgd2l0aG91dCBpdHMgZW5jbG9zaW5nIHF1b3Rlcy5cbiAgICB2YXIgcmF3Q29udGVudCA9IHJhdy5zbGljZSgxLCAtMSk7IC8vIENoZWNrIGZvciB0aGUgYWx0ZXJuYXRlIHF1b3RlLCB0byBkZXRlcm1pbmUgaWYgd2UncmUgYWxsb3dlZCB0byBzd2FwXG4gICAgLy8gdGhlIHF1b3RlcyBvbiBhIERpcmVjdGl2ZUxpdGVyYWwuXG5cbiAgICB2YXIgY2FuQ2hhbmdlRGlyZWN0aXZlUXVvdGVzID0gIXJhd0NvbnRlbnQuaW5jbHVkZXMoJ1wiJykgJiYgIXJhd0NvbnRlbnQuaW5jbHVkZXMoXCInXCIpO1xuICAgIC8qKiBAdHlwZSB7UXVvdGV9ICovXG5cbiAgICB2YXIgZW5jbG9zaW5nUXVvdGUgPSBvcHRpb25zLnBhcnNlciA9PT0gXCJqc29uXCIgPyAnXCInIDogb3B0aW9ucy5fX2lzSW5IdG1sQXR0cmlidXRlID8gXCInXCIgOiBnZXRQcmVmZXJyZWRRdW90ZShyYXcsIG9wdGlvbnMuc2luZ2xlUXVvdGUgPyBcIidcIiA6ICdcIicpOyAvLyBEaXJlY3RpdmVzIGFyZSBleGFjdCBjb2RlIHVuaXQgc2VxdWVuY2VzLCB3aGljaCBtZWFucyB0aGF0IHlvdSBjYW4ndFxuICAgIC8vIGNoYW5nZSB0aGUgZXNjYXBlIHNlcXVlbmNlcyB0aGV5IHVzZS5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ByZXR0aWVyL3ByZXR0aWVyL2lzc3Vlcy8xNTU1XG4gICAgLy8gYW5kIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jZGlyZWN0aXZlLXByb2xvZ3VlXG5cbiAgICBpZiAoaXNEaXJlY3RpdmVMaXRlcmFsKSB7XG4gICAgICBpZiAoY2FuQ2hhbmdlRGlyZWN0aXZlUXVvdGVzKSB7XG4gICAgICAgIHJldHVybiBlbmNsb3NpbmdRdW90ZSArIHJhd0NvbnRlbnQgKyBlbmNsb3NpbmdRdW90ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJhdztcbiAgICB9IC8vIEl0IG1pZ2h0IHNvdW5kIHVubmVjZXNzYXJ5IHRvIHVzZSBgbWFrZVN0cmluZ2AgZXZlbiBpZiB0aGUgc3RyaW5nIGFscmVhZHlcbiAgICAvLyBpcyBlbmNsb3NlZCB3aXRoIGBlbmNsb3NpbmdRdW90ZWAsIGJ1dCBpdCBpc24ndC4gVGhlIHN0cmluZyBjb3VsZCBjb250YWluXG4gICAgLy8gdW5uZWNlc3NhcnkgZXNjYXBlcyAoc3VjaCBhcyBpbiBgXCJcXCdcImApLiBBbHdheXMgdXNpbmcgYG1ha2VTdHJpbmdgIG1ha2VzXG4gICAgLy8gc3VyZSB0aGF0IHdlIGNvbnNpc3RlbnRseSBvdXRwdXQgdGhlIG1pbmltdW0gYW1vdW50IG9mIGVzY2FwZWQgcXVvdGVzLlxuXG5cbiAgICByZXR1cm4gbWFrZVN0cmluZyhyYXdDb250ZW50LCBlbmNsb3NpbmdRdW90ZSwgIShvcHRpb25zLnBhcnNlciA9PT0gXCJjc3NcIiB8fCBvcHRpb25zLnBhcnNlciA9PT0gXCJsZXNzXCIgfHwgb3B0aW9ucy5wYXJzZXIgPT09IFwic2Nzc1wiIHx8IG9wdGlvbnMuZW1iZWRkZWRJbkh0bWwpKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJhd0NvbnRlbnRcbiAgICogQHBhcmFtIHtRdW90ZX0gZW5jbG9zaW5nUXVvdGVcbiAgICogQHBhcmFtIHtib29sZWFuPX0gdW5lc2NhcGVVbm5lY2Vzc2FyeUVzY2FwZXNcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG5cblxuICBmdW5jdGlvbiBtYWtlU3RyaW5nKHJhd0NvbnRlbnQsIGVuY2xvc2luZ1F1b3RlLCB1bmVzY2FwZVVubmVjZXNzYXJ5RXNjYXBlcykge1xuICAgIHZhciBvdGhlclF1b3RlID0gZW5jbG9zaW5nUXVvdGUgPT09ICdcIicgPyBcIidcIiA6ICdcIic7IC8vIE1hdGNoZXMgX2FueV8gZXNjYXBlIGFuZCB1bmVzY2FwZWQgcXVvdGVzIChib3RoIHNpbmdsZSBhbmQgZG91YmxlKS5cblxuICAgIHZhciByZWdleCA9IC9cXFxcKFtcXHNcXFNdKXwoWydcIl0pL2c7IC8vIEVzY2FwZSBhbmQgdW5lc2NhcGUgc2luZ2xlIGFuZCBkb3VibGUgcXVvdGVzIGFzIG5lZWRlZCB0byBiZSBhYmxlIHRvXG4gICAgLy8gZW5jbG9zZSBgcmF3Q29udGVudGAgd2l0aCBgZW5jbG9zaW5nUXVvdGVgLlxuXG4gICAgdmFyIG5ld0NvbnRlbnQgPSByYXdDb250ZW50LnJlcGxhY2UocmVnZXgsIGZ1bmN0aW9uIChtYXRjaCwgZXNjYXBlZCwgcXVvdGUpIHtcbiAgICAgIC8vIElmIHdlIG1hdGNoZWQgYW4gZXNjYXBlLCBhbmQgdGhlIGVzY2FwZWQgY2hhcmFjdGVyIGlzIGEgcXVvdGUgb2YgdGhlXG4gICAgICAvLyBvdGhlciB0eXBlIHRoYW4gd2UgaW50ZW5kIHRvIGVuY2xvc2UgdGhlIHN0cmluZyB3aXRoLCB0aGVyZSdzIG5vIG5lZWQgZm9yXG4gICAgICAvLyBpdCB0byBiZSBlc2NhcGVkLCBzbyByZXR1cm4gaXQgX3dpdGhvdXRfIHRoZSBiYWNrc2xhc2guXG4gICAgICBpZiAoZXNjYXBlZCA9PT0gb3RoZXJRdW90ZSkge1xuICAgICAgICByZXR1cm4gZXNjYXBlZDtcbiAgICAgIH0gLy8gSWYgd2UgbWF0Y2hlZCBhbiB1bmVzY2FwZWQgcXVvdGUgYW5kIGl0IGlzIG9mIHRoZSBfc2FtZV8gdHlwZSBhcyB3ZVxuICAgICAgLy8gaW50ZW5kIHRvIGVuY2xvc2UgdGhlIHN0cmluZyB3aXRoLCBpdCBtdXN0IGJlIGVzY2FwZWQsIHNvIHJldHVybiBpdCB3aXRoXG4gICAgICAvLyBhIGJhY2tzbGFzaC5cblxuXG4gICAgICBpZiAocXVvdGUgPT09IGVuY2xvc2luZ1F1b3RlKSB7XG4gICAgICAgIHJldHVybiBcIlxcXFxcIiArIHF1b3RlO1xuICAgICAgfVxuXG4gICAgICBpZiAocXVvdGUpIHtcbiAgICAgICAgcmV0dXJuIHF1b3RlO1xuICAgICAgfSAvLyBVbmVzY2FwZSBhbnkgdW5uZWNlc3NhcmlseSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgIC8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9ibG9iL2RlMGI0YWQ3YmQ4MjBhZGU0MWIxZjYwNjAwOGJlYTY4NjgzZGMxMWEvbGliL3J1bGVzL25vLXVzZWxlc3MtZXNjYXBlLmpzI0wyN1xuXG5cbiAgICAgIHJldHVybiB1bmVzY2FwZVVubmVjZXNzYXJ5RXNjYXBlcyAmJiAvXlteXFxcXG5ydnRiZnV4XFxyXFxuXFx1MjAyOFxcdTIwMjlcIicwLTddJC8udGVzdChlc2NhcGVkKSA/IGVzY2FwZWQgOiBcIlxcXFxcIiArIGVzY2FwZWQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVuY2xvc2luZ1F1b3RlICsgbmV3Q29udGVudCArIGVuY2xvc2luZ1F1b3RlO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnROdW1iZXIocmF3TnVtYmVyKSB7XG4gICAgcmV0dXJuIHJhd051bWJlci50b0xvd2VyQ2FzZSgpIC8vIFJlbW92ZSB1bm5lY2Vzc2FyeSBwbHVzIGFuZCB6ZXJvZXMgZnJvbSBzY2llbnRpZmljIG5vdGF0aW9uLlxuICAgIC5yZXBsYWNlKC9eKFsrLV0/W1xcZC5dK2UpKD86XFwrfCgtKSk/MCooXFxkKS8sIFwiJDEkMiQzXCIpIC8vIFJlbW92ZSB1bm5lY2Vzc2FyeSBzY2llbnRpZmljIG5vdGF0aW9uICgxZTApLlxuICAgIC5yZXBsYWNlKC9eKFsrLV0/W1xcZC5dKyllWystXT8wKyQvLCBcIiQxXCIpIC8vIE1ha2Ugc3VyZSBudW1iZXJzIGFsd2F5cyBzdGFydCB3aXRoIGEgZGlnaXQuXG4gICAgLnJlcGxhY2UoL14oWystXSk/XFwuLywgXCIkMTAuXCIpIC8vIFJlbW92ZSBleHRyYW5lb3VzIHRyYWlsaW5nIGRlY2ltYWwgemVyb2VzLlxuICAgIC5yZXBsYWNlKC8oXFwuXFxkKz8pMCsoPz1lfCQpLywgXCIkMVwiKSAvLyBSZW1vdmUgdHJhaWxpbmcgZG90LlxuICAgIC5yZXBsYWNlKC9cXC4oPz1lfCQpLywgXCJcIik7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldE1heENvbnRpbnVvdXNDb3VudChzdHIsIHRhcmdldCkge1xuICAgIHZhciByZXN1bHRzID0gc3RyLm1hdGNoKG5ldyBSZWdFeHAoXCIoXCIuY29uY2F0KGVzY2FwZVN0cmluZ1JlZ2V4cCh0YXJnZXQpLCBcIikrXCIpLCBcImdcIikpO1xuXG4gICAgaWYgKHJlc3VsdHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzLnJlZHVjZShmdW5jdGlvbiAobWF4Q291bnQsIHJlc3VsdCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KG1heENvdW50LCByZXN1bHQubGVuZ3RoIC8gdGFyZ2V0Lmxlbmd0aCk7XG4gICAgfSwgMCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRNaW5Ob3RQcmVzZW50Q29udGludW91c0NvdW50KHN0ciwgdGFyZ2V0KSB7XG4gICAgdmFyIG1hdGNoZXMgPSBzdHIubWF0Y2gobmV3IFJlZ0V4cChcIihcIi5jb25jYXQoZXNjYXBlU3RyaW5nUmVnZXhwKHRhcmdldCksIFwiKStcIiksIFwiZ1wiKSk7XG5cbiAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIGNvdW50UHJlc2VudCA9IG5ldyBNYXAoKTtcbiAgICB2YXIgbWF4ID0gMDtcbiAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IG1hdGNoZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICB2YXIgY291bnQgPSBtYXRjaC5sZW5ndGggLyB0YXJnZXQubGVuZ3RoO1xuICAgICAgICBjb3VudFByZXNlbnQuc2V0KGNvdW50LCB0cnVlKTtcblxuICAgICAgICBpZiAoY291bnQgPiBtYXgpIHtcbiAgICAgICAgICBtYXggPSBjb3VudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBtYXg7IGkrKykge1xuICAgICAgaWYgKCFjb3VudFByZXNlbnQuZ2V0KGkpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXggKyAxO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFN0cmluZ1dpZHRoKHRleHQpIHtcbiAgICBpZiAoIXRleHQpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gLy8gc2hvcnRjdXQgdG8gYXZvaWQgbmVlZGxlc3Mgc3RyaW5nIGBSZWdFeHBgcywgcmVwbGFjZW1lbnRzLCBhbmQgYWxsb2NhdGlvbnMgd2l0aGluIGBzdHJpbmctd2lkdGhgXG5cblxuICAgIGlmICghbm90QXNjaWlSZWdleC50ZXN0KHRleHQpKSB7XG4gICAgICByZXR1cm4gdGV4dC5sZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZ1dpZHRoXzEodGV4dCk7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNJZ25vcmVDb21tZW50KHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICByZXR1cm4gaGFzTm9kZUlnbm9yZUNvbW1lbnQobm9kZSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNOb2RlSWdub3JlQ29tbWVudChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5jb21tZW50cyAmJiBub2RlLmNvbW1lbnRzLmxlbmd0aCA+IDAgJiYgbm9kZS5jb21tZW50cy5zb21lKGZ1bmN0aW9uIChjb21tZW50KSB7XG4gICAgICByZXR1cm4gY29tbWVudC52YWx1ZS50cmltKCkgPT09IFwicHJldHRpZXItaWdub3JlXCI7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaEFuY2VzdG9yVHlwZXMocGF0aCwgdHlwZXMsIGluZGV4KSB7XG4gICAgaW5kZXggPSBpbmRleCB8fCAwO1xuICAgIHR5cGVzID0gdHlwZXMuc2xpY2UoKTtcblxuICAgIHdoaWxlICh0eXBlcy5sZW5ndGgpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBwYXRoLmdldFBhcmVudE5vZGUoaW5kZXgpO1xuICAgICAgdmFyIHR5cGUgPSB0eXBlcy5zaGlmdCgpO1xuXG4gICAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQudHlwZSAhPT0gdHlwZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGluZGV4Kys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRDb21tZW50SGVscGVyKG5vZGUsIGNvbW1lbnQpIHtcbiAgICB2YXIgY29tbWVudHMgPSBub2RlLmNvbW1lbnRzIHx8IChub2RlLmNvbW1lbnRzID0gW10pO1xuICAgIGNvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgY29tbWVudC5wcmludGVkID0gZmFsc2U7IC8vIEZvciBzb21lIHJlYXNvbiwgVHlwZVNjcmlwdCBwYXJzZXMgYC8vIHhgIGluc2lkZSBvZiBKU1hUZXh0IGFzIGEgY29tbWVudFxuICAgIC8vIFdlIGFscmVhZHkgXCJwcmludFwiIGl0IHZpYSB0aGUgcmF3IHRleHQsIHdlIGRvbid0IG5lZWQgdG8gcmUtcHJpbnQgaXQgYXMgYVxuICAgIC8vIGNvbW1lbnRcblxuICAgIGlmIChub2RlLnR5cGUgPT09IFwiSlNYVGV4dFwiKSB7XG4gICAgICBjb21tZW50LnByaW50ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZExlYWRpbmdDb21tZW50KG5vZGUsIGNvbW1lbnQpIHtcbiAgICBjb21tZW50LmxlYWRpbmcgPSB0cnVlO1xuICAgIGNvbW1lbnQudHJhaWxpbmcgPSBmYWxzZTtcbiAgICBhZGRDb21tZW50SGVscGVyKG5vZGUsIGNvbW1lbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkRGFuZ2xpbmdDb21tZW50KG5vZGUsIGNvbW1lbnQpIHtcbiAgICBjb21tZW50LmxlYWRpbmcgPSBmYWxzZTtcbiAgICBjb21tZW50LnRyYWlsaW5nID0gZmFsc2U7XG4gICAgYWRkQ29tbWVudEhlbHBlcihub2RlLCBjb21tZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFRyYWlsaW5nQ29tbWVudChub2RlLCBjb21tZW50KSB7XG4gICAgY29tbWVudC5sZWFkaW5nID0gZmFsc2U7XG4gICAgY29tbWVudC50cmFpbGluZyA9IHRydWU7XG4gICAgYWRkQ29tbWVudEhlbHBlcihub2RlLCBjb21tZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzV2l0aGluUGFyZW50QXJyYXlQcm9wZXJ0eShwYXRoLCBwcm9wZXJ0eU5hbWUpIHtcbiAgICB2YXIgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICB2YXIgcGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG5cbiAgICBpZiAocGFyZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFyZW50W3Byb3BlcnR5TmFtZV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGtleSA9IHBhdGguZ2V0TmFtZSgpO1xuICAgIHJldHVybiBwYXJlbnRbcHJvcGVydHlOYW1lXVtrZXldID09PSBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZUVuZE9mTGluZVdpdGgodGV4dCwgcmVwbGFjZW1lbnQpIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSB0ZXh0LnNwbGl0KFwiXFxuXCIpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHJlcGxhY2VtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnRzO1xuICB9XG5cbiAgdmFyIHV0aWwgPSB7XG4gICAgcmVwbGFjZUVuZE9mTGluZVdpdGg6IHJlcGxhY2VFbmRPZkxpbmVXaXRoLFxuICAgIGdldFN0cmluZ1dpZHRoOiBnZXRTdHJpbmdXaWR0aCxcbiAgICBnZXRNYXhDb250aW51b3VzQ291bnQ6IGdldE1heENvbnRpbnVvdXNDb3VudCxcbiAgICBnZXRNaW5Ob3RQcmVzZW50Q29udGludW91c0NvdW50OiBnZXRNaW5Ob3RQcmVzZW50Q29udGludW91c0NvdW50LFxuICAgIGdldFByZWNlZGVuY2U6IGdldFByZWNlZGVuY2UsXG4gICAgc2hvdWxkRmxhdHRlbjogc2hvdWxkRmxhdHRlbixcbiAgICBpc0JpdHdpc2VPcGVyYXRvcjogaXNCaXR3aXNlT3BlcmF0b3IsXG4gICAgaXNFeHBvcnREZWNsYXJhdGlvbjogaXNFeHBvcnREZWNsYXJhdGlvbixcbiAgICBnZXRQYXJlbnRFeHBvcnREZWNsYXJhdGlvbjogZ2V0UGFyZW50RXhwb3J0RGVjbGFyYXRpb24sXG4gICAgZ2V0UGVudWx0aW1hdGU6IGdldFBlbnVsdGltYXRlLFxuICAgIGdldExhc3Q6IGdldExhc3QsXG4gICAgZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3RlckluZGV4V2l0aFN0YXJ0SW5kZXg6IGdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXJJbmRleFdpdGhTdGFydEluZGV4LFxuICAgIGdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXJJbmRleDogZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3RlckluZGV4LFxuICAgIGdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXI6IGdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXIsXG4gICAgc2tpcDogc2tpcCxcbiAgICBza2lwV2hpdGVzcGFjZTogc2tpcFdoaXRlc3BhY2UsXG4gICAgc2tpcFNwYWNlczogc2tpcFNwYWNlcyxcbiAgICBza2lwVG9MaW5lRW5kOiBza2lwVG9MaW5lRW5kLFxuICAgIHNraXBFdmVyeXRoaW5nQnV0TmV3TGluZTogc2tpcEV2ZXJ5dGhpbmdCdXROZXdMaW5lLFxuICAgIHNraXBJbmxpbmVDb21tZW50OiBza2lwSW5saW5lQ29tbWVudCxcbiAgICBza2lwVHJhaWxpbmdDb21tZW50OiBza2lwVHJhaWxpbmdDb21tZW50LFxuICAgIHNraXBOZXdsaW5lOiBza2lwTmV3bGluZSxcbiAgICBpc05leHRMaW5lRW1wdHlBZnRlckluZGV4OiBpc05leHRMaW5lRW1wdHlBZnRlckluZGV4LFxuICAgIGlzTmV4dExpbmVFbXB0eTogaXNOZXh0TGluZUVtcHR5LFxuICAgIGlzUHJldmlvdXNMaW5lRW1wdHk6IGlzUHJldmlvdXNMaW5lRW1wdHksXG4gICAgaGFzTmV3bGluZTogaGFzTmV3bGluZSxcbiAgICBoYXNOZXdsaW5lSW5SYW5nZTogaGFzTmV3bGluZUluUmFuZ2UsXG4gICAgaGFzU3BhY2VzOiBoYXNTcGFjZXMsXG4gICAgc2V0TG9jU3RhcnQ6IHNldExvY1N0YXJ0LFxuICAgIHNldExvY0VuZDogc2V0TG9jRW5kLFxuICAgIHN0YXJ0c1dpdGhOb0xvb2thaGVhZFRva2VuOiBzdGFydHNXaXRoTm9Mb29rYWhlYWRUb2tlbixcbiAgICBnZXRBbGlnbm1lbnRTaXplOiBnZXRBbGlnbm1lbnRTaXplLFxuICAgIGdldEluZGVudFNpemU6IGdldEluZGVudFNpemUsXG4gICAgZ2V0UHJlZmVycmVkUXVvdGU6IGdldFByZWZlcnJlZFF1b3RlLFxuICAgIHByaW50U3RyaW5nOiBwcmludFN0cmluZyxcbiAgICBwcmludE51bWJlcjogcHJpbnROdW1iZXIsXG4gICAgaGFzSWdub3JlQ29tbWVudDogaGFzSWdub3JlQ29tbWVudCxcbiAgICBoYXNOb2RlSWdub3JlQ29tbWVudDogaGFzTm9kZUlnbm9yZUNvbW1lbnQsXG4gICAgbWFrZVN0cmluZzogbWFrZVN0cmluZyxcbiAgICBtYXRjaEFuY2VzdG9yVHlwZXM6IG1hdGNoQW5jZXN0b3JUeXBlcyxcbiAgICBhZGRMZWFkaW5nQ29tbWVudDogYWRkTGVhZGluZ0NvbW1lbnQsXG4gICAgYWRkRGFuZ2xpbmdDb21tZW50OiBhZGREYW5nbGluZ0NvbW1lbnQsXG4gICAgYWRkVHJhaWxpbmdDb21tZW50OiBhZGRUcmFpbGluZ0NvbW1lbnQsXG4gICAgaXNXaXRoaW5QYXJlbnRBcnJheVByb3BlcnR5OiBpc1dpdGhpblBhcmVudEFycmF5UHJvcGVydHlcbiAgfTtcblxuICBmdW5jdGlvbiBndWVzc0VuZE9mTGluZSh0ZXh0KSB7XG4gICAgdmFyIGluZGV4ID0gdGV4dC5pbmRleE9mKFwiXFxyXCIpO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHJldHVybiB0ZXh0LmNoYXJBdChpbmRleCArIDEpID09PSBcIlxcblwiID8gXCJjcmxmXCIgOiBcImNyXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwibGZcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnZlcnRFbmRPZkxpbmVUb0NoYXJzKHZhbHVlKSB7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgY2FzZSBcImNyXCI6XG4gICAgICAgIHJldHVybiBcIlxcclwiO1xuXG4gICAgICBjYXNlIFwiY3JsZlwiOlxuICAgICAgICByZXR1cm4gXCJcXHJcXG5cIjtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFwiXFxuXCI7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVuZE9mTGluZSA9IHtcbiAgICBndWVzc0VuZE9mTGluZTogZ3Vlc3NFbmRPZkxpbmUsXG4gICAgY29udmVydEVuZE9mTGluZVRvQ2hhcnM6IGNvbnZlcnRFbmRPZkxpbmVUb0NoYXJzXG4gIH07XG5cbiAgdmFyIGdldFN0cmluZ1dpZHRoJDEgPSB1dGlsLmdldFN0cmluZ1dpZHRoO1xuICB2YXIgY29udmVydEVuZE9mTGluZVRvQ2hhcnMkMSA9IGVuZE9mTGluZS5jb252ZXJ0RW5kT2ZMaW5lVG9DaGFycztcbiAgdmFyIGNvbmNhdCQxID0gZG9jQnVpbGRlcnMuY29uY2F0LFxuICAgICAgZmlsbCQxID0gZG9jQnVpbGRlcnMuZmlsbCxcbiAgICAgIGN1cnNvciQxID0gZG9jQnVpbGRlcnMuY3Vyc29yO1xuICAvKiogQHR5cGUge1JlY29yZDxzeW1ib2wsIHR5cGVvZiBNT0RFX0JSRUFLIHwgdHlwZW9mIE1PREVfRkxBVD59ICovXG5cbiAgdmFyIGdyb3VwTW9kZU1hcDtcbiAgdmFyIE1PREVfQlJFQUsgPSAxO1xuICB2YXIgTU9ERV9GTEFUID0gMjtcblxuICBmdW5jdGlvbiByb290SW5kZW50KCkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogXCJcIixcbiAgICAgIGxlbmd0aDogMCxcbiAgICAgIHF1ZXVlOiBbXVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlSW5kZW50KGluZCwgb3B0aW9ucykge1xuICAgIHJldHVybiBnZW5lcmF0ZUluZChpbmQsIHtcbiAgICAgIHR5cGU6IFwiaW5kZW50XCJcbiAgICB9LCBvcHRpb25zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VBbGlnbihpbmQsIG4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbiA9PT0gLUluZmluaXR5ID8gaW5kLnJvb3QgfHwgcm9vdEluZGVudCgpIDogbiA8IDAgPyBnZW5lcmF0ZUluZChpbmQsIHtcbiAgICAgIHR5cGU6IFwiZGVkZW50XCJcbiAgICB9LCBvcHRpb25zKSA6ICFuID8gaW5kIDogbi50eXBlID09PSBcInJvb3RcIiA/IE9iamVjdC5hc3NpZ24oe30sIGluZCwge1xuICAgICAgcm9vdDogaW5kXG4gICAgfSkgOiB0eXBlb2YgbiA9PT0gXCJzdHJpbmdcIiA/IGdlbmVyYXRlSW5kKGluZCwge1xuICAgICAgdHlwZTogXCJzdHJpbmdBbGlnblwiLFxuICAgICAgbjogblxuICAgIH0sIG9wdGlvbnMpIDogZ2VuZXJhdGVJbmQoaW5kLCB7XG4gICAgICB0eXBlOiBcIm51bWJlckFsaWduXCIsXG4gICAgICBuOiBuXG4gICAgfSwgb3B0aW9ucyk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUluZChpbmQsIG5ld1BhcnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgcXVldWUgPSBuZXdQYXJ0LnR5cGUgPT09IFwiZGVkZW50XCIgPyBpbmQucXVldWUuc2xpY2UoMCwgLTEpIDogaW5kLnF1ZXVlLmNvbmNhdChuZXdQYXJ0KTtcbiAgICB2YXIgdmFsdWUgPSBcIlwiO1xuICAgIHZhciBsZW5ndGggPSAwO1xuICAgIHZhciBsYXN0VGFicyA9IDA7XG4gICAgdmFyIGxhc3RTcGFjZXMgPSAwO1xuICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gcXVldWVbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiaW5kZW50XCI6XG4gICAgICAgICAgICBmbHVzaCgpO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy51c2VUYWJzKSB7XG4gICAgICAgICAgICAgIGFkZFRhYnMoMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhZGRTcGFjZXMob3B0aW9ucy50YWJXaWR0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcInN0cmluZ0FsaWduXCI6XG4gICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgdmFsdWUgKz0gcGFydC5uO1xuICAgICAgICAgICAgbGVuZ3RoICs9IHBhcnQubi5sZW5ndGg7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJudW1iZXJBbGlnblwiOlxuICAgICAgICAgICAgbGFzdFRhYnMgKz0gMTtcbiAgICAgICAgICAgIGxhc3RTcGFjZXMgKz0gcGFydC5uO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgdHlwZSAnXCIuY29uY2F0KHBhcnQudHlwZSwgXCInXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmx1c2hTcGFjZXMoKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgaW5kLCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBsZW5ndGg6IGxlbmd0aCxcbiAgICAgIHF1ZXVlOiBxdWV1ZVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gYWRkVGFicyhjb3VudCkge1xuICAgICAgdmFsdWUgKz0gXCJcXHRcIi5yZXBlYXQoY291bnQpO1xuICAgICAgbGVuZ3RoICs9IG9wdGlvbnMudGFiV2lkdGggKiBjb3VudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRTcGFjZXMoY291bnQpIHtcbiAgICAgIHZhbHVlICs9IFwiIFwiLnJlcGVhdChjb3VudCk7XG4gICAgICBsZW5ndGggKz0gY291bnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICBpZiAob3B0aW9ucy51c2VUYWJzKSB7XG4gICAgICAgIGZsdXNoVGFicygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmx1c2hTcGFjZXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmbHVzaFRhYnMoKSB7XG4gICAgICBpZiAobGFzdFRhYnMgPiAwKSB7XG4gICAgICAgIGFkZFRhYnMobGFzdFRhYnMpO1xuICAgICAgfVxuXG4gICAgICByZXNldExhc3QoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmbHVzaFNwYWNlcygpIHtcbiAgICAgIGlmIChsYXN0U3BhY2VzID4gMCkge1xuICAgICAgICBhZGRTcGFjZXMobGFzdFNwYWNlcyk7XG4gICAgICB9XG5cbiAgICAgIHJlc2V0TGFzdCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2V0TGFzdCgpIHtcbiAgICAgIGxhc3RUYWJzID0gMDtcbiAgICAgIGxhc3RTcGFjZXMgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyaW0kMShvdXQpIHtcbiAgICBpZiAob3V0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIHRyaW1Db3VudCA9IDA7IC8vIFRyaW0gd2hpdGVzcGFjZSBhdCB0aGUgZW5kIG9mIGxpbmVcblxuICAgIHdoaWxlIChvdXQubGVuZ3RoID4gMCAmJiB0eXBlb2Ygb3V0W291dC5sZW5ndGggLSAxXSA9PT0gXCJzdHJpbmdcIiAmJiBvdXRbb3V0Lmxlbmd0aCAtIDFdLm1hdGNoKC9eWyBcXHRdKiQvKSkge1xuICAgICAgdHJpbUNvdW50ICs9IG91dC5wb3AoKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKG91dC5sZW5ndGggJiYgdHlwZW9mIG91dFtvdXQubGVuZ3RoIC0gMV0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHZhciB0cmltbWVkID0gb3V0W291dC5sZW5ndGggLSAxXS5yZXBsYWNlKC9bIFxcdF0qJC8sIFwiXCIpO1xuICAgICAgdHJpbUNvdW50ICs9IG91dFtvdXQubGVuZ3RoIC0gMV0ubGVuZ3RoIC0gdHJpbW1lZC5sZW5ndGg7XG4gICAgICBvdXRbb3V0Lmxlbmd0aCAtIDFdID0gdHJpbW1lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJpbUNvdW50O1xuICB9XG5cbiAgZnVuY3Rpb24gZml0cyhuZXh0LCByZXN0Q29tbWFuZHMsIHdpZHRoLCBvcHRpb25zLCBtdXN0QmVGbGF0KSB7XG4gICAgdmFyIHJlc3RJZHggPSByZXN0Q29tbWFuZHMubGVuZ3RoO1xuICAgIHZhciBjbWRzID0gW25leHRdOyAvLyBgb3V0YCBpcyBvbmx5IHVzZWQgZm9yIHdpZHRoIGNvdW50aW5nIGJlY2F1c2UgYHRyaW1gIHJlcXVpcmVzIHRvIGxvb2tcbiAgICAvLyBiYWNrd2FyZHMgZm9yIHNwYWNlIGNoYXJhY3RlcnMuXG5cbiAgICB2YXIgb3V0ID0gW107XG5cbiAgICB3aGlsZSAod2lkdGggPj0gMCkge1xuICAgICAgaWYgKGNtZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmIChyZXN0SWR4ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBjbWRzLnB1c2gocmVzdENvbW1hbmRzW3Jlc3RJZHggLSAxXSk7XG4gICAgICAgIHJlc3RJZHgtLTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciB4ID0gY21kcy5wb3AoKTtcbiAgICAgIHZhciBpbmQgPSB4WzBdO1xuICAgICAgdmFyIG1vZGUgPSB4WzFdO1xuICAgICAgdmFyIGRvYyA9IHhbMl07XG5cbiAgICAgIGlmICh0eXBlb2YgZG9jID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG91dC5wdXNoKGRvYyk7XG4gICAgICAgIHdpZHRoIC09IGdldFN0cmluZ1dpZHRoJDEoZG9jKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAoZG9jLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiY29uY2F0XCI6XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZG9jLnBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgIGNtZHMucHVzaChbaW5kLCBtb2RlLCBkb2MucGFydHNbaV1dKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiaW5kZW50XCI6XG4gICAgICAgICAgICBjbWRzLnB1c2goW21ha2VJbmRlbnQoaW5kLCBvcHRpb25zKSwgbW9kZSwgZG9jLmNvbnRlbnRzXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJhbGlnblwiOlxuICAgICAgICAgICAgY21kcy5wdXNoKFttYWtlQWxpZ24oaW5kLCBkb2Mubiwgb3B0aW9ucyksIG1vZGUsIGRvYy5jb250ZW50c10pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwidHJpbVwiOlxuICAgICAgICAgICAgd2lkdGggKz0gdHJpbSQxKG91dCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJncm91cFwiOlxuICAgICAgICAgICAgaWYgKG11c3RCZUZsYXQgJiYgZG9jLmJyZWFrKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY21kcy5wdXNoKFtpbmQsIGRvYy5icmVhayA/IE1PREVfQlJFQUsgOiBtb2RlLCBkb2MuY29udGVudHNdKTtcblxuICAgICAgICAgICAgaWYgKGRvYy5pZCkge1xuICAgICAgICAgICAgICBncm91cE1vZGVNYXBbZG9jLmlkXSA9IGNtZHNbY21kcy5sZW5ndGggLSAxXVsxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiZmlsbFwiOlxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSBkb2MucGFydHMubGVuZ3RoIC0gMTsgX2kgPj0gMDsgX2ktLSkge1xuICAgICAgICAgICAgICBjbWRzLnB1c2goW2luZCwgbW9kZSwgZG9jLnBhcnRzW19pXV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJpZi1icmVha1wiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgZ3JvdXBNb2RlID0gZG9jLmdyb3VwSWQgPyBncm91cE1vZGVNYXBbZG9jLmdyb3VwSWRdIDogbW9kZTtcblxuICAgICAgICAgICAgICBpZiAoZ3JvdXBNb2RlID09PSBNT0RFX0JSRUFLKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvYy5icmVha0NvbnRlbnRzKSB7XG4gICAgICAgICAgICAgICAgICBjbWRzLnB1c2goW2luZCwgbW9kZSwgZG9jLmJyZWFrQ29udGVudHNdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZ3JvdXBNb2RlID09PSBNT0RFX0ZMQVQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9jLmZsYXRDb250ZW50cykge1xuICAgICAgICAgICAgICAgICAgY21kcy5wdXNoKFtpbmQsIG1vZGUsIGRvYy5mbGF0Q29udGVudHNdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgXCJsaW5lXCI6XG4gICAgICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgICAgY2FzZSBNT0RFX0ZMQVQ6XG4gICAgICAgICAgICAgICAgaWYgKCFkb2MuaGFyZCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFkb2Muc29mdCkge1xuICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChcIiBcIik7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoIC09IDE7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICAgIGNhc2UgTU9ERV9CUkVBSzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludERvY1RvU3RyaW5nKGRvYywgb3B0aW9ucykge1xuICAgIGdyb3VwTW9kZU1hcCA9IHt9O1xuICAgIHZhciB3aWR0aCA9IG9wdGlvbnMucHJpbnRXaWR0aDtcbiAgICB2YXIgbmV3TGluZSA9IGNvbnZlcnRFbmRPZkxpbmVUb0NoYXJzJDEob3B0aW9ucy5lbmRPZkxpbmUpO1xuICAgIHZhciBwb3MgPSAwOyAvLyBjbWRzIGlzIGJhc2ljYWxseSBhIHN0YWNrLiBXZSd2ZSB0dXJuZWQgYSByZWN1cnNpdmUgY2FsbCBpbnRvIGFcbiAgICAvLyB3aGlsZSBsb29wIHdoaWNoIGlzIG11Y2ggZmFzdGVyLiBUaGUgd2hpbGUgbG9vcCBiZWxvdyBhZGRzIG5ld1xuICAgIC8vIGNtZHMgdG8gdGhlIGFycmF5IGluc3RlYWQgb2YgcmVjdXJzaXZlbHkgY2FsbGluZyBgcHJpbnRgLlxuXG4gICAgdmFyIGNtZHMgPSBbW3Jvb3RJbmRlbnQoKSwgTU9ERV9CUkVBSywgZG9jXV07XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIHZhciBzaG91bGRSZW1lYXN1cmUgPSBmYWxzZTtcbiAgICB2YXIgbGluZVN1ZmZpeCA9IFtdO1xuXG4gICAgd2hpbGUgKGNtZHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgeCA9IGNtZHMucG9wKCk7XG4gICAgICB2YXIgaW5kID0geFswXTtcbiAgICAgIHZhciBtb2RlID0geFsxXTtcbiAgICAgIHZhciBfZG9jID0geFsyXTtcblxuICAgICAgaWYgKHR5cGVvZiBfZG9jID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG91dC5wdXNoKF9kb2MpO1xuICAgICAgICBwb3MgKz0gZ2V0U3RyaW5nV2lkdGgkMShfZG9jKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAoX2RvYy50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcImN1cnNvclwiOlxuICAgICAgICAgICAgb3V0LnB1c2goY3Vyc29yJDEucGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiY29uY2F0XCI6XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gX2RvYy5wYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICBjbWRzLnB1c2goW2luZCwgbW9kZSwgX2RvYy5wYXJ0c1tpXV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJpbmRlbnRcIjpcbiAgICAgICAgICAgIGNtZHMucHVzaChbbWFrZUluZGVudChpbmQsIG9wdGlvbnMpLCBtb2RlLCBfZG9jLmNvbnRlbnRzXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJhbGlnblwiOlxuICAgICAgICAgICAgY21kcy5wdXNoKFttYWtlQWxpZ24oaW5kLCBfZG9jLm4sIG9wdGlvbnMpLCBtb2RlLCBfZG9jLmNvbnRlbnRzXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJ0cmltXCI6XG4gICAgICAgICAgICBwb3MgLT0gdHJpbSQxKG91dCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJncm91cFwiOlxuICAgICAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgTU9ERV9GTEFUOlxuICAgICAgICAgICAgICAgIGlmICghc2hvdWxkUmVtZWFzdXJlKSB7XG4gICAgICAgICAgICAgICAgICBjbWRzLnB1c2goW2luZCwgX2RvYy5icmVhayA/IE1PREVfQlJFQUsgOiBNT0RFX0ZMQVQsIF9kb2MuY29udGVudHNdKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBmYWxsdGhyb3VnaFxuXG4gICAgICAgICAgICAgIGNhc2UgTU9ERV9CUkVBSzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBzaG91bGRSZW1lYXN1cmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gW2luZCwgTU9ERV9GTEFULCBfZG9jLmNvbnRlbnRzXTtcbiAgICAgICAgICAgICAgICAgIHZhciByZW0gPSB3aWR0aCAtIHBvcztcblxuICAgICAgICAgICAgICAgICAgaWYgKCFfZG9jLmJyZWFrICYmIGZpdHMobmV4dCwgY21kcywgcmVtLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICBjbWRzLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBFeHBhbmRlZCBzdGF0ZXMgYXJlIGEgcmFyZSBjYXNlIHdoZXJlIGEgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FuIG1hbnVhbGx5IHByb3ZpZGUgbXVsdGlwbGUgcmVwcmVzZW50YXRpb25zIG9mXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0c2VsZi4gSXQgcHJvdmlkZXMgYW4gYXJyYXkgb2YgZG9jdW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIC8vIGdvaW5nIGZyb20gdGhlIGxlYXN0IGV4cGFuZGVkIChtb3N0IGZsYXR0ZW5lZClcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVwcmVzZW50YXRpb24gZmlyc3QgdG8gdGhlIG1vc3QgZXhwYW5kZWQuIElmIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gZ3JvdXAgaGFzIHRoZXNlLCB3ZSBuZWVkIHRvIG1hbnVhbGx5IGdvIHRocm91Z2hcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlc2Ugc3RhdGVzIGFuZCBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBmaXRzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoX2RvYy5leHBhbmRlZFN0YXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBtb3N0RXhwYW5kZWQgPSBfZG9jLmV4cGFuZGVkU3RhdGVzW19kb2MuZXhwYW5kZWRTdGF0ZXMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoX2RvYy5icmVhaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kcy5wdXNoKFtpbmQsIE1PREVfQlJFQUssIG1vc3RFeHBhbmRlZF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IDE7IF9pMiA8IF9kb2MuZXhwYW5kZWRTdGF0ZXMubGVuZ3RoICsgMTsgX2kyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pMiA+PSBfZG9jLmV4cGFuZGVkU3RhdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtZHMucHVzaChbaW5kLCBNT0RFX0JSRUFLLCBtb3N0RXhwYW5kZWRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBfZG9jLmV4cGFuZGVkU3RhdGVzW19pMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNtZCA9IFtpbmQsIE1PREVfRkxBVCwgc3RhdGVdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpdHMoY21kLCBjbWRzLCByZW0sIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbWRzLnB1c2goY21kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBjbWRzLnB1c2goW2luZCwgTU9ERV9CUkVBSywgX2RvYy5jb250ZW50c10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKF9kb2MuaWQpIHtcbiAgICAgICAgICAgICAgZ3JvdXBNb2RlTWFwW19kb2MuaWRdID0gY21kc1tjbWRzLmxlbmd0aCAtIDFdWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBGaWxscyBlYWNoIGxpbmUgd2l0aCBhcyBtdWNoIGNvZGUgYXMgcG9zc2libGUgYmVmb3JlIG1vdmluZyB0byBhIG5ld1xuICAgICAgICAgIC8vIGxpbmUgd2l0aCB0aGUgc2FtZSBpbmRlbnRhdGlvbi5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIEV4cGVjdHMgZG9jLnBhcnRzIHRvIGJlIGFuIGFycmF5IG9mIGFsdGVybmF0aW5nIGNvbnRlbnQgYW5kXG4gICAgICAgICAgLy8gd2hpdGVzcGFjZS4gVGhlIHdoaXRlc3BhY2UgY29udGFpbnMgdGhlIGxpbmVicmVha3MuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBGb3IgZXhhbXBsZTpcbiAgICAgICAgICAvLyAgIFtcIklcIiwgbGluZSwgXCJsb3ZlXCIsIGxpbmUsIFwibW9ua2V5c1wiXVxuICAgICAgICAgIC8vIG9yXG4gICAgICAgICAgLy8gICBbeyB0eXBlOiBncm91cCwgLi4uIH0sIHNvZnRsaW5lLCB7IHR5cGU6IGdyb3VwLCAuLi4gfV1cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIEl0IHVzZXMgdGhpcyBwYXJ0cyBzdHJ1Y3R1cmUgdG8gaGFuZGxlIHRocmVlIG1haW4gbGF5b3V0IGNhc2VzOlxuICAgICAgICAgIC8vICogVGhlIGZpcnN0IHR3byBjb250ZW50IGl0ZW1zIGZpdCBvbiB0aGUgc2FtZSBsaW5lIHdpdGhvdXRcbiAgICAgICAgICAvLyAgIGJyZWFraW5nXG4gICAgICAgICAgLy8gICAtPiBvdXRwdXQgdGhlIGZpcnN0IGNvbnRlbnQgaXRlbSBhbmQgdGhlIHdoaXRlc3BhY2UgXCJmbGF0XCIuXG4gICAgICAgICAgLy8gKiBPbmx5IHRoZSBmaXJzdCBjb250ZW50IGl0ZW0gZml0cyBvbiB0aGUgbGluZSB3aXRob3V0IGJyZWFraW5nXG4gICAgICAgICAgLy8gICAtPiBvdXRwdXQgdGhlIGZpcnN0IGNvbnRlbnQgaXRlbSBcImZsYXRcIiBhbmQgdGhlIHdoaXRlc3BhY2Ugd2l0aFxuICAgICAgICAgIC8vICAgXCJicmVha1wiLlxuICAgICAgICAgIC8vICogTmVpdGhlciBjb250ZW50IGl0ZW0gZml0cyBvbiB0aGUgbGluZSB3aXRob3V0IGJyZWFraW5nXG4gICAgICAgICAgLy8gICAtPiBvdXRwdXQgdGhlIGZpcnN0IGNvbnRlbnQgaXRlbSBhbmQgdGhlIHdoaXRlc3BhY2Ugd2l0aCBcImJyZWFrXCIuXG5cbiAgICAgICAgICBjYXNlIFwiZmlsbFwiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgX3JlbSA9IHdpZHRoIC0gcG9zO1xuXG4gICAgICAgICAgICAgIHZhciBwYXJ0cyA9IF9kb2MucGFydHM7XG5cbiAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBwYXJ0c1swXTtcbiAgICAgICAgICAgICAgdmFyIGNvbnRlbnRGbGF0Q21kID0gW2luZCwgTU9ERV9GTEFULCBjb250ZW50XTtcbiAgICAgICAgICAgICAgdmFyIGNvbnRlbnRCcmVha0NtZCA9IFtpbmQsIE1PREVfQlJFQUssIGNvbnRlbnRdO1xuICAgICAgICAgICAgICB2YXIgY29udGVudEZpdHMgPSBmaXRzKGNvbnRlbnRGbGF0Q21kLCBbXSwgX3JlbSwgb3B0aW9ucywgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50Rml0cykge1xuICAgICAgICAgICAgICAgICAgY21kcy5wdXNoKGNvbnRlbnRGbGF0Q21kKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY21kcy5wdXNoKGNvbnRlbnRCcmVha0NtZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgd2hpdGVzcGFjZSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgICB2YXIgd2hpdGVzcGFjZUZsYXRDbWQgPSBbaW5kLCBNT0RFX0ZMQVQsIHdoaXRlc3BhY2VdO1xuICAgICAgICAgICAgICB2YXIgd2hpdGVzcGFjZUJyZWFrQ21kID0gW2luZCwgTU9ERV9CUkVBSywgd2hpdGVzcGFjZV07XG5cbiAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50Rml0cykge1xuICAgICAgICAgICAgICAgICAgY21kcy5wdXNoKHdoaXRlc3BhY2VGbGF0Q21kKTtcbiAgICAgICAgICAgICAgICAgIGNtZHMucHVzaChjb250ZW50RmxhdENtZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNtZHMucHVzaCh3aGl0ZXNwYWNlQnJlYWtDbWQpO1xuICAgICAgICAgICAgICAgICAgY21kcy5wdXNoKGNvbnRlbnRCcmVha0NtZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH0gLy8gQXQgdGhpcyBwb2ludCB3ZSd2ZSBoYW5kbGVkIHRoZSBmaXJzdCBwYWlyIChjb250ZXh0LCBzZXBhcmF0b3IpXG4gICAgICAgICAgICAgIC8vIGFuZCB3aWxsIGNyZWF0ZSBhIG5ldyBmaWxsIGRvYyBmb3IgdGhlIHJlc3Qgb2YgdGhlIGNvbnRlbnQuXG4gICAgICAgICAgICAgIC8vIElkZWFsbHkgd2Ugd291bGRuJ3QgbXV0YXRlIHRoZSBhcnJheSBoZXJlIGJ1dCBjb3BpbmcgYWxsIHRoZVxuICAgICAgICAgICAgICAvLyBlbGVtZW50cyB0byBhIG5ldyBhcnJheSB3b3VsZCBtYWtlIHRoaXMgYWxnb3JpdGhtIHF1YWRyYXRpYyxcbiAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgdW51c2FibGUgZm9yIGxhcmdlIGFycmF5cyAoZS5nLiBsYXJnZSB0ZXh0cyBpbiBKU1gpLlxuXG5cbiAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKDAsIDIpO1xuICAgICAgICAgICAgICB2YXIgcmVtYWluaW5nQ21kID0gW2luZCwgbW9kZSwgZmlsbCQxKHBhcnRzKV07XG4gICAgICAgICAgICAgIHZhciBzZWNvbmRDb250ZW50ID0gcGFydHNbMF07XG4gICAgICAgICAgICAgIHZhciBmaXJzdEFuZFNlY29uZENvbnRlbnRGbGF0Q21kID0gW2luZCwgTU9ERV9GTEFULCBjb25jYXQkMShbY29udGVudCwgd2hpdGVzcGFjZSwgc2Vjb25kQ29udGVudF0pXTtcbiAgICAgICAgICAgICAgdmFyIGZpcnN0QW5kU2Vjb25kQ29udGVudEZpdHMgPSBmaXRzKGZpcnN0QW5kU2Vjb25kQ29udGVudEZsYXRDbWQsIFtdLCBfcmVtLCBvcHRpb25zLCB0cnVlKTtcblxuICAgICAgICAgICAgICBpZiAoZmlyc3RBbmRTZWNvbmRDb250ZW50Rml0cykge1xuICAgICAgICAgICAgICAgIGNtZHMucHVzaChyZW1haW5pbmdDbWQpO1xuICAgICAgICAgICAgICAgIGNtZHMucHVzaCh3aGl0ZXNwYWNlRmxhdENtZCk7XG4gICAgICAgICAgICAgICAgY21kcy5wdXNoKGNvbnRlbnRGbGF0Q21kKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb250ZW50Rml0cykge1xuICAgICAgICAgICAgICAgIGNtZHMucHVzaChyZW1haW5pbmdDbWQpO1xuICAgICAgICAgICAgICAgIGNtZHMucHVzaCh3aGl0ZXNwYWNlQnJlYWtDbWQpO1xuICAgICAgICAgICAgICAgIGNtZHMucHVzaChjb250ZW50RmxhdENtZCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY21kcy5wdXNoKHJlbWFpbmluZ0NtZCk7XG4gICAgICAgICAgICAgICAgY21kcy5wdXNoKHdoaXRlc3BhY2VCcmVha0NtZCk7XG4gICAgICAgICAgICAgICAgY21kcy5wdXNoKGNvbnRlbnRCcmVha0NtZCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgXCJpZi1icmVha1wiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgZ3JvdXBNb2RlID0gX2RvYy5ncm91cElkID8gZ3JvdXBNb2RlTWFwW19kb2MuZ3JvdXBJZF0gOiBtb2RlO1xuXG4gICAgICAgICAgICAgIGlmIChncm91cE1vZGUgPT09IE1PREVfQlJFQUspIHtcbiAgICAgICAgICAgICAgICBpZiAoX2RvYy5icmVha0NvbnRlbnRzKSB7XG4gICAgICAgICAgICAgICAgICBjbWRzLnB1c2goW2luZCwgbW9kZSwgX2RvYy5icmVha0NvbnRlbnRzXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGdyb3VwTW9kZSA9PT0gTU9ERV9GTEFUKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9kb2MuZmxhdENvbnRlbnRzKSB7XG4gICAgICAgICAgICAgICAgICBjbWRzLnB1c2goW2luZCwgbW9kZSwgX2RvYy5mbGF0Q29udGVudHNdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgXCJsaW5lLXN1ZmZpeFwiOlxuICAgICAgICAgICAgbGluZVN1ZmZpeC5wdXNoKFtpbmQsIG1vZGUsIF9kb2MuY29udGVudHNdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImxpbmUtc3VmZml4LWJvdW5kYXJ5XCI6XG4gICAgICAgICAgICBpZiAobGluZVN1ZmZpeC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNtZHMucHVzaChbaW5kLCBtb2RlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJsaW5lXCIsXG4gICAgICAgICAgICAgICAgaGFyZDogdHJ1ZVxuICAgICAgICAgICAgICB9XSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImxpbmVcIjpcbiAgICAgICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgICBjYXNlIE1PREVfRkxBVDpcbiAgICAgICAgICAgICAgICBpZiAoIV9kb2MuaGFyZCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFfZG9jLnNvZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goXCIgXCIpO1xuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbGluZSB3YXMgZm9yY2VkIGludG8gdGhlIG91dHB1dCBldmVuIGlmIHdlXG4gICAgICAgICAgICAgICAgICAvLyB3ZXJlIGluIGZsYXR0ZW5lZCBtb2RlLCBzbyB3ZSBuZWVkIHRvIHRlbGwgdGhlIG5leHRcbiAgICAgICAgICAgICAgICAgIC8vIGdyb3VwIHRoYXQgbm8gbWF0dGVyIHdoYXQsIGl0IG5lZWRzIHRvIHJlbWVhc3VyZVxuICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGUgcHJldmlvdXMgbWVhc3VyZW1lbnQgZGlkbid0IGFjY3VyYXRlbHlcbiAgICAgICAgICAgICAgICAgIC8vIGNhcHR1cmUgdGhlIGVudGlyZSBleHByZXNzaW9uICh0aGlzIGlzIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgICAgLy8gZm9yIG5lc3RlZCBncm91cHMpXG4gICAgICAgICAgICAgICAgICBzaG91bGRSZW1lYXN1cmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBmYWxsdGhyb3VnaFxuXG4gICAgICAgICAgICAgIGNhc2UgTU9ERV9CUkVBSzpcbiAgICAgICAgICAgICAgICBpZiAobGluZVN1ZmZpeC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIGNtZHMucHVzaChbaW5kLCBtb2RlLCBfZG9jXSk7XG4gICAgICAgICAgICAgICAgICBbXS5wdXNoLmFwcGx5KGNtZHMsIGxpbmVTdWZmaXgucmV2ZXJzZSgpKTtcbiAgICAgICAgICAgICAgICAgIGxpbmVTdWZmaXggPSBbXTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfZG9jLmxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpbmQucm9vdCkge1xuICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChuZXdMaW5lLCBpbmQucm9vdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGluZC5yb290Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKG5ld0xpbmUpO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwb3MgLT0gdHJpbSQxKG91dCk7XG4gICAgICAgICAgICAgICAgICBvdXQucHVzaChuZXdMaW5lICsgaW5kLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIHBvcyA9IGluZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGN1cnNvclBsYWNlaG9sZGVySW5kZXggPSBvdXQuaW5kZXhPZihjdXJzb3IkMS5wbGFjZWhvbGRlcik7XG5cbiAgICBpZiAoY3Vyc29yUGxhY2Vob2xkZXJJbmRleCAhPT0gLTEpIHtcbiAgICAgIHZhciBvdGhlckN1cnNvclBsYWNlaG9sZGVySW5kZXggPSBvdXQuaW5kZXhPZihjdXJzb3IkMS5wbGFjZWhvbGRlciwgY3Vyc29yUGxhY2Vob2xkZXJJbmRleCArIDEpO1xuICAgICAgdmFyIGJlZm9yZUN1cnNvciA9IG91dC5zbGljZSgwLCBjdXJzb3JQbGFjZWhvbGRlckluZGV4KS5qb2luKFwiXCIpO1xuICAgICAgdmFyIGFyb3VuZEN1cnNvciA9IG91dC5zbGljZShjdXJzb3JQbGFjZWhvbGRlckluZGV4ICsgMSwgb3RoZXJDdXJzb3JQbGFjZWhvbGRlckluZGV4KS5qb2luKFwiXCIpO1xuICAgICAgdmFyIGFmdGVyQ3Vyc29yID0gb3V0LnNsaWNlKG90aGVyQ3Vyc29yUGxhY2Vob2xkZXJJbmRleCArIDEpLmpvaW4oXCJcIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmb3JtYXR0ZWQ6IGJlZm9yZUN1cnNvciArIGFyb3VuZEN1cnNvciArIGFmdGVyQ3Vyc29yLFxuICAgICAgICBjdXJzb3JOb2RlU3RhcnQ6IGJlZm9yZUN1cnNvci5sZW5ndGgsXG4gICAgICAgIGN1cnNvck5vZGVUZXh0OiBhcm91bmRDdXJzb3JcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1hdHRlZDogb3V0LmpvaW4oXCJcIilcbiAgICB9O1xuICB9XG5cbiAgdmFyIGRvY1ByaW50ZXIgPSB7XG4gICAgcHJpbnREb2NUb1N0cmluZzogcHJpbnREb2NUb1N0cmluZ1xuICB9O1xuXG4gIHZhciB0cmF2ZXJzZURvY09uRXhpdFN0YWNrTWFya2VyID0ge307XG5cbiAgZnVuY3Rpb24gdHJhdmVyc2VEb2MoZG9jLCBvbkVudGVyLCBvbkV4aXQsIHNob3VsZFRyYXZlcnNlQ29uZGl0aW9uYWxHcm91cHMpIHtcbiAgICB2YXIgZG9jc1N0YWNrID0gW2RvY107XG5cbiAgICB3aGlsZSAoZG9jc1N0YWNrLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdmFyIF9kb2MgPSBkb2NzU3RhY2sucG9wKCk7XG5cbiAgICAgIGlmIChfZG9jID09PSB0cmF2ZXJzZURvY09uRXhpdFN0YWNrTWFya2VyKSB7XG4gICAgICAgIG9uRXhpdChkb2NzU3RhY2sucG9wKCkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNob3VsZFJlY3Vyc2UgPSB0cnVlO1xuXG4gICAgICBpZiAob25FbnRlcikge1xuICAgICAgICBpZiAob25FbnRlcihfZG9jKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBzaG91bGRSZWN1cnNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9uRXhpdCkge1xuICAgICAgICBkb2NzU3RhY2sucHVzaChfZG9jKTtcbiAgICAgICAgZG9jc1N0YWNrLnB1c2godHJhdmVyc2VEb2NPbkV4aXRTdGFja01hcmtlcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRSZWN1cnNlKSB7XG4gICAgICAgIC8vIFdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIHBhcnRzIHRvIHByb2Nlc3MsXG4gICAgICAgIC8vIHRoZSBwYXJ0cyBuZWVkIHRvIGJlIHB1c2hlZCBvbnRvIHRoZSBzdGFjayBpbiByZXZlcnNlIG9yZGVyLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZXkgYXJlIHByb2Nlc3NlZCBpbiB0aGUgb3JpZ2luYWwgb3JkZXJcbiAgICAgICAgLy8gd2hlbiB0aGUgc3RhY2sgaXMgcG9wcGVkLlxuICAgICAgICBpZiAoX2RvYy50eXBlID09PSBcImNvbmNhdFwiIHx8IF9kb2MudHlwZSA9PT0gXCJmaWxsXCIpIHtcbiAgICAgICAgICBmb3IgKHZhciBpYyA9IF9kb2MucGFydHMubGVuZ3RoLCBpID0gaWMgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgZG9jc1N0YWNrLnB1c2goX2RvYy5wYXJ0c1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKF9kb2MudHlwZSA9PT0gXCJpZi1icmVha1wiKSB7XG4gICAgICAgICAgaWYgKF9kb2MuZmxhdENvbnRlbnRzKSB7XG4gICAgICAgICAgICBkb2NzU3RhY2sucHVzaChfZG9jLmZsYXRDb250ZW50cyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF9kb2MuYnJlYWtDb250ZW50cykge1xuICAgICAgICAgICAgZG9jc1N0YWNrLnB1c2goX2RvYy5icmVha0NvbnRlbnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoX2RvYy50eXBlID09PSBcImdyb3VwXCIgJiYgX2RvYy5leHBhbmRlZFN0YXRlcykge1xuICAgICAgICAgIGlmIChzaG91bGRUcmF2ZXJzZUNvbmRpdGlvbmFsR3JvdXBzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaWMgPSBfZG9jLmV4cGFuZGVkU3RhdGVzLmxlbmd0aCwgX2kgPSBfaWMgLSAxOyBfaSA+PSAwOyAtLV9pKSB7XG4gICAgICAgICAgICAgIGRvY3NTdGFjay5wdXNoKF9kb2MuZXhwYW5kZWRTdGF0ZXNbX2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9jc1N0YWNrLnB1c2goX2RvYy5jb250ZW50cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKF9kb2MuY29udGVudHMpIHtcbiAgICAgICAgICBkb2NzU3RhY2sucHVzaChfZG9jLmNvbnRlbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcERvYyhkb2MsIGNiKSB7XG4gICAgaWYgKGRvYy50eXBlID09PSBcImNvbmNhdFwiIHx8IGRvYy50eXBlID09PSBcImZpbGxcIikge1xuICAgICAgdmFyIHBhcnRzID0gZG9jLnBhcnRzLm1hcChmdW5jdGlvbiAocGFydCkge1xuICAgICAgICByZXR1cm4gbWFwRG9jKHBhcnQsIGNiKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNiKE9iamVjdC5hc3NpZ24oe30sIGRvYywge1xuICAgICAgICBwYXJ0czogcGFydHNcbiAgICAgIH0pKTtcbiAgICB9IGVsc2UgaWYgKGRvYy50eXBlID09PSBcImlmLWJyZWFrXCIpIHtcbiAgICAgIHZhciBicmVha0NvbnRlbnRzID0gZG9jLmJyZWFrQ29udGVudHMgJiYgbWFwRG9jKGRvYy5icmVha0NvbnRlbnRzLCBjYik7XG4gICAgICB2YXIgZmxhdENvbnRlbnRzID0gZG9jLmZsYXRDb250ZW50cyAmJiBtYXBEb2MoZG9jLmZsYXRDb250ZW50cywgY2IpO1xuICAgICAgcmV0dXJuIGNiKE9iamVjdC5hc3NpZ24oe30sIGRvYywge1xuICAgICAgICBicmVha0NvbnRlbnRzOiBicmVha0NvbnRlbnRzLFxuICAgICAgICBmbGF0Q29udGVudHM6IGZsYXRDb250ZW50c1xuICAgICAgfSkpO1xuICAgIH0gZWxzZSBpZiAoZG9jLmNvbnRlbnRzKSB7XG4gICAgICB2YXIgY29udGVudHMgPSBtYXBEb2MoZG9jLmNvbnRlbnRzLCBjYik7XG4gICAgICByZXR1cm4gY2IoT2JqZWN0LmFzc2lnbih7fSwgZG9jLCB7XG4gICAgICAgIGNvbnRlbnRzOiBjb250ZW50c1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBjYihkb2MpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEluRG9jKGRvYywgZm4sIGRlZmF1bHRWYWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBkZWZhdWx0VmFsdWU7XG4gICAgdmFyIGhhc1N0b3BwZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGZpbmRJbkRvY09uRW50ZXJGbihkb2MpIHtcbiAgICAgIHZhciBtYXliZVJlc3VsdCA9IGZuKGRvYyk7XG5cbiAgICAgIGlmIChtYXliZVJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGhhc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICByZXN1bHQgPSBtYXliZVJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc1N0b3BwZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyYXZlcnNlRG9jKGRvYywgZmluZEluRG9jT25FbnRlckZuKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNFbXB0eShuKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBuID09PSBcInN0cmluZ1wiICYmIG4ubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNMaW5lTmV4dEZuKGRvYykge1xuICAgIGlmICh0eXBlb2YgZG9jID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGRvYy50eXBlID09PSBcImxpbmVcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNMaW5lTmV4dChkb2MpIHtcbiAgICByZXR1cm4gZmluZEluRG9jKGRvYywgaXNMaW5lTmV4dEZuLCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiB3aWxsQnJlYWtGbihkb2MpIHtcbiAgICBpZiAoZG9jLnR5cGUgPT09IFwiZ3JvdXBcIiAmJiBkb2MuYnJlYWspIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChkb2MudHlwZSA9PT0gXCJsaW5lXCIgJiYgZG9jLmhhcmQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChkb2MudHlwZSA9PT0gXCJicmVhay1wYXJlbnRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gd2lsbEJyZWFrKGRvYykge1xuICAgIHJldHVybiBmaW5kSW5Eb2MoZG9jLCB3aWxsQnJlYWtGbiwgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gYnJlYWtQYXJlbnRHcm91cChncm91cFN0YWNrKSB7XG4gICAgaWYgKGdyb3VwU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHBhcmVudEdyb3VwID0gZ3JvdXBTdGFja1tncm91cFN0YWNrLmxlbmd0aCAtIDFdOyAvLyBCcmVha3MgYXJlIG5vdCBwcm9wYWdhdGVkIHRocm91Z2ggY29uZGl0aW9uYWwgZ3JvdXBzIGJlY2F1c2VcbiAgICAgIC8vIHRoZSB1c2VyIGlzIGV4cGVjdGVkIHRvIG1hbnVhbGx5IGhhbmRsZSB3aGF0IGJyZWFrcy5cblxuICAgICAgaWYgKCFwYXJlbnRHcm91cC5leHBhbmRlZFN0YXRlcykge1xuICAgICAgICBwYXJlbnRHcm91cC5icmVhayA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9wYWdhdGVCcmVha3MoZG9jKSB7XG4gICAgdmFyIGFscmVhZHlWaXNpdGVkU2V0ID0gbmV3IFNldCgpO1xuICAgIHZhciBncm91cFN0YWNrID0gW107XG5cbiAgICBmdW5jdGlvbiBwcm9wYWdhdGVCcmVha3NPbkVudGVyRm4oZG9jKSB7XG4gICAgICBpZiAoZG9jLnR5cGUgPT09IFwiYnJlYWstcGFyZW50XCIpIHtcbiAgICAgICAgYnJlYWtQYXJlbnRHcm91cChncm91cFN0YWNrKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRvYy50eXBlID09PSBcImdyb3VwXCIpIHtcbiAgICAgICAgZ3JvdXBTdGFjay5wdXNoKGRvYyk7XG5cbiAgICAgICAgaWYgKGFscmVhZHlWaXNpdGVkU2V0Lmhhcyhkb2MpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgYWxyZWFkeVZpc2l0ZWRTZXQuYWRkKGRvYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvcGFnYXRlQnJlYWtzT25FeGl0Rm4oZG9jKSB7XG4gICAgICBpZiAoZG9jLnR5cGUgPT09IFwiZ3JvdXBcIikge1xuICAgICAgICB2YXIgZ3JvdXAgPSBncm91cFN0YWNrLnBvcCgpO1xuXG4gICAgICAgIGlmIChncm91cC5icmVhaykge1xuICAgICAgICAgIGJyZWFrUGFyZW50R3JvdXAoZ3JvdXBTdGFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cmF2ZXJzZURvYyhkb2MsIHByb3BhZ2F0ZUJyZWFrc09uRW50ZXJGbiwgcHJvcGFnYXRlQnJlYWtzT25FeGl0Rm4sXG4gICAgLyogc2hvdWxkVHJhdmVyc2VDb25kaXRpb25hbEdyb3VwcyAqL1xuICAgIHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTGluZXNGbihkb2MpIHtcbiAgICAvLyBGb3JjZSB0aGlzIGRvYyBpbnRvIGZsYXQgbW9kZSBieSBzdGF0aWNhbGx5IGNvbnZlcnRpbmcgYWxsXG4gICAgLy8gbGluZXMgaW50byBzcGFjZXMgKG9yIHNvZnQgbGluZXMgaW50byBub3RoaW5nKS4gSGFyZCBsaW5lc1xuICAgIC8vIHNob3VsZCBzdGlsbCBvdXRwdXQgYmVjYXVzZSB0aGVyZSdzIHRvbyBncmVhdCBvZiBhIGNoYW5jZVxuICAgIC8vIG9mIGJyZWFraW5nIGV4aXN0aW5nIGFzc3VtcHRpb25zIG90aGVyd2lzZS5cbiAgICBpZiAoZG9jLnR5cGUgPT09IFwibGluZVwiICYmICFkb2MuaGFyZCkge1xuICAgICAgcmV0dXJuIGRvYy5zb2Z0ID8gXCJcIiA6IFwiIFwiO1xuICAgIH0gZWxzZSBpZiAoZG9jLnR5cGUgPT09IFwiaWYtYnJlYWtcIikge1xuICAgICAgcmV0dXJuIGRvYy5mbGF0Q29udGVudHMgfHwgXCJcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9jO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTGluZXMoZG9jKSB7XG4gICAgcmV0dXJuIG1hcERvYyhkb2MsIHJlbW92ZUxpbmVzRm4pO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RyaXBUcmFpbGluZ0hhcmRsaW5lKGRvYykge1xuICAgIC8vIEhBQ0sgcmVtb3ZlIGVuZGluZyBoYXJkbGluZSwgb3JpZ2luYWwgUFI6ICMxOTg0XG4gICAgaWYgKGRvYy50eXBlID09PSBcImNvbmNhdFwiICYmIGRvYy5wYXJ0cy5sZW5ndGggIT09IDApIHtcbiAgICAgIHZhciBsYXN0UGFydCA9IGRvYy5wYXJ0c1tkb2MucGFydHMubGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmIChsYXN0UGFydC50eXBlID09PSBcImNvbmNhdFwiKSB7XG4gICAgICAgIGlmIChsYXN0UGFydC5wYXJ0cy5sZW5ndGggPT09IDIgJiYgbGFzdFBhcnQucGFydHNbMF0uaGFyZCAmJiBsYXN0UGFydC5wYXJ0c1sxXS50eXBlID09PSBcImJyZWFrLXBhcmVudFwiKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiY29uY2F0XCIsXG4gICAgICAgICAgICBwYXJ0czogZG9jLnBhcnRzLnNsaWNlKDAsIC0xKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiY29uY2F0XCIsXG4gICAgICAgICAgcGFydHM6IGRvYy5wYXJ0cy5zbGljZSgwLCAtMSkuY29uY2F0KHN0cmlwVHJhaWxpbmdIYXJkbGluZShsYXN0UGFydCkpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvYztcbiAgfVxuXG4gIHZhciBkb2NVdGlscyA9IHtcbiAgICBpc0VtcHR5OiBpc0VtcHR5LFxuICAgIHdpbGxCcmVhazogd2lsbEJyZWFrLFxuICAgIGlzTGluZU5leHQ6IGlzTGluZU5leHQsXG4gICAgdHJhdmVyc2VEb2M6IHRyYXZlcnNlRG9jLFxuICAgIGZpbmRJbkRvYzogZmluZEluRG9jLFxuICAgIG1hcERvYzogbWFwRG9jLFxuICAgIHByb3BhZ2F0ZUJyZWFrczogcHJvcGFnYXRlQnJlYWtzLFxuICAgIHJlbW92ZUxpbmVzOiByZW1vdmVMaW5lcyxcbiAgICBzdHJpcFRyYWlsaW5nSGFyZGxpbmU6IHN0cmlwVHJhaWxpbmdIYXJkbGluZVxuICB9O1xuXG4gIGZ1bmN0aW9uIGZsYXR0ZW5Eb2MoZG9jKSB7XG4gICAgaWYgKGRvYy50eXBlID09PSBcImNvbmNhdFwiKSB7XG4gICAgICB2YXIgcmVzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLnBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBkb2MyID0gZG9jLnBhcnRzW2ldO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZG9jMiAhPT0gXCJzdHJpbmdcIiAmJiBkb2MyLnR5cGUgPT09IFwiY29uY2F0XCIpIHtcbiAgICAgICAgICBbXS5wdXNoLmFwcGx5KHJlcywgZmxhdHRlbkRvYyhkb2MyKS5wYXJ0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGZsYXR0ZW5lZCA9IGZsYXR0ZW5Eb2MoZG9jMik7XG5cbiAgICAgICAgICBpZiAoZmxhdHRlbmVkICE9PSBcIlwiKSB7XG4gICAgICAgICAgICByZXMucHVzaChmbGF0dGVuZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZG9jLCB7XG4gICAgICAgIHBhcnRzOiByZXNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoZG9jLnR5cGUgPT09IFwiaWYtYnJlYWtcIikge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGRvYywge1xuICAgICAgICBicmVha0NvbnRlbnRzOiBkb2MuYnJlYWtDb250ZW50cyAhPSBudWxsID8gZmxhdHRlbkRvYyhkb2MuYnJlYWtDb250ZW50cykgOiBudWxsLFxuICAgICAgICBmbGF0Q29udGVudHM6IGRvYy5mbGF0Q29udGVudHMgIT0gbnVsbCA/IGZsYXR0ZW5Eb2MoZG9jLmZsYXRDb250ZW50cykgOiBudWxsXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGRvYy50eXBlID09PSBcImdyb3VwXCIpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBkb2MsIHtcbiAgICAgICAgY29udGVudHM6IGZsYXR0ZW5Eb2MoZG9jLmNvbnRlbnRzKSxcbiAgICAgICAgZXhwYW5kZWRTdGF0ZXM6IGRvYy5leHBhbmRlZFN0YXRlcyA/IGRvYy5leHBhbmRlZFN0YXRlcy5tYXAoZmxhdHRlbkRvYykgOiBkb2MuZXhwYW5kZWRTdGF0ZXNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoZG9jLmNvbnRlbnRzKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZG9jLCB7XG4gICAgICAgIGNvbnRlbnRzOiBmbGF0dGVuRG9jKGRvYy5jb250ZW50cylcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBkb2M7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludERvYyhkb2MpIHtcbiAgICBpZiAodHlwZW9mIGRvYyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRvYyk7XG4gICAgfVxuXG4gICAgaWYgKGRvYy50eXBlID09PSBcImxpbmVcIikge1xuICAgICAgaWYgKGRvYy5saXRlcmFsKSB7XG4gICAgICAgIHJldHVybiBcImxpdGVyYWxsaW5lXCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChkb2MuaGFyZCkge1xuICAgICAgICByZXR1cm4gXCJoYXJkbGluZVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoZG9jLnNvZnQpIHtcbiAgICAgICAgcmV0dXJuIFwic29mdGxpbmVcIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwibGluZVwiO1xuICAgIH1cblxuICAgIGlmIChkb2MudHlwZSA9PT0gXCJicmVhay1wYXJlbnRcIikge1xuICAgICAgcmV0dXJuIFwiYnJlYWtQYXJlbnRcIjtcbiAgICB9XG5cbiAgICBpZiAoZG9jLnR5cGUgPT09IFwidHJpbVwiKSB7XG4gICAgICByZXR1cm4gXCJ0cmltXCI7XG4gICAgfVxuXG4gICAgaWYgKGRvYy50eXBlID09PSBcImNvbmNhdFwiKSB7XG4gICAgICByZXR1cm4gXCJbXCIgKyBkb2MucGFydHMubWFwKHByaW50RG9jKS5qb2luKFwiLCBcIikgKyBcIl1cIjtcbiAgICB9XG5cbiAgICBpZiAoZG9jLnR5cGUgPT09IFwiaW5kZW50XCIpIHtcbiAgICAgIHJldHVybiBcImluZGVudChcIiArIHByaW50RG9jKGRvYy5jb250ZW50cykgKyBcIilcIjtcbiAgICB9XG5cbiAgICBpZiAoZG9jLnR5cGUgPT09IFwiYWxpZ25cIikge1xuICAgICAgcmV0dXJuIGRvYy5uID09PSAtSW5maW5pdHkgPyBcImRlZGVudFRvUm9vdChcIiArIHByaW50RG9jKGRvYy5jb250ZW50cykgKyBcIilcIiA6IGRvYy5uIDwgMCA/IFwiZGVkZW50KFwiICsgcHJpbnREb2MoZG9jLmNvbnRlbnRzKSArIFwiKVwiIDogZG9jLm4udHlwZSA9PT0gXCJyb290XCIgPyBcIm1hcmtBc1Jvb3QoXCIgKyBwcmludERvYyhkb2MuY29udGVudHMpICsgXCIpXCIgOiBcImFsaWduKFwiICsgSlNPTi5zdHJpbmdpZnkoZG9jLm4pICsgXCIsIFwiICsgcHJpbnREb2MoZG9jLmNvbnRlbnRzKSArIFwiKVwiO1xuICAgIH1cblxuICAgIGlmIChkb2MudHlwZSA9PT0gXCJpZi1icmVha1wiKSB7XG4gICAgICByZXR1cm4gXCJpZkJyZWFrKFwiICsgcHJpbnREb2MoZG9jLmJyZWFrQ29udGVudHMpICsgKGRvYy5mbGF0Q29udGVudHMgPyBcIiwgXCIgKyBwcmludERvYyhkb2MuZmxhdENvbnRlbnRzKSA6IFwiXCIpICsgXCIpXCI7XG4gICAgfVxuXG4gICAgaWYgKGRvYy50eXBlID09PSBcImdyb3VwXCIpIHtcbiAgICAgIGlmIChkb2MuZXhwYW5kZWRTdGF0ZXMpIHtcbiAgICAgICAgcmV0dXJuIFwiY29uZGl0aW9uYWxHcm91cChcIiArIFwiW1wiICsgZG9jLmV4cGFuZGVkU3RhdGVzLm1hcChwcmludERvYykuam9pbihcIixcIikgKyBcIl0pXCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoZG9jLmJyZWFrID8gXCJ3cmFwcGVkR3JvdXBcIiA6IFwiZ3JvdXBcIikgKyBcIihcIiArIHByaW50RG9jKGRvYy5jb250ZW50cykgKyBcIilcIjtcbiAgICB9XG5cbiAgICBpZiAoZG9jLnR5cGUgPT09IFwiZmlsbFwiKSB7XG4gICAgICByZXR1cm4gXCJmaWxsXCIgKyBcIihcIiArIGRvYy5wYXJ0cy5tYXAocHJpbnREb2MpLmpvaW4oXCIsIFwiKSArIFwiKVwiO1xuICAgIH1cblxuICAgIGlmIChkb2MudHlwZSA9PT0gXCJsaW5lLXN1ZmZpeFwiKSB7XG4gICAgICByZXR1cm4gXCJsaW5lU3VmZml4KFwiICsgcHJpbnREb2MoZG9jLmNvbnRlbnRzKSArIFwiKVwiO1xuICAgIH1cblxuICAgIGlmIChkb2MudHlwZSA9PT0gXCJsaW5lLXN1ZmZpeC1ib3VuZGFyeVwiKSB7XG4gICAgICByZXR1cm4gXCJsaW5lU3VmZml4Qm91bmRhcnlcIjtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRvYyB0eXBlIFwiICsgZG9jLnR5cGUpO1xuICB9XG5cbiAgdmFyIGRvY0RlYnVnID0ge1xuICAgIHByaW50RG9jVG9EZWJ1ZzogZnVuY3Rpb24gcHJpbnREb2NUb0RlYnVnKGRvYykge1xuICAgICAgcmV0dXJuIHByaW50RG9jKGZsYXR0ZW5Eb2MoZG9jKSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBkb2MgPSB7XG4gICAgYnVpbGRlcnM6IGRvY0J1aWxkZXJzLFxuICAgIHByaW50ZXI6IGRvY1ByaW50ZXIsXG4gICAgdXRpbHM6IGRvY1V0aWxzLFxuICAgIGRlYnVnOiBkb2NEZWJ1Z1xuICB9O1xuXG4gIHZhciBtYXBEb2MkMSA9IGRvYy51dGlscy5tYXBEb2M7XG5cbiAgZnVuY3Rpb24gaXNOZXh0TGluZUVtcHR5JDEodGV4dCwgbm9kZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB1dGlsLmlzTmV4dExpbmVFbXB0eSh0ZXh0LCBub2RlLCBvcHRpb25zLmxvY0VuZCk7XG4gIH1cblxuICBmdW5jdGlvbiBpc1ByZXZpb3VzTGluZUVtcHR5JDEodGV4dCwgbm9kZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB1dGlsLmlzUHJldmlvdXNMaW5lRW1wdHkodGV4dCwgbm9kZSwgb3B0aW9ucy5sb2NTdGFydCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXROZXh0Tm9uU3BhY2VOb25Db21tZW50Q2hhcmFjdGVySW5kZXgkMSh0ZXh0LCBub2RlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHV0aWwuZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3RlckluZGV4KHRleHQsIG5vZGUsIG9wdGlvbnMubG9jRW5kKTtcbiAgfVxuXG4gIHZhciB1dGlsU2hhcmVkID0ge1xuICAgIGdldE1heENvbnRpbnVvdXNDb3VudDogdXRpbC5nZXRNYXhDb250aW51b3VzQ291bnQsXG4gICAgZ2V0U3RyaW5nV2lkdGg6IHV0aWwuZ2V0U3RyaW5nV2lkdGgsXG4gICAgZ2V0QWxpZ25tZW50U2l6ZTogdXRpbC5nZXRBbGlnbm1lbnRTaXplLFxuICAgIGdldEluZGVudFNpemU6IHV0aWwuZ2V0SW5kZW50U2l6ZSxcbiAgICBza2lwOiB1dGlsLnNraXAsXG4gICAgc2tpcFdoaXRlc3BhY2U6IHV0aWwuc2tpcFdoaXRlc3BhY2UsXG4gICAgc2tpcFNwYWNlczogdXRpbC5za2lwU3BhY2VzLFxuICAgIHNraXBOZXdsaW5lOiB1dGlsLnNraXBOZXdsaW5lLFxuICAgIHNraXBUb0xpbmVFbmQ6IHV0aWwuc2tpcFRvTGluZUVuZCxcbiAgICBza2lwRXZlcnl0aGluZ0J1dE5ld0xpbmU6IHV0aWwuc2tpcEV2ZXJ5dGhpbmdCdXROZXdMaW5lLFxuICAgIHNraXBJbmxpbmVDb21tZW50OiB1dGlsLnNraXBJbmxpbmVDb21tZW50LFxuICAgIHNraXBUcmFpbGluZ0NvbW1lbnQ6IHV0aWwuc2tpcFRyYWlsaW5nQ29tbWVudCxcbiAgICBoYXNOZXdsaW5lOiB1dGlsLmhhc05ld2xpbmUsXG4gICAgaGFzTmV3bGluZUluUmFuZ2U6IHV0aWwuaGFzTmV3bGluZUluUmFuZ2UsXG4gICAgaGFzU3BhY2VzOiB1dGlsLmhhc1NwYWNlcyxcbiAgICBpc05leHRMaW5lRW1wdHk6IGlzTmV4dExpbmVFbXB0eSQxLFxuICAgIGlzTmV4dExpbmVFbXB0eUFmdGVySW5kZXg6IHV0aWwuaXNOZXh0TGluZUVtcHR5QWZ0ZXJJbmRleCxcbiAgICBpc1ByZXZpb3VzTGluZUVtcHR5OiBpc1ByZXZpb3VzTGluZUVtcHR5JDEsXG4gICAgZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3RlckluZGV4OiBnZXROZXh0Tm9uU3BhY2VOb25Db21tZW50Q2hhcmFjdGVySW5kZXgkMSxcbiAgICBtYXBEb2M6IG1hcERvYyQxLFxuICAgIC8vIFRPRE86IHJlbW92ZSBpbiAyLjAsIHdlIGFscmVhZHkgZXhwb3NlZCBpdCBpbiBkb2NVdGlsc1xuICAgIG1ha2VTdHJpbmc6IHV0aWwubWFrZVN0cmluZyxcbiAgICBhZGRMZWFkaW5nQ29tbWVudDogdXRpbC5hZGRMZWFkaW5nQ29tbWVudCxcbiAgICBhZGREYW5nbGluZ0NvbW1lbnQ6IHV0aWwuYWRkRGFuZ2xpbmdDb21tZW50LFxuICAgIGFkZFRyYWlsaW5nQ29tbWVudDogdXRpbC5hZGRUcmFpbGluZ0NvbW1lbnRcbiAgfTtcblxuICB2YXIgX3JlcXVpcmUkJDAkYnVpbGRlcnMgPSBkb2MuYnVpbGRlcnMsXG4gICAgICBjb25jYXQkMiA9IF9yZXF1aXJlJCQwJGJ1aWxkZXJzLmNvbmNhdCxcbiAgICAgIGhhcmRsaW5lJDEgPSBfcmVxdWlyZSQkMCRidWlsZGVycy5oYXJkbGluZSxcbiAgICAgIGJyZWFrUGFyZW50JDEgPSBfcmVxdWlyZSQkMCRidWlsZGVycy5icmVha1BhcmVudCxcbiAgICAgIGluZGVudCQxID0gX3JlcXVpcmUkJDAkYnVpbGRlcnMuaW5kZW50LFxuICAgICAgbGluZVN1ZmZpeCQxID0gX3JlcXVpcmUkJDAkYnVpbGRlcnMubGluZVN1ZmZpeCxcbiAgICAgIGpvaW4kMSA9IF9yZXF1aXJlJCQwJGJ1aWxkZXJzLmpvaW4sXG4gICAgICBjdXJzb3IkMiA9IF9yZXF1aXJlJCQwJGJ1aWxkZXJzLmN1cnNvcjtcbiAgdmFyIGhhc05ld2xpbmUkMSA9IHV0aWwuaGFzTmV3bGluZSxcbiAgICAgIHNraXBOZXdsaW5lJDEgPSB1dGlsLnNraXBOZXdsaW5lLFxuICAgICAgaXNQcmV2aW91c0xpbmVFbXB0eSQyID0gdXRpbC5pc1ByZXZpb3VzTGluZUVtcHR5O1xuICB2YXIgYWRkTGVhZGluZ0NvbW1lbnQkMSA9IHV0aWxTaGFyZWQuYWRkTGVhZGluZ0NvbW1lbnQsXG4gICAgICBhZGREYW5nbGluZ0NvbW1lbnQkMSA9IHV0aWxTaGFyZWQuYWRkRGFuZ2xpbmdDb21tZW50LFxuICAgICAgYWRkVHJhaWxpbmdDb21tZW50JDEgPSB1dGlsU2hhcmVkLmFkZFRyYWlsaW5nQ29tbWVudDtcbiAgdmFyIGNoaWxkTm9kZXNDYWNoZUtleSA9IFN5bWJvbChcImNoaWxkLW5vZGVzXCIpO1xuXG4gIGZ1bmN0aW9uIGdldFNvcnRlZENoaWxkTm9kZXMobm9kZSwgb3B0aW9ucywgcmVzdWx0QXJyYXkpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJpbnRlciA9IG9wdGlvbnMucHJpbnRlcixcbiAgICAgICAgbG9jU3RhcnQgPSBvcHRpb25zLmxvY1N0YXJ0LFxuICAgICAgICBsb2NFbmQgPSBvcHRpb25zLmxvY0VuZDtcblxuICAgIGlmIChyZXN1bHRBcnJheSkge1xuICAgICAgaWYgKG5vZGUgJiYgcHJpbnRlci5jYW5BdHRhY2hDb21tZW50ICYmIHByaW50ZXIuY2FuQXR0YWNoQ29tbWVudChub2RlKSkge1xuICAgICAgICAvLyBUaGlzIHJldmVyc2UgaW5zZXJ0aW9uIHNvcnQgYWxtb3N0IGFsd2F5cyB0YWtlcyBjb25zdGFudFxuICAgICAgICAvLyB0aW1lIGJlY2F1c2Ugd2UgYWxtb3N0IGFsd2F5cyAobWF5YmUgYWx3YXlzPykgYXBwZW5kIHRoZVxuICAgICAgICAvLyBub2RlcyBpbiBvcmRlciBhbnl3YXkuXG4gICAgICAgIHZhciBpO1xuXG4gICAgICAgIGZvciAoaSA9IHJlc3VsdEFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgaWYgKGxvY1N0YXJ0KHJlc3VsdEFycmF5W2ldKSA8PSBsb2NTdGFydChub2RlKSAmJiBsb2NFbmQocmVzdWx0QXJyYXlbaV0pIDw9IGxvY0VuZChub2RlKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0QXJyYXkuc3BsaWNlKGkgKyAxLCAwLCBub2RlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZVtjaGlsZE5vZGVzQ2FjaGVLZXldKSB7XG4gICAgICByZXR1cm4gbm9kZVtjaGlsZE5vZGVzQ2FjaGVLZXldO1xuICAgIH1cblxuICAgIHZhciBjaGlsZE5vZGVzO1xuXG4gICAgaWYgKHByaW50ZXIuZ2V0Q29tbWVudENoaWxkTm9kZXMpIHtcbiAgICAgIGNoaWxkTm9kZXMgPSBwcmludGVyLmdldENvbW1lbnRDaGlsZE5vZGVzKG5vZGUpO1xuICAgIH0gZWxzZSBpZiAobm9kZSAmJiBfdHlwZW9mKG5vZGUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjaGlsZE5vZGVzID0gT2JqZWN0LmtleXMobm9kZSkuZmlsdGVyKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBuICE9PSBcImVuY2xvc2luZ05vZGVcIiAmJiBuICE9PSBcInByZWNlZGluZ05vZGVcIiAmJiBuICE9PSBcImZvbGxvd2luZ05vZGVcIjtcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gbm9kZVtuXTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghY2hpbGROb2Rlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghcmVzdWx0QXJyYXkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub2RlLCBjaGlsZE5vZGVzQ2FjaGVLZXksIHtcbiAgICAgICAgdmFsdWU6IHJlc3VsdEFycmF5ID0gW10sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjaGlsZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xuICAgICAgZ2V0U29ydGVkQ2hpbGROb2RlcyhjaGlsZE5vZGUsIG9wdGlvbnMsIHJlc3VsdEFycmF5KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0QXJyYXk7XG4gIH0gLy8gQXMgZWZmaWNpZW50bHkgYXMgcG9zc2libGUsIGRlY29yYXRlIHRoZSBjb21tZW50IG9iamVjdCB3aXRoXG4gIC8vIC5wcmVjZWRpbmdOb2RlLCAuZW5jbG9zaW5nTm9kZSwgYW5kL29yIC5mb2xsb3dpbmdOb2RlIHByb3BlcnRpZXMsIGF0XG4gIC8vIGxlYXN0IG9uZSBvZiB3aGljaCBpcyBndWFyYW50ZWVkIHRvIGJlIGRlZmluZWQuXG5cblxuICBmdW5jdGlvbiBkZWNvcmF0ZUNvbW1lbnQobm9kZSwgY29tbWVudCwgb3B0aW9ucykge1xuICAgIHZhciBsb2NTdGFydCA9IG9wdGlvbnMubG9jU3RhcnQsXG4gICAgICAgIGxvY0VuZCA9IG9wdGlvbnMubG9jRW5kO1xuICAgIHZhciBjaGlsZE5vZGVzID0gZ2V0U29ydGVkQ2hpbGROb2Rlcyhub2RlLCBvcHRpb25zKTtcbiAgICB2YXIgcHJlY2VkaW5nTm9kZTtcbiAgICB2YXIgZm9sbG93aW5nTm9kZTsgLy8gVGltZSB0byBkdXN0IG9mZiB0aGUgb2xkIGJpbmFyeSBzZWFyY2ggcm9iZXMgYW5kIHdpemFyZCBoYXQuXG5cbiAgICB2YXIgbGVmdCA9IDA7XG4gICAgdmFyIHJpZ2h0ID0gY2hpbGROb2Rlcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVmdCA8IHJpZ2h0KSB7XG4gICAgICB2YXIgbWlkZGxlID0gbGVmdCArIHJpZ2h0ID4+IDE7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZE5vZGVzW21pZGRsZV07XG5cbiAgICAgIGlmIChsb2NTdGFydChjaGlsZCkgLSBsb2NTdGFydChjb21tZW50KSA8PSAwICYmIGxvY0VuZChjb21tZW50KSAtIGxvY0VuZChjaGlsZCkgPD0gMCkge1xuICAgICAgICAvLyBUaGUgY29tbWVudCBpcyBjb21wbGV0ZWx5IGNvbnRhaW5lZCBieSB0aGlzIGNoaWxkIG5vZGUuXG4gICAgICAgIGNvbW1lbnQuZW5jbG9zaW5nTm9kZSA9IGNoaWxkO1xuICAgICAgICBkZWNvcmF0ZUNvbW1lbnQoY2hpbGQsIGNvbW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm47IC8vIEFiYW5kb24gdGhlIGJpbmFyeSBzZWFyY2ggYXQgdGhpcyBsZXZlbC5cbiAgICAgIH1cblxuICAgICAgaWYgKGxvY0VuZChjaGlsZCkgLSBsb2NTdGFydChjb21tZW50KSA8PSAwKSB7XG4gICAgICAgIC8vIFRoaXMgY2hpbGQgbm9kZSBmYWxscyBjb21wbGV0ZWx5IGJlZm9yZSB0aGUgY29tbWVudC5cbiAgICAgICAgLy8gQmVjYXVzZSB3ZSB3aWxsIG5ldmVyIGNvbnNpZGVyIHRoaXMgbm9kZSBvciBhbnkgbm9kZXNcbiAgICAgICAgLy8gYmVmb3JlIGl0IGFnYWluLCB0aGlzIG5vZGUgbXVzdCBiZSB0aGUgY2xvc2VzdCBwcmVjZWRpbmdcbiAgICAgICAgLy8gbm9kZSB3ZSBoYXZlIGVuY291bnRlcmVkIHNvIGZhci5cbiAgICAgICAgcHJlY2VkaW5nTm9kZSA9IGNoaWxkO1xuICAgICAgICBsZWZ0ID0gbWlkZGxlICsgMTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChsb2NFbmQoY29tbWVudCkgLSBsb2NTdGFydChjaGlsZCkgPD0gMCkge1xuICAgICAgICAvLyBUaGlzIGNoaWxkIG5vZGUgZmFsbHMgY29tcGxldGVseSBhZnRlciB0aGUgY29tbWVudC5cbiAgICAgICAgLy8gQmVjYXVzZSB3ZSB3aWxsIG5ldmVyIGNvbnNpZGVyIHRoaXMgbm9kZSBvciBhbnkgbm9kZXMgYWZ0ZXJcbiAgICAgICAgLy8gaXQgYWdhaW4sIHRoaXMgbm9kZSBtdXN0IGJlIHRoZSBjbG9zZXN0IGZvbGxvd2luZyBub2RlIHdlXG4gICAgICAgIC8vIGhhdmUgZW5jb3VudGVyZWQgc28gZmFyLlxuICAgICAgICBmb2xsb3dpbmdOb2RlID0gY2hpbGQ7XG4gICAgICAgIHJpZ2h0ID0gbWlkZGxlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tbWVudCBsb2NhdGlvbiBvdmVybGFwcyB3aXRoIG5vZGUgbG9jYXRpb25cIik7XG4gICAgfSAvLyBXZSBkb24ndCB3YW50IGNvbW1lbnRzIGluc2lkZSBvZiBkaWZmZXJlbnQgZXhwcmVzc2lvbnMgaW5zaWRlIG9mIHRoZSBzYW1lXG4gICAgLy8gdGVtcGxhdGUgbGl0ZXJhbCB0byBtb3ZlIHRvIGFub3RoZXIgZXhwcmVzc2lvbi5cblxuXG4gICAgaWYgKGNvbW1lbnQuZW5jbG9zaW5nTm9kZSAmJiBjb21tZW50LmVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJUZW1wbGF0ZUxpdGVyYWxcIikge1xuICAgICAgdmFyIHF1YXNpcyA9IGNvbW1lbnQuZW5jbG9zaW5nTm9kZS5xdWFzaXM7XG4gICAgICB2YXIgY29tbWVudEluZGV4ID0gZmluZEV4cHJlc3Npb25JbmRleEZvckNvbW1lbnQocXVhc2lzLCBjb21tZW50LCBvcHRpb25zKTtcblxuICAgICAgaWYgKHByZWNlZGluZ05vZGUgJiYgZmluZEV4cHJlc3Npb25JbmRleEZvckNvbW1lbnQocXVhc2lzLCBwcmVjZWRpbmdOb2RlLCBvcHRpb25zKSAhPT0gY29tbWVudEluZGV4KSB7XG4gICAgICAgIHByZWNlZGluZ05vZGUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm9sbG93aW5nTm9kZSAmJiBmaW5kRXhwcmVzc2lvbkluZGV4Rm9yQ29tbWVudChxdWFzaXMsIGZvbGxvd2luZ05vZGUsIG9wdGlvbnMpICE9PSBjb21tZW50SW5kZXgpIHtcbiAgICAgICAgZm9sbG93aW5nTm9kZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZWNlZGluZ05vZGUpIHtcbiAgICAgIGNvbW1lbnQucHJlY2VkaW5nTm9kZSA9IHByZWNlZGluZ05vZGU7XG4gICAgfVxuXG4gICAgaWYgKGZvbGxvd2luZ05vZGUpIHtcbiAgICAgIGNvbW1lbnQuZm9sbG93aW5nTm9kZSA9IGZvbGxvd2luZ05vZGU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXR0YWNoKGNvbW1lbnRzLCBhc3QsIHRleHQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29tbWVudHMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRpZXNUb0JyZWFrID0gW107XG4gICAgdmFyIGxvY1N0YXJ0ID0gb3B0aW9ucy5sb2NTdGFydCxcbiAgICAgICAgbG9jRW5kID0gb3B0aW9ucy5sb2NFbmQ7XG4gICAgY29tbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tbWVudCwgaSkge1xuICAgICAgaWYgKG9wdGlvbnMucGFyc2VyID09PSBcImpzb25cIiB8fCBvcHRpb25zLnBhcnNlciA9PT0gXCJqc29uNVwiIHx8IG9wdGlvbnMucGFyc2VyID09PSBcIl9fanNfZXhwcmVzc2lvblwiIHx8IG9wdGlvbnMucGFyc2VyID09PSBcIl9fdnVlX2V4cHJlc3Npb25cIikge1xuICAgICAgICBpZiAobG9jU3RhcnQoY29tbWVudCkgLSBsb2NTdGFydChhc3QpIDw9IDApIHtcbiAgICAgICAgICBhZGRMZWFkaW5nQ29tbWVudCQxKGFzdCwgY29tbWVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvY0VuZChjb21tZW50KSAtIGxvY0VuZChhc3QpID49IDApIHtcbiAgICAgICAgICBhZGRUcmFpbGluZ0NvbW1lbnQkMShhc3QsIGNvbW1lbnQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkZWNvcmF0ZUNvbW1lbnQoYXN0LCBjb21tZW50LCBvcHRpb25zKTtcbiAgICAgIHZhciBwcmVjZWRpbmdOb2RlID0gY29tbWVudC5wcmVjZWRpbmdOb2RlLFxuICAgICAgICAgIGVuY2xvc2luZ05vZGUgPSBjb21tZW50LmVuY2xvc2luZ05vZGUsXG4gICAgICAgICAgZm9sbG93aW5nTm9kZSA9IGNvbW1lbnQuZm9sbG93aW5nTm9kZTtcbiAgICAgIHZhciBwbHVnaW5IYW5kbGVPd25MaW5lQ29tbWVudCA9IG9wdGlvbnMucHJpbnRlci5oYW5kbGVDb21tZW50cyAmJiBvcHRpb25zLnByaW50ZXIuaGFuZGxlQ29tbWVudHMub3duTGluZSA/IG9wdGlvbnMucHJpbnRlci5oYW5kbGVDb21tZW50cy5vd25MaW5lIDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgdmFyIHBsdWdpbkhhbmRsZUVuZE9mTGluZUNvbW1lbnQgPSBvcHRpb25zLnByaW50ZXIuaGFuZGxlQ29tbWVudHMgJiYgb3B0aW9ucy5wcmludGVyLmhhbmRsZUNvbW1lbnRzLmVuZE9mTGluZSA/IG9wdGlvbnMucHJpbnRlci5oYW5kbGVDb21tZW50cy5lbmRPZkxpbmUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgICB2YXIgcGx1Z2luSGFuZGxlUmVtYWluaW5nQ29tbWVudCA9IG9wdGlvbnMucHJpbnRlci5oYW5kbGVDb21tZW50cyAmJiBvcHRpb25zLnByaW50ZXIuaGFuZGxlQ29tbWVudHMucmVtYWluaW5nID8gb3B0aW9ucy5wcmludGVyLmhhbmRsZUNvbW1lbnRzLnJlbWFpbmluZyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgIHZhciBpc0xhc3RDb21tZW50ID0gY29tbWVudHMubGVuZ3RoIC0gMSA9PT0gaTtcblxuICAgICAgaWYgKGhhc05ld2xpbmUkMSh0ZXh0LCBsb2NTdGFydChjb21tZW50KSwge1xuICAgICAgICBiYWNrd2FyZHM6IHRydWVcbiAgICAgIH0pKSB7XG4gICAgICAgIC8vIElmIGEgY29tbWVudCBleGlzdHMgb24gaXRzIG93biBsaW5lLCBwcmVmZXIgYSBsZWFkaW5nIGNvbW1lbnQuXG4gICAgICAgIC8vIFdlIGFsc28gbmVlZCB0byBjaGVjayBpZiBpdCdzIHRoZSBmaXJzdCBsaW5lIG9mIHRoZSBmaWxlLlxuICAgICAgICBpZiAocGx1Z2luSGFuZGxlT3duTGluZUNvbW1lbnQoY29tbWVudCwgdGV4dCwgb3B0aW9ucywgYXN0LCBpc0xhc3RDb21tZW50KSkgOyBlbHNlIGlmIChmb2xsb3dpbmdOb2RlKSB7XG4gICAgICAgICAgLy8gQWx3YXlzIGEgbGVhZGluZyBjb21tZW50LlxuICAgICAgICAgIGFkZExlYWRpbmdDb21tZW50JDEoZm9sbG93aW5nTm9kZSwgY29tbWVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJlY2VkaW5nTm9kZSkge1xuICAgICAgICAgIGFkZFRyYWlsaW5nQ29tbWVudCQxKHByZWNlZGluZ05vZGUsIGNvbW1lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGVuY2xvc2luZ05vZGUpIHtcbiAgICAgICAgICBhZGREYW5nbGluZ0NvbW1lbnQkMShlbmNsb3NpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGVyZSBhcmUgbm8gbm9kZXMsIGxldCdzIGF0dGFjaCBpdCB0byB0aGUgcm9vdCBvZiB0aGUgYXN0XG5cbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIGFkZERhbmdsaW5nQ29tbWVudCQxKGFzdCwgY29tbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaGFzTmV3bGluZSQxKHRleHQsIGxvY0VuZChjb21tZW50KSkpIHtcbiAgICAgICAgaWYgKHBsdWdpbkhhbmRsZUVuZE9mTGluZUNvbW1lbnQoY29tbWVudCwgdGV4dCwgb3B0aW9ucywgYXN0LCBpc0xhc3RDb21tZW50KSkgOyBlbHNlIGlmIChwcmVjZWRpbmdOb2RlKSB7XG4gICAgICAgICAgLy8gVGhlcmUgaXMgY29udGVudCBiZWZvcmUgdGhpcyBjb21tZW50IG9uIHRoZSBzYW1lIGxpbmUsIGJ1dFxuICAgICAgICAgIC8vIG5vbmUgYWZ0ZXIgaXQsIHNvIHByZWZlciBhIHRyYWlsaW5nIGNvbW1lbnQgb2YgdGhlIHByZXZpb3VzIG5vZGUuXG4gICAgICAgICAgYWRkVHJhaWxpbmdDb21tZW50JDEocHJlY2VkaW5nTm9kZSwgY29tbWVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9sbG93aW5nTm9kZSkge1xuICAgICAgICAgIGFkZExlYWRpbmdDb21tZW50JDEoZm9sbG93aW5nTm9kZSwgY29tbWVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZW5jbG9zaW5nTm9kZSkge1xuICAgICAgICAgIGFkZERhbmdsaW5nQ29tbWVudCQxKGVuY2xvc2luZ05vZGUsIGNvbW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZXJlIGFyZSBubyBub2RlcywgbGV0J3MgYXR0YWNoIGl0IHRvIHRoZSByb290IG9mIHRoZSBhc3RcblxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgYWRkRGFuZ2xpbmdDb21tZW50JDEoYXN0LCBjb21tZW50KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBsdWdpbkhhbmRsZVJlbWFpbmluZ0NvbW1lbnQoY29tbWVudCwgdGV4dCwgb3B0aW9ucywgYXN0LCBpc0xhc3RDb21tZW50KSkgOyBlbHNlIGlmIChwcmVjZWRpbmdOb2RlICYmIGZvbGxvd2luZ05vZGUpIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UsIHRleHQgZXhpc3RzIGJvdGggYmVmb3JlIGFuZCBhZnRlciB0aGUgY29tbWVudCBvblxuICAgICAgICAgIC8vIHRoZSBzYW1lIGxpbmUuIElmIHRoZXJlIGlzIGJvdGggYSBwcmVjZWRpbmcgYW5kIGZvbGxvd2luZ1xuICAgICAgICAgIC8vIG5vZGUsIHVzZSBhIHRpZS1icmVha2luZyBhbGdvcml0aG0gdG8gZGV0ZXJtaW5lIGlmIGl0IHNob3VsZFxuICAgICAgICAgIC8vIGJlIGF0dGFjaGVkIHRvIHRoZSBuZXh0IG9yIHByZXZpb3VzIG5vZGUuIEluIHRoZSBsYXN0IGNhc2UsXG4gICAgICAgICAgLy8gc2ltcGx5IGF0dGFjaCB0aGUgcmlnaHQgbm9kZTtcbiAgICAgICAgICB2YXIgdGllQ291bnQgPSB0aWVzVG9CcmVhay5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAodGllQ291bnQgPiAwKSB7XG4gICAgICAgICAgICB2YXIgbGFzdFRpZSA9IHRpZXNUb0JyZWFrW3RpZUNvdW50IC0gMV07XG5cbiAgICAgICAgICAgIGlmIChsYXN0VGllLmZvbGxvd2luZ05vZGUgIT09IGNvbW1lbnQuZm9sbG93aW5nTm9kZSkge1xuICAgICAgICAgICAgICBicmVha1RpZXModGllc1RvQnJlYWssIHRleHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRpZXNUb0JyZWFrLnB1c2goY29tbWVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJlY2VkaW5nTm9kZSkge1xuICAgICAgICAgIGFkZFRyYWlsaW5nQ29tbWVudCQxKHByZWNlZGluZ05vZGUsIGNvbW1lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvbGxvd2luZ05vZGUpIHtcbiAgICAgICAgICBhZGRMZWFkaW5nQ29tbWVudCQxKGZvbGxvd2luZ05vZGUsIGNvbW1lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGVuY2xvc2luZ05vZGUpIHtcbiAgICAgICAgICBhZGREYW5nbGluZ0NvbW1lbnQkMShlbmNsb3NpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGVyZSBhcmUgbm8gbm9kZXMsIGxldCdzIGF0dGFjaCBpdCB0byB0aGUgcm9vdCBvZiB0aGUgYXN0XG5cbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIGFkZERhbmdsaW5nQ29tbWVudCQxKGFzdCwgY29tbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBicmVha1RpZXModGllc1RvQnJlYWssIHRleHQsIG9wdGlvbnMpO1xuICAgIGNvbW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbW1lbnQpIHtcbiAgICAgIC8vIFRoZXNlIG5vZGUgcmVmZXJlbmNlcyB3ZXJlIHVzZWZ1bCBmb3IgYnJlYWtpbmcgdGllcywgYnV0IHdlXG4gICAgICAvLyBkb24ndCBuZWVkIHRoZW0gYW55bW9yZSwgYW5kIHRoZXkgY3JlYXRlIGN5Y2xlcyBpbiB0aGUgQVNUIHRoYXRcbiAgICAgIC8vIG1heSBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbiBpZiB3ZSBkb24ndCBkZWxldGUgdGhlbSBoZXJlLlxuICAgICAgZGVsZXRlIGNvbW1lbnQucHJlY2VkaW5nTm9kZTtcbiAgICAgIGRlbGV0ZSBjb21tZW50LmVuY2xvc2luZ05vZGU7XG4gICAgICBkZWxldGUgY29tbWVudC5mb2xsb3dpbmdOb2RlO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYnJlYWtUaWVzKHRpZXNUb0JyZWFrLCB0ZXh0LCBvcHRpb25zKSB7XG4gICAgdmFyIHRpZUNvdW50ID0gdGllc1RvQnJlYWsubGVuZ3RoO1xuXG4gICAgaWYgKHRpZUNvdW50ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF90aWVzVG9CcmVhayQgPSB0aWVzVG9CcmVha1swXSxcbiAgICAgICAgcHJlY2VkaW5nTm9kZSA9IF90aWVzVG9CcmVhayQucHJlY2VkaW5nTm9kZSxcbiAgICAgICAgZm9sbG93aW5nTm9kZSA9IF90aWVzVG9CcmVhayQuZm9sbG93aW5nTm9kZTtcbiAgICB2YXIgZ2FwRW5kUG9zID0gb3B0aW9ucy5sb2NTdGFydChmb2xsb3dpbmdOb2RlKTsgLy8gSXRlcmF0ZSBiYWNrd2FyZHMgdGhyb3VnaCB0aWVzVG9CcmVhaywgZXhhbWluaW5nIHRoZSBnYXBzXG4gICAgLy8gYmV0d2VlbiB0aGUgdGllZCBjb21tZW50cy4gSW4gb3JkZXIgdG8gcXVhbGlmeSBhcyBsZWFkaW5nLCBhXG4gICAgLy8gY29tbWVudCBtdXN0IGJlIHNlcGFyYXRlZCBmcm9tIGZvbGxvd2luZ05vZGUgYnkgYW4gdW5icm9rZW4gc2VyaWVzIG9mXG4gICAgLy8gZ2FwcyAob3Igb3RoZXIgY29tbWVudHMpLiBHYXBzIHNob3VsZCBvbmx5IGNvbnRhaW4gd2hpdGVzcGFjZSBvciBvcGVuXG4gICAgLy8gcGFyZW50aGVzZXMuXG5cbiAgICB2YXIgaW5kZXhPZkZpcnN0TGVhZGluZ0NvbW1lbnQ7XG5cbiAgICBmb3IgKGluZGV4T2ZGaXJzdExlYWRpbmdDb21tZW50ID0gdGllQ291bnQ7IGluZGV4T2ZGaXJzdExlYWRpbmdDb21tZW50ID4gMDsgLS1pbmRleE9mRmlyc3RMZWFkaW5nQ29tbWVudCkge1xuICAgICAgdmFyIGNvbW1lbnQgPSB0aWVzVG9CcmVha1tpbmRleE9mRmlyc3RMZWFkaW5nQ29tbWVudCAtIDFdO1xuICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGNvbW1lbnQucHJlY2VkaW5nTm9kZSwgcHJlY2VkaW5nTm9kZSk7XG4gICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoY29tbWVudC5mb2xsb3dpbmdOb2RlLCBmb2xsb3dpbmdOb2RlKTtcbiAgICAgIHZhciBnYXAgPSB0ZXh0LnNsaWNlKG9wdGlvbnMubG9jRW5kKGNvbW1lbnQpLCBnYXBFbmRQb3MpO1xuXG4gICAgICBpZiAoL15bXFxzKF0qJC8udGVzdChnYXApKSB7XG4gICAgICAgIGdhcEVuZFBvcyA9IG9wdGlvbnMubG9jU3RhcnQoY29tbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgZ2FwIHN0cmluZyBjb250YWluZWQgc29tZXRoaW5nIG90aGVyIHRoYW4gd2hpdGVzcGFjZSBvciBvcGVuXG4gICAgICAgIC8vIHBhcmVudGhlc2VzLlxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aWVzVG9CcmVhay5mb3JFYWNoKGZ1bmN0aW9uIChjb21tZW50LCBpKSB7XG4gICAgICBpZiAoaSA8IGluZGV4T2ZGaXJzdExlYWRpbmdDb21tZW50KSB7XG4gICAgICAgIGFkZFRyYWlsaW5nQ29tbWVudCQxKHByZWNlZGluZ05vZGUsIGNvbW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkTGVhZGluZ0NvbW1lbnQkMShmb2xsb3dpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aWVzVG9CcmVhay5sZW5ndGggPSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRDb21tZW50KGNvbW1lbnRQYXRoLCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbW1lbnQgPSBjb21tZW50UGF0aC5nZXRWYWx1ZSgpO1xuICAgIGNvbW1lbnQucHJpbnRlZCA9IHRydWU7XG4gICAgcmV0dXJuIG9wdGlvbnMucHJpbnRlci5wcmludENvbW1lbnQoY29tbWVudFBhdGgsIG9wdGlvbnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEV4cHJlc3Npb25JbmRleEZvckNvbW1lbnQocXVhc2lzLCBjb21tZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gb3B0aW9ucy5sb2NTdGFydChjb21tZW50KSAtIDE7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHF1YXNpcy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHN0YXJ0UG9zIDwgZ2V0UXVhc2lSYW5nZShxdWFzaXNbaV0pLnN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBpIC0gMTtcbiAgICAgIH1cbiAgICB9IC8vIFdlIGhhdmVuJ3QgZm91bmQgaXQsIGl0IHByb2JhYmx5IG1lYW5zIHRoYXQgc29tZSBvZiB0aGUgbG9jYXRpb25zIGFyZSBvZmYuXG4gICAgLy8gTGV0J3MganVzdCByZXR1cm4gdGhlIGZpcnN0IG9uZS5cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cblxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UXVhc2lSYW5nZShleHByKSB7XG4gICAgaWYgKGV4cHIuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQmFiZWxcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBleHByLnN0YXJ0LFxuICAgICAgICBlbmQ6IGV4cHIuZW5kXG4gICAgICB9O1xuICAgIH0gLy8gRmxvd1xuXG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IGV4cHIucmFuZ2VbMF0sXG4gICAgICBlbmQ6IGV4cHIucmFuZ2VbMV1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRMZWFkaW5nQ29tbWVudChjb21tZW50UGF0aCwgcHJpbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgY29tbWVudCA9IGNvbW1lbnRQYXRoLmdldFZhbHVlKCk7XG4gICAgdmFyIGNvbnRlbnRzID0gcHJpbnRDb21tZW50KGNvbW1lbnRQYXRoLCBvcHRpb25zKTtcblxuICAgIGlmICghY29udGVudHMpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIHZhciBpc0Jsb2NrID0gb3B0aW9ucy5wcmludGVyLmlzQmxvY2tDb21tZW50ICYmIG9wdGlvbnMucHJpbnRlci5pc0Jsb2NrQ29tbWVudChjb21tZW50KTsgLy8gTGVhZGluZyBibG9jayBjb21tZW50cyBzaG91bGQgc2VlIGlmIHRoZXkgbmVlZCB0byBzdGF5IG9uIHRoZVxuICAgIC8vIHNhbWUgbGluZSBvciBub3QuXG5cbiAgICBpZiAoaXNCbG9jaykge1xuICAgICAgcmV0dXJuIGNvbmNhdCQyKFtjb250ZW50cywgaGFzTmV3bGluZSQxKG9wdGlvbnMub3JpZ2luYWxUZXh0LCBvcHRpb25zLmxvY0VuZChjb21tZW50KSkgPyBoYXJkbGluZSQxIDogXCIgXCJdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uY2F0JDIoW2NvbnRlbnRzLCBoYXJkbGluZSQxXSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludFRyYWlsaW5nQ29tbWVudChjb21tZW50UGF0aCwgcHJpbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgY29tbWVudCA9IGNvbW1lbnRQYXRoLmdldFZhbHVlKCk7XG4gICAgdmFyIGNvbnRlbnRzID0gcHJpbnRDb21tZW50KGNvbW1lbnRQYXRoLCBvcHRpb25zKTtcblxuICAgIGlmICghY29udGVudHMpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIHZhciBpc0Jsb2NrID0gb3B0aW9ucy5wcmludGVyLmlzQmxvY2tDb21tZW50ICYmIG9wdGlvbnMucHJpbnRlci5pc0Jsb2NrQ29tbWVudChjb21tZW50KTsgLy8gV2UgZG9uJ3Qgd2FudCB0aGUgbGluZSB0byBicmVha1xuICAgIC8vIHdoZW4gdGhlIHBhcmVudFBhcmVudE5vZGUgaXMgYSBDbGFzc0RlY2xhcmF0aW9uLy1FeHByZXNzaW9uXG4gICAgLy8gQW5kIHRoZSBwYXJlbnROb2RlIGlzIGluIHRoZSBzdXBlckNsYXNzIHByb3BlcnR5XG5cbiAgICB2YXIgcGFyZW50Tm9kZSA9IGNvbW1lbnRQYXRoLmdldE5vZGUoMSk7XG4gICAgdmFyIHBhcmVudFBhcmVudE5vZGUgPSBjb21tZW50UGF0aC5nZXROb2RlKDIpO1xuICAgIHZhciBpc1BhcmVudFN1cGVyQ2xhc3MgPSBwYXJlbnRQYXJlbnROb2RlICYmIChwYXJlbnRQYXJlbnROb2RlLnR5cGUgPT09IFwiQ2xhc3NEZWNsYXJhdGlvblwiIHx8IHBhcmVudFBhcmVudE5vZGUudHlwZSA9PT0gXCJDbGFzc0V4cHJlc3Npb25cIikgJiYgcGFyZW50UGFyZW50Tm9kZS5zdXBlckNsYXNzID09PSBwYXJlbnROb2RlO1xuXG4gICAgaWYgKGhhc05ld2xpbmUkMShvcHRpb25zLm9yaWdpbmFsVGV4dCwgb3B0aW9ucy5sb2NTdGFydChjb21tZW50KSwge1xuICAgICAgYmFja3dhcmRzOiB0cnVlXG4gICAgfSkpIHtcbiAgICAgIC8vIFRoaXMgYWxsb3dzIGNvbW1lbnRzIGF0IHRoZSBlbmQgb2YgbmVzdGVkIHN0cnVjdHVyZXM6XG4gICAgICAvLyB7XG4gICAgICAvLyAgIHg6IDEsXG4gICAgICAvLyAgIHk6IDJcbiAgICAgIC8vICAgLy8gQSBjb21tZW50XG4gICAgICAvLyB9XG4gICAgICAvLyBUaG9zZSBraW5kcyBvZiBjb21tZW50cyBhcmUgYWxtb3N0IGFsd2F5cyBsZWFkaW5nIGNvbW1lbnRzLCBidXRcbiAgICAgIC8vIGhlcmUgaXQgZG9lc24ndCBnbyBcIm91dHNpZGVcIiB0aGUgYmxvY2sgYW5kIHR1cm5zIGl0IGludG8gYVxuICAgICAgLy8gdHJhaWxpbmcgY29tbWVudCBmb3IgYDJgLiBXZSBjYW4gc2ltdWxhdGUgdGhlIGFib3ZlIGJ5IGNoZWNraW5nXG4gICAgICAvLyBpZiB0aGlzIGEgY29tbWVudCBvbiBpdHMgb3duIGxpbmU7IG5vcm1hbCB0cmFpbGluZyBjb21tZW50cyBhcmVcbiAgICAgIC8vIGFsd2F5cyBhdCB0aGUgZW5kIG9mIGFub3RoZXIgZXhwcmVzc2lvbi5cbiAgICAgIHZhciBpc0xpbmVCZWZvcmVFbXB0eSA9IGlzUHJldmlvdXNMaW5lRW1wdHkkMihvcHRpb25zLm9yaWdpbmFsVGV4dCwgY29tbWVudCwgb3B0aW9ucy5sb2NTdGFydCk7XG4gICAgICByZXR1cm4gbGluZVN1ZmZpeCQxKGNvbmNhdCQyKFtoYXJkbGluZSQxLCBpc0xpbmVCZWZvcmVFbXB0eSA/IGhhcmRsaW5lJDEgOiBcIlwiLCBjb250ZW50c10pKTtcbiAgICB9IGVsc2UgaWYgKGlzQmxvY2sgfHwgaXNQYXJlbnRTdXBlckNsYXNzKSB7XG4gICAgICAvLyBUcmFpbGluZyBibG9jayBjb21tZW50cyBuZXZlciBuZWVkIGEgbmV3bGluZVxuICAgICAgcmV0dXJuIGNvbmNhdCQyKFtcIiBcIiwgY29udGVudHNdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uY2F0JDIoW2xpbmVTdWZmaXgkMShjb25jYXQkMihbXCIgXCIsIGNvbnRlbnRzXSkpLCAhaXNCbG9jayA/IGJyZWFrUGFyZW50JDEgOiBcIlwiXSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludERhbmdsaW5nQ29tbWVudHMocGF0aCwgb3B0aW9ucywgc2FtZUluZGVudCwgZmlsdGVyKSB7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgdmFyIG5vZGUgPSBwYXRoLmdldFZhbHVlKCk7XG5cbiAgICBpZiAoIW5vZGUgfHwgIW5vZGUuY29tbWVudHMpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIHBhdGguZWFjaChmdW5jdGlvbiAoY29tbWVudFBhdGgpIHtcbiAgICAgIHZhciBjb21tZW50ID0gY29tbWVudFBhdGguZ2V0VmFsdWUoKTtcblxuICAgICAgaWYgKGNvbW1lbnQgJiYgIWNvbW1lbnQubGVhZGluZyAmJiAhY29tbWVudC50cmFpbGluZyAmJiAoIWZpbHRlciB8fCBmaWx0ZXIoY29tbWVudCkpKSB7XG4gICAgICAgIHBhcnRzLnB1c2gocHJpbnRDb21tZW50KGNvbW1lbnRQYXRoLCBvcHRpb25zKSk7XG4gICAgICB9XG4gICAgfSwgXCJjb21tZW50c1wiKTtcblxuICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIGlmIChzYW1lSW5kZW50KSB7XG4gICAgICByZXR1cm4gam9pbiQxKGhhcmRsaW5lJDEsIHBhcnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZW50JDEoY29uY2F0JDIoW2hhcmRsaW5lJDEsIGpvaW4kMShoYXJkbGluZSQxLCBwYXJ0cyldKSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwZW5kQ3Vyc29yUGxhY2Vob2xkZXIocGF0aCwgb3B0aW9ucywgcHJpbnRlZCkge1xuICAgIGlmIChwYXRoLmdldE5vZGUoKSA9PT0gb3B0aW9ucy5jdXJzb3JOb2RlICYmIHBhdGguZ2V0VmFsdWUoKSkge1xuICAgICAgcmV0dXJuIGNvbmNhdCQyKFtjdXJzb3IkMiwgcHJpbnRlZCwgY3Vyc29yJDJdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJpbnRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50Q29tbWVudHMocGF0aCwgcHJpbnQsIG9wdGlvbnMsIG5lZWRzU2VtaSkge1xuICAgIHZhciB2YWx1ZSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICB2YXIgcHJpbnRlZCA9IHByaW50KHBhdGgpO1xuICAgIHZhciBjb21tZW50cyA9IHZhbHVlICYmIHZhbHVlLmNvbW1lbnRzO1xuXG4gICAgaWYgKCFjb21tZW50cyB8fCBjb21tZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBwcmVwZW5kQ3Vyc29yUGxhY2Vob2xkZXIocGF0aCwgb3B0aW9ucywgcHJpbnRlZCk7XG4gICAgfVxuXG4gICAgdmFyIGxlYWRpbmdQYXJ0cyA9IFtdO1xuICAgIHZhciB0cmFpbGluZ1BhcnRzID0gW25lZWRzU2VtaSA/IFwiO1wiIDogXCJcIiwgcHJpbnRlZF07XG4gICAgcGF0aC5lYWNoKGZ1bmN0aW9uIChjb21tZW50UGF0aCkge1xuICAgICAgdmFyIGNvbW1lbnQgPSBjb21tZW50UGF0aC5nZXRWYWx1ZSgpO1xuICAgICAgdmFyIGxlYWRpbmcgPSBjb21tZW50LmxlYWRpbmcsXG4gICAgICAgICAgdHJhaWxpbmcgPSBjb21tZW50LnRyYWlsaW5nO1xuXG4gICAgICBpZiAobGVhZGluZykge1xuICAgICAgICB2YXIgY29udGVudHMgPSBwcmludExlYWRpbmdDb21tZW50KGNvbW1lbnRQYXRoLCBwcmludCwgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKCFjb250ZW50cykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxlYWRpbmdQYXJ0cy5wdXNoKGNvbnRlbnRzKTtcbiAgICAgICAgdmFyIHRleHQgPSBvcHRpb25zLm9yaWdpbmFsVGV4dDtcbiAgICAgICAgdmFyIGluZGV4ID0gc2tpcE5ld2xpbmUkMSh0ZXh0LCBvcHRpb25zLmxvY0VuZChjb21tZW50KSk7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9PSBmYWxzZSAmJiBoYXNOZXdsaW5lJDEodGV4dCwgaW5kZXgpKSB7XG4gICAgICAgICAgbGVhZGluZ1BhcnRzLnB1c2goaGFyZGxpbmUkMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHJhaWxpbmcpIHtcbiAgICAgICAgdHJhaWxpbmdQYXJ0cy5wdXNoKHByaW50VHJhaWxpbmdDb21tZW50KGNvbW1lbnRQYXRoLCBwcmludCwgb3B0aW9ucykpO1xuICAgICAgfVxuICAgIH0sIFwiY29tbWVudHNcIik7XG4gICAgcmV0dXJuIHByZXBlbmRDdXJzb3JQbGFjZWhvbGRlcihwYXRoLCBvcHRpb25zLCBjb25jYXQkMihsZWFkaW5nUGFydHMuY29uY2F0KHRyYWlsaW5nUGFydHMpKSk7XG4gIH1cblxuICB2YXIgY29tbWVudHMgPSB7XG4gICAgYXR0YWNoOiBhdHRhY2gsXG4gICAgcHJpbnRDb21tZW50czogcHJpbnRDb21tZW50cyxcbiAgICBwcmludERhbmdsaW5nQ29tbWVudHM6IHByaW50RGFuZ2xpbmdDb21tZW50cyxcbiAgICBnZXRTb3J0ZWRDaGlsZE5vZGVzOiBnZXRTb3J0ZWRDaGlsZE5vZGVzXG4gIH07XG5cbiAgZnVuY3Rpb24gRmFzdFBhdGgodmFsdWUpIHtcbiAgICBhc3NlcnQub2sodGhpcyBpbnN0YW5jZW9mIEZhc3RQYXRoKTtcbiAgICB0aGlzLnN0YWNrID0gW3ZhbHVlXTtcbiAgfSAvLyBUaGUgbmFtZSBvZiB0aGUgY3VycmVudCBwcm9wZXJ0eSBpcyBhbHdheXMgdGhlIHBlbnVsdGltYXRlIGVsZW1lbnQgb2ZcbiAgLy8gdGhpcy5zdGFjaywgYW5kIGFsd2F5cyBhIFN0cmluZy5cblxuXG4gIEZhc3RQYXRoLnByb3RvdHlwZS5nZXROYW1lID0gZnVuY3Rpb24gZ2V0TmFtZSgpIHtcbiAgICB2YXIgcyA9IHRoaXMuc3RhY2s7XG4gICAgdmFyIGxlbiA9IHMubGVuZ3RoO1xuXG4gICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgIHJldHVybiBzW2xlbiAtIDJdO1xuICAgIH0gLy8gU2luY2UgdGhlIG5hbWUgaXMgYWx3YXlzIGEgc3RyaW5nLCBudWxsIGlzIGEgc2FmZSBzZW50aW5lbCB2YWx1ZSB0b1xuICAgIC8vIHJldHVybiBpZiB3ZSBkbyBub3Qga25vdyB0aGUgbmFtZSBvZiB0aGUgKHJvb3QpIHZhbHVlLlxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07IC8vIFRoZSB2YWx1ZSBvZiB0aGUgY3VycmVudCBwcm9wZXJ0eSBpcyBhbHdheXMgdGhlIGZpbmFsIGVsZW1lbnQgb2ZcbiAgLy8gdGhpcy5zdGFjay5cblxuXG4gIEZhc3RQYXRoLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICAgIHZhciBzID0gdGhpcy5zdGFjaztcbiAgICByZXR1cm4gc1tzLmxlbmd0aCAtIDFdO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGdldE5vZGVIZWxwZXIocGF0aCwgY291bnQpIHtcbiAgICB2YXIgc3RhY2tJbmRleCA9IGdldE5vZGVTdGFja0luZGV4SGVscGVyKHBhdGguc3RhY2ssIGNvdW50KTtcbiAgICByZXR1cm4gc3RhY2tJbmRleCA9PT0gLTEgPyBudWxsIDogcGF0aC5zdGFja1tzdGFja0luZGV4XTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5vZGVTdGFja0luZGV4SGVscGVyKHN0YWNrLCBjb3VudCkge1xuICAgIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgdmFyIHZhbHVlID0gc3RhY2tbaV07XG5cbiAgICAgIGlmICh2YWx1ZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgLS1jb3VudCA8IDApIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgRmFzdFBhdGgucHJvdG90eXBlLmdldE5vZGUgPSBmdW5jdGlvbiBnZXROb2RlKGNvdW50KSB7XG4gICAgcmV0dXJuIGdldE5vZGVIZWxwZXIodGhpcywgfn5jb3VudCk7XG4gIH07XG5cbiAgRmFzdFBhdGgucHJvdG90eXBlLmdldFBhcmVudE5vZGUgPSBmdW5jdGlvbiBnZXRQYXJlbnROb2RlKGNvdW50KSB7XG4gICAgcmV0dXJuIGdldE5vZGVIZWxwZXIodGhpcywgfn5jb3VudCArIDEpO1xuICB9OyAvLyBUZW1wb3JhcmlseSBwdXNoIHByb3BlcnRpZXMgbmFtZWQgYnkgc3RyaW5nIGFyZ3VtZW50cyBnaXZlbiBhZnRlciB0aGVcbiAgLy8gY2FsbGJhY2sgZnVuY3Rpb24gb250byB0aGlzLnN0YWNrLCB0aGVuIGNhbGwgdGhlIGNhbGxiYWNrIHdpdGggYVxuICAvLyByZWZlcmVuY2UgdG8gdGhpcyAobW9kaWZpZWQpIEZhc3RQYXRoIG9iamVjdC4gTm90ZSB0aGF0IHRoZSBzdGFjayB3aWxsXG4gIC8vIGJlIHJlc3RvcmVkIHRvIGl0cyBvcmlnaW5hbCBzdGF0ZSBhZnRlciB0aGUgY2FsbGJhY2sgaXMgZmluaXNoZWQsIHNvIGl0XG4gIC8vIGlzIHByb2JhYmx5IGEgbWlzdGFrZSB0byByZXRhaW4gYSByZWZlcmVuY2UgdG8gdGhlIHBhdGguXG5cblxuICBGYXN0UGF0aC5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIGNhbGwoY2FsbGJhY2tcbiAgLyosIG5hbWUxLCBuYW1lMiwgLi4uICovXG4gICkge1xuICAgIHZhciBzID0gdGhpcy5zdGFjaztcbiAgICB2YXIgb3JpZ0xlbiA9IHMubGVuZ3RoO1xuICAgIHZhciB2YWx1ZSA9IHNbb3JpZ0xlbiAtIDFdO1xuICAgIHZhciBhcmdjID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJnYzsgKytpKSB7XG4gICAgICB2YXIgbmFtZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIHZhbHVlID0gdmFsdWVbbmFtZV07XG4gICAgICBzLnB1c2gobmFtZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBjYWxsYmFjayh0aGlzKTtcbiAgICBzLmxlbmd0aCA9IG9yaWdMZW47XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBGYXN0UGF0aC5wcm90b3R5cGUuY2FsbFBhcmVudCA9IGZ1bmN0aW9uIGNhbGxQYXJlbnQoY2FsbGJhY2ssIGNvdW50KSB7XG4gICAgdmFyIHN0YWNrSW5kZXggPSBnZXROb2RlU3RhY2tJbmRleEhlbHBlcih0aGlzLnN0YWNrLCB+fmNvdW50ICsgMSk7XG4gICAgdmFyIHBhcmVudFZhbHVlcyA9IHRoaXMuc3RhY2suc3BsaWNlKHN0YWNrSW5kZXggKyAxKTtcbiAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2sodGhpcyk7XG4gICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5zdGFjaywgcGFyZW50VmFsdWVzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9OyAvLyBTaW1pbGFyIHRvIEZhc3RQYXRoLnByb3RvdHlwZS5jYWxsLCBleGNlcHQgdGhhdCB0aGUgdmFsdWUgb2J0YWluZWQgYnlcbiAgLy8gYWNjZXNzaW5nIHRoaXMuZ2V0VmFsdWUoKVtuYW1lMV1bbmFtZTJdLi4uIHNob3VsZCBiZSBhcnJheS1saWtlLiBUaGVcbiAgLy8gY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGlzIHBhdGggb2JqZWN0IGZvciBlYWNoXG4gIC8vIGVsZW1lbnQgb2YgdGhlIGFycmF5LlxuXG5cbiAgRmFzdFBhdGgucHJvdG90eXBlLmVhY2ggPSBmdW5jdGlvbiBlYWNoKGNhbGxiYWNrXG4gIC8qLCBuYW1lMSwgbmFtZTIsIC4uLiAqL1xuICApIHtcbiAgICB2YXIgcyA9IHRoaXMuc3RhY2s7XG4gICAgdmFyIG9yaWdMZW4gPSBzLmxlbmd0aDtcbiAgICB2YXIgdmFsdWUgPSBzW29yaWdMZW4gLSAxXTtcbiAgICB2YXIgYXJnYyA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ2M7ICsraSkge1xuICAgICAgdmFyIG5hbWUgPSBhcmd1bWVudHNbaV07XG4gICAgICB2YWx1ZSA9IHZhbHVlW25hbWVdO1xuICAgICAgcy5wdXNoKG5hbWUsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdmFsdWUubGVuZ3RoOyArK19pKSB7XG4gICAgICBpZiAoX2kgaW4gdmFsdWUpIHtcbiAgICAgICAgcy5wdXNoKF9pLCB2YWx1ZVtfaV0pOyAvLyBJZiB0aGUgY2FsbGJhY2sgbmVlZHMgdG8ga25vdyB0aGUgdmFsdWUgb2YgaSwgY2FsbFxuICAgICAgICAvLyBwYXRoLmdldE5hbWUoKSwgYXNzdW1pbmcgcGF0aCBpcyB0aGUgcGFyYW1ldGVyIG5hbWUuXG5cbiAgICAgICAgY2FsbGJhY2sodGhpcyk7XG4gICAgICAgIHMubGVuZ3RoIC09IDI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcy5sZW5ndGggPSBvcmlnTGVuO1xuICB9OyAvLyBTaW1pbGFyIHRvIEZhc3RQYXRoLnByb3RvdHlwZS5lYWNoLCBleGNlcHQgdGhhdCB0aGUgcmVzdWx0cyBvZiB0aGVcbiAgLy8gY2FsbGJhY2sgZnVuY3Rpb24gaW52b2NhdGlvbnMgYXJlIHN0b3JlZCBpbiBhbiBhcnJheSBhbmQgcmV0dXJuZWQgYXRcbiAgLy8gdGhlIGVuZCBvZiB0aGUgaXRlcmF0aW9uLlxuXG5cbiAgRmFzdFBhdGgucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcChjYWxsYmFja1xuICAvKiwgbmFtZTEsIG5hbWUyLCAuLi4gKi9cbiAgKSB7XG4gICAgdmFyIHMgPSB0aGlzLnN0YWNrO1xuICAgIHZhciBvcmlnTGVuID0gcy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlID0gc1tvcmlnTGVuIC0gMV07XG4gICAgdmFyIGFyZ2MgPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdjOyArK2kpIHtcbiAgICAgIHZhciBuYW1lID0gYXJndW1lbnRzW2ldO1xuICAgICAgdmFsdWUgPSB2YWx1ZVtuYW1lXTtcbiAgICAgIHMucHVzaChuYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheSh2YWx1ZS5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgdmFsdWUubGVuZ3RoOyArK19pMikge1xuICAgICAgaWYgKF9pMiBpbiB2YWx1ZSkge1xuICAgICAgICBzLnB1c2goX2kyLCB2YWx1ZVtfaTJdKTtcbiAgICAgICAgcmVzdWx0W19pMl0gPSBjYWxsYmFjayh0aGlzLCBfaTIpO1xuICAgICAgICBzLmxlbmd0aCAtPSAyO1xuICAgICAgfVxuICAgIH1cblxuICAgIHMubGVuZ3RoID0gb3JpZ0xlbjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciBmYXN0UGF0aCA9IEZhc3RQYXRoO1xuXG4gIHZhciBub3JtYWxpemUkMiA9IG9wdGlvbnMkMS5ub3JtYWxpemU7XG5cbiAgZnVuY3Rpb24gcHJpbnRTdWJ0cmVlKHBhdGgsIHByaW50LCBvcHRpb25zLCBwcmludEFzdFRvRG9jKSB7XG4gICAgaWYgKG9wdGlvbnMucHJpbnRlci5lbWJlZCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMucHJpbnRlci5lbWJlZChwYXRoLCBwcmludCwgZnVuY3Rpb24gKHRleHQsIHBhcnRpYWxOZXh0T3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGV4dFRvRG9jKHRleHQsIHBhcnRpYWxOZXh0T3B0aW9ucywgb3B0aW9ucywgcHJpbnRBc3RUb0RvYyk7XG4gICAgICB9LCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0ZXh0VG9Eb2ModGV4dCwgcGFydGlhbE5leHRPcHRpb25zLCBwYXJlbnRPcHRpb25zLCBwcmludEFzdFRvRG9jKSB7XG4gICAgdmFyIG5leHRPcHRpb25zID0gbm9ybWFsaXplJDIoT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50T3B0aW9ucywgcGFydGlhbE5leHRPcHRpb25zLCB7XG4gICAgICBwYXJlbnRQYXJzZXI6IHBhcmVudE9wdGlvbnMucGFyc2VyLFxuICAgICAgZW1iZWRkZWRJbkh0bWw6ICEhKHBhcmVudE9wdGlvbnMuZW1iZWRkZWRJbkh0bWwgfHwgcGFyZW50T3B0aW9ucy5wYXJzZXIgPT09IFwiaHRtbFwiIHx8IHBhcmVudE9wdGlvbnMucGFyc2VyID09PSBcInZ1ZVwiIHx8IHBhcmVudE9wdGlvbnMucGFyc2VyID09PSBcImFuZ3VsYXJcIiB8fCBwYXJlbnRPcHRpb25zLnBhcnNlciA9PT0gXCJsd2NcIiksXG4gICAgICBvcmlnaW5hbFRleHQ6IHRleHRcbiAgICB9KSwge1xuICAgICAgcGFzc1Rocm91Z2g6IHRydWVcbiAgICB9KTtcbiAgICB2YXIgcmVzdWx0ID0gcGFyc2VyLnBhcnNlKHRleHQsIG5leHRPcHRpb25zKTtcbiAgICB2YXIgYXN0ID0gcmVzdWx0LmFzdDtcbiAgICB0ZXh0ID0gcmVzdWx0LnRleHQ7XG4gICAgdmFyIGFzdENvbW1lbnRzID0gYXN0LmNvbW1lbnRzO1xuICAgIGRlbGV0ZSBhc3QuY29tbWVudHM7XG4gICAgY29tbWVudHMuYXR0YWNoKGFzdENvbW1lbnRzLCBhc3QsIHRleHQsIG5leHRPcHRpb25zKTtcbiAgICByZXR1cm4gcHJpbnRBc3RUb0RvYyhhc3QsIG5leHRPcHRpb25zKTtcbiAgfVxuXG4gIHZhciBtdWx0aXBhcnNlciA9IHtcbiAgICBwcmludFN1YnRyZWU6IHByaW50U3VidHJlZVxuICB9O1xuXG4gIHZhciBkb2MkMSA9IGRvYztcbiAgdmFyIGRvY0J1aWxkZXJzJDEgPSBkb2MkMS5idWlsZGVycztcbiAgdmFyIGNvbmNhdCQzID0gZG9jQnVpbGRlcnMkMS5jb25jYXQ7XG4gIHZhciBoYXJkbGluZSQyID0gZG9jQnVpbGRlcnMkMS5oYXJkbGluZTtcbiAgdmFyIGFkZEFsaWdubWVudFRvRG9jJDEgPSBkb2NCdWlsZGVycyQxLmFkZEFsaWdubWVudFRvRG9jO1xuICB2YXIgZG9jVXRpbHMkMSA9IGRvYyQxLnV0aWxzO1xuICAvKipcbiAgICogVGFrZXMgYW4gYWJzdHJhY3Qgc3ludGF4IHRyZWUgKEFTVCkgYW5kIHJlY3Vyc2l2ZWx5IGNvbnZlcnRzIGl0IHRvIGFcbiAgICogZG9jdW1lbnQgKHNlcmllcyBvZiBwcmludGluZyBwcmltaXRpdmVzKS5cbiAgICpcbiAgICogVGhpcyBpcyBkb25lIGJ5IGRlc2NlbmRpbmcgZG93biB0aGUgQVNUIHJlY3Vyc2l2ZWx5LiBUaGUgcmVjdXJzaW9uXG4gICAqIGludm9sdmVzIHR3byBmdW5jdGlvbnMgdGhhdCBjYWxsIGVhY2ggb3RoZXI6XG4gICAqXG4gICAqIDEuIHByaW50R2VuZXJpY2FsbHkoKSwgd2hpY2ggaXMgZGVmaW5lZCBhcyBhbiBpbm5lciBmdW5jdGlvbiBoZXJlLlxuICAgKiAgICBJdCBiYXNpY2FsbHkgdGFrZXMgY2FyZSBvZiBub2RlIGNhY2hpbmcuXG4gICAqIDIuIGNhbGxQbHVnaW5QcmludEZ1bmN0aW9uKCksIHdoaWNoIGNoZWNrcyBmb3Igc29tZSBvcHRpb25zLCBhbmRcbiAgICogICAgdWx0aW1hdGVseSBjYWxscyB0aGUgcHJpbnQoKSBmdW5jdGlvbiBwcm92aWRlZCBieSB0aGUgcGx1Z2luLlxuICAgKlxuICAgKiBUaGUgcGx1Z2luIGZ1bmN0aW9uIHdpbGwgY2FsbCBwcmludEdlbmVyaWNhbGx5KCkgYWdhaW4gZm9yIGNoaWxkIG5vZGVzXG4gICAqIG9mIHRoZSBjdXJyZW50IG5vZGUsIHdoaWNoIHdpbGwgZG8gaXRzIGhvdXNla2VlcGluZywgdGhlbiBjYWxsIHRoZVxuICAgKiBwbHVnaW4gZnVuY3Rpb24gYWdhaW4sIGFuZCBzbyBvbi5cbiAgICpcbiAgICogQWxsIHRoZSB3aGlsZSwgdGhlc2UgZnVuY3Rpb25zIHBhc3MgYSBcInBhdGhcIiB2YXJpYWJsZSBhcm91bmQsIHdoaWNoXG4gICAqIGlzIGEgc3RhY2stbGlrZSBkYXRhIHN0cnVjdHVyZSAoRmFzdFBhdGgpIHRoYXQgbWFpbnRhaW5zIHRoZSBjdXJyZW50XG4gICAqIHN0YXRlIG9mIHRoZSByZWN1cnNpb24uIEl0IGlzIGNhbGxlZCBcInBhdGhcIiwgYmVjYXVzZSBpdCByZXByZXNlbnRzXG4gICAqIHRoZSBwYXRoIHRvIHRoZSBjdXJyZW50IG5vZGUgdGhyb3VnaCB0aGUgQWJzdHJhY3QgU3ludGF4IFRyZWUuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHByaW50QXN0VG9Eb2MoYXN0LCBvcHRpb25zKSB7XG4gICAgdmFyIGFsaWdubWVudFNpemUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgdmFyIHByaW50ZXIgPSBvcHRpb25zLnByaW50ZXI7XG5cbiAgICBpZiAocHJpbnRlci5wcmVwcm9jZXNzKSB7XG4gICAgICBhc3QgPSBwcmludGVyLnByZXByb2Nlc3MoYXN0LCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB2YXIgY2FjaGUgPSBuZXcgTWFwKCk7XG5cbiAgICBmdW5jdGlvbiBwcmludEdlbmVyaWNhbGx5KHBhdGgsIGFyZ3MpIHtcbiAgICAgIHZhciBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgICAgdmFyIHNob3VsZENhY2hlID0gbm9kZSAmJiBfdHlwZW9mKG5vZGUpID09PSBcIm9iamVjdFwiICYmIGFyZ3MgPT09IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHNob3VsZENhY2hlICYmIGNhY2hlLmhhcyhub2RlKSkge1xuICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KG5vZGUpO1xuICAgICAgfSAvLyBXZSBsZXQgSlNYRWxlbWVudCBwcmludCBpdHMgY29tbWVudHMgaXRzZWxmIGJlY2F1c2UgaXQgYWRkcyAoKSBhcm91bmRcbiAgICAgIC8vIFVuaW9uVHlwZUFubm90YXRpb24gaGFzIHRvIGFsaWduIHRoZSBjaGlsZCB3aXRob3V0IHRoZSBjb21tZW50c1xuXG5cbiAgICAgIHZhciByZXM7XG5cbiAgICAgIGlmIChwcmludGVyLndpbGxQcmludE93bkNvbW1lbnRzICYmIHByaW50ZXIud2lsbFByaW50T3duQ29tbWVudHMocGF0aCwgb3B0aW9ucykpIHtcbiAgICAgICAgcmVzID0gY2FsbFBsdWdpblByaW50RnVuY3Rpb24ocGF0aCwgb3B0aW9ucywgcHJpbnRHZW5lcmljYWxseSwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBwcmludENvbW1lbnRzIHdpbGwgY2FsbCB0aGUgcGx1Z2luIHByaW50IGZ1bmN0aW9uIGFuZCBjaGVjayBmb3JcbiAgICAgICAgLy8gY29tbWVudHMgdG8gcHJpbnRcbiAgICAgICAgcmVzID0gY29tbWVudHMucHJpbnRDb21tZW50cyhwYXRoLCBmdW5jdGlvbiAocCkge1xuICAgICAgICAgIHJldHVybiBjYWxsUGx1Z2luUHJpbnRGdW5jdGlvbihwLCBvcHRpb25zLCBwcmludEdlbmVyaWNhbGx5LCBhcmdzKTtcbiAgICAgICAgfSwgb3B0aW9ucywgYXJncyAmJiBhcmdzLm5lZWRzU2VtaSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRDYWNoZSkge1xuICAgICAgICBjYWNoZS5zZXQobm9kZSwgcmVzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICB2YXIgZG9jID0gcHJpbnRHZW5lcmljYWxseShuZXcgZmFzdFBhdGgoYXN0KSk7XG5cbiAgICBpZiAoYWxpZ25tZW50U2l6ZSA+IDApIHtcbiAgICAgIC8vIEFkZCBhIGhhcmRsaW5lIHRvIG1ha2UgdGhlIGluZGVudHMgdGFrZSBlZmZlY3RcbiAgICAgIC8vIEl0IHNob3VsZCBiZSByZW1vdmVkIGluIGluZGV4LmpzIGZvcm1hdCgpXG4gICAgICBkb2MgPSBhZGRBbGlnbm1lbnRUb0RvYyQxKGNvbmNhdCQzKFtoYXJkbGluZSQyLCBkb2NdKSwgYWxpZ25tZW50U2l6ZSwgb3B0aW9ucy50YWJXaWR0aCk7XG4gICAgfVxuXG4gICAgZG9jVXRpbHMkMS5wcm9wYWdhdGVCcmVha3MoZG9jKTtcbiAgICByZXR1cm4gZG9jO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FsbFBsdWdpblByaW50RnVuY3Rpb24ocGF0aCwgb3B0aW9ucywgcHJpbnRQYXRoLCBhcmdzKSB7XG4gICAgYXNzZXJ0Lm9rKHBhdGggaW5zdGFuY2VvZiBmYXN0UGF0aCk7XG4gICAgdmFyIG5vZGUgPSBwYXRoLmdldFZhbHVlKCk7XG4gICAgdmFyIHByaW50ZXIgPSBvcHRpb25zLnByaW50ZXI7IC8vIEVzY2FwZSBoYXRjaFxuXG4gICAgaWYgKHByaW50ZXIuaGFzUHJldHRpZXJJZ25vcmUgJiYgcHJpbnRlci5oYXNQcmV0dGllcklnbm9yZShwYXRoKSkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMub3JpZ2luYWxUZXh0LnNsaWNlKG9wdGlvbnMubG9jU3RhcnQobm9kZSksIG9wdGlvbnMubG9jRW5kKG5vZGUpKTtcbiAgICB9XG5cbiAgICBpZiAobm9kZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gUG90ZW50aWFsbHkgc3dpdGNoIHRvIGEgZGlmZmVyZW50IHBhcnNlclxuICAgICAgICB2YXIgc3ViID0gbXVsdGlwYXJzZXIucHJpbnRTdWJ0cmVlKHBhdGgsIHByaW50UGF0aCwgb3B0aW9ucywgcHJpbnRBc3RUb0RvYyk7XG5cbiAgICAgICAgaWYgKHN1Yikge1xuICAgICAgICAgIHJldHVybiBzdWI7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoY29tbW9uanNHbG9iYWwuUFJFVFRJRVJfREVCVUcpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSAvLyBDb250aW51ZSB3aXRoIGN1cnJlbnQgcGFyc2VyXG5cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcHJpbnRlci5wcmludChwYXRoLCBvcHRpb25zLCBwcmludFBhdGgsIGFyZ3MpO1xuICB9XG5cbiAgdmFyIGFzdFRvRG9jID0gcHJpbnRBc3RUb0RvYztcblxuICBmdW5jdGlvbiBmaW5kU2libGluZ0FuY2VzdG9ycyhzdGFydE5vZGVBbmRQYXJlbnRzLCBlbmROb2RlQW5kUGFyZW50cywgb3B0cykge1xuICAgIHZhciByZXN1bHRTdGFydE5vZGUgPSBzdGFydE5vZGVBbmRQYXJlbnRzLm5vZGU7XG4gICAgdmFyIHJlc3VsdEVuZE5vZGUgPSBlbmROb2RlQW5kUGFyZW50cy5ub2RlO1xuXG4gICAgaWYgKHJlc3VsdFN0YXJ0Tm9kZSA9PT0gcmVzdWx0RW5kTm9kZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnROb2RlOiByZXN1bHRTdGFydE5vZGUsXG4gICAgICAgIGVuZE5vZGU6IHJlc3VsdEVuZE5vZGVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBlbmROb2RlQW5kUGFyZW50cy5wYXJlbnROb2Rlc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgdmFyIGVuZFBhcmVudCA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgIGlmIChlbmRQYXJlbnQudHlwZSAhPT0gXCJQcm9ncmFtXCIgJiYgZW5kUGFyZW50LnR5cGUgIT09IFwiRmlsZVwiICYmIG9wdHMubG9jU3RhcnQoZW5kUGFyZW50KSA+PSBvcHRzLmxvY1N0YXJ0KHN0YXJ0Tm9kZUFuZFBhcmVudHMubm9kZSkpIHtcbiAgICAgICAgICByZXN1bHRFbmROb2RlID0gZW5kUGFyZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBzdGFydE5vZGVBbmRQYXJlbnRzLnBhcmVudE5vZGVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG4gICAgICAgIHZhciBzdGFydFBhcmVudCA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICBpZiAoc3RhcnRQYXJlbnQudHlwZSAhPT0gXCJQcm9ncmFtXCIgJiYgc3RhcnRQYXJlbnQudHlwZSAhPT0gXCJGaWxlXCIgJiYgb3B0cy5sb2NFbmQoc3RhcnRQYXJlbnQpIDw9IG9wdHMubG9jRW5kKGVuZE5vZGVBbmRQYXJlbnRzLm5vZGUpKSB7XG4gICAgICAgICAgcmVzdWx0U3RhcnROb2RlID0gc3RhcnRQYXJlbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnROb2RlOiByZXN1bHRTdGFydE5vZGUsXG4gICAgICBlbmROb2RlOiByZXN1bHRFbmROb2RlXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmROb2RlQXRPZmZzZXQobm9kZSwgb2Zmc2V0LCBvcHRpb25zLCBwcmVkaWNhdGUsIHBhcmVudE5vZGVzKSB7XG4gICAgcHJlZGljYXRlID0gcHJlZGljYXRlIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBwYXJlbnROb2RlcyA9IHBhcmVudE5vZGVzIHx8IFtdO1xuICAgIHZhciBzdGFydCA9IG9wdGlvbnMubG9jU3RhcnQobm9kZSwgb3B0aW9ucy5sb2NTdGFydCk7XG4gICAgdmFyIGVuZCA9IG9wdGlvbnMubG9jRW5kKG5vZGUsIG9wdGlvbnMubG9jRW5kKTtcblxuICAgIGlmIChzdGFydCA8PSBvZmZzZXQgJiYgb2Zmc2V0IDw9IGVuZCkge1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjMgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjMgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSBjb21tZW50cy5nZXRTb3J0ZWRDaGlsZE5vZGVzKG5vZGUsIG9wdGlvbnMpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAzOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gKF9zdGVwMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IF9zdGVwMy52YWx1ZTtcbiAgICAgICAgICB2YXIgY2hpbGRSZXN1bHQgPSBmaW5kTm9kZUF0T2Zmc2V0KGNoaWxkTm9kZSwgb2Zmc2V0LCBvcHRpb25zLCBwcmVkaWNhdGUsIFtub2RlXS5jb25jYXQocGFyZW50Tm9kZXMpKTtcblxuICAgICAgICAgIGlmIChjaGlsZFJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yMyA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyAmJiBfaXRlcmF0b3IzLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IzLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIHBhcmVudE5vZGVzOiBwYXJlbnROb2Rlc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBTZWUgaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi81LjEvI3NlYy1BLjVcblxuXG4gIGZ1bmN0aW9uIGlzU291cmNlRWxlbWVudChvcHRzLCBub2RlKSB7XG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gSlMgYW5kIEpTIGxpa2UgdG8gYXZvaWQgcmVwZXRpdGlvbnNcblxuXG4gICAgdmFyIGpzU291cmNlRWxlbWVudHMgPSBbXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIsIFwiQmxvY2tTdGF0ZW1lbnRcIiwgXCJCcmVha1N0YXRlbWVudFwiLCBcIkNvbnRpbnVlU3RhdGVtZW50XCIsIFwiRGVidWdnZXJTdGF0ZW1lbnRcIiwgXCJEb1doaWxlU3RhdGVtZW50XCIsIFwiRW1wdHlTdGF0ZW1lbnRcIiwgXCJFeHByZXNzaW9uU3RhdGVtZW50XCIsIFwiRm9ySW5TdGF0ZW1lbnRcIiwgXCJGb3JTdGF0ZW1lbnRcIiwgXCJJZlN0YXRlbWVudFwiLCBcIkxhYmVsZWRTdGF0ZW1lbnRcIiwgXCJSZXR1cm5TdGF0ZW1lbnRcIiwgXCJTd2l0Y2hTdGF0ZW1lbnRcIiwgXCJUaHJvd1N0YXRlbWVudFwiLCBcIlRyeVN0YXRlbWVudFwiLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiwgXCJXaGlsZVN0YXRlbWVudFwiLCBcIldpdGhTdGF0ZW1lbnRcIiwgXCJDbGFzc0RlY2xhcmF0aW9uXCIsIC8vIEVTIDIwMTVcbiAgICBcIkltcG9ydERlY2xhcmF0aW9uXCIsIC8vIE1vZHVsZVxuICAgIFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIsIC8vIE1vZHVsZVxuICAgIFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiLCAvLyBNb2R1bGVcbiAgICBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIsIC8vIE1vZHVsZVxuICAgIFwiVHlwZUFsaWFzXCIsIC8vIEZsb3dcbiAgICBcIkludGVyZmFjZURlY2xhcmF0aW9uXCIsIC8vIEZsb3csIFR5cGVTY3JpcHRcbiAgICBcIlR5cGVBbGlhc0RlY2xhcmF0aW9uXCIsIC8vIFR5cGVTY3JpcHRcbiAgICBcIkV4cG9ydEFzc2lnbm1lbnRcIiwgLy8gVHlwZVNjcmlwdFxuICAgIFwiRXhwb3J0RGVjbGFyYXRpb25cIiAvLyBUeXBlU2NyaXB0XG4gICAgXTtcbiAgICB2YXIganNvblNvdXJjZUVsZW1lbnRzID0gW1wiT2JqZWN0RXhwcmVzc2lvblwiLCBcIkFycmF5RXhwcmVzc2lvblwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJOdW1lcmljTGl0ZXJhbFwiLCBcIkJvb2xlYW5MaXRlcmFsXCIsIFwiTnVsbExpdGVyYWxcIl07XG4gICAgdmFyIGdyYXBocWxTb3VyY2VFbGVtZW50cyA9IFtcIk9wZXJhdGlvbkRlZmluaXRpb25cIiwgXCJGcmFnbWVudERlZmluaXRpb25cIiwgXCJWYXJpYWJsZURlZmluaXRpb25cIiwgXCJUeXBlRXh0ZW5zaW9uRGVmaW5pdGlvblwiLCBcIk9iamVjdFR5cGVEZWZpbml0aW9uXCIsIFwiRmllbGREZWZpbml0aW9uXCIsIFwiRGlyZWN0aXZlRGVmaW5pdGlvblwiLCBcIkVudW1UeXBlRGVmaW5pdGlvblwiLCBcIkVudW1WYWx1ZURlZmluaXRpb25cIiwgXCJJbnB1dFZhbHVlRGVmaW5pdGlvblwiLCBcIklucHV0T2JqZWN0VHlwZURlZmluaXRpb25cIiwgXCJTY2hlbWFEZWZpbml0aW9uXCIsIFwiT3BlcmF0aW9uVHlwZURlZmluaXRpb25cIiwgXCJJbnRlcmZhY2VUeXBlRGVmaW5pdGlvblwiLCBcIlVuaW9uVHlwZURlZmluaXRpb25cIiwgXCJTY2FsYXJUeXBlRGVmaW5pdGlvblwiXTtcblxuICAgIHN3aXRjaCAob3B0cy5wYXJzZXIpIHtcbiAgICAgIGNhc2UgXCJmbG93XCI6XG4gICAgICBjYXNlIFwiYmFiZWxcIjpcbiAgICAgIGNhc2UgXCJ0eXBlc2NyaXB0XCI6XG4gICAgICAgIHJldHVybiBqc1NvdXJjZUVsZW1lbnRzLmluZGV4T2Yobm9kZS50eXBlKSA+IC0xO1xuXG4gICAgICBjYXNlIFwianNvblwiOlxuICAgICAgICByZXR1cm4ganNvblNvdXJjZUVsZW1lbnRzLmluZGV4T2Yobm9kZS50eXBlKSA+IC0xO1xuXG4gICAgICBjYXNlIFwiZ3JhcGhxbFwiOlxuICAgICAgICByZXR1cm4gZ3JhcGhxbFNvdXJjZUVsZW1lbnRzLmluZGV4T2Yobm9kZS5raW5kKSA+IC0xO1xuXG4gICAgICBjYXNlIFwidnVlXCI6XG4gICAgICAgIHJldHVybiBub2RlLnRhZyAhPT0gXCJyb290XCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FsY3VsYXRlUmFuZ2UodGV4dCwgb3B0cywgYXN0KSB7XG4gICAgLy8gQ29udHJhY3QgdGhlIHJhbmdlIHNvIHRoYXQgaXQgaGFzIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgYXQgaXRzIGVuZHBvaW50cy5cbiAgICAvLyBUaGlzIGVuc3VyZXMgd2UgY2FuIGZvcm1hdCBhIHJhbmdlIHRoYXQgZG9lc24ndCBlbmQgb24gYSBub2RlLlxuICAgIHZhciByYW5nZVN0cmluZ09yaWcgPSB0ZXh0LnNsaWNlKG9wdHMucmFuZ2VTdGFydCwgb3B0cy5yYW5nZUVuZCk7XG4gICAgdmFyIHN0YXJ0Tm9uV2hpdGVzcGFjZSA9IE1hdGgubWF4KG9wdHMucmFuZ2VTdGFydCArIHJhbmdlU3RyaW5nT3JpZy5zZWFyY2goL1xcUy8pLCBvcHRzLnJhbmdlU3RhcnQpO1xuICAgIHZhciBlbmROb25XaGl0ZXNwYWNlO1xuXG4gICAgZm9yIChlbmROb25XaGl0ZXNwYWNlID0gb3B0cy5yYW5nZUVuZDsgZW5kTm9uV2hpdGVzcGFjZSA+IG9wdHMucmFuZ2VTdGFydDsgLS1lbmROb25XaGl0ZXNwYWNlKSB7XG4gICAgICBpZiAodGV4dFtlbmROb25XaGl0ZXNwYWNlIC0gMV0ubWF0Y2goL1xcUy8pKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzdGFydE5vZGVBbmRQYXJlbnRzID0gZmluZE5vZGVBdE9mZnNldChhc3QsIHN0YXJ0Tm9uV2hpdGVzcGFjZSwgb3B0cywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBpc1NvdXJjZUVsZW1lbnQob3B0cywgbm9kZSk7XG4gICAgfSk7XG4gICAgdmFyIGVuZE5vZGVBbmRQYXJlbnRzID0gZmluZE5vZGVBdE9mZnNldChhc3QsIGVuZE5vbldoaXRlc3BhY2UsIG9wdHMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gaXNTb3VyY2VFbGVtZW50KG9wdHMsIG5vZGUpO1xuICAgIH0pO1xuXG4gICAgaWYgKCFzdGFydE5vZGVBbmRQYXJlbnRzIHx8ICFlbmROb2RlQW5kUGFyZW50cykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmFuZ2VTdGFydDogMCxcbiAgICAgICAgcmFuZ2VFbmQ6IDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHNpYmxpbmdBbmNlc3RvcnMgPSBmaW5kU2libGluZ0FuY2VzdG9ycyhzdGFydE5vZGVBbmRQYXJlbnRzLCBlbmROb2RlQW5kUGFyZW50cywgb3B0cyk7XG4gICAgdmFyIHN0YXJ0Tm9kZSA9IHNpYmxpbmdBbmNlc3RvcnMuc3RhcnROb2RlLFxuICAgICAgICBlbmROb2RlID0gc2libGluZ0FuY2VzdG9ycy5lbmROb2RlO1xuICAgIHZhciByYW5nZVN0YXJ0ID0gTWF0aC5taW4ob3B0cy5sb2NTdGFydChzdGFydE5vZGUsIG9wdHMubG9jU3RhcnQpLCBvcHRzLmxvY1N0YXJ0KGVuZE5vZGUsIG9wdHMubG9jU3RhcnQpKTtcbiAgICB2YXIgcmFuZ2VFbmQgPSBNYXRoLm1heChvcHRzLmxvY0VuZChzdGFydE5vZGUsIG9wdHMubG9jRW5kKSwgb3B0cy5sb2NFbmQoZW5kTm9kZSwgb3B0cy5sb2NFbmQpKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmFuZ2VTdGFydDogcmFuZ2VTdGFydCxcbiAgICAgIHJhbmdlRW5kOiByYW5nZUVuZFxuICAgIH07XG4gIH1cblxuICB2YXIgcmFuZ2VVdGlsID0ge1xuICAgIGNhbGN1bGF0ZVJhbmdlOiBjYWxjdWxhdGVSYW5nZSxcbiAgICBmaW5kTm9kZUF0T2Zmc2V0OiBmaW5kTm9kZUF0T2Zmc2V0XG4gIH07XG5cbiAgdmFyIGRpZmYgPSBnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlKGluZGV4X2VzNik7XG5cbiAgdmFyIG5vcm1hbGl6ZU9wdGlvbnMkMSA9IG9wdGlvbnMkMS5ub3JtYWxpemU7XG4gIHZhciBndWVzc0VuZE9mTGluZSQxID0gZW5kT2ZMaW5lLmd1ZXNzRW5kT2ZMaW5lLFxuICAgICAgY29udmVydEVuZE9mTGluZVRvQ2hhcnMkMiA9IGVuZE9mTGluZS5jb252ZXJ0RW5kT2ZMaW5lVG9DaGFycztcbiAgdmFyIG1hcERvYyQyID0gZG9jLnV0aWxzLm1hcERvYyxcbiAgICAgIF9wcmludERvY1RvU3RyaW5nID0gZG9jLnByaW50ZXIucHJpbnREb2NUb1N0cmluZyxcbiAgICAgIHByaW50RG9jVG9EZWJ1ZyA9IGRvYy5kZWJ1Zy5wcmludERvY1RvRGVidWc7XG4gIHZhciBVVEY4Qk9NID0gMHhmZWZmO1xuICB2YXIgQ1VSU09SID0gU3ltYm9sKFwiY3Vyc29yXCIpO1xuICB2YXIgUExBQ0VIT0xERVJTID0ge1xuICAgIGN1cnNvck9mZnNldDogXCI8PDxQUkVUVElFUl9DVVJTT1I+Pj5cIixcbiAgICByYW5nZVN0YXJ0OiBcIjw8PFBSRVRUSUVSX1JBTkdFX1NUQVJUPj4+XCIsXG4gICAgcmFuZ2VFbmQ6IFwiPDw8UFJFVFRJRVJfUkFOR0VfRU5EPj4+XCJcbiAgfTtcblxuICBmdW5jdGlvbiBlbnN1cmVBbGxDb21tZW50c1ByaW50ZWQoYXN0Q29tbWVudHMpIHtcbiAgICBpZiAoIWFzdENvbW1lbnRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhc3RDb21tZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGFzdENvbW1lbnRzW2ldLnZhbHVlLnRyaW0oKSA9PT0gXCJwcmV0dGllci1pZ25vcmVcIikge1xuICAgICAgICAvLyBJZiB0aGVyZSdzIGEgcHJldHRpZXItaWdub3JlLCB3ZSdyZSBub3QgcHJpbnRpbmcgdGhhdCBzdWItdHJlZSBzbyB3ZVxuICAgICAgICAvLyBkb24ndCBrbm93IGlmIHRoZSBjb21tZW50cyB3YXMgcHJpbnRlZCBvciBub3QuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhc3RDb21tZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21tZW50KSB7XG4gICAgICBpZiAoIWNvbW1lbnQucHJpbnRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbW1lbnQgXCInICsgY29tbWVudC52YWx1ZS50cmltKCkgKyAnXCIgd2FzIG5vdCBwcmludGVkLiBQbGVhc2UgcmVwb3J0IHRoaXMgZXJyb3IhJyk7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBjb21tZW50LnByaW50ZWQ7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhdHRhY2hDb21tZW50cyh0ZXh0LCBhc3QsIG9wdHMpIHtcbiAgICB2YXIgYXN0Q29tbWVudHMgPSBhc3QuY29tbWVudHM7XG5cbiAgICBpZiAoYXN0Q29tbWVudHMpIHtcbiAgICAgIGRlbGV0ZSBhc3QuY29tbWVudHM7XG4gICAgICBjb21tZW50cy5hdHRhY2goYXN0Q29tbWVudHMsIGFzdCwgdGV4dCwgb3B0cyk7XG4gICAgfVxuXG4gICAgYXN0LnRva2VucyA9IFtdO1xuICAgIG9wdHMub3JpZ2luYWxUZXh0ID0gb3B0cy5wYXJzZXIgPT09IFwieWFtbFwiID8gdGV4dCA6IHRleHQudHJpbVJpZ2h0KCk7XG4gICAgcmV0dXJuIGFzdENvbW1lbnRzO1xuICB9XG5cbiAgZnVuY3Rpb24gY29yZUZvcm1hdCh0ZXh0LCBvcHRzLCBhZGRBbGlnbm1lbnRTaXplKSB7XG4gICAgaWYgKCF0ZXh0IHx8ICF0ZXh0LnRyaW0oKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZvcm1hdHRlZDogXCJcIixcbiAgICAgICAgY3Vyc29yT2Zmc2V0OiAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIGFkZEFsaWdubWVudFNpemUgPSBhZGRBbGlnbm1lbnRTaXplIHx8IDA7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlci5wYXJzZSh0ZXh0LCBvcHRzKTtcbiAgICB2YXIgYXN0ID0gcGFyc2VkLmFzdDtcbiAgICB0ZXh0ID0gcGFyc2VkLnRleHQ7XG5cbiAgICBpZiAob3B0cy5jdXJzb3JPZmZzZXQgPj0gMCkge1xuICAgICAgdmFyIG5vZGVSZXN1bHQgPSByYW5nZVV0aWwuZmluZE5vZGVBdE9mZnNldChhc3QsIG9wdHMuY3Vyc29yT2Zmc2V0LCBvcHRzKTtcblxuICAgICAgaWYgKG5vZGVSZXN1bHQgJiYgbm9kZVJlc3VsdC5ub2RlKSB7XG4gICAgICAgIG9wdHMuY3Vyc29yTm9kZSA9IG5vZGVSZXN1bHQubm9kZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYXN0Q29tbWVudHMgPSBhdHRhY2hDb21tZW50cyh0ZXh0LCBhc3QsIG9wdHMpO1xuICAgIHZhciBkb2MgPSBhc3RUb0RvYyhhc3QsIG9wdHMsIGFkZEFsaWdubWVudFNpemUpO1xuICAgIHZhciBlb2wgPSBjb252ZXJ0RW5kT2ZMaW5lVG9DaGFycyQyKG9wdHMuZW5kT2ZMaW5lKTtcblxuICAgIHZhciByZXN1bHQgPSBfcHJpbnREb2NUb1N0cmluZyhvcHRzLmVuZE9mTGluZSA9PT0gXCJsZlwiID8gZG9jIDogbWFwRG9jJDIoZG9jLCBmdW5jdGlvbiAoY3VycmVudERvYykge1xuICAgICAgcmV0dXJuIHR5cGVvZiBjdXJyZW50RG9jID09PSBcInN0cmluZ1wiICYmIGN1cnJlbnREb2MuaW5kZXhPZihcIlxcblwiKSAhPT0gLTEgPyBjdXJyZW50RG9jLnJlcGxhY2UoL1xcbi9nLCBlb2wpIDogY3VycmVudERvYztcbiAgICB9KSwgb3B0cyk7XG5cbiAgICBlbnN1cmVBbGxDb21tZW50c1ByaW50ZWQoYXN0Q29tbWVudHMpOyAvLyBSZW1vdmUgZXh0cmEgbGVhZGluZyBpbmRlbnRhdGlvbiBhcyB3ZWxsIGFzIHRoZSBhZGRlZCBpbmRlbnRhdGlvbiBhZnRlciBsYXN0IG5ld2xpbmVcblxuICAgIGlmIChhZGRBbGlnbm1lbnRTaXplID4gMCkge1xuICAgICAgdmFyIHRyaW1tZWQgPSByZXN1bHQuZm9ybWF0dGVkLnRyaW0oKTtcblxuICAgICAgaWYgKHJlc3VsdC5jdXJzb3JOb2RlU3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQuY3Vyc29yTm9kZVN0YXJ0IC09IHJlc3VsdC5mb3JtYXR0ZWQuaW5kZXhPZih0cmltbWVkKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0LmZvcm1hdHRlZCA9IHRyaW1tZWQgKyBjb252ZXJ0RW5kT2ZMaW5lVG9DaGFycyQyKG9wdHMuZW5kT2ZMaW5lKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5jdXJzb3JPZmZzZXQgPj0gMCkge1xuICAgICAgdmFyIG9sZEN1cnNvck5vZGVTdGFydDtcbiAgICAgIHZhciBvbGRDdXJzb3JOb2RlVGV4dDtcbiAgICAgIHZhciBjdXJzb3JPZmZzZXRSZWxhdGl2ZVRvT2xkQ3Vyc29yTm9kZTtcbiAgICAgIHZhciBuZXdDdXJzb3JOb2RlU3RhcnQ7XG4gICAgICB2YXIgbmV3Q3Vyc29yTm9kZVRleHQ7XG5cbiAgICAgIGlmIChvcHRzLmN1cnNvck5vZGUgJiYgcmVzdWx0LmN1cnNvck5vZGVUZXh0KSB7XG4gICAgICAgIG9sZEN1cnNvck5vZGVTdGFydCA9IG9wdHMubG9jU3RhcnQob3B0cy5jdXJzb3JOb2RlKTtcbiAgICAgICAgb2xkQ3Vyc29yTm9kZVRleHQgPSB0ZXh0LnNsaWNlKG9sZEN1cnNvck5vZGVTdGFydCwgb3B0cy5sb2NFbmQob3B0cy5jdXJzb3JOb2RlKSk7XG4gICAgICAgIGN1cnNvck9mZnNldFJlbGF0aXZlVG9PbGRDdXJzb3JOb2RlID0gb3B0cy5jdXJzb3JPZmZzZXQgLSBvbGRDdXJzb3JOb2RlU3RhcnQ7XG4gICAgICAgIG5ld0N1cnNvck5vZGVTdGFydCA9IHJlc3VsdC5jdXJzb3JOb2RlU3RhcnQ7XG4gICAgICAgIG5ld0N1cnNvck5vZGVUZXh0ID0gcmVzdWx0LmN1cnNvck5vZGVUZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2xkQ3Vyc29yTm9kZVN0YXJ0ID0gMDtcbiAgICAgICAgb2xkQ3Vyc29yTm9kZVRleHQgPSB0ZXh0O1xuICAgICAgICBjdXJzb3JPZmZzZXRSZWxhdGl2ZVRvT2xkQ3Vyc29yTm9kZSA9IG9wdHMuY3Vyc29yT2Zmc2V0O1xuICAgICAgICBuZXdDdXJzb3JOb2RlU3RhcnQgPSAwO1xuICAgICAgICBuZXdDdXJzb3JOb2RlVGV4dCA9IHJlc3VsdC5mb3JtYXR0ZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChvbGRDdXJzb3JOb2RlVGV4dCA9PT0gbmV3Q3Vyc29yTm9kZVRleHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmb3JtYXR0ZWQ6IHJlc3VsdC5mb3JtYXR0ZWQsXG4gICAgICAgICAgY3Vyc29yT2Zmc2V0OiBuZXdDdXJzb3JOb2RlU3RhcnQgKyBjdXJzb3JPZmZzZXRSZWxhdGl2ZVRvT2xkQ3Vyc29yTm9kZVxuICAgICAgICB9O1xuICAgICAgfSAvLyBkaWZmIG9sZCBhbmQgbmV3IGN1cnNvciBub2RlIHRleHRzLCB3aXRoIGEgc3BlY2lhbCBjdXJzb3JcbiAgICAgIC8vIHN5bWJvbCBpbnNlcnRlZCB0byBmaW5kIG91dCB3aGVyZSBpdCBtb3ZlcyB0b1xuXG5cbiAgICAgIHZhciBvbGRDdXJzb3JOb2RlQ2hhckFycmF5ID0gb2xkQ3Vyc29yTm9kZVRleHQuc3BsaXQoXCJcIik7XG4gICAgICBvbGRDdXJzb3JOb2RlQ2hhckFycmF5LnNwbGljZShjdXJzb3JPZmZzZXRSZWxhdGl2ZVRvT2xkQ3Vyc29yTm9kZSwgMCwgQ1VSU09SKTtcbiAgICAgIHZhciBuZXdDdXJzb3JOb2RlQ2hhckFycmF5ID0gbmV3Q3Vyc29yTm9kZVRleHQuc3BsaXQoXCJcIik7XG4gICAgICB2YXIgY3Vyc29yTm9kZURpZmYgPSBkaWZmLmRpZmZBcnJheXMob2xkQ3Vyc29yTm9kZUNoYXJBcnJheSwgbmV3Q3Vyc29yTm9kZUNoYXJBcnJheSk7XG4gICAgICB2YXIgY3Vyc29yT2Zmc2V0ID0gbmV3Q3Vyc29yTm9kZVN0YXJ0O1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGN1cnNvck5vZGVEaWZmW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBlbnRyeSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgaWYgKGVudHJ5LnJlbW92ZWQpIHtcbiAgICAgICAgICAgIGlmIChlbnRyeS52YWx1ZS5pbmRleE9mKENVUlNPUikgPiAtMSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3Vyc29yT2Zmc2V0ICs9IGVudHJ5LmNvdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZm9ybWF0dGVkOiByZXN1bHQuZm9ybWF0dGVkLFxuICAgICAgICBjdXJzb3JPZmZzZXQ6IGN1cnNvck9mZnNldFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZm9ybWF0dGVkOiByZXN1bHQuZm9ybWF0dGVkXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFJhbmdlKHRleHQsIG9wdHMpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VyLnBhcnNlKHRleHQsIG9wdHMpO1xuICAgIHZhciBhc3QgPSBwYXJzZWQuYXN0O1xuICAgIHRleHQgPSBwYXJzZWQudGV4dDtcbiAgICB2YXIgcmFuZ2UgPSByYW5nZVV0aWwuY2FsY3VsYXRlUmFuZ2UodGV4dCwgb3B0cywgYXN0KTtcbiAgICB2YXIgcmFuZ2VTdGFydCA9IHJhbmdlLnJhbmdlU3RhcnQ7XG4gICAgdmFyIHJhbmdlRW5kID0gcmFuZ2UucmFuZ2VFbmQ7XG4gICAgdmFyIHJhbmdlU3RyaW5nID0gdGV4dC5zbGljZShyYW5nZVN0YXJ0LCByYW5nZUVuZCk7IC8vIFRyeSB0byBleHRlbmQgdGhlIHJhbmdlIGJhY2t3YXJkcyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaW5lLlxuICAgIC8vIFRoaXMgaXMgc28gd2UgY2FuIGRldGVjdCBpbmRlbnRhdGlvbiBjb3JyZWN0bHkgYW5kIHJlc3RvcmUgaXQuXG4gICAgLy8gVXNlIGBNYXRoLm1pbmAgc2luY2UgYGxhc3RJbmRleE9mYCByZXR1cm5zIDAgd2hlbiBgcmFuZ2VTdGFydGAgaXMgMFxuXG4gICAgdmFyIHJhbmdlU3RhcnQyID0gTWF0aC5taW4ocmFuZ2VTdGFydCwgdGV4dC5sYXN0SW5kZXhPZihcIlxcblwiLCByYW5nZVN0YXJ0KSArIDEpO1xuICAgIHZhciBpbmRlbnRTdHJpbmcgPSB0ZXh0LnNsaWNlKHJhbmdlU3RhcnQyLCByYW5nZVN0YXJ0KTtcbiAgICB2YXIgYWxpZ25tZW50U2l6ZSA9IHV0aWwuZ2V0QWxpZ25tZW50U2l6ZShpbmRlbnRTdHJpbmcsIG9wdHMudGFiV2lkdGgpO1xuICAgIHZhciByYW5nZVJlc3VsdCA9IGNvcmVGb3JtYXQocmFuZ2VTdHJpbmcsIE9iamVjdC5hc3NpZ24oe30sIG9wdHMsIHtcbiAgICAgIHJhbmdlU3RhcnQ6IDAsXG4gICAgICByYW5nZUVuZDogSW5maW5pdHksXG4gICAgICAvLyB0cmFjayB0aGUgY3Vyc29yIG9mZnNldCBvbmx5IGlmIGl0J3Mgd2l0aGluIG91ciByYW5nZVxuICAgICAgY3Vyc29yT2Zmc2V0OiBvcHRzLmN1cnNvck9mZnNldCA+PSByYW5nZVN0YXJ0ICYmIG9wdHMuY3Vyc29yT2Zmc2V0IDwgcmFuZ2VFbmQgPyBvcHRzLmN1cnNvck9mZnNldCAtIHJhbmdlU3RhcnQgOiAtMVxuICAgIH0pLCBhbGlnbm1lbnRTaXplKTsgLy8gU2luY2UgdGhlIHJhbmdlIGNvbnRyYWN0cyB0byBhdm9pZCB0cmFpbGluZyB3aGl0ZXNwYWNlLFxuICAgIC8vIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBuZXdsaW5lIHRoYXQgd2FzIGluc2VydGVkIGJ5IHRoZSBgZm9ybWF0YCBjYWxsLlxuXG4gICAgdmFyIHJhbmdlVHJpbW1lZCA9IHJhbmdlUmVzdWx0LmZvcm1hdHRlZC50cmltUmlnaHQoKTtcbiAgICB2YXIgcmFuZ2VMZWZ0ID0gdGV4dC5zbGljZSgwLCByYW5nZVN0YXJ0KTtcbiAgICB2YXIgcmFuZ2VSaWdodCA9IHRleHQuc2xpY2UocmFuZ2VFbmQpO1xuICAgIHZhciBjdXJzb3JPZmZzZXQgPSBvcHRzLmN1cnNvck9mZnNldDtcblxuICAgIGlmIChvcHRzLmN1cnNvck9mZnNldCA+PSByYW5nZUVuZCkge1xuICAgICAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRoZSBjdXJzb3Igd2FzIHBhc3QgdGhlIGVuZCBvZiB0aGUgcmFuZ2VcbiAgICAgIGN1cnNvck9mZnNldCA9IG9wdHMuY3Vyc29yT2Zmc2V0IC0gcmFuZ2VFbmQgKyAocmFuZ2VTdGFydCArIHJhbmdlVHJpbW1lZC5sZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAocmFuZ2VSZXN1bHQuY3Vyc29yT2Zmc2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGUgY3Vyc29yIHdhcyBpbiB0aGUgcmFuZ2VcbiAgICAgIGN1cnNvck9mZnNldCA9IHJhbmdlUmVzdWx0LmN1cnNvck9mZnNldCArIHJhbmdlU3RhcnQ7XG4gICAgfSAvLyBrZWVwIHRoZSBjdXJzb3IgYXMgaXQgd2FzIGlmIGl0IHdhcyBiZWZvcmUgdGhlIHN0YXJ0IG9mIHRoZSByYW5nZVxuXG5cbiAgICB2YXIgZm9ybWF0dGVkO1xuXG4gICAgaWYgKG9wdHMuZW5kT2ZMaW5lID09PSBcImxmXCIpIHtcbiAgICAgIGZvcm1hdHRlZCA9IHJhbmdlTGVmdCArIHJhbmdlVHJpbW1lZCArIHJhbmdlUmlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlb2wgPSBjb252ZXJ0RW5kT2ZMaW5lVG9DaGFycyQyKG9wdHMuZW5kT2ZMaW5lKTtcblxuICAgICAgaWYgKGN1cnNvck9mZnNldCA+PSAwKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IFtyYW5nZUxlZnQsIHJhbmdlVHJpbW1lZCwgcmFuZ2VSaWdodF07XG4gICAgICAgIHZhciBwYXJ0SW5kZXggPSAwO1xuICAgICAgICB2YXIgcGFydE9mZnNldCA9IGN1cnNvck9mZnNldDtcblxuICAgICAgICB3aGlsZSAocGFydEluZGV4IDwgcGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1twYXJ0SW5kZXhdO1xuXG4gICAgICAgICAgaWYgKHBhcnRPZmZzZXQgPCBwYXJ0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcGFydHNbcGFydEluZGV4XSA9IHBhcnRzW3BhcnRJbmRleF0uc2xpY2UoMCwgcGFydE9mZnNldCkgKyBQTEFDRUhPTERFUlMuY3Vyc29yT2Zmc2V0ICsgcGFydHNbcGFydEluZGV4XS5zbGljZShwYXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcnRJbmRleCsrO1xuICAgICAgICAgIHBhcnRPZmZzZXQgLT0gcGFydC5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3UmFuZ2VMZWZ0ID0gcGFydHNbMF0sXG4gICAgICAgICAgICBuZXdSYW5nZVRyaW1tZWQgPSBwYXJ0c1sxXSxcbiAgICAgICAgICAgIG5ld1JhbmdlUmlnaHQgPSBwYXJ0c1syXTtcbiAgICAgICAgZm9ybWF0dGVkID0gKG5ld1JhbmdlTGVmdC5yZXBsYWNlKC9cXG4vZywgZW9sKSArIG5ld1JhbmdlVHJpbW1lZCArIG5ld1JhbmdlUmlnaHQucmVwbGFjZSgvXFxuL2csIGVvbCkpLnJlcGxhY2UoUExBQ0VIT0xERVJTLmN1cnNvck9mZnNldCwgZnVuY3Rpb24gKF8sIGluZGV4KSB7XG4gICAgICAgICAgY3Vyc29yT2Zmc2V0ID0gaW5kZXg7XG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9ybWF0dGVkID0gcmFuZ2VMZWZ0LnJlcGxhY2UoL1xcbi9nLCBlb2wpICsgcmFuZ2VUcmltbWVkICsgcmFuZ2VSaWdodC5yZXBsYWNlKC9cXG4vZywgZW9sKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZm9ybWF0dGVkOiBmb3JtYXR0ZWQsXG4gICAgICBjdXJzb3JPZmZzZXQ6IGN1cnNvck9mZnNldFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXQodGV4dCwgb3B0cykge1xuICAgIHZhciBzZWxlY3RlZFBhcnNlciA9IHBhcnNlci5yZXNvbHZlUGFyc2VyKG9wdHMpO1xuICAgIHZhciBoYXNQcmFnbWEgPSAhc2VsZWN0ZWRQYXJzZXIuaGFzUHJhZ21hIHx8IHNlbGVjdGVkUGFyc2VyLmhhc1ByYWdtYSh0ZXh0KTtcblxuICAgIGlmIChvcHRzLnJlcXVpcmVQcmFnbWEgJiYgIWhhc1ByYWdtYSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZm9ybWF0dGVkOiB0ZXh0XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChvcHRzLmVuZE9mTGluZSA9PT0gXCJhdXRvXCIpIHtcbiAgICAgIG9wdHMuZW5kT2ZMaW5lID0gZ3Vlc3NFbmRPZkxpbmUkMSh0ZXh0KTtcbiAgICB9XG5cbiAgICB2YXIgaGFzQ3Vyc29yID0gb3B0cy5jdXJzb3JPZmZzZXQgPj0gMDtcbiAgICB2YXIgaGFzUmFuZ2VTdGFydCA9IG9wdHMucmFuZ2VTdGFydCA+IDA7XG4gICAgdmFyIGhhc1JhbmdlRW5kID0gb3B0cy5yYW5nZUVuZCA8IHRleHQubGVuZ3RoOyAvLyBnZXQgcmlkIG9mIENSL0NSTEYgcGFyc2luZ1xuXG4gICAgaWYgKHRleHQuaW5kZXhPZihcIlxcclwiKSAhPT0gLTEpIHtcbiAgICAgIHZhciBvZmZzZXRLZXlzID0gW2hhc0N1cnNvciAmJiBcImN1cnNvck9mZnNldFwiLCBoYXNSYW5nZVN0YXJ0ICYmIFwicmFuZ2VTdGFydFwiLCBoYXNSYW5nZUVuZCAmJiBcInJhbmdlRW5kXCJdLmZpbHRlcihCb29sZWFuKS5zb3J0KGZ1bmN0aW9uIChhS2V5LCBiS2V5KSB7XG4gICAgICAgIHJldHVybiBvcHRzW2FLZXldIC0gb3B0c1tiS2V5XTtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBpID0gb2Zmc2V0S2V5cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIga2V5ID0gb2Zmc2V0S2V5c1tpXTtcbiAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMCwgb3B0c1trZXldKSArIFBMQUNFSE9MREVSU1trZXldICsgdGV4dC5zbGljZShvcHRzW2tleV0pO1xuICAgICAgfVxuXG4gICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpO1xuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfaSkge1xuICAgICAgICB2YXIga2V5ID0gb2Zmc2V0S2V5c1tfaV07XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoUExBQ0VIT0xERVJTW2tleV0sIGZ1bmN0aW9uIChfLCBpbmRleCkge1xuICAgICAgICAgIG9wdHNba2V5XSA9IGluZGV4O1xuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBvZmZzZXRLZXlzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBfbG9vcChfaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGhhc1VuaWNvZGVCT00gPSB0ZXh0LmNoYXJDb2RlQXQoMCkgPT09IFVURjhCT007XG5cbiAgICBpZiAoaGFzVW5pY29kZUJPTSkge1xuICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDEpO1xuXG4gICAgICBpZiAoaGFzQ3Vyc29yKSB7XG4gICAgICAgIG9wdHMuY3Vyc29yT2Zmc2V0Kys7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNSYW5nZVN0YXJ0KSB7XG4gICAgICAgIG9wdHMucmFuZ2VTdGFydCsrO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzUmFuZ2VFbmQpIHtcbiAgICAgICAgb3B0cy5yYW5nZUVuZCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaGFzQ3Vyc29yKSB7XG4gICAgICBvcHRzLmN1cnNvck9mZnNldCA9IC0xO1xuICAgIH1cblxuICAgIGlmIChvcHRzLnJhbmdlU3RhcnQgPCAwKSB7XG4gICAgICBvcHRzLnJhbmdlU3RhcnQgPSAwO1xuICAgIH1cblxuICAgIGlmIChvcHRzLnJhbmdlRW5kID4gdGV4dC5sZW5ndGgpIHtcbiAgICAgIG9wdHMucmFuZ2VFbmQgPSB0ZXh0Lmxlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gaGFzUmFuZ2VTdGFydCB8fCBoYXNSYW5nZUVuZCA/IGZvcm1hdFJhbmdlKHRleHQsIG9wdHMpIDogY29yZUZvcm1hdChvcHRzLmluc2VydFByYWdtYSAmJiBvcHRzLnByaW50ZXIuaW5zZXJ0UHJhZ21hICYmICFoYXNQcmFnbWEgPyBvcHRzLnByaW50ZXIuaW5zZXJ0UHJhZ21hKHRleHQpIDogdGV4dCwgb3B0cyk7XG5cbiAgICBpZiAoaGFzVW5pY29kZUJPTSkge1xuICAgICAgcmVzdWx0LmZvcm1hdHRlZCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoVVRGOEJPTSkgKyByZXN1bHQuZm9ybWF0dGVkO1xuXG4gICAgICBpZiAoaGFzQ3Vyc29yKSB7XG4gICAgICAgIHJlc3VsdC5jdXJzb3JPZmZzZXQrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGNvcmUgPSB7XG4gICAgZm9ybWF0V2l0aEN1cnNvcjogZnVuY3Rpb24gZm9ybWF0V2l0aEN1cnNvcih0ZXh0LCBvcHRzKSB7XG4gICAgICBvcHRzID0gbm9ybWFsaXplT3B0aW9ucyQxKG9wdHMpO1xuICAgICAgcmV0dXJuIGZvcm1hdCh0ZXh0LCBvcHRzKTtcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSh0ZXh0LCBvcHRzLCBtYXNzYWdlKSB7XG4gICAgICBvcHRzID0gbm9ybWFsaXplT3B0aW9ucyQxKG9wdHMpO1xuXG4gICAgICBpZiAodGV4dC5pbmRleE9mKFwiXFxyXCIpICE9PSAtMSkge1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyc2VkID0gcGFyc2VyLnBhcnNlKHRleHQsIG9wdHMpO1xuXG4gICAgICBpZiAobWFzc2FnZSkge1xuICAgICAgICBwYXJzZWQuYXN0ID0gbWFzc2FnZUFzdChwYXJzZWQuYXN0LCBvcHRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9LFxuICAgIGZvcm1hdEFTVDogZnVuY3Rpb24gZm9ybWF0QVNUKGFzdCwgb3B0cykge1xuICAgICAgb3B0cyA9IG5vcm1hbGl6ZU9wdGlvbnMkMShvcHRzKTtcbiAgICAgIHZhciBkb2MgPSBhc3RUb0RvYyhhc3QsIG9wdHMpO1xuICAgICAgcmV0dXJuIF9wcmludERvY1RvU3RyaW5nKGRvYywgb3B0cyk7XG4gICAgfSxcbiAgICAvLyBEb2Vzbid0IGhhbmRsZSBzaGViYW5nIGZvciBub3dcbiAgICBmb3JtYXREb2M6IGZ1bmN0aW9uIGZvcm1hdERvYyhkb2MsIG9wdHMpIHtcbiAgICAgIHZhciBkZWJ1ZyA9IHByaW50RG9jVG9EZWJ1Zyhkb2MpO1xuICAgICAgb3B0cyA9IG5vcm1hbGl6ZU9wdGlvbnMkMShPYmplY3QuYXNzaWduKHt9LCBvcHRzLCB7XG4gICAgICAgIHBhcnNlcjogXCJiYWJlbFwiXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gZm9ybWF0KGRlYnVnLCBvcHRzKS5mb3JtYXR0ZWQ7XG4gICAgfSxcbiAgICBwcmludFRvRG9jOiBmdW5jdGlvbiBwcmludFRvRG9jKHRleHQsIG9wdHMpIHtcbiAgICAgIG9wdHMgPSBub3JtYWxpemVPcHRpb25zJDEob3B0cyk7XG4gICAgICB2YXIgcGFyc2VkID0gcGFyc2VyLnBhcnNlKHRleHQsIG9wdHMpO1xuICAgICAgdmFyIGFzdCA9IHBhcnNlZC5hc3Q7XG4gICAgICB0ZXh0ID0gcGFyc2VkLnRleHQ7XG4gICAgICBhdHRhY2hDb21tZW50cyh0ZXh0LCBhc3QsIG9wdHMpO1xuICAgICAgcmV0dXJuIGFzdFRvRG9jKGFzdCwgb3B0cyk7XG4gICAgfSxcbiAgICBwcmludERvY1RvU3RyaW5nOiBmdW5jdGlvbiBwcmludERvY1RvU3RyaW5nKGRvYywgb3B0cykge1xuICAgICAgcmV0dXJuIF9wcmludERvY1RvU3RyaW5nKGRvYywgbm9ybWFsaXplT3B0aW9ucyQxKG9wdHMpKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGluZGV4ID0gW1xuICBcdFwiYVwiLFxuICBcdFwiYWJiclwiLFxuICBcdFwiYWNyb255bVwiLFxuICBcdFwiYWRkcmVzc1wiLFxuICBcdFwiYXBwbGV0XCIsXG4gIFx0XCJhcmVhXCIsXG4gIFx0XCJhcnRpY2xlXCIsXG4gIFx0XCJhc2lkZVwiLFxuICBcdFwiYXVkaW9cIixcbiAgXHRcImJcIixcbiAgXHRcImJhc2VcIixcbiAgXHRcImJhc2Vmb250XCIsXG4gIFx0XCJiZGlcIixcbiAgXHRcImJkb1wiLFxuICBcdFwiYmdzb3VuZFwiLFxuICBcdFwiYmlnXCIsXG4gIFx0XCJibGlua1wiLFxuICBcdFwiYmxvY2txdW90ZVwiLFxuICBcdFwiYm9keVwiLFxuICBcdFwiYnJcIixcbiAgXHRcImJ1dHRvblwiLFxuICBcdFwiY2FudmFzXCIsXG4gIFx0XCJjYXB0aW9uXCIsXG4gIFx0XCJjZW50ZXJcIixcbiAgXHRcImNpdGVcIixcbiAgXHRcImNvZGVcIixcbiAgXHRcImNvbFwiLFxuICBcdFwiY29sZ3JvdXBcIixcbiAgXHRcImNvbW1hbmRcIixcbiAgXHRcImNvbnRlbnRcIixcbiAgXHRcImRhdGFcIixcbiAgXHRcImRhdGFsaXN0XCIsXG4gIFx0XCJkZFwiLFxuICBcdFwiZGVsXCIsXG4gIFx0XCJkZXRhaWxzXCIsXG4gIFx0XCJkZm5cIixcbiAgXHRcImRpYWxvZ1wiLFxuICBcdFwiZGlyXCIsXG4gIFx0XCJkaXZcIixcbiAgXHRcImRsXCIsXG4gIFx0XCJkdFwiLFxuICBcdFwiZWxlbWVudFwiLFxuICBcdFwiZW1cIixcbiAgXHRcImVtYmVkXCIsXG4gIFx0XCJmaWVsZHNldFwiLFxuICBcdFwiZmlnY2FwdGlvblwiLFxuICBcdFwiZmlndXJlXCIsXG4gIFx0XCJmb250XCIsXG4gIFx0XCJmb290ZXJcIixcbiAgXHRcImZvcm1cIixcbiAgXHRcImZyYW1lXCIsXG4gIFx0XCJmcmFtZXNldFwiLFxuICBcdFwiaDFcIixcbiAgXHRcImgyXCIsXG4gIFx0XCJoM1wiLFxuICBcdFwiaDRcIixcbiAgXHRcImg1XCIsXG4gIFx0XCJoNlwiLFxuICBcdFwiaGVhZFwiLFxuICBcdFwiaGVhZGVyXCIsXG4gIFx0XCJoZ3JvdXBcIixcbiAgXHRcImhyXCIsXG4gIFx0XCJodG1sXCIsXG4gIFx0XCJpXCIsXG4gIFx0XCJpZnJhbWVcIixcbiAgXHRcImltYWdlXCIsXG4gIFx0XCJpbWdcIixcbiAgXHRcImlucHV0XCIsXG4gIFx0XCJpbnNcIixcbiAgXHRcImlzaW5kZXhcIixcbiAgXHRcImtiZFwiLFxuICBcdFwia2V5Z2VuXCIsXG4gIFx0XCJsYWJlbFwiLFxuICBcdFwibGVnZW5kXCIsXG4gIFx0XCJsaVwiLFxuICBcdFwibGlua1wiLFxuICBcdFwibGlzdGluZ1wiLFxuICBcdFwibWFpblwiLFxuICBcdFwibWFwXCIsXG4gIFx0XCJtYXJrXCIsXG4gIFx0XCJtYXJxdWVlXCIsXG4gIFx0XCJtYXRoXCIsXG4gIFx0XCJtZW51XCIsXG4gIFx0XCJtZW51aXRlbVwiLFxuICBcdFwibWV0YVwiLFxuICBcdFwibWV0ZXJcIixcbiAgXHRcIm11bHRpY29sXCIsXG4gIFx0XCJuYXZcIixcbiAgXHRcIm5leHRpZFwiLFxuICBcdFwibm9iclwiLFxuICBcdFwibm9lbWJlZFwiLFxuICBcdFwibm9mcmFtZXNcIixcbiAgXHRcIm5vc2NyaXB0XCIsXG4gIFx0XCJvYmplY3RcIixcbiAgXHRcIm9sXCIsXG4gIFx0XCJvcHRncm91cFwiLFxuICBcdFwib3B0aW9uXCIsXG4gIFx0XCJvdXRwdXRcIixcbiAgXHRcInBcIixcbiAgXHRcInBhcmFtXCIsXG4gIFx0XCJwaWN0dXJlXCIsXG4gIFx0XCJwbGFpbnRleHRcIixcbiAgXHRcInByZVwiLFxuICBcdFwicHJvZ3Jlc3NcIixcbiAgXHRcInFcIixcbiAgXHRcInJiXCIsXG4gIFx0XCJyYmNcIixcbiAgXHRcInJwXCIsXG4gIFx0XCJydFwiLFxuICBcdFwicnRjXCIsXG4gIFx0XCJydWJ5XCIsXG4gIFx0XCJzXCIsXG4gIFx0XCJzYW1wXCIsXG4gIFx0XCJzY3JpcHRcIixcbiAgXHRcInNlY3Rpb25cIixcbiAgXHRcInNlbGVjdFwiLFxuICBcdFwic2hhZG93XCIsXG4gIFx0XCJzbG90XCIsXG4gIFx0XCJzbWFsbFwiLFxuICBcdFwic291cmNlXCIsXG4gIFx0XCJzcGFjZXJcIixcbiAgXHRcInNwYW5cIixcbiAgXHRcInN0cmlrZVwiLFxuICBcdFwic3Ryb25nXCIsXG4gIFx0XCJzdHlsZVwiLFxuICBcdFwic3ViXCIsXG4gIFx0XCJzdW1tYXJ5XCIsXG4gIFx0XCJzdXBcIixcbiAgXHRcInN2Z1wiLFxuICBcdFwidGFibGVcIixcbiAgXHRcInRib2R5XCIsXG4gIFx0XCJ0ZFwiLFxuICBcdFwidGVtcGxhdGVcIixcbiAgXHRcInRleHRhcmVhXCIsXG4gIFx0XCJ0Zm9vdFwiLFxuICBcdFwidGhcIixcbiAgXHRcInRoZWFkXCIsXG4gIFx0XCJ0aW1lXCIsXG4gIFx0XCJ0aXRsZVwiLFxuICBcdFwidHJcIixcbiAgXHRcInRyYWNrXCIsXG4gIFx0XCJ0dFwiLFxuICBcdFwidVwiLFxuICBcdFwidWxcIixcbiAgXHRcInZhclwiLFxuICBcdFwidmlkZW9cIixcbiAgXHRcIndiclwiLFxuICBcdFwieG1wXCJcbiAgXTtcblxuICB2YXIgaHRtbFRhZ05hbWVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAnZGVmYXVsdCc6IGluZGV4XG4gIH0pO1xuXG4gIHZhciBodG1sVGFnTmFtZXMkMSA9IGdldENqc0V4cG9ydEZyb21OYW1lc3BhY2UoaHRtbFRhZ05hbWVzKTtcblxuICBmdW5jdGlvbiBjbGVhbihhc3QsIG5ld09iaiwgcGFyZW50KSB7XG4gICAgW1wicmF3XCIsIC8vIGZyb250LW1hdHRlclxuICAgIFwicmF3c1wiLCBcInNvdXJjZUluZGV4XCIsIFwic291cmNlXCIsIFwiYmVmb3JlXCIsIFwiYWZ0ZXJcIiwgXCJ0cmFpbGluZ0NvbW1hXCJdLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGRlbGV0ZSBuZXdPYmpbbmFtZV07XG4gICAgfSk7XG5cbiAgICBpZiAoYXN0LnR5cGUgPT09IFwieWFtbFwiKSB7XG4gICAgICBkZWxldGUgbmV3T2JqLnZhbHVlO1xuICAgIH0gLy8gLS1pbnNlcnQtcHJhZ21hXG5cblxuICAgIGlmIChhc3QudHlwZSA9PT0gXCJjc3MtY29tbWVudFwiICYmIHBhcmVudC50eXBlID09PSBcImNzcy1yb290XCIgJiYgcGFyZW50Lm5vZGVzLmxlbmd0aCAhPT0gMCAmJiAoIC8vIGZpcnN0IG5vbi1mcm9udC1tYXR0ZXIgY29tbWVudFxuICAgIHBhcmVudC5ub2Rlc1swXSA9PT0gYXN0IHx8IChwYXJlbnQubm9kZXNbMF0udHlwZSA9PT0gXCJ5YW1sXCIgfHwgcGFyZW50Lm5vZGVzWzBdLnR5cGUgPT09IFwidG9tbFwiKSAmJiBwYXJlbnQubm9kZXNbMV0gPT09IGFzdCkpIHtcbiAgICAgIC8qKlxuICAgICAgICogc29tZXRoaW5nXG4gICAgICAgKlxuICAgICAgICogQGZvcm1hdFxuICAgICAgICovXG4gICAgICBkZWxldGUgbmV3T2JqLnRleHQ7IC8vIHN0YW5kYWxvbmUgcHJhZ21hXG5cbiAgICAgIGlmICgvXlxcKlxccypAKGZvcm1hdHxwcmV0dGllcilcXHMqJC8udGVzdChhc3QudGV4dCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFzdC50eXBlID09PSBcIm1lZGlhLXF1ZXJ5XCIgfHwgYXN0LnR5cGUgPT09IFwibWVkaWEtcXVlcnktbGlzdFwiIHx8IGFzdC50eXBlID09PSBcIm1lZGlhLWZlYXR1cmUtZXhwcmVzc2lvblwiKSB7XG4gICAgICBkZWxldGUgbmV3T2JqLnZhbHVlO1xuICAgIH1cblxuICAgIGlmIChhc3QudHlwZSA9PT0gXCJjc3MtcnVsZVwiKSB7XG4gICAgICBkZWxldGUgbmV3T2JqLnBhcmFtcztcbiAgICB9XG5cbiAgICBpZiAoYXN0LnR5cGUgPT09IFwic2VsZWN0b3ItY29tYmluYXRvclwiKSB7XG4gICAgICBuZXdPYmoudmFsdWUgPSBuZXdPYmoudmFsdWUucmVwbGFjZSgvXFxzKy9nLCBcIiBcIik7XG4gICAgfVxuXG4gICAgaWYgKGFzdC50eXBlID09PSBcIm1lZGlhLWZlYXR1cmVcIikge1xuICAgICAgbmV3T2JqLnZhbHVlID0gbmV3T2JqLnZhbHVlLnJlcGxhY2UoLyAvZywgXCJcIik7XG4gICAgfVxuXG4gICAgaWYgKGFzdC50eXBlID09PSBcInZhbHVlLXdvcmRcIiAmJiAoYXN0LmlzQ29sb3IgJiYgYXN0LmlzSGV4IHx8IFtcImluaXRpYWxcIiwgXCJpbmhlcml0XCIsIFwidW5zZXRcIiwgXCJyZXZlcnRcIl0uaW5kZXhPZihuZXdPYmoudmFsdWUucmVwbGFjZSgpLnRvTG93ZXJDYXNlKCkpICE9PSAtMSkgfHwgYXN0LnR5cGUgPT09IFwibWVkaWEtZmVhdHVyZVwiIHx8IGFzdC50eXBlID09PSBcInNlbGVjdG9yLXJvb3QtaW52YWxpZFwiIHx8IGFzdC50eXBlID09PSBcInNlbGVjdG9yLXBzZXVkb1wiKSB7XG4gICAgICBuZXdPYmoudmFsdWUgPSBuZXdPYmoudmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoYXN0LnR5cGUgPT09IFwiY3NzLWRlY2xcIikge1xuICAgICAgbmV3T2JqLnByb3AgPSBuZXdPYmoucHJvcC50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmIChhc3QudHlwZSA9PT0gXCJjc3MtYXRydWxlXCIgfHwgYXN0LnR5cGUgPT09IFwiY3NzLWltcG9ydFwiKSB7XG4gICAgICBuZXdPYmoubmFtZSA9IG5ld09iai5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKGFzdC50eXBlID09PSBcInZhbHVlLW51bWJlclwiKSB7XG4gICAgICBuZXdPYmoudW5pdCA9IG5ld09iai51bml0LnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKChhc3QudHlwZSA9PT0gXCJtZWRpYS1mZWF0dXJlXCIgfHwgYXN0LnR5cGUgPT09IFwibWVkaWEta2V5d29yZFwiIHx8IGFzdC50eXBlID09PSBcIm1lZGlhLXR5cGVcIiB8fCBhc3QudHlwZSA9PT0gXCJtZWRpYS11bmtub3duXCIgfHwgYXN0LnR5cGUgPT09IFwibWVkaWEtdXJsXCIgfHwgYXN0LnR5cGUgPT09IFwibWVkaWEtdmFsdWVcIiB8fCBhc3QudHlwZSA9PT0gXCJzZWxlY3Rvci1hdHRyaWJ1dGVcIiB8fCBhc3QudHlwZSA9PT0gXCJzZWxlY3Rvci1zdHJpbmdcIiB8fCBhc3QudHlwZSA9PT0gXCJzZWxlY3Rvci1jbGFzc1wiIHx8IGFzdC50eXBlID09PSBcInNlbGVjdG9yLWNvbWJpbmF0b3JcIiB8fCBhc3QudHlwZSA9PT0gXCJ2YWx1ZS1zdHJpbmdcIikgJiYgbmV3T2JqLnZhbHVlKSB7XG4gICAgICBuZXdPYmoudmFsdWUgPSBjbGVhbkNTU1N0cmluZ3MobmV3T2JqLnZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoYXN0LnR5cGUgPT09IFwic2VsZWN0b3ItYXR0cmlidXRlXCIpIHtcbiAgICAgIG5ld09iai5hdHRyaWJ1dGUgPSBuZXdPYmouYXR0cmlidXRlLnRyaW0oKTtcblxuICAgICAgaWYgKG5ld09iai5uYW1lc3BhY2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdPYmoubmFtZXNwYWNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgbmV3T2JqLm5hbWVzcGFjZSA9IG5ld09iai5uYW1lc3BhY2UudHJpbSgpO1xuXG4gICAgICAgICAgaWYgKG5ld09iai5uYW1lc3BhY2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBuZXdPYmoubmFtZXNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5ld09iai52YWx1ZSkge1xuICAgICAgICBuZXdPYmoudmFsdWUgPSBuZXdPYmoudmFsdWUudHJpbSgpLnJlcGxhY2UoL15bJ1wiXXxbJ1wiXSQvZywgXCJcIik7XG4gICAgICAgIGRlbGV0ZSBuZXdPYmoucXVvdGVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgoYXN0LnR5cGUgPT09IFwibWVkaWEtdmFsdWVcIiB8fCBhc3QudHlwZSA9PT0gXCJtZWRpYS10eXBlXCIgfHwgYXN0LnR5cGUgPT09IFwidmFsdWUtbnVtYmVyXCIgfHwgYXN0LnR5cGUgPT09IFwic2VsZWN0b3Itcm9vdC1pbnZhbGlkXCIgfHwgYXN0LnR5cGUgPT09IFwic2VsZWN0b3ItY2xhc3NcIiB8fCBhc3QudHlwZSA9PT0gXCJzZWxlY3Rvci1jb21iaW5hdG9yXCIgfHwgYXN0LnR5cGUgPT09IFwic2VsZWN0b3ItdGFnXCIpICYmIG5ld09iai52YWx1ZSkge1xuICAgICAgbmV3T2JqLnZhbHVlID0gbmV3T2JqLnZhbHVlLnJlcGxhY2UoLyhbXFxkLmVFKy1dKykoW2EtekEtWl0qKS9nLCBmdW5jdGlvbiAobWF0Y2gsIG51bVN0ciwgdW5pdCkge1xuICAgICAgICB2YXIgbnVtID0gTnVtYmVyKG51bVN0cik7XG4gICAgICAgIHJldHVybiBpc05hTihudW0pID8gbWF0Y2ggOiBudW0gKyB1bml0LnRvTG93ZXJDYXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYXN0LnR5cGUgPT09IFwic2VsZWN0b3ItdGFnXCIpIHtcbiAgICAgIHZhciBsb3dlcmNhc2VkVmFsdWUgPSBhc3QudmFsdWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgaWYgKGh0bWxUYWdOYW1lcyQxLmluZGV4T2YobG93ZXJjYXNlZFZhbHVlKSAhPT0gLTEpIHtcbiAgICAgICAgbmV3T2JqLnZhbHVlID0gbG93ZXJjYXNlZFZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoW1wiZnJvbVwiLCBcInRvXCJdLmluZGV4T2YobG93ZXJjYXNlZFZhbHVlKSAhPT0gLTEpIHtcbiAgICAgICAgbmV3T2JqLnZhbHVlID0gbG93ZXJjYXNlZFZhbHVlO1xuICAgICAgfVxuICAgIH0gLy8gV29ya2Fyb3VuZCB3aGVuIGBwb3N0Y3NzLXZhbHVlcy1wYXJzZXJgIHBhcnNlIGBub3RgLCBgYW5kYCBvciBgb3JgIGtleXdvcmRzIGFzIGB2YWx1ZS1mdW5jYFxuXG5cbiAgICBpZiAoYXN0LnR5cGUgPT09IFwiY3NzLWF0cnVsZVwiICYmIGFzdC5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwic3VwcG9ydHNcIikge1xuICAgICAgZGVsZXRlIG5ld09iai52YWx1ZTtcbiAgICB9IC8vIFdvcmthcm91bmQgZm9yIFNDU1MgbmVzdGVkIHByb3BlcnRpZXNcblxuXG4gICAgaWYgKGFzdC50eXBlID09PSBcInNlbGVjdG9yLXVua25vd25cIikge1xuICAgICAgZGVsZXRlIG5ld09iai52YWx1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbkNTU1N0cmluZ3ModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvJy9nLCAnXCInKS5yZXBsYWNlKC9cXFxcKFteYS1mQS1GXFxkXSkvZywgXCIkMVwiKTtcbiAgfVxuXG4gIHZhciBjbGVhbl8xID0gY2xlYW47XG5cbiAgdmFyIF9yZXF1aXJlJCQwJGJ1aWxkZXJzJDEgPSBkb2MuYnVpbGRlcnMsXG4gICAgICBoYXJkbGluZSQzID0gX3JlcXVpcmUkJDAkYnVpbGRlcnMkMS5oYXJkbGluZSxcbiAgICAgIGxpdGVyYWxsaW5lJDEgPSBfcmVxdWlyZSQkMCRidWlsZGVycyQxLmxpdGVyYWxsaW5lLFxuICAgICAgY29uY2F0JDQgPSBfcmVxdWlyZSQkMCRidWlsZGVycyQxLmNvbmNhdCxcbiAgICAgIG1hcmtBc1Jvb3QkMSA9IF9yZXF1aXJlJCQwJGJ1aWxkZXJzJDEubWFya0FzUm9vdCxcbiAgICAgIG1hcERvYyQzID0gZG9jLnV0aWxzLm1hcERvYztcblxuICBmdW5jdGlvbiBlbWJlZChwYXRoLCBwcmludCwgdGV4dFRvRG9jXG4gIC8qLCBvcHRpb25zICovXG4gICkge1xuICAgIHZhciBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJ5YW1sXCIpIHtcbiAgICAgIHJldHVybiBtYXJrQXNSb290JDEoY29uY2F0JDQoW1wiLS0tXCIsIGhhcmRsaW5lJDMsIG5vZGUudmFsdWUudHJpbSgpID8gcmVwbGFjZU5ld2xpbmVzV2l0aExpdGVyYWxsaW5lcyh0ZXh0VG9Eb2Mobm9kZS52YWx1ZSwge1xuICAgICAgICBwYXJzZXI6IFwieWFtbFwiXG4gICAgICB9KSkgOiBcIlwiLCBcIi0tLVwiLCBoYXJkbGluZSQzXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuXG4gICAgZnVuY3Rpb24gcmVwbGFjZU5ld2xpbmVzV2l0aExpdGVyYWxsaW5lcyhkb2MpIHtcbiAgICAgIHJldHVybiBtYXBEb2MkMyhkb2MsIGZ1bmN0aW9uIChjdXJyZW50RG9jKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgY3VycmVudERvYyA9PT0gXCJzdHJpbmdcIiAmJiBjdXJyZW50RG9jLmluY2x1ZGVzKFwiXFxuXCIpID8gY29uY2F0JDQoY3VycmVudERvYy5zcGxpdCgvKFxcbikvZykubWFwKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgICAgcmV0dXJuIGkgJSAyID09PSAwID8gdiA6IGxpdGVyYWxsaW5lJDE7XG4gICAgICAgIH0pKSA6IGN1cnJlbnREb2M7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICB2YXIgZW1iZWRfMSA9IGVtYmVkO1xuXG4gIHZhciBkZXRlY3ROZXdsaW5lID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld2xpbmVzID0gc3RyLm1hdGNoKC8oPzpcXHI/XFxuKS9nKSB8fCBbXTtcblxuICAgICAgaWYgKG5ld2xpbmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGNybGYgPSBuZXdsaW5lcy5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiBlbCA9PT0gJ1xcclxcbic7XG4gICAgICB9KS5sZW5ndGg7XG4gICAgICB2YXIgbGYgPSBuZXdsaW5lcy5sZW5ndGggLSBjcmxmO1xuICAgICAgcmV0dXJuIGNybGYgPiBsZiA/ICdcXHJcXG4nIDogJ1xcbic7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzLmdyYWNlZnVsID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzKHN0cikgfHwgJ1xcbic7XG4gICAgfTtcbiAgfSk7XG4gIHZhciBkZXRlY3ROZXdsaW5lXzEgPSBkZXRlY3ROZXdsaW5lLmdyYWNlZnVsO1xuXG4gIHZhciBidWlsZCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgZXhwb3J0cy5leHRyYWN0ID0gZXh0cmFjdDtcbiAgICBleHBvcnRzLnN0cmlwID0gc3RyaXA7XG4gICAgZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuICAgIGV4cG9ydHMucGFyc2VXaXRoQ29tbWVudHMgPSBwYXJzZVdpdGhDb21tZW50cztcbiAgICBleHBvcnRzLnByaW50ID0gcHJpbnQ7XG5cbiAgICBmdW5jdGlvbiBfb3MoKSB7XG4gICAgICB2YXIgZGF0YSA9IHJlcXVpcmUkJDAkMTtcblxuICAgICAgX29zID0gZnVuY3Rpb24gX29zKCkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9kZXRlY3ROZXdsaW5lKCkge1xuICAgICAgdmFyIGRhdGEgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGRldGVjdE5ld2xpbmUpO1xuXG4gICAgICBfZGV0ZWN0TmV3bGluZSA9IGZ1bmN0aW9uIF9kZXRlY3ROZXdsaW5lKCkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gICAgICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICAgICAqL1xuXG5cbiAgICB2YXIgY29tbWVudEVuZFJlID0gL1xcKlxcLyQvO1xuICAgIHZhciBjb21tZW50U3RhcnRSZSA9IC9eXFwvXFwqXFwqLztcbiAgICB2YXIgZG9jYmxvY2tSZSA9IC9eXFxzKihcXC9cXCpcXCo/KC58XFxyP1xcbikqP1xcKlxcLykvO1xuICAgIHZhciBsaW5lQ29tbWVudFJlID0gLyhefFxccyspXFwvXFwvKFteXFxyXFxuXSopL2c7XG4gICAgdmFyIGx0cmltTmV3bGluZVJlID0gL14oXFxyP1xcbikrLztcbiAgICB2YXIgbXVsdGlsaW5lUmUgPSAvKD86XnxcXHI/XFxuKSAqKEBbXlxcclxcbl0qPykgKlxccj9cXG4gKig/IVteQFxcclxcbl0qXFwvXFwvW15dKikoW15AXFxyXFxuXFxzXVteQFxcclxcbl0rPykgKlxccj9cXG4vZztcbiAgICB2YXIgcHJvcGVydHlSZSA9IC8oPzpefFxccj9cXG4pICpAKFxcUyspICooW15cXHJcXG5dKikvZztcbiAgICB2YXIgc3RyaW5nU3RhcnRSZSA9IC8oXFxyP1xcbnxeKSAqXFwqID8vZztcblxuICAgIGZ1bmN0aW9uIGV4dHJhY3QoY29udGVudHMpIHtcbiAgICAgIHZhciBtYXRjaCA9IGNvbnRlbnRzLm1hdGNoKGRvY2Jsb2NrUmUpO1xuICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMF0udHJpbUxlZnQoKSA6ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0cmlwKGNvbnRlbnRzKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBjb250ZW50cy5tYXRjaChkb2NibG9ja1JlKTtcbiAgICAgIHJldHVybiBtYXRjaCAmJiBtYXRjaFswXSA/IGNvbnRlbnRzLnN1YnN0cmluZyhtYXRjaFswXS5sZW5ndGgpIDogY29udGVudHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2UoZG9jYmxvY2spIHtcbiAgICAgIHJldHVybiBwYXJzZVdpdGhDb21tZW50cyhkb2NibG9jaykucHJhZ21hcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVdpdGhDb21tZW50cyhkb2NibG9jaykge1xuICAgICAgdmFyIGxpbmUgPSAoMCwgX2RldGVjdE5ld2xpbmUoKS5kZWZhdWx0KShkb2NibG9jaykgfHwgX29zKCkuRU9MO1xuXG4gICAgICBkb2NibG9jayA9IGRvY2Jsb2NrLnJlcGxhY2UoY29tbWVudFN0YXJ0UmUsICcnKS5yZXBsYWNlKGNvbW1lbnRFbmRSZSwgJycpLnJlcGxhY2Uoc3RyaW5nU3RhcnRSZSwgJyQxJyk7IC8vIE5vcm1hbGl6ZSBtdWx0aS1saW5lIGRpcmVjdGl2ZXNcblxuICAgICAgdmFyIHByZXYgPSAnJztcblxuICAgICAgd2hpbGUgKHByZXYgIT09IGRvY2Jsb2NrKSB7XG4gICAgICAgIHByZXYgPSBkb2NibG9jaztcbiAgICAgICAgZG9jYmxvY2sgPSBkb2NibG9jay5yZXBsYWNlKG11bHRpbGluZVJlLCBcIlwiLmNvbmNhdChsaW5lLCBcIiQxICQyXCIpLmNvbmNhdChsaW5lKSk7XG4gICAgICB9XG5cbiAgICAgIGRvY2Jsb2NrID0gZG9jYmxvY2sucmVwbGFjZShsdHJpbU5ld2xpbmVSZSwgJycpLnRyaW1SaWdodCgpO1xuICAgICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB2YXIgY29tbWVudHMgPSBkb2NibG9jay5yZXBsYWNlKHByb3BlcnR5UmUsICcnKS5yZXBsYWNlKGx0cmltTmV3bGluZVJlLCAnJykudHJpbVJpZ2h0KCk7XG4gICAgICB2YXIgbWF0Y2g7XG5cbiAgICAgIHdoaWxlIChtYXRjaCA9IHByb3BlcnR5UmUuZXhlYyhkb2NibG9jaykpIHtcbiAgICAgICAgLy8gc3RyaXAgbGluZWNvbW1lbnRzIGZyb20gcHJhZ21hc1xuICAgICAgICB2YXIgbmV4dFByYWdtYSA9IG1hdGNoWzJdLnJlcGxhY2UobGluZUNvbW1lbnRSZSwgJycpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0W21hdGNoWzFdXSA9PT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheShyZXN1bHRbbWF0Y2hbMV1dKSkge1xuICAgICAgICAgIHJlc3VsdFttYXRjaFsxXV0gPSBbXS5jb25jYXQocmVzdWx0W21hdGNoWzFdXSwgbmV4dFByYWdtYSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W21hdGNoWzFdXSA9IG5leHRQcmFnbWE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29tbWVudHM6IGNvbW1lbnRzLFxuICAgICAgICBwcmFnbWFzOiByZXN1bHRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJpbnQoX3JlZikge1xuICAgICAgdmFyIF9yZWYkY29tbWVudHMgPSBfcmVmLmNvbW1lbnRzLFxuICAgICAgICAgIGNvbW1lbnRzID0gX3JlZiRjb21tZW50cyA9PT0gdm9pZCAwID8gJycgOiBfcmVmJGNvbW1lbnRzLFxuICAgICAgICAgIF9yZWYkcHJhZ21hcyA9IF9yZWYucHJhZ21hcyxcbiAgICAgICAgICBwcmFnbWFzID0gX3JlZiRwcmFnbWFzID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkcHJhZ21hcztcblxuICAgICAgdmFyIGxpbmUgPSAoMCwgX2RldGVjdE5ld2xpbmUoKS5kZWZhdWx0KShjb21tZW50cykgfHwgX29zKCkuRU9MO1xuXG4gICAgICB2YXIgaGVhZCA9ICcvKionO1xuICAgICAgdmFyIHN0YXJ0ID0gJyAqJztcbiAgICAgIHZhciB0YWlsID0gJyAqLyc7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByYWdtYXMpO1xuICAgICAgdmFyIHByaW50ZWRPYmplY3QgPSBrZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBwcmludEtleVZhbHVlcyhrZXksIHByYWdtYXNba2V5XSk7XG4gICAgICB9KS5yZWR1Y2UoZnVuY3Rpb24gKGFyciwgbmV4dCkge1xuICAgICAgICByZXR1cm4gYXJyLmNvbmNhdChuZXh0KTtcbiAgICAgIH0sIFtdKS5tYXAoZnVuY3Rpb24gKGtleVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBzdGFydCArICcgJyArIGtleVZhbHVlICsgbGluZTtcbiAgICAgIH0pLmpvaW4oJycpO1xuXG4gICAgICBpZiAoIWNvbW1lbnRzKSB7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMSAmJiAhQXJyYXkuaXNBcnJheShwcmFnbWFzW2tleXNbMF1dKSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHByYWdtYXNba2V5c1swXV07XG4gICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGhlYWQsIFwiIFwiKS5jb25jYXQocHJpbnRLZXlWYWx1ZXMoa2V5c1swXSwgdmFsdWUpWzBdKS5jb25jYXQodGFpbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHByaW50ZWRDb21tZW50cyA9IGNvbW1lbnRzLnNwbGl0KGxpbmUpLm1hcChmdW5jdGlvbiAodGV4dExpbmUpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHN0YXJ0LCBcIiBcIikuY29uY2F0KHRleHRMaW5lKTtcbiAgICAgIH0pLmpvaW4obGluZSkgKyBsaW5lO1xuICAgICAgcmV0dXJuIGhlYWQgKyBsaW5lICsgKGNvbW1lbnRzID8gcHJpbnRlZENvbW1lbnRzIDogJycpICsgKGNvbW1lbnRzICYmIGtleXMubGVuZ3RoID8gc3RhcnQgKyBsaW5lIDogJycpICsgcHJpbnRlZE9iamVjdCArIHRhaWw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJpbnRLZXlWYWx1ZXMoa2V5LCB2YWx1ZU9yQXJyYXkpIHtcbiAgICAgIHJldHVybiBbXS5jb25jYXQodmFsdWVPckFycmF5KS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBcIkBcIi5jb25jYXQoa2V5LCBcIiBcIikuY29uY2F0KHZhbHVlKS50cmltKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICB1bndyYXBFeHBvcnRzKGJ1aWxkKTtcbiAgdmFyIGJ1aWxkXzEgPSBidWlsZC5leHRyYWN0O1xuICB2YXIgYnVpbGRfMiA9IGJ1aWxkLnN0cmlwO1xuICB2YXIgYnVpbGRfMyA9IGJ1aWxkLnBhcnNlO1xuICB2YXIgYnVpbGRfNCA9IGJ1aWxkLnBhcnNlV2l0aENvbW1lbnRzO1xuICB2YXIgYnVpbGRfNSA9IGJ1aWxkLnByaW50O1xuXG4gIGZ1bmN0aW9uIGhhc1ByYWdtYSh0ZXh0KSB7XG4gICAgdmFyIHByYWdtYXMgPSBPYmplY3Qua2V5cyhidWlsZC5wYXJzZShidWlsZC5leHRyYWN0KHRleHQpKSk7XG4gICAgcmV0dXJuIHByYWdtYXMuaW5kZXhPZihcInByZXR0aWVyXCIpICE9PSAtMSB8fCBwcmFnbWFzLmluZGV4T2YoXCJmb3JtYXRcIikgIT09IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0UHJhZ21hKHRleHQpIHtcbiAgICB2YXIgcGFyc2VkRG9jYmxvY2sgPSBidWlsZC5wYXJzZVdpdGhDb21tZW50cyhidWlsZC5leHRyYWN0KHRleHQpKTtcbiAgICB2YXIgcHJhZ21hcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgZm9ybWF0OiBcIlwiXG4gICAgfSwgcGFyc2VkRG9jYmxvY2sucHJhZ21hcyk7XG4gICAgdmFyIG5ld0RvY2Jsb2NrID0gYnVpbGQucHJpbnQoe1xuICAgICAgcHJhZ21hczogcHJhZ21hcyxcbiAgICAgIGNvbW1lbnRzOiBwYXJzZWREb2NibG9jay5jb21tZW50cy5yZXBsYWNlKC9eKFxccys/XFxyP1xcbikrLywgXCJcIikgLy8gcmVtb3ZlIGxlYWRpbmcgbmV3bGluZXNcblxuICAgIH0pLnJlcGxhY2UoLyhcXHJcXG58XFxyKS9nLCBcIlxcblwiKTsgLy8gbm9ybWFsaXNlIG5ld2xpbmVzIChtaXRpZ2F0ZSB1c2Ugb2Ygb3MuRU9MIGJ5IGplc3QtZG9jYmxvY2spXG5cbiAgICB2YXIgc3RyaXBwZWRUZXh0ID0gYnVpbGQuc3RyaXAodGV4dCk7XG4gICAgdmFyIHNlcGFyYXRpbmdOZXdsaW5lcyA9IHN0cmlwcGVkVGV4dC5zdGFydHNXaXRoKFwiXFxuXCIpID8gXCJcXG5cIiA6IFwiXFxuXFxuXCI7XG4gICAgcmV0dXJuIG5ld0RvY2Jsb2NrICsgc2VwYXJhdGluZ05ld2xpbmVzICsgc3RyaXBwZWRUZXh0O1xuICB9XG5cbiAgdmFyIHByYWdtYSA9IHtcbiAgICBoYXNQcmFnbWE6IGhhc1ByYWdtYSxcbiAgICBpbnNlcnRQcmFnbWE6IGluc2VydFByYWdtYVxuICB9O1xuXG4gIHZhciBERUxJTUlURVJfTUFQID0ge1xuICAgIFwiLS0tXCI6IFwieWFtbFwiLFxuICAgIFwiKysrXCI6IFwidG9tbFwiXG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2UkMSh0ZXh0KSB7XG4gICAgdmFyIGRlbGltaXRlclJlZ2V4ID0gT2JqZWN0LmtleXMoREVMSU1JVEVSX01BUCkubWFwKGVzY2FwZVN0cmluZ1JlZ2V4cCkuam9pbihcInxcIik7XG4gICAgdmFyIG1hdGNoID0gdGV4dC5tYXRjaCggLy8gdHJhaWxpbmcgc3BhY2VzIGFmdGVyIGRlbGltaXRlcnMgYXJlIGFsbG93ZWRcbiAgICBuZXcgUmVnRXhwKFwiXihcIi5jb25jYXQoZGVsaW1pdGVyUmVnZXgsIFwiKVteXFxcXG5cXFxcU10qXFxcXG4oPzooW1xcXFxzXFxcXFNdKj8pXFxcXG4pP1xcXFwxW15cXFxcblxcXFxTXSooXFxcXG58JClcIikpKTtcblxuICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbnRNYXR0ZXI6IG51bGwsXG4gICAgICAgIGNvbnRlbnQ6IHRleHRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHJhdyA9IG1hdGNoWzBdLnJlcGxhY2UoL1xcbiQvLCBcIlwiKTtcbiAgICB2YXIgZGVsaW1pdGVyID0gbWF0Y2hbMV07XG4gICAgdmFyIHZhbHVlID0gbWF0Y2hbMl07XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb250TWF0dGVyOiB7XG4gICAgICAgIHR5cGU6IERFTElNSVRFUl9NQVBbZGVsaW1pdGVyXSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICByYXc6IHJhd1xuICAgICAgfSxcbiAgICAgIGNvbnRlbnQ6IG1hdGNoWzBdLnJlcGxhY2UoL1teXFxuXS9nLCBcIiBcIikgKyB0ZXh0LnNsaWNlKG1hdGNoWzBdLmxlbmd0aClcbiAgICB9O1xuICB9XG5cbiAgdmFyIGZyb250TWF0dGVyID0gcGFyc2UkMTtcblxuICBmdW5jdGlvbiBoYXNQcmFnbWEkMSh0ZXh0KSB7XG4gICAgcmV0dXJuIHByYWdtYS5oYXNQcmFnbWEoZnJvbnRNYXR0ZXIodGV4dCkuY29udGVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnRQcmFnbWEkMSh0ZXh0KSB7XG4gICAgdmFyIF9wYXJzZUZyb250TWF0dGVyID0gZnJvbnRNYXR0ZXIodGV4dCksXG4gICAgICAgIGZyb250TWF0dGVyJDEgPSBfcGFyc2VGcm9udE1hdHRlci5mcm9udE1hdHRlcixcbiAgICAgICAgY29udGVudCA9IF9wYXJzZUZyb250TWF0dGVyLmNvbnRlbnQ7XG5cbiAgICByZXR1cm4gKGZyb250TWF0dGVyJDEgPyBmcm9udE1hdHRlciQxLnJhdyArIFwiXFxuXFxuXCIgOiBcIlwiKSArIHByYWdtYS5pbnNlcnRQcmFnbWEoY29udGVudCk7XG4gIH1cblxuICB2YXIgcHJhZ21hJDEgPSB7XG4gICAgaGFzUHJhZ21hOiBoYXNQcmFnbWEkMSxcbiAgICBpbnNlcnRQcmFnbWE6IGluc2VydFByYWdtYSQxXG4gIH07XG5cbiAgdmFyIGNvbG9yQWRqdXN0ZXJGdW5jdGlvbnMgPSBbXCJyZWRcIiwgXCJncmVlblwiLCBcImJsdWVcIiwgXCJhbHBoYVwiLCBcImFcIiwgXCJyZ2JcIiwgXCJodWVcIiwgXCJoXCIsIFwic2F0dXJhdGlvblwiLCBcInNcIiwgXCJsaWdodG5lc3NcIiwgXCJsXCIsIFwid2hpdGVuZXNzXCIsIFwid1wiLCBcImJsYWNrbmVzc1wiLCBcImJcIiwgXCJ0aW50XCIsIFwic2hhZGVcIiwgXCJibGVuZFwiLCBcImJsZW5kYVwiLCBcImNvbnRyYXN0XCIsIFwiaHNsXCIsIFwiaHNsYVwiLCBcImh3YlwiLCBcImh3YmFcIl07XG5cbiAgZnVuY3Rpb24gZ2V0QW5jZXN0b3JDb3VudGVyKHBhdGgsIHR5cGVPclR5cGVzKSB7XG4gICAgdmFyIHR5cGVzID0gW10uY29uY2F0KHR5cGVPclR5cGVzKTtcbiAgICB2YXIgY291bnRlciA9IC0xO1xuICAgIHZhciBhbmNlc3Rvck5vZGU7XG5cbiAgICB3aGlsZSAoYW5jZXN0b3JOb2RlID0gcGF0aC5nZXRQYXJlbnROb2RlKCsrY291bnRlcikpIHtcbiAgICAgIGlmICh0eXBlcy5pbmRleE9mKGFuY2VzdG9yTm9kZS50eXBlKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGNvdW50ZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QW5jZXN0b3JOb2RlKHBhdGgsIHR5cGVPclR5cGVzKSB7XG4gICAgdmFyIGNvdW50ZXIgPSBnZXRBbmNlc3RvckNvdW50ZXIocGF0aCwgdHlwZU9yVHlwZXMpO1xuICAgIHJldHVybiBjb3VudGVyID09PSAtMSA/IG51bGwgOiBwYXRoLmdldFBhcmVudE5vZGUoY291bnRlcik7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQcm9wT2ZEZWNsTm9kZShwYXRoKSB7XG4gICAgdmFyIGRlY2xBbmNlc3Rvck5vZGUgPSBnZXRBbmNlc3Rvck5vZGUocGF0aCwgXCJjc3MtZGVjbFwiKTtcbiAgICByZXR1cm4gZGVjbEFuY2VzdG9yTm9kZSAmJiBkZWNsQW5jZXN0b3JOb2RlLnByb3AgJiYgZGVjbEFuY2VzdG9yTm9kZS5wcm9wLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBpc1NDU1MocGFyc2VyLCB0ZXh0KSB7XG4gICAgdmFyIGhhc0V4cGxpY2l0UGFyc2VyQ2hvaWNlID0gcGFyc2VyID09PSBcImxlc3NcIiB8fCBwYXJzZXIgPT09IFwic2Nzc1wiO1xuICAgIHZhciBJU19QT1NTSUJMWV9TQ1NTID0gLyhcXHdcXHMqOiBbXn06XSt8Iyl7fEBpbXBvcnRbXlxcbl0rKHVybHwsKS87XG4gICAgcmV0dXJuIGhhc0V4cGxpY2l0UGFyc2VyQ2hvaWNlID8gcGFyc2VyID09PSBcInNjc3NcIiA6IElTX1BPU1NJQkxZX1NDU1MudGVzdCh0ZXh0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzV2lkZUtleXdvcmRzKHZhbHVlKSB7XG4gICAgcmV0dXJuIFtcImluaXRpYWxcIiwgXCJpbmhlcml0XCIsIFwidW5zZXRcIiwgXCJyZXZlcnRcIl0uaW5kZXhPZih2YWx1ZS50b0xvd2VyQ2FzZSgpKSAhPT0gLTE7XG4gIH1cblxuICBmdW5jdGlvbiBpc0tleWZyYW1lQXRSdWxlS2V5d29yZHMocGF0aCwgdmFsdWUpIHtcbiAgICB2YXIgYXRSdWxlQW5jZXN0b3JOb2RlID0gZ2V0QW5jZXN0b3JOb2RlKHBhdGgsIFwiY3NzLWF0cnVsZVwiKTtcbiAgICByZXR1cm4gYXRSdWxlQW5jZXN0b3JOb2RlICYmIGF0UnVsZUFuY2VzdG9yTm9kZS5uYW1lICYmIGF0UnVsZUFuY2VzdG9yTm9kZS5uYW1lLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoXCJrZXlmcmFtZXNcIikgJiYgW1wiZnJvbVwiLCBcInRvXCJdLmluZGV4T2YodmFsdWUudG9Mb3dlckNhc2UoKSkgIT09IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF5YmVUb0xvd2VyQ2FzZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5pbmNsdWRlcyhcIiRcIikgfHwgdmFsdWUuaW5jbHVkZXMoXCJAXCIpIHx8IHZhbHVlLmluY2x1ZGVzKFwiI1wiKSB8fCB2YWx1ZS5zdGFydHNXaXRoKFwiJVwiKSB8fCB2YWx1ZS5zdGFydHNXaXRoKFwiLS1cIikgfHwgdmFsdWUuc3RhcnRzV2l0aChcIjotLVwiKSB8fCB2YWx1ZS5pbmNsdWRlcyhcIihcIikgJiYgdmFsdWUuaW5jbHVkZXMoXCIpXCIpID8gdmFsdWUgOiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zaWRlVmFsdWVGdW5jdGlvbk5vZGUocGF0aCwgZnVuY3Rpb25OYW1lKSB7XG4gICAgdmFyIGZ1bmNBbmNlc3Rvck5vZGUgPSBnZXRBbmNlc3Rvck5vZGUocGF0aCwgXCJ2YWx1ZS1mdW5jXCIpO1xuICAgIHJldHVybiBmdW5jQW5jZXN0b3JOb2RlICYmIGZ1bmNBbmNlc3Rvck5vZGUudmFsdWUgJiYgZnVuY0FuY2VzdG9yTm9kZS52YWx1ZS50b0xvd2VyQ2FzZSgpID09PSBmdW5jdGlvbk5hbWU7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNpZGVJQ1NTUnVsZU5vZGUocGF0aCkge1xuICAgIHZhciBydWxlQW5jZXN0b3JOb2RlID0gZ2V0QW5jZXN0b3JOb2RlKHBhdGgsIFwiY3NzLXJ1bGVcIik7XG4gICAgcmV0dXJuIHJ1bGVBbmNlc3Rvck5vZGUgJiYgcnVsZUFuY2VzdG9yTm9kZS5yYXdzICYmIHJ1bGVBbmNlc3Rvck5vZGUucmF3cy5zZWxlY3RvciAmJiAocnVsZUFuY2VzdG9yTm9kZS5yYXdzLnNlbGVjdG9yLnN0YXJ0c1dpdGgoXCI6aW1wb3J0XCIpIHx8IHJ1bGVBbmNlc3Rvck5vZGUucmF3cy5zZWxlY3Rvci5zdGFydHNXaXRoKFwiOmV4cG9ydFwiKSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNpZGVBdFJ1bGVOb2RlKHBhdGgsIGF0UnVsZU5hbWVPckF0UnVsZU5hbWVzKSB7XG4gICAgdmFyIGF0UnVsZU5hbWVzID0gW10uY29uY2F0KGF0UnVsZU5hbWVPckF0UnVsZU5hbWVzKTtcbiAgICB2YXIgYXRSdWxlQW5jZXN0b3JOb2RlID0gZ2V0QW5jZXN0b3JOb2RlKHBhdGgsIFwiY3NzLWF0cnVsZVwiKTtcbiAgICByZXR1cm4gYXRSdWxlQW5jZXN0b3JOb2RlICYmIGF0UnVsZU5hbWVzLmluZGV4T2YoYXRSdWxlQW5jZXN0b3JOb2RlLm5hbWUudG9Mb3dlckNhc2UoKSkgIT09IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zaWRlVVJMRnVuY3Rpb25JbkltcG9ydEF0UnVsZU5vZGUocGF0aCkge1xuICAgIHZhciBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIHZhciBhdFJ1bGVBbmNlc3Rvck5vZGUgPSBnZXRBbmNlc3Rvck5vZGUocGF0aCwgXCJjc3MtYXRydWxlXCIpO1xuICAgIHJldHVybiBhdFJ1bGVBbmNlc3Rvck5vZGUgJiYgYXRSdWxlQW5jZXN0b3JOb2RlLm5hbWUgPT09IFwiaW1wb3J0XCIgJiYgbm9kZS5ncm91cHNbMF0udmFsdWUgPT09IFwidXJsXCIgJiYgbm9kZS5ncm91cHMubGVuZ3RoID09PSAyO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNVUkxGdW5jdGlvbk5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwidmFsdWUtZnVuY1wiICYmIG5vZGUudmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ1cmxcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTGFzdE5vZGUocGF0aCwgbm9kZSkge1xuICAgIHZhciBwYXJlbnROb2RlID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG5cbiAgICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZXMgPSBwYXJlbnROb2RlLm5vZGVzO1xuICAgIHJldHVybiBub2RlcyAmJiBub2Rlcy5pbmRleE9mKG5vZGUpID09PSBub2Rlcy5sZW5ndGggLSAxO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNIVE1MVGFnKHZhbHVlKSB7XG4gICAgcmV0dXJuIGh0bWxUYWdOYW1lcyQxLmluZGV4T2YodmFsdWUudG9Mb3dlckNhc2UoKSkgIT09IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNEZXRhY2hlZFJ1bGVzZXREZWNsYXJhdGlvbk5vZGUobm9kZSkge1xuICAgIC8vIElmIGEgTGVzcyBmaWxlIGVuZHMgdXAgYmVpbmcgcGFyc2VkIHdpdGggdGhlIFNDU1MgcGFyc2VyLCBMZXNzXG4gICAgLy8gdmFyaWFibGUgZGVjbGFyYXRpb25zIHdpbGwgYmUgcGFyc2VkIGFzIGF0cnVsZXMgd2l0aCBuYW1lcyBlbmRpbmdcbiAgICAvLyB3aXRoIGEgY29sb24sIHNvIGtlZXAgdGhlIG9yaWdpbmFsIGNhc2UgdGhlbi5cbiAgICBpZiAoIW5vZGUuc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZW9mIG5vZGUuc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgL15ALis6LiokLy50ZXN0KG5vZGUuc2VsZWN0b3IpIHx8IG5vZGUuc2VsZWN0b3IudmFsdWUgJiYgL15ALis6LiokLy50ZXN0KG5vZGUuc2VsZWN0b3IudmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNGb3JLZXl3b3JkTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJ2YWx1ZS13b3JkXCIgJiYgW1wiZnJvbVwiLCBcInRocm91Z2hcIiwgXCJlbmRcIl0uaW5kZXhPZihub2RlLnZhbHVlKSAhPT0gLTE7XG4gIH1cblxuICBmdW5jdGlvbiBpc0lmRWxzZUtleXdvcmROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcInZhbHVlLXdvcmRcIiAmJiBbXCJhbmRcIiwgXCJvclwiLCBcIm5vdFwiXS5pbmRleE9mKG5vZGUudmFsdWUpICE9PSAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRWFjaEtleXdvcmROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcInZhbHVlLXdvcmRcIiAmJiBub2RlLnZhbHVlID09PSBcImluXCI7XG4gIH1cblxuICBmdW5jdGlvbiBpc011bHRpcGxpY2F0aW9uTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJ2YWx1ZS1vcGVyYXRvclwiICYmIG5vZGUudmFsdWUgPT09IFwiKlwiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNEaXZpc2lvbk5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwidmFsdWUtb3BlcmF0b3JcIiAmJiBub2RlLnZhbHVlID09PSBcIi9cIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQWRkaXRpb25Ob2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcInZhbHVlLW9wZXJhdG9yXCIgJiYgbm9kZS52YWx1ZSA9PT0gXCIrXCI7XG4gIH1cblxuICBmdW5jdGlvbiBpc1N1YnRyYWN0aW9uTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJ2YWx1ZS1vcGVyYXRvclwiICYmIG5vZGUudmFsdWUgPT09IFwiLVwiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNNb2R1bG9Ob2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcInZhbHVlLW9wZXJhdG9yXCIgJiYgbm9kZS52YWx1ZSA9PT0gXCIlXCI7XG4gIH1cblxuICBmdW5jdGlvbiBpc01hdGhPcGVyYXRvck5vZGUobm9kZSkge1xuICAgIHJldHVybiBpc011bHRpcGxpY2F0aW9uTm9kZShub2RlKSB8fCBpc0RpdmlzaW9uTm9kZShub2RlKSB8fCBpc0FkZGl0aW9uTm9kZShub2RlKSB8fCBpc1N1YnRyYWN0aW9uTm9kZShub2RlKSB8fCBpc01vZHVsb05vZGUobm9kZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0VxdWFsaXR5T3BlcmF0b3JOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcInZhbHVlLXdvcmRcIiAmJiBbXCI9PVwiLCBcIiE9XCJdLmluZGV4T2Yobm9kZS52YWx1ZSkgIT09IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNSZWxhdGlvbmFsT3BlcmF0b3JOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcInZhbHVlLXdvcmRcIiAmJiBbXCI8XCIsIFwiPlwiLCBcIjw9XCIsIFwiPj1cIl0uaW5kZXhPZihub2RlLnZhbHVlKSAhPT0gLTE7XG4gIH1cblxuICBmdW5jdGlvbiBpc1NDU1NDb250cm9sRGlyZWN0aXZlTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJjc3MtYXRydWxlXCIgJiYgW1wiaWZcIiwgXCJlbHNlXCIsIFwiZm9yXCIsIFwiZWFjaFwiLCBcIndoaWxlXCJdLmluZGV4T2Yobm9kZS5uYW1lKSAhPT0gLTE7XG4gIH1cblxuICBmdW5jdGlvbiBpc1NDU1NOZXN0ZWRQcm9wZXJ0eU5vZGUobm9kZSkge1xuICAgIGlmICghbm9kZS5zZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlLnNlbGVjdG9yLnJlcGxhY2UoL1xcL1xcKi4qP1xcKlxcLy8sIFwiXCIpLnJlcGxhY2UoL1xcL1xcLy4qP1xcbi8sIFwiXCIpLnRyaW0oKS5lbmRzV2l0aChcIjpcIik7XG4gIH1cblxuICBmdW5jdGlvbiBpc0RldGFjaGVkUnVsZXNldENhbGxOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5yYXdzICYmIG5vZGUucmF3cy5wYXJhbXMgJiYgL15cXChcXHMqXFwpJC8udGVzdChub2RlLnJhd3MucGFyYW1zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVGVtcGxhdGVQbGFjZWhvbGRlck5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5hbWUuc3RhcnRzV2l0aChcInByZXR0aWVyLXBsYWNlaG9sZGVyXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNUZW1wbGF0ZVByb3BOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5wcm9wLnN0YXJ0c1dpdGgoXCJAcHJldHRpZXItcGxhY2Vob2xkZXJcIik7XG4gIH1cblxuICBmdW5jdGlvbiBpc1Bvc3Rjc3NTaW1wbGVWYXJOb2RlKGN1cnJlbnROb2RlLCBuZXh0Tm9kZSkge1xuICAgIHJldHVybiBjdXJyZW50Tm9kZS52YWx1ZSA9PT0gXCIkJFwiICYmIGN1cnJlbnROb2RlLnR5cGUgPT09IFwidmFsdWUtZnVuY1wiICYmIG5leHROb2RlICYmIG5leHROb2RlLnR5cGUgPT09IFwidmFsdWUtd29yZFwiICYmICFuZXh0Tm9kZS5yYXdzLmJlZm9yZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0NvbXBvc2VzTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudmFsdWUgJiYgbm9kZS52YWx1ZS50eXBlID09PSBcInZhbHVlLXJvb3RcIiAmJiBub2RlLnZhbHVlLmdyb3VwICYmIG5vZGUudmFsdWUuZ3JvdXAudHlwZSA9PT0gXCJ2YWx1ZS12YWx1ZVwiICYmIG5vZGUucHJvcC50b0xvd2VyQ2FzZSgpID09PSBcImNvbXBvc2VzXCI7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNQYXJlbnNBcm91bmROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS52YWx1ZSAmJiBub2RlLnZhbHVlLmdyb3VwICYmIG5vZGUudmFsdWUuZ3JvdXAuZ3JvdXAgJiYgbm9kZS52YWx1ZS5ncm91cC5ncm91cC50eXBlID09PSBcInZhbHVlLXBhcmVuX2dyb3VwXCIgJiYgbm9kZS52YWx1ZS5ncm91cC5ncm91cC5vcGVuICE9PSBudWxsICYmIG5vZGUudmFsdWUuZ3JvdXAuZ3JvdXAuY2xvc2UgIT09IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNFbXB0eVJhd0JlZm9yZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUucmF3cyAmJiBub2RlLnJhd3MuYmVmb3JlID09PSBcIlwiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNLZXlWYWx1ZVBhaXJOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcInZhbHVlLWNvbW1hX2dyb3VwXCIgJiYgbm9kZS5ncm91cHMgJiYgbm9kZS5ncm91cHNbMV0gJiYgbm9kZS5ncm91cHNbMV0udHlwZSA9PT0gXCJ2YWx1ZS1jb2xvblwiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNLZXlWYWx1ZVBhaXJJblBhcmVuR3JvdXBOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcInZhbHVlLXBhcmVuX2dyb3VwXCIgJiYgbm9kZS5ncm91cHMgJiYgbm9kZS5ncm91cHNbMF0gJiYgaXNLZXlWYWx1ZVBhaXJOb2RlKG5vZGUuZ3JvdXBzWzBdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU0NTU01hcEl0ZW1Ob2RlKHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTsgLy8gSWdub3JlIGVtcHR5IGl0ZW0gKGkuZS4gYCRrZXk6ICgpYClcblxuICAgIGlmIChub2RlLmdyb3Vwcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50UGFyZW50Tm9kZSA9IHBhdGguZ2V0UGFyZW50Tm9kZSgxKTsgLy8gQ2hlY2sgb3BlbiBwYXJlbnMgY29udGFpbiBrZXkvdmFsdWUgcGFpciAoaS5lLiBgKGtleTogdmFsdWUpYCBhbmQgYChrZXk6ICh2YWx1ZSwgb3RoZXItdmFsdWUpYClcblxuICAgIGlmICghaXNLZXlWYWx1ZVBhaXJJblBhcmVuR3JvdXBOb2RlKG5vZGUpICYmICEocGFyZW50UGFyZW50Tm9kZSAmJiBpc0tleVZhbHVlUGFpckluUGFyZW5Hcm91cE5vZGUocGFyZW50UGFyZW50Tm9kZSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGRlY2xOb2RlID0gZ2V0QW5jZXN0b3JOb2RlKHBhdGgsIFwiY3NzLWRlY2xcIik7IC8vIFNDU1MgbWFwIGRlY2xhcmF0aW9uIChpLmUuIGAkbWFwOiAoa2V5OiB2YWx1ZSwgb3RoZXIta2V5OiBvdGhlci12YWx1ZSlgKVxuXG4gICAgaWYgKGRlY2xOb2RlICYmIGRlY2xOb2RlLnByb3AgJiYgZGVjbE5vZGUucHJvcC5zdGFydHNXaXRoKFwiJFwiKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBMaXN0IGFzIHZhbHVlIG9mIGtleSBpbnNpZGUgU0NTUyBtYXAgKGkuZS4gYCRtYXA6IChrZXk6ICh2YWx1ZSBvdGhlci12YWx1ZSBvdGhlci1vdGhlci12YWx1ZSkpYClcblxuXG4gICAgaWYgKGlzS2V5VmFsdWVQYWlySW5QYXJlbkdyb3VwTm9kZShwYXJlbnRQYXJlbnROb2RlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBTQ1NTIE1hcCBpcyBhcmd1bWVudCBvZiBmdW5jdGlvbiAoaS5lLiBgZnVuYygoa2V5OiB2YWx1ZSwgb3RoZXIta2V5OiBvdGhlci12YWx1ZSkpYClcblxuXG4gICAgaWYgKHBhcmVudFBhcmVudE5vZGUudHlwZSA9PT0gXCJ2YWx1ZS1mdW5jXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSW5saW5lVmFsdWVDb21tZW50Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJ2YWx1ZS1jb21tZW50XCIgJiYgbm9kZS5pbmxpbmU7XG4gIH1cblxuICBmdW5jdGlvbiBpc0hhc2hOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcInZhbHVlLXdvcmRcIiAmJiBub2RlLnZhbHVlID09PSBcIiNcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTGVmdEN1cmx5QnJhY2VOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcInZhbHVlLXdvcmRcIiAmJiBub2RlLnZhbHVlID09PSBcIntcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUmlnaHRDdXJseUJyYWNlTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJ2YWx1ZS13b3JkXCIgJiYgbm9kZS52YWx1ZSA9PT0gXCJ9XCI7XG4gIH1cblxuICBmdW5jdGlvbiBpc1dvcmROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gW1widmFsdWUtd29yZFwiLCBcInZhbHVlLWF0d29yZFwiXS5pbmRleE9mKG5vZGUudHlwZSkgIT09IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNDb2xvbk5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwidmFsdWUtY29sb25cIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTWVkaWFBbmRTdXBwb3J0c0tleXdvcmRzKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS52YWx1ZSAmJiBbXCJub3RcIiwgXCJhbmRcIiwgXCJvclwiXS5pbmRleE9mKG5vZGUudmFsdWUudG9Mb3dlckNhc2UoKSkgIT09IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNDb2xvckFkanVzdGVyRnVuY05vZGUobm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgIT09IFwidmFsdWUtZnVuY1wiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbG9yQWRqdXN0ZXJGdW5jdGlvbnMuaW5kZXhPZihub2RlLnZhbHVlLnRvTG93ZXJDYXNlKCkpICE9PSAtMTtcbiAgfVxuXG4gIHZhciB1dGlscyQyID0ge1xuICAgIGdldEFuY2VzdG9yQ291bnRlcjogZ2V0QW5jZXN0b3JDb3VudGVyLFxuICAgIGdldEFuY2VzdG9yTm9kZTogZ2V0QW5jZXN0b3JOb2RlLFxuICAgIGdldFByb3BPZkRlY2xOb2RlOiBnZXRQcm9wT2ZEZWNsTm9kZSxcbiAgICBtYXliZVRvTG93ZXJDYXNlOiBtYXliZVRvTG93ZXJDYXNlLFxuICAgIGluc2lkZVZhbHVlRnVuY3Rpb25Ob2RlOiBpbnNpZGVWYWx1ZUZ1bmN0aW9uTm9kZSxcbiAgICBpbnNpZGVJQ1NTUnVsZU5vZGU6IGluc2lkZUlDU1NSdWxlTm9kZSxcbiAgICBpbnNpZGVBdFJ1bGVOb2RlOiBpbnNpZGVBdFJ1bGVOb2RlLFxuICAgIGluc2lkZVVSTEZ1bmN0aW9uSW5JbXBvcnRBdFJ1bGVOb2RlOiBpbnNpZGVVUkxGdW5jdGlvbkluSW1wb3J0QXRSdWxlTm9kZSxcbiAgICBpc0tleWZyYW1lQXRSdWxlS2V5d29yZHM6IGlzS2V5ZnJhbWVBdFJ1bGVLZXl3b3JkcyxcbiAgICBpc0hUTUxUYWc6IGlzSFRNTFRhZyxcbiAgICBpc1dpZGVLZXl3b3JkczogaXNXaWRlS2V5d29yZHMsXG4gICAgaXNTQ1NTOiBpc1NDU1MsXG4gICAgaXNMYXN0Tm9kZTogaXNMYXN0Tm9kZSxcbiAgICBpc1NDU1NDb250cm9sRGlyZWN0aXZlTm9kZTogaXNTQ1NTQ29udHJvbERpcmVjdGl2ZU5vZGUsXG4gICAgaXNEZXRhY2hlZFJ1bGVzZXREZWNsYXJhdGlvbk5vZGU6IGlzRGV0YWNoZWRSdWxlc2V0RGVjbGFyYXRpb25Ob2RlLFxuICAgIGlzUmVsYXRpb25hbE9wZXJhdG9yTm9kZTogaXNSZWxhdGlvbmFsT3BlcmF0b3JOb2RlLFxuICAgIGlzRXF1YWxpdHlPcGVyYXRvck5vZGU6IGlzRXF1YWxpdHlPcGVyYXRvck5vZGUsXG4gICAgaXNNdWx0aXBsaWNhdGlvbk5vZGU6IGlzTXVsdGlwbGljYXRpb25Ob2RlLFxuICAgIGlzRGl2aXNpb25Ob2RlOiBpc0RpdmlzaW9uTm9kZSxcbiAgICBpc0FkZGl0aW9uTm9kZTogaXNBZGRpdGlvbk5vZGUsXG4gICAgaXNTdWJ0cmFjdGlvbk5vZGU6IGlzU3VidHJhY3Rpb25Ob2RlLFxuICAgIGlzTW9kdWxvTm9kZTogaXNNb2R1bG9Ob2RlLFxuICAgIGlzTWF0aE9wZXJhdG9yTm9kZTogaXNNYXRoT3BlcmF0b3JOb2RlLFxuICAgIGlzRWFjaEtleXdvcmROb2RlOiBpc0VhY2hLZXl3b3JkTm9kZSxcbiAgICBpc0ZvcktleXdvcmROb2RlOiBpc0ZvcktleXdvcmROb2RlLFxuICAgIGlzVVJMRnVuY3Rpb25Ob2RlOiBpc1VSTEZ1bmN0aW9uTm9kZSxcbiAgICBpc0lmRWxzZUtleXdvcmROb2RlOiBpc0lmRWxzZUtleXdvcmROb2RlLFxuICAgIGhhc0NvbXBvc2VzTm9kZTogaGFzQ29tcG9zZXNOb2RlLFxuICAgIGhhc1BhcmVuc0Fyb3VuZE5vZGU6IGhhc1BhcmVuc0Fyb3VuZE5vZGUsXG4gICAgaGFzRW1wdHlSYXdCZWZvcmU6IGhhc0VtcHR5UmF3QmVmb3JlLFxuICAgIGlzU0NTU05lc3RlZFByb3BlcnR5Tm9kZTogaXNTQ1NTTmVzdGVkUHJvcGVydHlOb2RlLFxuICAgIGlzRGV0YWNoZWRSdWxlc2V0Q2FsbE5vZGU6IGlzRGV0YWNoZWRSdWxlc2V0Q2FsbE5vZGUsXG4gICAgaXNUZW1wbGF0ZVBsYWNlaG9sZGVyTm9kZTogaXNUZW1wbGF0ZVBsYWNlaG9sZGVyTm9kZSxcbiAgICBpc1RlbXBsYXRlUHJvcE5vZGU6IGlzVGVtcGxhdGVQcm9wTm9kZSxcbiAgICBpc1Bvc3Rjc3NTaW1wbGVWYXJOb2RlOiBpc1Bvc3Rjc3NTaW1wbGVWYXJOb2RlLFxuICAgIGlzS2V5VmFsdWVQYWlyTm9kZTogaXNLZXlWYWx1ZVBhaXJOb2RlLFxuICAgIGlzS2V5VmFsdWVQYWlySW5QYXJlbkdyb3VwTm9kZTogaXNLZXlWYWx1ZVBhaXJJblBhcmVuR3JvdXBOb2RlLFxuICAgIGlzU0NTU01hcEl0ZW1Ob2RlOiBpc1NDU1NNYXBJdGVtTm9kZSxcbiAgICBpc0lubGluZVZhbHVlQ29tbWVudE5vZGU6IGlzSW5saW5lVmFsdWVDb21tZW50Tm9kZSxcbiAgICBpc0hhc2hOb2RlOiBpc0hhc2hOb2RlLFxuICAgIGlzTGVmdEN1cmx5QnJhY2VOb2RlOiBpc0xlZnRDdXJseUJyYWNlTm9kZSxcbiAgICBpc1JpZ2h0Q3VybHlCcmFjZU5vZGU6IGlzUmlnaHRDdXJseUJyYWNlTm9kZSxcbiAgICBpc1dvcmROb2RlOiBpc1dvcmROb2RlLFxuICAgIGlzQ29sb25Ob2RlOiBpc0NvbG9uTm9kZSxcbiAgICBpc01lZGlhQW5kU3VwcG9ydHNLZXl3b3JkczogaXNNZWRpYUFuZFN1cHBvcnRzS2V5d29yZHMsXG4gICAgaXNDb2xvckFkanVzdGVyRnVuY05vZGU6IGlzQ29sb3JBZGp1c3RlckZ1bmNOb2RlXG4gIH07XG5cbiAgdmFyIGluc2VydFByYWdtYSQyID0gcHJhZ21hJDEuaW5zZXJ0UHJhZ21hO1xuICB2YXIgcHJpbnROdW1iZXIkMSA9IHV0aWwucHJpbnROdW1iZXIsXG4gICAgICBwcmludFN0cmluZyQxID0gdXRpbC5wcmludFN0cmluZyxcbiAgICAgIGhhc0lnbm9yZUNvbW1lbnQkMSA9IHV0aWwuaGFzSWdub3JlQ29tbWVudCxcbiAgICAgIGhhc05ld2xpbmUkMiA9IHV0aWwuaGFzTmV3bGluZTtcbiAgdmFyIGlzTmV4dExpbmVFbXB0eSQyID0gdXRpbFNoYXJlZC5pc05leHRMaW5lRW1wdHk7XG4gIHZhciBfcmVxdWlyZSQkMyRidWlsZGVycyA9IGRvYy5idWlsZGVycyxcbiAgICAgIGNvbmNhdCQ1ID0gX3JlcXVpcmUkJDMkYnVpbGRlcnMuY29uY2F0LFxuICAgICAgam9pbiQyID0gX3JlcXVpcmUkJDMkYnVpbGRlcnMuam9pbixcbiAgICAgIGxpbmUkMSA9IF9yZXF1aXJlJCQzJGJ1aWxkZXJzLmxpbmUsXG4gICAgICBoYXJkbGluZSQ0ID0gX3JlcXVpcmUkJDMkYnVpbGRlcnMuaGFyZGxpbmUsXG4gICAgICBzb2Z0bGluZSQxID0gX3JlcXVpcmUkJDMkYnVpbGRlcnMuc29mdGxpbmUsXG4gICAgICBncm91cCQxID0gX3JlcXVpcmUkJDMkYnVpbGRlcnMuZ3JvdXAsXG4gICAgICBmaWxsJDIgPSBfcmVxdWlyZSQkMyRidWlsZGVycy5maWxsLFxuICAgICAgaW5kZW50JDIgPSBfcmVxdWlyZSQkMyRidWlsZGVycy5pbmRlbnQsXG4gICAgICBkZWRlbnQkMSA9IF9yZXF1aXJlJCQzJGJ1aWxkZXJzLmRlZGVudCxcbiAgICAgIGlmQnJlYWskMSA9IF9yZXF1aXJlJCQzJGJ1aWxkZXJzLmlmQnJlYWssXG4gICAgICByZW1vdmVMaW5lcyQxID0gZG9jLnV0aWxzLnJlbW92ZUxpbmVzO1xuICB2YXIgZ2V0QW5jZXN0b3JOb2RlJDEgPSB1dGlscyQyLmdldEFuY2VzdG9yTm9kZSxcbiAgICAgIGdldFByb3BPZkRlY2xOb2RlJDEgPSB1dGlscyQyLmdldFByb3BPZkRlY2xOb2RlLFxuICAgICAgbWF5YmVUb0xvd2VyQ2FzZSQxID0gdXRpbHMkMi5tYXliZVRvTG93ZXJDYXNlLFxuICAgICAgaW5zaWRlVmFsdWVGdW5jdGlvbk5vZGUkMSA9IHV0aWxzJDIuaW5zaWRlVmFsdWVGdW5jdGlvbk5vZGUsXG4gICAgICBpbnNpZGVJQ1NTUnVsZU5vZGUkMSA9IHV0aWxzJDIuaW5zaWRlSUNTU1J1bGVOb2RlLFxuICAgICAgaW5zaWRlQXRSdWxlTm9kZSQxID0gdXRpbHMkMi5pbnNpZGVBdFJ1bGVOb2RlLFxuICAgICAgaW5zaWRlVVJMRnVuY3Rpb25JbkltcG9ydEF0UnVsZU5vZGUkMSA9IHV0aWxzJDIuaW5zaWRlVVJMRnVuY3Rpb25JbkltcG9ydEF0UnVsZU5vZGUsXG4gICAgICBpc0tleWZyYW1lQXRSdWxlS2V5d29yZHMkMSA9IHV0aWxzJDIuaXNLZXlmcmFtZUF0UnVsZUtleXdvcmRzLFxuICAgICAgaXNIVE1MVGFnJDEgPSB1dGlscyQyLmlzSFRNTFRhZyxcbiAgICAgIGlzV2lkZUtleXdvcmRzJDEgPSB1dGlscyQyLmlzV2lkZUtleXdvcmRzLFxuICAgICAgaXNTQ1NTJDEgPSB1dGlscyQyLmlzU0NTUyxcbiAgICAgIGlzTGFzdE5vZGUkMSA9IHV0aWxzJDIuaXNMYXN0Tm9kZSxcbiAgICAgIGlzU0NTU0NvbnRyb2xEaXJlY3RpdmVOb2RlJDEgPSB1dGlscyQyLmlzU0NTU0NvbnRyb2xEaXJlY3RpdmVOb2RlLFxuICAgICAgaXNEZXRhY2hlZFJ1bGVzZXREZWNsYXJhdGlvbk5vZGUkMSA9IHV0aWxzJDIuaXNEZXRhY2hlZFJ1bGVzZXREZWNsYXJhdGlvbk5vZGUsXG4gICAgICBpc1JlbGF0aW9uYWxPcGVyYXRvck5vZGUkMSA9IHV0aWxzJDIuaXNSZWxhdGlvbmFsT3BlcmF0b3JOb2RlLFxuICAgICAgaXNFcXVhbGl0eU9wZXJhdG9yTm9kZSQxID0gdXRpbHMkMi5pc0VxdWFsaXR5T3BlcmF0b3JOb2RlLFxuICAgICAgaXNNdWx0aXBsaWNhdGlvbk5vZGUkMSA9IHV0aWxzJDIuaXNNdWx0aXBsaWNhdGlvbk5vZGUsXG4gICAgICBpc0RpdmlzaW9uTm9kZSQxID0gdXRpbHMkMi5pc0RpdmlzaW9uTm9kZSxcbiAgICAgIGlzQWRkaXRpb25Ob2RlJDEgPSB1dGlscyQyLmlzQWRkaXRpb25Ob2RlLFxuICAgICAgaXNTdWJ0cmFjdGlvbk5vZGUkMSA9IHV0aWxzJDIuaXNTdWJ0cmFjdGlvbk5vZGUsXG4gICAgICBpc01hdGhPcGVyYXRvck5vZGUkMSA9IHV0aWxzJDIuaXNNYXRoT3BlcmF0b3JOb2RlLFxuICAgICAgaXNFYWNoS2V5d29yZE5vZGUkMSA9IHV0aWxzJDIuaXNFYWNoS2V5d29yZE5vZGUsXG4gICAgICBpc0ZvcktleXdvcmROb2RlJDEgPSB1dGlscyQyLmlzRm9yS2V5d29yZE5vZGUsXG4gICAgICBpc1VSTEZ1bmN0aW9uTm9kZSQxID0gdXRpbHMkMi5pc1VSTEZ1bmN0aW9uTm9kZSxcbiAgICAgIGlzSWZFbHNlS2V5d29yZE5vZGUkMSA9IHV0aWxzJDIuaXNJZkVsc2VLZXl3b3JkTm9kZSxcbiAgICAgIGhhc0NvbXBvc2VzTm9kZSQxID0gdXRpbHMkMi5oYXNDb21wb3Nlc05vZGUsXG4gICAgICBoYXNQYXJlbnNBcm91bmROb2RlJDEgPSB1dGlscyQyLmhhc1BhcmVuc0Fyb3VuZE5vZGUsXG4gICAgICBoYXNFbXB0eVJhd0JlZm9yZSQxID0gdXRpbHMkMi5oYXNFbXB0eVJhd0JlZm9yZSxcbiAgICAgIGlzS2V5VmFsdWVQYWlyTm9kZSQxID0gdXRpbHMkMi5pc0tleVZhbHVlUGFpck5vZGUsXG4gICAgICBpc0RldGFjaGVkUnVsZXNldENhbGxOb2RlJDEgPSB1dGlscyQyLmlzRGV0YWNoZWRSdWxlc2V0Q2FsbE5vZGUsXG4gICAgICBpc1RlbXBsYXRlUGxhY2Vob2xkZXJOb2RlJDEgPSB1dGlscyQyLmlzVGVtcGxhdGVQbGFjZWhvbGRlck5vZGUsXG4gICAgICBpc1RlbXBsYXRlUHJvcE5vZGUkMSA9IHV0aWxzJDIuaXNUZW1wbGF0ZVByb3BOb2RlLFxuICAgICAgaXNQb3N0Y3NzU2ltcGxlVmFyTm9kZSQxID0gdXRpbHMkMi5pc1Bvc3Rjc3NTaW1wbGVWYXJOb2RlLFxuICAgICAgaXNTQ1NTTWFwSXRlbU5vZGUkMSA9IHV0aWxzJDIuaXNTQ1NTTWFwSXRlbU5vZGUsXG4gICAgICBpc0lubGluZVZhbHVlQ29tbWVudE5vZGUkMSA9IHV0aWxzJDIuaXNJbmxpbmVWYWx1ZUNvbW1lbnROb2RlLFxuICAgICAgaXNIYXNoTm9kZSQxID0gdXRpbHMkMi5pc0hhc2hOb2RlLFxuICAgICAgaXNMZWZ0Q3VybHlCcmFjZU5vZGUkMSA9IHV0aWxzJDIuaXNMZWZ0Q3VybHlCcmFjZU5vZGUsXG4gICAgICBpc1JpZ2h0Q3VybHlCcmFjZU5vZGUkMSA9IHV0aWxzJDIuaXNSaWdodEN1cmx5QnJhY2VOb2RlLFxuICAgICAgaXNXb3JkTm9kZSQxID0gdXRpbHMkMi5pc1dvcmROb2RlLFxuICAgICAgaXNDb2xvbk5vZGUkMSA9IHV0aWxzJDIuaXNDb2xvbk5vZGUsXG4gICAgICBpc01lZGlhQW5kU3VwcG9ydHNLZXl3b3JkcyQxID0gdXRpbHMkMi5pc01lZGlhQW5kU3VwcG9ydHNLZXl3b3JkcyxcbiAgICAgIGlzQ29sb3JBZGp1c3RlckZ1bmNOb2RlJDEgPSB1dGlscyQyLmlzQ29sb3JBZGp1c3RlckZ1bmNOb2RlO1xuXG4gIGZ1bmN0aW9uIHNob3VsZFByaW50Q29tbWEob3B0aW9ucykge1xuICAgIHN3aXRjaCAob3B0aW9ucy50cmFpbGluZ0NvbW1hKSB7XG4gICAgICBjYXNlIFwiYWxsXCI6XG4gICAgICBjYXNlIFwiZXM1XCI6XG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICBjYXNlIFwibm9uZVwiOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyaWNQcmludChwYXRoLCBvcHRpb25zLCBwcmludCkge1xuICAgIHZhciBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXG4gICAgaWYgKCFub2RlKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5vZGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwieWFtbFwiOlxuICAgICAgY2FzZSBcInRvbWxcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCQ1KFtub2RlLnJhdywgaGFyZGxpbmUkNF0pO1xuXG4gICAgICBjYXNlIFwiY3NzLXJvb3RcIjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBub2RlcyA9IHByaW50Tm9kZVNlcXVlbmNlKHBhdGgsIG9wdGlvbnMsIHByaW50KTtcblxuICAgICAgICAgIGlmIChub2Rlcy5wYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQkNShbbm9kZXMsIGhhcmRsaW5lJDRdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcImNzcy1jb21tZW50XCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAobm9kZS5yYXdzLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnJhd3MuY29udGVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdGV4dCA9IG9wdGlvbnMub3JpZ2luYWxUZXh0LnNsaWNlKG9wdGlvbnMubG9jU3RhcnQobm9kZSksIG9wdGlvbnMubG9jRW5kKG5vZGUpKTtcbiAgICAgICAgICB2YXIgcmF3VGV4dCA9IG5vZGUucmF3cy50ZXh0IHx8IG5vZGUudGV4dDsgLy8gV29ya2Fyb3VuZCBhIGJ1ZyB3aGVyZSB0aGUgbG9jYXRpb24gaXMgb2ZmLlxuICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3N0Y3NzL3Bvc3Rjc3Mtc2Nzcy9pc3N1ZXMvNjNcblxuICAgICAgICAgIGlmICh0ZXh0LmluZGV4T2YocmF3VGV4dCkgPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5yYXdzLmlubGluZSkge1xuICAgICAgICAgICAgICByZXR1cm4gY29uY2F0JDUoW1wiLy8gXCIsIHJhd1RleHRdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCQ1KFtcIi8qIFwiLCByYXdUZXh0LCBcIiAqL1wiXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcImNzcy1ydWxlXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDUoW3BhdGguY2FsbChwcmludCwgXCJzZWxlY3RvclwiKSwgbm9kZS5pbXBvcnRhbnQgPyBcIiAhaW1wb3J0YW50XCIgOiBcIlwiLCBub2RlLm5vZGVzID8gY29uY2F0JDUoW1wiIHtcIiwgbm9kZS5ub2Rlcy5sZW5ndGggPiAwID8gaW5kZW50JDIoY29uY2F0JDUoW2hhcmRsaW5lJDQsIHByaW50Tm9kZVNlcXVlbmNlKHBhdGgsIG9wdGlvbnMsIHByaW50KV0pKSA6IFwiXCIsIGhhcmRsaW5lJDQsIFwifVwiLCBpc0RldGFjaGVkUnVsZXNldERlY2xhcmF0aW9uTm9kZSQxKG5vZGUpID8gXCI7XCIgOiBcIlwiXSkgOiBcIjtcIl0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJjc3MtZGVjbFwiOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBwYXRoLmdldFBhcmVudE5vZGUoKTtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDUoW25vZGUucmF3cy5iZWZvcmUucmVwbGFjZSgvW1xccztdL2csIFwiXCIpLCBpbnNpZGVJQ1NTUnVsZU5vZGUkMShwYXRoKSA/IG5vZGUucHJvcCA6IG1heWJlVG9Mb3dlckNhc2UkMShub2RlLnByb3ApLCBub2RlLnJhd3MuYmV0d2Vlbi50cmltKCkgPT09IFwiOlwiID8gXCI6XCIgOiBub2RlLnJhd3MuYmV0d2Vlbi50cmltKCksIG5vZGUuZXh0ZW5kID8gXCJcIiA6IFwiIFwiLCBoYXNDb21wb3Nlc05vZGUkMShub2RlKSA/IHJlbW92ZUxpbmVzJDEocGF0aC5jYWxsKHByaW50LCBcInZhbHVlXCIpKSA6IHBhdGguY2FsbChwcmludCwgXCJ2YWx1ZVwiKSwgbm9kZS5yYXdzLmltcG9ydGFudCA/IG5vZGUucmF3cy5pbXBvcnRhbnQucmVwbGFjZSgvXFxzKiFcXHMqaW1wb3J0YW50L2ksIFwiICFpbXBvcnRhbnRcIikgOiBub2RlLmltcG9ydGFudCA/IFwiICFpbXBvcnRhbnRcIiA6IFwiXCIsIG5vZGUucmF3cy5zY3NzRGVmYXVsdCA/IG5vZGUucmF3cy5zY3NzRGVmYXVsdC5yZXBsYWNlKC9cXHMqIWRlZmF1bHQvaSwgXCIgIWRlZmF1bHRcIikgOiBub2RlLnNjc3NEZWZhdWx0ID8gXCIgIWRlZmF1bHRcIiA6IFwiXCIsIG5vZGUucmF3cy5zY3NzR2xvYmFsID8gbm9kZS5yYXdzLnNjc3NHbG9iYWwucmVwbGFjZSgvXFxzKiFnbG9iYWwvaSwgXCIgIWdsb2JhbFwiKSA6IG5vZGUuc2Nzc0dsb2JhbCA/IFwiICFnbG9iYWxcIiA6IFwiXCIsIG5vZGUubm9kZXMgPyBjb25jYXQkNShbXCIge1wiLCBpbmRlbnQkMihjb25jYXQkNShbc29mdGxpbmUkMSwgcHJpbnROb2RlU2VxdWVuY2UocGF0aCwgb3B0aW9ucywgcHJpbnQpXSkpLCBzb2Z0bGluZSQxLCBcIn1cIl0pIDogaXNUZW1wbGF0ZVByb3BOb2RlJDEobm9kZSkgJiYgIXBhcmVudE5vZGUucmF3cy5zZW1pY29sb24gJiYgb3B0aW9ucy5vcmlnaW5hbFRleHRbb3B0aW9ucy5sb2NFbmQobm9kZSkgLSAxXSAhPT0gXCI7XCIgPyBcIlwiIDogXCI7XCJdKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiY3NzLWF0cnVsZVwiOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9wYXJlbnROb2RlID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG5cbiAgICAgICAgICByZXR1cm4gY29uY2F0JDUoW1wiQFwiLCAvLyBJZiBhIExlc3MgZmlsZSBlbmRzIHVwIGJlaW5nIHBhcnNlZCB3aXRoIHRoZSBTQ1NTIHBhcnNlciwgTGVzc1xuICAgICAgICAgIC8vIHZhcmlhYmxlIGRlY2xhcmF0aW9ucyB3aWxsIGJlIHBhcnNlZCBhcyBhdC1ydWxlcyB3aXRoIG5hbWVzIGVuZGluZ1xuICAgICAgICAgIC8vIHdpdGggYSBjb2xvbiwgc28ga2VlcCB0aGUgb3JpZ2luYWwgY2FzZSB0aGVuLlxuICAgICAgICAgIGlzRGV0YWNoZWRSdWxlc2V0Q2FsbE5vZGUkMShub2RlKSB8fCBub2RlLm5hbWUuZW5kc1dpdGgoXCI6XCIpID8gbm9kZS5uYW1lIDogbWF5YmVUb0xvd2VyQ2FzZSQxKG5vZGUubmFtZSksIG5vZGUucGFyYW1zID8gY29uY2F0JDUoW2lzRGV0YWNoZWRSdWxlc2V0Q2FsbE5vZGUkMShub2RlKSA/IFwiXCIgOiBpc1RlbXBsYXRlUGxhY2Vob2xkZXJOb2RlJDEobm9kZSkgJiYgL15cXHMqXFxuLy50ZXN0KG5vZGUucmF3cy5hZnRlck5hbWUpID8gL15cXHMqXFxuXFxzKlxcbi8udGVzdChub2RlLnJhd3MuYWZ0ZXJOYW1lKSA/IGNvbmNhdCQ1KFtoYXJkbGluZSQ0LCBoYXJkbGluZSQ0XSkgOiBoYXJkbGluZSQ0IDogXCIgXCIsIHBhdGguY2FsbChwcmludCwgXCJwYXJhbXNcIildKSA6IFwiXCIsIG5vZGUuc2VsZWN0b3IgPyBpbmRlbnQkMihjb25jYXQkNShbXCIgXCIsIHBhdGguY2FsbChwcmludCwgXCJzZWxlY3RvclwiKV0pKSA6IFwiXCIsIG5vZGUudmFsdWUgPyBncm91cCQxKGNvbmNhdCQ1KFtcIiBcIiwgcGF0aC5jYWxsKHByaW50LCBcInZhbHVlXCIpLCBpc1NDU1NDb250cm9sRGlyZWN0aXZlTm9kZSQxKG5vZGUpID8gaGFzUGFyZW5zQXJvdW5kTm9kZSQxKG5vZGUpID8gXCIgXCIgOiBsaW5lJDEgOiBcIlwiXSkpIDogbm9kZS5uYW1lID09PSBcImVsc2VcIiA/IFwiIFwiIDogXCJcIiwgbm9kZS5ub2RlcyA/IGNvbmNhdCQ1KFtpc1NDU1NDb250cm9sRGlyZWN0aXZlTm9kZSQxKG5vZGUpID8gXCJcIiA6IFwiIFwiLCBcIntcIiwgaW5kZW50JDIoY29uY2F0JDUoW25vZGUubm9kZXMubGVuZ3RoID4gMCA/IHNvZnRsaW5lJDEgOiBcIlwiLCBwcmludE5vZGVTZXF1ZW5jZShwYXRoLCBvcHRpb25zLCBwcmludCldKSksIHNvZnRsaW5lJDEsIFwifVwiXSkgOiBpc1RlbXBsYXRlUGxhY2Vob2xkZXJOb2RlJDEobm9kZSkgJiYgIV9wYXJlbnROb2RlLnJhd3Muc2VtaWNvbG9uICYmIG9wdGlvbnMub3JpZ2luYWxUZXh0W29wdGlvbnMubG9jRW5kKG5vZGUpIC0gMV0gIT09IFwiO1wiID8gXCJcIiA6IFwiO1wiXSk7XG4gICAgICAgIH1cbiAgICAgIC8vIHBvc3Rjc3MtbWVkaWEtcXVlcnktcGFyc2VyXG5cbiAgICAgIGNhc2UgXCJtZWRpYS1xdWVyeS1saXN0XCI6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcGFydHMgPSBbXTtcbiAgICAgICAgICBwYXRoLmVhY2goZnVuY3Rpb24gKGNoaWxkUGF0aCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBjaGlsZFBhdGguZ2V0VmFsdWUoKTtcblxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJtZWRpYS1xdWVyeVwiICYmIG5vZGUudmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGNoaWxkUGF0aC5jYWxsKHByaW50KSk7XG4gICAgICAgICAgfSwgXCJub2Rlc1wiKTtcbiAgICAgICAgICByZXR1cm4gZ3JvdXAkMShpbmRlbnQkMihqb2luJDIobGluZSQxLCBwYXJ0cykpKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwibWVkaWEtcXVlcnlcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBjb25jYXQkNShbam9pbiQyKFwiIFwiLCBwYXRoLm1hcChwcmludCwgXCJub2Rlc1wiKSksIGlzTGFzdE5vZGUkMShwYXRoLCBub2RlKSA/IFwiXCIgOiBcIixcIl0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJtZWRpYS10eXBlXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gYWRqdXN0TnVtYmVycyhhZGp1c3RTdHJpbmdzKG5vZGUudmFsdWUsIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwibWVkaWEtZmVhdHVyZS1leHByZXNzaW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIW5vZGUubm9kZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb25jYXQkNShbXCIoXCIsIGNvbmNhdCQ1KHBhdGgubWFwKHByaW50LCBcIm5vZGVzXCIpKSwgXCIpXCJdKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwibWVkaWEtZmVhdHVyZVwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG1heWJlVG9Mb3dlckNhc2UkMShhZGp1c3RTdHJpbmdzKG5vZGUudmFsdWUucmVwbGFjZSgvICsvZywgXCIgXCIpLCBvcHRpb25zKSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIm1lZGlhLWNvbG9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDUoW25vZGUudmFsdWUsIFwiIFwiXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIm1lZGlhLXZhbHVlXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gYWRqdXN0TnVtYmVycyhhZGp1c3RTdHJpbmdzKG5vZGUudmFsdWUsIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwibWVkaWEta2V5d29yZFwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGFkanVzdFN0cmluZ3Mobm9kZS52YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIm1lZGlhLXVybFwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGFkanVzdFN0cmluZ3Mobm9kZS52YWx1ZS5yZXBsYWNlKC9edXJsXFwoXFxzKy9naSwgXCJ1cmwoXCIpLnJlcGxhY2UoL1xccytcXCkkL2dpLCBcIilcIiksIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJtZWRpYS11bmtub3duXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgLy8gcG9zdGNzcy1zZWxlY3Rvci1wYXJzZXJcblxuICAgICAgY2FzZSBcInNlbGVjdG9yLXJvb3RcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBncm91cCQxKGNvbmNhdCQ1KFtpbnNpZGVBdFJ1bGVOb2RlJDEocGF0aCwgXCJjdXN0b20tc2VsZWN0b3JcIikgPyBjb25jYXQkNShbZ2V0QW5jZXN0b3JOb2RlJDEocGF0aCwgXCJjc3MtYXRydWxlXCIpLmN1c3RvbVNlbGVjdG9yLCBsaW5lJDFdKSA6IFwiXCIsIGpvaW4kMihjb25jYXQkNShbXCIsXCIsIGluc2lkZUF0UnVsZU5vZGUkMShwYXRoLCBbXCJleHRlbmRcIiwgXCJjdXN0b20tc2VsZWN0b3JcIiwgXCJuZXN0XCJdKSA/IGxpbmUkMSA6IGhhcmRsaW5lJDRdKSwgcGF0aC5tYXAocHJpbnQsIFwibm9kZXNcIikpXSkpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJzZWxlY3Rvci1zZWxlY3RvclwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdyb3VwJDEoaW5kZW50JDIoY29uY2F0JDUocGF0aC5tYXAocHJpbnQsIFwibm9kZXNcIikpKSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInNlbGVjdG9yLWNvbW1lbnRcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJzZWxlY3Rvci1zdHJpbmdcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBhZGp1c3RTdHJpbmdzKG5vZGUudmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJzZWxlY3Rvci10YWdcIjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfcGFyZW50Tm9kZTIgPSBwYXRoLmdldFBhcmVudE5vZGUoKTtcblxuICAgICAgICAgIHZhciBpbmRleCA9IF9wYXJlbnROb2RlMiAmJiBfcGFyZW50Tm9kZTIubm9kZXMuaW5kZXhPZihub2RlKTtcblxuICAgICAgICAgIHZhciBwcmV2Tm9kZSA9IGluZGV4ICYmIF9wYXJlbnROb2RlMi5ub2Rlc1tpbmRleCAtIDFdO1xuICAgICAgICAgIHJldHVybiBjb25jYXQkNShbbm9kZS5uYW1lc3BhY2UgPyBjb25jYXQkNShbbm9kZS5uYW1lc3BhY2UgPT09IHRydWUgPyBcIlwiIDogbm9kZS5uYW1lc3BhY2UudHJpbSgpLCBcInxcIl0pIDogXCJcIiwgcHJldk5vZGUudHlwZSA9PT0gXCJzZWxlY3Rvci1uZXN0aW5nXCIgPyBub2RlLnZhbHVlIDogYWRqdXN0TnVtYmVycyhpc0hUTUxUYWckMShub2RlLnZhbHVlKSB8fCBpc0tleWZyYW1lQXRSdWxlS2V5d29yZHMkMShwYXRoLCBub2RlLnZhbHVlKSA/IG5vZGUudmFsdWUudG9Mb3dlckNhc2UoKSA6IG5vZGUudmFsdWUpXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInNlbGVjdG9yLWlkXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDUoW1wiI1wiLCBub2RlLnZhbHVlXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInNlbGVjdG9yLWNsYXNzXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDUoW1wiLlwiLCBhZGp1c3ROdW1iZXJzKGFkanVzdFN0cmluZ3Mobm9kZS52YWx1ZSwgb3B0aW9ucykpXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInNlbGVjdG9yLWF0dHJpYnV0ZVwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ1KFtcIltcIiwgbm9kZS5uYW1lc3BhY2UgPyBjb25jYXQkNShbbm9kZS5uYW1lc3BhY2UgPT09IHRydWUgPyBcIlwiIDogbm9kZS5uYW1lc3BhY2UudHJpbSgpLCBcInxcIl0pIDogXCJcIiwgbm9kZS5hdHRyaWJ1dGUudHJpbSgpLCBub2RlLm9wZXJhdG9yID8gbm9kZS5vcGVyYXRvciA6IFwiXCIsIG5vZGUudmFsdWUgPyBxdW90ZUF0dHJpYnV0ZVZhbHVlKGFkanVzdFN0cmluZ3Mobm9kZS52YWx1ZS50cmltKCksIG9wdGlvbnMpLCBvcHRpb25zKSA6IFwiXCIsIG5vZGUuaW5zZW5zaXRpdmUgPyBcIiBpXCIgOiBcIlwiLCBcIl1cIl0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJzZWxlY3Rvci1jb21iaW5hdG9yXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAobm9kZS52YWx1ZSA9PT0gXCIrXCIgfHwgbm9kZS52YWx1ZSA9PT0gXCI+XCIgfHwgbm9kZS52YWx1ZSA9PT0gXCJ+XCIgfHwgbm9kZS52YWx1ZSA9PT0gXCI+Pj5cIikge1xuICAgICAgICAgICAgdmFyIF9wYXJlbnROb2RlMyA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpO1xuXG4gICAgICAgICAgICB2YXIgX2xlYWRpbmcgPSBfcGFyZW50Tm9kZTMudHlwZSA9PT0gXCJzZWxlY3Rvci1zZWxlY3RvclwiICYmIF9wYXJlbnROb2RlMy5ub2Rlc1swXSA9PT0gbm9kZSA/IFwiXCIgOiBsaW5lJDE7XG5cbiAgICAgICAgICAgIHJldHVybiBjb25jYXQkNShbX2xlYWRpbmcsIG5vZGUudmFsdWUsIGlzTGFzdE5vZGUkMShwYXRoLCBub2RlKSA/IFwiXCIgOiBcIiBcIl0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBsZWFkaW5nID0gbm9kZS52YWx1ZS50cmltKCkuc3RhcnRzV2l0aChcIihcIikgPyBsaW5lJDEgOiBcIlwiO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGFkanVzdE51bWJlcnMoYWRqdXN0U3RyaW5ncyhub2RlLnZhbHVlLnRyaW0oKSwgb3B0aW9ucykpIHx8IGxpbmUkMTtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDUoW2xlYWRpbmcsIHZhbHVlXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInNlbGVjdG9yLXVuaXZlcnNhbFwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ1KFtub2RlLm5hbWVzcGFjZSA/IGNvbmNhdCQ1KFtub2RlLm5hbWVzcGFjZSA9PT0gdHJ1ZSA/IFwiXCIgOiBub2RlLm5hbWVzcGFjZS50cmltKCksIFwifFwiXSkgOiBcIlwiLCBub2RlLnZhbHVlXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInNlbGVjdG9yLXBzZXVkb1wiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ1KFttYXliZVRvTG93ZXJDYXNlJDEobm9kZS52YWx1ZSksIG5vZGUubm9kZXMgJiYgbm9kZS5ub2Rlcy5sZW5ndGggPiAwID8gY29uY2F0JDUoW1wiKFwiLCBqb2luJDIoXCIsIFwiLCBwYXRoLm1hcChwcmludCwgXCJub2Rlc1wiKSksIFwiKVwiXSkgOiBcIlwiXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInNlbGVjdG9yLW5lc3RpbmdcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJzZWxlY3Rvci11bmtub3duXCI6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcnVsZUFuY2VzdG9yTm9kZSA9IGdldEFuY2VzdG9yTm9kZSQxKHBhdGgsIFwiY3NzLXJ1bGVcIik7IC8vIE5lc3RlZCBTQ1NTIHByb3BlcnR5XG5cbiAgICAgICAgICBpZiAocnVsZUFuY2VzdG9yTm9kZSAmJiBydWxlQW5jZXN0b3JOb2RlLmlzU0NTU05lc3RlclByb3BlcnR5KSB7XG4gICAgICAgICAgICByZXR1cm4gYWRqdXN0TnVtYmVycyhhZGp1c3RTdHJpbmdzKG1heWJlVG9Mb3dlckNhc2UkMShub2RlLnZhbHVlKSwgb3B0aW9ucykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAvLyBwb3N0Y3NzLXZhbHVlcy1wYXJzZXJcblxuICAgICAgY2FzZSBcInZhbHVlLXZhbHVlXCI6XG4gICAgICBjYXNlIFwidmFsdWUtcm9vdFwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHBhdGguY2FsbChwcmludCwgXCJncm91cFwiKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwidmFsdWUtY29tbWVudFwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ1KFtub2RlLmlubGluZSA/IFwiLy9cIiA6IFwiLypcIiwgbm9kZS52YWx1ZSwgbm9kZS5pbmxpbmUgPyBcIlwiIDogXCIqL1wiXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInZhbHVlLWNvbW1hX2dyb3VwXCI6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3BhcmVudE5vZGU0ID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG5cbiAgICAgICAgICB2YXIgcGFyZW50UGFyZW50Tm9kZSA9IHBhdGguZ2V0UGFyZW50Tm9kZSgxKTtcbiAgICAgICAgICB2YXIgZGVjbEFuY2VzdG9yUHJvcCA9IGdldFByb3BPZkRlY2xOb2RlJDEocGF0aCk7XG4gICAgICAgICAgdmFyIGlzR3JpZFZhbHVlID0gZGVjbEFuY2VzdG9yUHJvcCAmJiBfcGFyZW50Tm9kZTQudHlwZSA9PT0gXCJ2YWx1ZS12YWx1ZVwiICYmIChkZWNsQW5jZXN0b3JQcm9wID09PSBcImdyaWRcIiB8fCBkZWNsQW5jZXN0b3JQcm9wLnN0YXJ0c1dpdGgoXCJncmlkLXRlbXBsYXRlXCIpKTtcbiAgICAgICAgICB2YXIgYXRSdWxlQW5jZXN0b3JOb2RlID0gZ2V0QW5jZXN0b3JOb2RlJDEocGF0aCwgXCJjc3MtYXRydWxlXCIpO1xuICAgICAgICAgIHZhciBpc0NvbnRyb2xEaXJlY3RpdmUgPSBhdFJ1bGVBbmNlc3Rvck5vZGUgJiYgaXNTQ1NTQ29udHJvbERpcmVjdGl2ZU5vZGUkMShhdFJ1bGVBbmNlc3Rvck5vZGUpO1xuICAgICAgICAgIHZhciBwcmludGVkID0gcGF0aC5tYXAocHJpbnQsIFwiZ3JvdXBzXCIpO1xuICAgICAgICAgIHZhciBfcGFydHMgPSBbXTtcbiAgICAgICAgICB2YXIgaW5zaWRlVVJMRnVuY3Rpb24gPSBpbnNpZGVWYWx1ZUZ1bmN0aW9uTm9kZSQxKHBhdGgsIFwidXJsXCIpO1xuICAgICAgICAgIHZhciBpbnNpZGVTQ1NTSW50ZXJwb2xhdGlvbkluU3RyaW5nID0gZmFsc2U7XG4gICAgICAgICAgdmFyIGRpZEJyZWFrID0gZmFsc2U7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuZ3JvdXBzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBfcGFydHMucHVzaChwcmludGVkW2ldKTsgLy8gSWdub3JlIHZhbHVlIGluc2lkZSBgdXJsKClgXG5cblxuICAgICAgICAgICAgaWYgKGluc2lkZVVSTEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaVByZXZOb2RlID0gbm9kZS5ncm91cHNbaSAtIDFdO1xuICAgICAgICAgICAgdmFyIGlOb2RlID0gbm9kZS5ncm91cHNbaV07XG4gICAgICAgICAgICB2YXIgaU5leHROb2RlID0gbm9kZS5ncm91cHNbaSArIDFdO1xuICAgICAgICAgICAgdmFyIGlOZXh0TmV4dE5vZGUgPSBub2RlLmdyb3Vwc1tpICsgMl07IC8vIElnbm9yZSBhZnRlciBsYXRlc3Qgbm9kZSAoaS5lLiBiZWZvcmUgc2VtaWNvbG9uKVxuXG4gICAgICAgICAgICBpZiAoIWlOZXh0Tm9kZSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gLy8gSWdub3JlIHNwYWNlcyBiZWZvcmUvYWZ0ZXIgc3RyaW5nIGludGVycG9sYXRpb24gKGkuZS4gYFwiI3tteS1mbihcIl9cIil9XCJgKVxuXG5cbiAgICAgICAgICAgIHZhciBpc1N0YXJ0U0NTU0ludGVycG9sYXRpb25JblN0cmluZyA9IGlOb2RlLnR5cGUgPT09IFwidmFsdWUtc3RyaW5nXCIgJiYgaU5vZGUudmFsdWUuc3RhcnRzV2l0aChcIiN7XCIpO1xuICAgICAgICAgICAgdmFyIGlzRW5kaW5nU0NTU0ludGVycG9sYXRpb25JblN0cmluZyA9IGluc2lkZVNDU1NJbnRlcnBvbGF0aW9uSW5TdHJpbmcgJiYgaU5leHROb2RlLnR5cGUgPT09IFwidmFsdWUtc3RyaW5nXCIgJiYgaU5leHROb2RlLnZhbHVlLmVuZHNXaXRoKFwifVwiKTtcblxuICAgICAgICAgICAgaWYgKGlzU3RhcnRTQ1NTSW50ZXJwb2xhdGlvbkluU3RyaW5nIHx8IGlzRW5kaW5nU0NTU0ludGVycG9sYXRpb25JblN0cmluZykge1xuICAgICAgICAgICAgICBpbnNpZGVTQ1NTSW50ZXJwb2xhdGlvbkluU3RyaW5nID0gIWluc2lkZVNDU1NJbnRlcnBvbGF0aW9uSW5TdHJpbmc7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5zaWRlU0NTU0ludGVycG9sYXRpb25JblN0cmluZykge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gLy8gSWdub3JlIGNvbG9uIChpLmUuIGA6YClcblxuXG4gICAgICAgICAgICBpZiAoaXNDb2xvbk5vZGUkMShpTm9kZSkgfHwgaXNDb2xvbk5vZGUkMShpTmV4dE5vZGUpKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSAvLyBJZ25vcmUgYEBgIGluIExlc3MgKGkuZS4gYEBAdmFyO2ApXG5cblxuICAgICAgICAgICAgaWYgKGlOb2RlLnR5cGUgPT09IFwidmFsdWUtYXR3b3JkXCIgJiYgaU5vZGUudmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vIElnbm9yZSBgfmAgaW4gTGVzcyAoaS5lLiBgY29udGVudDogflwiXi8vKiBzb21lIGhvcnJpYmxlIGJ1dCBuZWVkZWQgY3NzIGhhY2tcIjtgKVxuXG5cbiAgICAgICAgICAgIGlmIChpTm9kZS52YWx1ZSA9PT0gXCJ+XCIpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vIElnbm9yZSBlc2NhcGUgYFxcYFxuXG5cbiAgICAgICAgICAgIGlmIChpTm9kZS52YWx1ZSAmJiBpTm9kZS52YWx1ZS5pbmRleE9mKFwiXFxcXFwiKSAhPT0gLTEgJiYgaU5leHROb2RlICYmIGlOZXh0Tm9kZS50eXBlICE9PSBcInZhbHVlLWNvbW1lbnRcIikge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gLy8gSWdub3JlIGVzY2FwZWQgYC9gXG5cblxuICAgICAgICAgICAgaWYgKGlQcmV2Tm9kZSAmJiBpUHJldk5vZGUudmFsdWUgJiYgaVByZXZOb2RlLnZhbHVlLmluZGV4T2YoXCJcXFxcXCIpID09PSBpUHJldk5vZGUudmFsdWUubGVuZ3RoIC0gMSAmJiBpTm9kZS50eXBlID09PSBcInZhbHVlLW9wZXJhdG9yXCIgJiYgaU5vZGUudmFsdWUgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSAvLyBJZ25vcmUgYFxcYCAoaS5lLiBgJHZhcmlhYmxlOiBcXEBzbWFsbDtgKVxuXG5cbiAgICAgICAgICAgIGlmIChpTm9kZS52YWx1ZSA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vIElnbm9yZSBgJCRgIChpLmUuIGBiYWNrZ3JvdW5kLWNvbG9yOiAkJChzdHlsZSlDb2xvcjtgKVxuXG5cbiAgICAgICAgICAgIGlmIChpc1Bvc3Rjc3NTaW1wbGVWYXJOb2RlJDEoaU5vZGUsIGlOZXh0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vIElnbm9yZSBzcGFjZXMgYWZ0ZXIgYCNgIGFuZCBhZnRlciBge2AgYW5kIGJlZm9yZSBgfWAgaW4gU0NTUyBpbnRlcnBvbGF0aW9uIChpLmUuIGAje3ZhcmlhYmxlfWApXG5cblxuICAgICAgICAgICAgaWYgKGlzSGFzaE5vZGUkMShpTm9kZSkgfHwgaXNMZWZ0Q3VybHlCcmFjZU5vZGUkMShpTm9kZSkgfHwgaXNSaWdodEN1cmx5QnJhY2VOb2RlJDEoaU5leHROb2RlKSB8fCBpc0xlZnRDdXJseUJyYWNlTm9kZSQxKGlOZXh0Tm9kZSkgJiYgaGFzRW1wdHlSYXdCZWZvcmUkMShpTmV4dE5vZGUpIHx8IGlzUmlnaHRDdXJseUJyYWNlTm9kZSQxKGlOb2RlKSAmJiBoYXNFbXB0eVJhd0JlZm9yZSQxKGlOZXh0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vIElnbm9yZSBjc3MgdmFyaWFibGVzIGFuZCBpbnRlcnBvbGF0aW9uIGluIFNDU1MgKGkuZS4gYC0tI3skdmFyfWApXG5cblxuICAgICAgICAgICAgaWYgKGlOb2RlLnZhbHVlID09PSBcIi0tXCIgJiYgaXNIYXNoTm9kZSQxKGlOZXh0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vIEZvcm1hdHRpbmcgbWF0aCBvcGVyYXRpb25zXG5cblxuICAgICAgICAgICAgdmFyIGlzTWF0aE9wZXJhdG9yID0gaXNNYXRoT3BlcmF0b3JOb2RlJDEoaU5vZGUpO1xuICAgICAgICAgICAgdmFyIGlzTmV4dE1hdGhPcGVyYXRvciA9IGlzTWF0aE9wZXJhdG9yTm9kZSQxKGlOZXh0Tm9kZSk7IC8vIFByaW50IHNwYWNlcyBiZWZvcmUgYW5kIGFmdGVyIG1hdGggb3BlcmF0b3JzIGJlc2lkZSBTQ1NTIGludGVycG9sYXRpb24gYXMgaXNcbiAgICAgICAgICAgIC8vIChpLmUuIGAjeyR2YXJ9KzVgLCBgI3skdmFyfSArNWAsIGAjeyR2YXJ9KyA1YCwgYCN7JHZhcn0gKyA1YClcbiAgICAgICAgICAgIC8vIChpLmUuIGA1KyN7JHZhcn1gLCBgNSArI3skdmFyfWAsIGA1KyAjeyR2YXJ9YCwgYDUgKyAjeyR2YXJ9YClcblxuICAgICAgICAgICAgaWYgKChpc01hdGhPcGVyYXRvciAmJiBpc0hhc2hOb2RlJDEoaU5leHROb2RlKSB8fCBpc05leHRNYXRoT3BlcmF0b3IgJiYgaXNSaWdodEN1cmx5QnJhY2VOb2RlJDEoaU5vZGUpKSAmJiBoYXNFbXB0eVJhd0JlZm9yZSQxKGlOZXh0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vIFByaW50IHNwYWNlcyBiZWZvcmUgYW5kIGFmdGVyIGFkZGl0aW9uIGFuZCBzdWJ0cmFjdGlvbiBtYXRoIG9wZXJhdG9ycyBhcyBpcyBpbiBgY2FsY2AgZnVuY3Rpb25cbiAgICAgICAgICAgIC8vIGR1ZSB0byB0aGUgZmFjdCB0aGF0IGl0IGlzIG5vdCB2YWxpZCBzeW50YXhcbiAgICAgICAgICAgIC8vIChpLmUuIGBjYWxjKDFweCsxcHgpYCwgYGNhbGMoMXB4KyAxcHgpYCwgYGNhbGMoMXB4ICsxcHgpYCwgYGNhbGMoMXB4ICsgMXB4KWApXG5cblxuICAgICAgICAgICAgaWYgKGluc2lkZVZhbHVlRnVuY3Rpb25Ob2RlJDEocGF0aCwgXCJjYWxjXCIpICYmIChpc0FkZGl0aW9uTm9kZSQxKGlOb2RlKSB8fCBpc0FkZGl0aW9uTm9kZSQxKGlOZXh0Tm9kZSkgfHwgaXNTdWJ0cmFjdGlvbk5vZGUkMShpTm9kZSkgfHwgaXNTdWJ0cmFjdGlvbk5vZGUkMShpTmV4dE5vZGUpKSAmJiBoYXNFbXB0eVJhd0JlZm9yZSQxKGlOZXh0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vIFByaW50IHNwYWNlcyBhZnRlciBgK2AgYW5kIGAtYCBpbiBjb2xvciBhZGp1c3RlciBmdW5jdGlvbnMgYXMgaXMgKGUuZy4gYGNvbG9yKHJlZCBsKCsgMjAlKSlgKVxuICAgICAgICAgICAgLy8gQWRqdXN0ZXJzIHdpdGggc2lnbmVkIG51bWJlcnMgKGUuZy4gYGNvbG9yKHJlZCBsKCsyMCUpKWApIG91dHB1dCBhcy1pcy5cblxuXG4gICAgICAgICAgICB2YXIgaXNDb2xvckFkanVzdGVyTm9kZSA9IChpc0FkZGl0aW9uTm9kZSQxKGlOb2RlKSB8fCBpc1N1YnRyYWN0aW9uTm9kZSQxKGlOb2RlKSkgJiYgaSA9PT0gMCAmJiAoaU5leHROb2RlLnR5cGUgPT09IFwidmFsdWUtbnVtYmVyXCIgfHwgaU5leHROb2RlLmlzSGV4KSAmJiBwYXJlbnRQYXJlbnROb2RlICYmIGlzQ29sb3JBZGp1c3RlckZ1bmNOb2RlJDEocGFyZW50UGFyZW50Tm9kZSkgJiYgIWhhc0VtcHR5UmF3QmVmb3JlJDEoaU5leHROb2RlKTtcbiAgICAgICAgICAgIHZhciByZXF1aXJlU3BhY2VCZWZvcmVPcGVyYXRvciA9IGlOZXh0TmV4dE5vZGUgJiYgaU5leHROZXh0Tm9kZS50eXBlID09PSBcInZhbHVlLWZ1bmNcIiB8fCBpTmV4dE5leHROb2RlICYmIGlzV29yZE5vZGUkMShpTmV4dE5leHROb2RlKSB8fCBpTm9kZS50eXBlID09PSBcInZhbHVlLWZ1bmNcIiB8fCBpc1dvcmROb2RlJDEoaU5vZGUpO1xuICAgICAgICAgICAgdmFyIHJlcXVpcmVTcGFjZUFmdGVyT3BlcmF0b3IgPSBpTmV4dE5vZGUudHlwZSA9PT0gXCJ2YWx1ZS1mdW5jXCIgfHwgaXNXb3JkTm9kZSQxKGlOZXh0Tm9kZSkgfHwgaVByZXZOb2RlICYmIGlQcmV2Tm9kZS50eXBlID09PSBcInZhbHVlLWZ1bmNcIiB8fCBpUHJldk5vZGUgJiYgaXNXb3JkTm9kZSQxKGlQcmV2Tm9kZSk7IC8vIEZvcm1hdHRpbmcgYC9gLCBgK2AsIGAtYCBzaWduXG5cbiAgICAgICAgICAgIGlmICghKGlzTXVsdGlwbGljYXRpb25Ob2RlJDEoaU5leHROb2RlKSB8fCBpc011bHRpcGxpY2F0aW9uTm9kZSQxKGlOb2RlKSkgJiYgIWluc2lkZVZhbHVlRnVuY3Rpb25Ob2RlJDEocGF0aCwgXCJjYWxjXCIpICYmICFpc0NvbG9yQWRqdXN0ZXJOb2RlICYmIChpc0RpdmlzaW9uTm9kZSQxKGlOZXh0Tm9kZSkgJiYgIXJlcXVpcmVTcGFjZUJlZm9yZU9wZXJhdG9yIHx8IGlzRGl2aXNpb25Ob2RlJDEoaU5vZGUpICYmICFyZXF1aXJlU3BhY2VBZnRlck9wZXJhdG9yIHx8IGlzQWRkaXRpb25Ob2RlJDEoaU5leHROb2RlKSAmJiAhcmVxdWlyZVNwYWNlQmVmb3JlT3BlcmF0b3IgfHwgaXNBZGRpdGlvbk5vZGUkMShpTm9kZSkgJiYgIXJlcXVpcmVTcGFjZUFmdGVyT3BlcmF0b3IgfHwgaXNTdWJ0cmFjdGlvbk5vZGUkMShpTmV4dE5vZGUpIHx8IGlzU3VidHJhY3Rpb25Ob2RlJDEoaU5vZGUpKSAmJiAoaGFzRW1wdHlSYXdCZWZvcmUkMShpTmV4dE5vZGUpIHx8IGlzTWF0aE9wZXJhdG9yICYmICghaVByZXZOb2RlIHx8IGlQcmV2Tm9kZSAmJiBpc01hdGhPcGVyYXRvck5vZGUkMShpUHJldk5vZGUpKSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vIEFkZCBgaGFyZGxpbmVgIGFmdGVyIGlubGluZSBjb21tZW50IChpLmUuIGAvLyBjb21tZW50XFxuIGZvbzogYmFyO2ApXG5cblxuICAgICAgICAgICAgaWYgKGlzSW5saW5lVmFsdWVDb21tZW50Tm9kZSQxKGlOb2RlKSkge1xuICAgICAgICAgICAgICBfcGFydHMucHVzaChoYXJkbGluZSQ0KTtcblxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gLy8gSGFuZGxlIGtleXdvcmRzIGluIFNDU1MgY29udHJvbCBkaXJlY3RpdmVcblxuXG4gICAgICAgICAgICBpZiAoaXNDb250cm9sRGlyZWN0aXZlICYmIChpc0VxdWFsaXR5T3BlcmF0b3JOb2RlJDEoaU5leHROb2RlKSB8fCBpc1JlbGF0aW9uYWxPcGVyYXRvck5vZGUkMShpTmV4dE5vZGUpIHx8IGlzSWZFbHNlS2V5d29yZE5vZGUkMShpTmV4dE5vZGUpIHx8IGlzRWFjaEtleXdvcmROb2RlJDEoaU5vZGUpIHx8IGlzRm9yS2V5d29yZE5vZGUkMShpTm9kZSkpKSB7XG4gICAgICAgICAgICAgIF9wYXJ0cy5wdXNoKFwiIFwiKTtcblxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gLy8gQXQtcnVsZSBgbmFtZXNwYWNlYCBzaG91bGQgYmUgaW4gb25lIGxpbmVcblxuXG4gICAgICAgICAgICBpZiAoYXRSdWxlQW5jZXN0b3JOb2RlICYmIGF0UnVsZUFuY2VzdG9yTm9kZS5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwibmFtZXNwYWNlXCIpIHtcbiAgICAgICAgICAgICAgX3BhcnRzLnB1c2goXCIgXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSAvLyBGb3JtYXR0aW5nIGBncmlkYCBwcm9wZXJ0eVxuXG5cbiAgICAgICAgICAgIGlmIChpc0dyaWRWYWx1ZSkge1xuICAgICAgICAgICAgICBpZiAoaU5vZGUuc291cmNlICYmIGlOZXh0Tm9kZS5zb3VyY2UgJiYgaU5vZGUuc291cmNlLnN0YXJ0LmxpbmUgIT09IGlOZXh0Tm9kZS5zb3VyY2Uuc3RhcnQubGluZSkge1xuICAgICAgICAgICAgICAgIF9wYXJ0cy5wdXNoKGhhcmRsaW5lJDQpO1xuXG4gICAgICAgICAgICAgICAgZGlkQnJlYWsgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9wYXJ0cy5wdXNoKFwiIFwiKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSAvLyBBZGQgYHNwYWNlYCBiZWZvcmUgbmV4dCBtYXRoIG9wZXJhdGlvblxuICAgICAgICAgICAgLy8gTm90ZTogYGdyaXBgIHByb3BlcnR5IGhhdmUgYC9gIGRlbGltaXRlciBhbmQgaXQgaXMgbm90IG1hdGggb3BlcmF0aW9uLCBzb1xuICAgICAgICAgICAgLy8gYGdyaWRgIHByb3BlcnR5IGhhbmRsZXMgYWJvdmVcblxuXG4gICAgICAgICAgICBpZiAoaXNOZXh0TWF0aE9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgIF9wYXJ0cy5wdXNoKFwiIFwiKTtcblxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gLy8gQmUgZGVmYXVsdCBhbGwgdmFsdWVzIGdvIHRocm91Z2ggYGxpbmVgXG5cblxuICAgICAgICAgICAgX3BhcnRzLnB1c2gobGluZSQxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGlkQnJlYWspIHtcbiAgICAgICAgICAgIF9wYXJ0cy51bnNoaWZ0KGhhcmRsaW5lJDQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc0NvbnRyb2xEaXJlY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiBncm91cCQxKGluZGVudCQyKGNvbmNhdCQ1KF9wYXJ0cykpKTtcbiAgICAgICAgICB9IC8vIEluZGVudCBpcyBub3QgbmVlZGVkIGZvciBpbXBvcnQgdXJsIHdoZW4gdXJsIGlzIHZlcnkgbG9uZ1xuICAgICAgICAgIC8vIGFuZCBub2RlIGhhcyB0d28gZ3JvdXBzXG4gICAgICAgICAgLy8gd2hlbiB0eXBlIGlzIHZhbHVlLWNvbW1hX2dyb3VwXG4gICAgICAgICAgLy8gZXhhbXBsZSBAaW1wb3J0IHVybChcInZlcnlsb25ndXJsXCIpIHByb2plY3Rpb24sdHZcblxuXG4gICAgICAgICAgaWYgKGluc2lkZVVSTEZ1bmN0aW9uSW5JbXBvcnRBdFJ1bGVOb2RlJDEocGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBncm91cCQxKGZpbGwkMihfcGFydHMpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZ3JvdXAkMShpbmRlbnQkMihmaWxsJDIoX3BhcnRzKSkpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJ2YWx1ZS1wYXJlbl9ncm91cFwiOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9wYXJlbnROb2RlNSA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpO1xuXG4gICAgICAgICAgaWYgKF9wYXJlbnROb2RlNSAmJiBpc1VSTEZ1bmN0aW9uTm9kZSQxKF9wYXJlbnROb2RlNSkgJiYgKG5vZGUuZ3JvdXBzLmxlbmd0aCA9PT0gMSB8fCBub2RlLmdyb3Vwcy5sZW5ndGggPiAwICYmIG5vZGUuZ3JvdXBzWzBdLnR5cGUgPT09IFwidmFsdWUtY29tbWFfZ3JvdXBcIiAmJiBub2RlLmdyb3Vwc1swXS5ncm91cHMubGVuZ3RoID4gMCAmJiBub2RlLmdyb3Vwc1swXS5ncm91cHNbMF0udHlwZSA9PT0gXCJ2YWx1ZS13b3JkXCIgJiYgbm9kZS5ncm91cHNbMF0uZ3JvdXBzWzBdLnZhbHVlLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQkNShbbm9kZS5vcGVuID8gcGF0aC5jYWxsKHByaW50LCBcIm9wZW5cIikgOiBcIlwiLCBqb2luJDIoXCIsXCIsIHBhdGgubWFwKHByaW50LCBcImdyb3Vwc1wiKSksIG5vZGUuY2xvc2UgPyBwYXRoLmNhbGwocHJpbnQsIFwiY2xvc2VcIikgOiBcIlwiXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFub2RlLm9wZW4pIHtcbiAgICAgICAgICAgIHZhciBfcHJpbnRlZCA9IHBhdGgubWFwKHByaW50LCBcImdyb3Vwc1wiKTtcblxuICAgICAgICAgICAgdmFyIHJlcyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgX3ByaW50ZWQubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChfaSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGNvbmNhdCQ1KFtcIixcIiwgbGluZSQxXSkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmVzLnB1c2goX3ByaW50ZWRbX2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGdyb3VwJDEoaW5kZW50JDIoZmlsbCQyKHJlcykpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaXNTQ1NTTWFwSXRlbSA9IGlzU0NTU01hcEl0ZW1Ob2RlJDEocGF0aCk7XG4gICAgICAgICAgcmV0dXJuIGdyb3VwJDEoY29uY2F0JDUoW25vZGUub3BlbiA/IHBhdGguY2FsbChwcmludCwgXCJvcGVuXCIpIDogXCJcIiwgaW5kZW50JDIoY29uY2F0JDUoW3NvZnRsaW5lJDEsIGpvaW4kMihjb25jYXQkNShbXCIsXCIsIGxpbmUkMV0pLCBwYXRoLm1hcChmdW5jdGlvbiAoY2hpbGRQYXRoKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGNoaWxkUGF0aC5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgdmFyIHByaW50ZWQgPSBwcmludChjaGlsZFBhdGgpOyAvLyBLZXkvVmFsdWUgcGFpciBpbiBvcGVuIHBhcmVuIGFscmVhZHkgaW5kZW50ZWRcblxuICAgICAgICAgICAgaWYgKGlzS2V5VmFsdWVQYWlyTm9kZSQxKG5vZGUpICYmIG5vZGUudHlwZSA9PT0gXCJ2YWx1ZS1jb21tYV9ncm91cFwiICYmIG5vZGUuZ3JvdXBzICYmIG5vZGUuZ3JvdXBzWzJdICYmIG5vZGUuZ3JvdXBzWzJdLnR5cGUgPT09IFwidmFsdWUtcGFyZW5fZ3JvdXBcIikge1xuICAgICAgICAgICAgICBwcmludGVkLmNvbnRlbnRzLmNvbnRlbnRzLnBhcnRzWzFdID0gZ3JvdXAkMShwcmludGVkLmNvbnRlbnRzLmNvbnRlbnRzLnBhcnRzWzFdKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGdyb3VwJDEoZGVkZW50JDEocHJpbnRlZCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcHJpbnRlZDtcbiAgICAgICAgICB9LCBcImdyb3Vwc1wiKSldKSksIGlmQnJlYWskMShpc1NDU1MkMShvcHRpb25zLnBhcnNlciwgb3B0aW9ucy5vcmlnaW5hbFRleHQpICYmIGlzU0NTU01hcEl0ZW0gJiYgc2hvdWxkUHJpbnRDb21tYShvcHRpb25zKSA/IFwiLFwiIDogXCJcIiksIHNvZnRsaW5lJDEsIG5vZGUuY2xvc2UgPyBwYXRoLmNhbGwocHJpbnQsIFwiY2xvc2VcIikgOiBcIlwiXSksIHtcbiAgICAgICAgICAgIHNob3VsZEJyZWFrOiBpc1NDU1NNYXBJdGVtXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInZhbHVlLWZ1bmNcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBjb25jYXQkNShbbm9kZS52YWx1ZSwgaW5zaWRlQXRSdWxlTm9kZSQxKHBhdGgsIFwic3VwcG9ydHNcIikgJiYgaXNNZWRpYUFuZFN1cHBvcnRzS2V5d29yZHMkMShub2RlKSA/IFwiIFwiIDogXCJcIiwgcGF0aC5jYWxsKHByaW50LCBcImdyb3VwXCIpXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInZhbHVlLXBhcmVuXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwidmFsdWUtbnVtYmVyXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDUoW3ByaW50Q3NzTnVtYmVyKG5vZGUudmFsdWUpLCBtYXliZVRvTG93ZXJDYXNlJDEobm9kZS51bml0KV0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJ2YWx1ZS1vcGVyYXRvclwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInZhbHVlLXdvcmRcIjpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChub2RlLmlzQ29sb3IgJiYgbm9kZS5pc0hleCB8fCBpc1dpZGVLZXl3b3JkcyQxKG5vZGUudmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJ2YWx1ZS1jb2xvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ1KFtub2RlLnZhbHVlLCAvLyBEb24ndCBhZGQgc3BhY2VzIG9uIGA6YCBpbiBgdXJsYCBmdW5jdGlvbiAoaS5lLiBgdXJsKGZiZ2x5cGg6IGNyb3NzLW91dGxpbmUsIGZpZy13aGl0ZSlgKVxuICAgICAgICAgIGluc2lkZVZhbHVlRnVuY3Rpb25Ob2RlJDEocGF0aCwgXCJ1cmxcIikgPyBcIlwiIDogbGluZSQxXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInZhbHVlLWNvbW1hXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDUoW25vZGUudmFsdWUsIFwiIFwiXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInZhbHVlLXN0cmluZ1wiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHByaW50U3RyaW5nJDEobm9kZS5yYXdzLnF1b3RlICsgbm9kZS52YWx1ZSArIG5vZGUucmF3cy5xdW90ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInZhbHVlLWF0d29yZFwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ1KFtcIkBcIiwgbm9kZS52YWx1ZV0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJ2YWx1ZS11bmljb2RlLXJhbmdlXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwidmFsdWUtdW5rbm93blwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBwb3N0Y3NzIHR5cGUgXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KG5vZGUudHlwZSkpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcmludE5vZGVTZXF1ZW5jZShwYXRoLCBvcHRpb25zLCBwcmludCkge1xuICAgIHZhciBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICBwYXRoLm1hcChmdW5jdGlvbiAocGF0aENoaWxkKSB7XG4gICAgICB2YXIgcHJldk5vZGUgPSBub2RlLm5vZGVzW2kgLSAxXTtcblxuICAgICAgaWYgKHByZXZOb2RlICYmIHByZXZOb2RlLnR5cGUgPT09IFwiY3NzLWNvbW1lbnRcIiAmJiBwcmV2Tm9kZS50ZXh0LnRyaW0oKSA9PT0gXCJwcmV0dGllci1pZ25vcmVcIikge1xuICAgICAgICB2YXIgY2hpbGROb2RlID0gcGF0aENoaWxkLmdldFZhbHVlKCk7XG4gICAgICAgIHBhcnRzLnB1c2gob3B0aW9ucy5vcmlnaW5hbFRleHQuc2xpY2Uob3B0aW9ucy5sb2NTdGFydChjaGlsZE5vZGUpLCBvcHRpb25zLmxvY0VuZChjaGlsZE5vZGUpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0cy5wdXNoKHBhdGhDaGlsZC5jYWxsKHByaW50KSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpICE9PSBub2RlLm5vZGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZXNbaSArIDFdLnR5cGUgPT09IFwiY3NzLWNvbW1lbnRcIiAmJiAhaGFzTmV3bGluZSQyKG9wdGlvbnMub3JpZ2luYWxUZXh0LCBvcHRpb25zLmxvY1N0YXJ0KG5vZGUubm9kZXNbaSArIDFdKSwge1xuICAgICAgICAgIGJhY2t3YXJkczogdHJ1ZVxuICAgICAgICB9KSAmJiBub2RlLm5vZGVzW2ldLnR5cGUgIT09IFwieWFtbFwiICYmIG5vZGUubm9kZXNbaV0udHlwZSAhPT0gXCJ0b21sXCIgfHwgbm9kZS5ub2Rlc1tpICsgMV0udHlwZSA9PT0gXCJjc3MtYXRydWxlXCIgJiYgbm9kZS5ub2Rlc1tpICsgMV0ubmFtZSA9PT0gXCJlbHNlXCIgJiYgbm9kZS5ub2Rlc1tpXS50eXBlICE9PSBcImNzcy1jb21tZW50XCIpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKFwiIFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKGhhcmRsaW5lJDQpO1xuXG4gICAgICAgICAgaWYgKGlzTmV4dExpbmVFbXB0eSQyKG9wdGlvbnMub3JpZ2luYWxUZXh0LCBwYXRoQ2hpbGQuZ2V0VmFsdWUoKSwgb3B0aW9ucykgJiYgbm9kZS5ub2Rlc1tpXS50eXBlICE9PSBcInlhbWxcIiAmJiBub2RlLm5vZGVzW2ldLnR5cGUgIT09IFwidG9tbFwiKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGhhcmRsaW5lJDQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpKys7XG4gICAgfSwgXCJub2Rlc1wiKTtcbiAgICByZXR1cm4gY29uY2F0JDUocGFydHMpO1xuICB9XG5cbiAgdmFyIFNUUklOR19SRUdFWCQxID0gLyhbJ1wiXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcW1xcc1xcU10pKlxcMS9nO1xuICB2YXIgTlVNQkVSX1JFR0VYID0gLyg/OlxcZCpcXC5cXGQrfFxcZCtcXC4/KSg/OltlRV1bKy1dP1xcZCspPy9nO1xuICB2YXIgU1RBTkRBUkRfVU5JVF9SRUdFWCA9IC9bYS16QS1aXSsvZztcbiAgdmFyIFdPUkRfUEFSVF9SRUdFWCA9IC9bJEBdP1thLXpBLVpfXFx1MDA4MC1cXHVGRkZGXVtcXHdcXC1cXHUwMDgwLVxcdUZGRkZdKi9nO1xuICB2YXIgQURKVVNUX05VTUJFUlNfUkVHRVggPSBSZWdFeHAoU1RSSU5HX1JFR0VYJDEuc291cmNlICsgXCJ8XCIgKyBcIihcIi5jb25jYXQoV09SRF9QQVJUX1JFR0VYLnNvdXJjZSwgXCIpP1wiKSArIFwiKFwiLmNvbmNhdChOVU1CRVJfUkVHRVguc291cmNlLCBcIilcIikgKyBcIihcIi5jb25jYXQoU1RBTkRBUkRfVU5JVF9SRUdFWC5zb3VyY2UsIFwiKT9cIiksIFwiZ1wiKTtcblxuICBmdW5jdGlvbiBhZGp1c3RTdHJpbmdzKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoU1RSSU5HX1JFR0VYJDEsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgcmV0dXJuIHByaW50U3RyaW5nJDEobWF0Y2gsIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcXVvdGVBdHRyaWJ1dGVWYWx1ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHZhciBxdW90ZSA9IG9wdGlvbnMuc2luZ2xlUXVvdGUgPyBcIidcIiA6ICdcIic7XG4gICAgcmV0dXJuIHZhbHVlLmluY2x1ZGVzKCdcIicpIHx8IHZhbHVlLmluY2x1ZGVzKFwiJ1wiKSA/IHZhbHVlIDogcXVvdGUgKyB2YWx1ZSArIHF1b3RlO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRqdXN0TnVtYmVycyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKEFESlVTVF9OVU1CRVJTX1JFR0VYLCBmdW5jdGlvbiAobWF0Y2gsIHF1b3RlLCB3b3JkUGFydCwgbnVtYmVyLCB1bml0KSB7XG4gICAgICByZXR1cm4gIXdvcmRQYXJ0ICYmIG51bWJlciA/ICh3b3JkUGFydCB8fCBcIlwiKSArIHByaW50Q3NzTnVtYmVyKG51bWJlcikgKyBtYXliZVRvTG93ZXJDYXNlJDEodW5pdCB8fCBcIlwiKSA6IG1hdGNoO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRDc3NOdW1iZXIocmF3TnVtYmVyKSB7XG4gICAgcmV0dXJuIHByaW50TnVtYmVyJDEocmF3TnVtYmVyKSAvLyBSZW1vdmUgdHJhaWxpbmcgYC4wYC5cbiAgICAucmVwbGFjZSgvXFwuMCg/PSR8ZSkvLCBcIlwiKTtcbiAgfVxuXG4gIHZhciBwcmludGVyUG9zdGNzcyA9IHtcbiAgICBwcmludDogZ2VuZXJpY1ByaW50LFxuICAgIGVtYmVkOiBlbWJlZF8xLFxuICAgIGluc2VydFByYWdtYTogaW5zZXJ0UHJhZ21hJDIsXG4gICAgaGFzUHJldHRpZXJJZ25vcmU6IGhhc0lnbm9yZUNvbW1lbnQkMSxcbiAgICBtYXNzYWdlQXN0Tm9kZTogY2xlYW5fMVxuICB9O1xuXG4gIHZhciBDQVRFR09SWV9DT01NT04gPSBcIkNvbW1vblwiOyAvLyBmb3JtYXQgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL3ByZXR0aWVyL3ByZXR0aWVyL2Jsb2IvbWFzdGVyL3NyYy9tYWluL2NvcmUtb3B0aW9ucy5qc1xuXG4gIHZhciBjb21tb25PcHRpb25zID0ge1xuICAgIGJyYWNrZXRTcGFjaW5nOiB7XG4gICAgICBzaW5jZTogXCIwLjAuMFwiLFxuICAgICAgY2F0ZWdvcnk6IENBVEVHT1JZX0NPTU1PTixcbiAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlByaW50IHNwYWNlcyBiZXR3ZWVuIGJyYWNrZXRzLlwiLFxuICAgICAgb3Bwb3NpdGVEZXNjcmlwdGlvbjogXCJEbyBub3QgcHJpbnQgc3BhY2VzIGJldHdlZW4gYnJhY2tldHMuXCJcbiAgICB9LFxuICAgIHNpbmdsZVF1b3RlOiB7XG4gICAgICBzaW5jZTogXCIwLjAuMFwiLFxuICAgICAgY2F0ZWdvcnk6IENBVEVHT1JZX0NPTU1PTixcbiAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICBkZXNjcmlwdGlvbjogXCJVc2Ugc2luZ2xlIHF1b3RlcyBpbnN0ZWFkIG9mIGRvdWJsZSBxdW90ZXMuXCJcbiAgICB9LFxuICAgIHByb3NlV3JhcDoge1xuICAgICAgc2luY2U6IFwiMS44LjJcIixcbiAgICAgIGNhdGVnb3J5OiBDQVRFR09SWV9DT01NT04sXG4gICAgICB0eXBlOiBcImNob2ljZVwiLFxuICAgICAgZGVmYXVsdDogW3tcbiAgICAgICAgc2luY2U6IFwiMS44LjJcIixcbiAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgc2luY2U6IFwiMS45LjBcIixcbiAgICAgICAgdmFsdWU6IFwicHJlc2VydmVcIlxuICAgICAgfV0sXG4gICAgICBkZXNjcmlwdGlvbjogXCJIb3cgdG8gd3JhcCBwcm9zZS5cIixcbiAgICAgIGNob2ljZXM6IFt7XG4gICAgICAgIHNpbmNlOiBcIjEuOS4wXCIsXG4gICAgICAgIHZhbHVlOiBcImFsd2F5c1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJXcmFwIHByb3NlIGlmIGl0IGV4Y2VlZHMgdGhlIHByaW50IHdpZHRoLlwiXG4gICAgICB9LCB7XG4gICAgICAgIHNpbmNlOiBcIjEuOS4wXCIsXG4gICAgICAgIHZhbHVlOiBcIm5ldmVyXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkRvIG5vdCB3cmFwIHByb3NlLlwiXG4gICAgICB9LCB7XG4gICAgICAgIHNpbmNlOiBcIjEuOS4wXCIsXG4gICAgICAgIHZhbHVlOiBcInByZXNlcnZlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIldyYXAgcHJvc2UgYXMtaXMuXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICBkZXByZWNhdGVkOiBcIjEuOS4wXCIsXG4gICAgICAgIHJlZGlyZWN0OiBcIm5ldmVyXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IHRydWUsXG4gICAgICAgIGRlcHJlY2F0ZWQ6IFwiMS45LjBcIixcbiAgICAgICAgcmVkaXJlY3Q6IFwiYWx3YXlzXCJcbiAgICAgIH1dXG4gICAgfVxuICB9O1xuXG4gIHZhciBvcHRpb25zJDIgPSB7XG4gICAgc2luZ2xlUXVvdGU6IGNvbW1vbk9wdGlvbnMuc2luZ2xlUXVvdGVcbiAgfTtcblxuICB2YXIgY3JlYXRlTGFuZ3VhZ2UgPSBmdW5jdGlvbiBjcmVhdGVMYW5ndWFnZShsaW5ndWlzdERhdGEsIHRyYW5zZm9ybSkge1xuICAgIHZhciBsYW5ndWFnZSA9IHt9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIGxpbmd1aXN0RGF0YSkge1xuICAgICAgdmFyIG5ld0tleSA9IGtleSA9PT0gXCJsYW5ndWFnZUlkXCIgPyBcImxpbmd1aXN0TGFuZ3VhZ2VJZFwiIDoga2V5O1xuICAgICAgbGFuZ3VhZ2VbbmV3S2V5XSA9IGxpbmd1aXN0RGF0YVtrZXldO1xuICAgIH1cblxuICAgIHJldHVybiB0cmFuc2Zvcm0obGFuZ3VhZ2UpO1xuICB9O1xuXG4gIHZhciBuYW1lJDEgPSBcIkNTU1wiO1xuICB2YXIgdHlwZSA9IFwibWFya3VwXCI7XG4gIHZhciB0bVNjb3BlID0gXCJzb3VyY2UuY3NzXCI7XG4gIHZhciBhY2VNb2RlID0gXCJjc3NcIjtcbiAgdmFyIGNvZGVtaXJyb3JNb2RlID0gXCJjc3NcIjtcbiAgdmFyIGNvZGVtaXJyb3JNaW1lVHlwZSA9IFwidGV4dC9jc3NcIjtcbiAgdmFyIGNvbG9yID0gXCIjNTYzZDdjXCI7XG4gIHZhciBleHRlbnNpb25zID0gW1xuICBcdFwiLmNzc1wiXG4gIF07XG4gIHZhciBsYW5ndWFnZUlkID0gNTA7XG4gIHZhciBDU1MgPSB7XG4gIFx0bmFtZTogbmFtZSQxLFxuICBcdHR5cGU6IHR5cGUsXG4gIFx0dG1TY29wZTogdG1TY29wZSxcbiAgXHRhY2VNb2RlOiBhY2VNb2RlLFxuICBcdGNvZGVtaXJyb3JNb2RlOiBjb2RlbWlycm9yTW9kZSxcbiAgXHRjb2RlbWlycm9yTWltZVR5cGU6IGNvZGVtaXJyb3JNaW1lVHlwZSxcbiAgXHRjb2xvcjogY29sb3IsXG4gIFx0ZXh0ZW5zaW9uczogZXh0ZW5zaW9ucyxcbiAgXHRsYW5ndWFnZUlkOiBsYW5ndWFnZUlkXG4gIH07XG5cbiAgdmFyIENTUyQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBuYW1lOiBuYW1lJDEsXG4gICAgdHlwZTogdHlwZSxcbiAgICB0bVNjb3BlOiB0bVNjb3BlLFxuICAgIGFjZU1vZGU6IGFjZU1vZGUsXG4gICAgY29kZW1pcnJvck1vZGU6IGNvZGVtaXJyb3JNb2RlLFxuICAgIGNvZGVtaXJyb3JNaW1lVHlwZTogY29kZW1pcnJvck1pbWVUeXBlLFxuICAgIGNvbG9yOiBjb2xvcixcbiAgICBleHRlbnNpb25zOiBleHRlbnNpb25zLFxuICAgIGxhbmd1YWdlSWQ6IGxhbmd1YWdlSWQsXG4gICAgJ2RlZmF1bHQnOiBDU1NcbiAgfSk7XG5cbiAgdmFyIG5hbWUkMiA9IFwiUG9zdENTU1wiO1xuICB2YXIgdHlwZSQxID0gXCJtYXJrdXBcIjtcbiAgdmFyIHRtU2NvcGUkMSA9IFwic291cmNlLnBvc3Rjc3NcIjtcbiAgdmFyIGdyb3VwJDIgPSBcIkNTU1wiO1xuICB2YXIgZXh0ZW5zaW9ucyQxID0gW1xuICBcdFwiLnBjc3NcIlxuICBdO1xuICB2YXIgYWNlTW9kZSQxID0gXCJ0ZXh0XCI7XG4gIHZhciBsYW5ndWFnZUlkJDEgPSAyNjI3NjQ0Mzc7XG4gIHZhciBQb3N0Q1NTID0ge1xuICBcdG5hbWU6IG5hbWUkMixcbiAgXHR0eXBlOiB0eXBlJDEsXG4gIFx0dG1TY29wZTogdG1TY29wZSQxLFxuICBcdGdyb3VwOiBncm91cCQyLFxuICBcdGV4dGVuc2lvbnM6IGV4dGVuc2lvbnMkMSxcbiAgXHRhY2VNb2RlOiBhY2VNb2RlJDEsXG4gIFx0bGFuZ3VhZ2VJZDogbGFuZ3VhZ2VJZCQxXG4gIH07XG5cbiAgdmFyIFBvc3RDU1MkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgbmFtZTogbmFtZSQyLFxuICAgIHR5cGU6IHR5cGUkMSxcbiAgICB0bVNjb3BlOiB0bVNjb3BlJDEsXG4gICAgZ3JvdXA6IGdyb3VwJDIsXG4gICAgZXh0ZW5zaW9uczogZXh0ZW5zaW9ucyQxLFxuICAgIGFjZU1vZGU6IGFjZU1vZGUkMSxcbiAgICBsYW5ndWFnZUlkOiBsYW5ndWFnZUlkJDEsXG4gICAgJ2RlZmF1bHQnOiBQb3N0Q1NTXG4gIH0pO1xuXG4gIHZhciBuYW1lJDMgPSBcIkxlc3NcIjtcbiAgdmFyIHR5cGUkMiA9IFwibWFya3VwXCI7XG4gIHZhciBncm91cCQzID0gXCJDU1NcIjtcbiAgdmFyIGV4dGVuc2lvbnMkMiA9IFtcbiAgXHRcIi5sZXNzXCJcbiAgXTtcbiAgdmFyIHRtU2NvcGUkMiA9IFwic291cmNlLmNzcy5sZXNzXCI7XG4gIHZhciBhY2VNb2RlJDIgPSBcImxlc3NcIjtcbiAgdmFyIGNvZGVtaXJyb3JNb2RlJDEgPSBcImNzc1wiO1xuICB2YXIgY29kZW1pcnJvck1pbWVUeXBlJDEgPSBcInRleHQvY3NzXCI7XG4gIHZhciBsYW5ndWFnZUlkJDIgPSAxOTg7XG4gIHZhciBMZXNzID0ge1xuICBcdG5hbWU6IG5hbWUkMyxcbiAgXHR0eXBlOiB0eXBlJDIsXG4gIFx0Z3JvdXA6IGdyb3VwJDMsXG4gIFx0ZXh0ZW5zaW9uczogZXh0ZW5zaW9ucyQyLFxuICBcdHRtU2NvcGU6IHRtU2NvcGUkMixcbiAgXHRhY2VNb2RlOiBhY2VNb2RlJDIsXG4gIFx0Y29kZW1pcnJvck1vZGU6IGNvZGVtaXJyb3JNb2RlJDEsXG4gIFx0Y29kZW1pcnJvck1pbWVUeXBlOiBjb2RlbWlycm9yTWltZVR5cGUkMSxcbiAgXHRsYW5ndWFnZUlkOiBsYW5ndWFnZUlkJDJcbiAgfTtcblxuICB2YXIgTGVzcyQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBuYW1lOiBuYW1lJDMsXG4gICAgdHlwZTogdHlwZSQyLFxuICAgIGdyb3VwOiBncm91cCQzLFxuICAgIGV4dGVuc2lvbnM6IGV4dGVuc2lvbnMkMixcbiAgICB0bVNjb3BlOiB0bVNjb3BlJDIsXG4gICAgYWNlTW9kZTogYWNlTW9kZSQyLFxuICAgIGNvZGVtaXJyb3JNb2RlOiBjb2RlbWlycm9yTW9kZSQxLFxuICAgIGNvZGVtaXJyb3JNaW1lVHlwZTogY29kZW1pcnJvck1pbWVUeXBlJDEsXG4gICAgbGFuZ3VhZ2VJZDogbGFuZ3VhZ2VJZCQyLFxuICAgICdkZWZhdWx0JzogTGVzc1xuICB9KTtcblxuICB2YXIgbmFtZSQ0ID0gXCJTQ1NTXCI7XG4gIHZhciB0eXBlJDMgPSBcIm1hcmt1cFwiO1xuICB2YXIgdG1TY29wZSQzID0gXCJzb3VyY2UuY3NzLnNjc3NcIjtcbiAgdmFyIGdyb3VwJDQgPSBcIkNTU1wiO1xuICB2YXIgYWNlTW9kZSQzID0gXCJzY3NzXCI7XG4gIHZhciBjb2RlbWlycm9yTW9kZSQyID0gXCJjc3NcIjtcbiAgdmFyIGNvZGVtaXJyb3JNaW1lVHlwZSQyID0gXCJ0ZXh0L3gtc2Nzc1wiO1xuICB2YXIgZXh0ZW5zaW9ucyQzID0gW1xuICBcdFwiLnNjc3NcIlxuICBdO1xuICB2YXIgbGFuZ3VhZ2VJZCQzID0gMzI5O1xuICB2YXIgU0NTUyA9IHtcbiAgXHRuYW1lOiBuYW1lJDQsXG4gIFx0dHlwZTogdHlwZSQzLFxuICBcdHRtU2NvcGU6IHRtU2NvcGUkMyxcbiAgXHRncm91cDogZ3JvdXAkNCxcbiAgXHRhY2VNb2RlOiBhY2VNb2RlJDMsXG4gIFx0Y29kZW1pcnJvck1vZGU6IGNvZGVtaXJyb3JNb2RlJDIsXG4gIFx0Y29kZW1pcnJvck1pbWVUeXBlOiBjb2RlbWlycm9yTWltZVR5cGUkMixcbiAgXHRleHRlbnNpb25zOiBleHRlbnNpb25zJDMsXG4gIFx0bGFuZ3VhZ2VJZDogbGFuZ3VhZ2VJZCQzXG4gIH07XG5cbiAgdmFyIFNDU1MkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgbmFtZTogbmFtZSQ0LFxuICAgIHR5cGU6IHR5cGUkMyxcbiAgICB0bVNjb3BlOiB0bVNjb3BlJDMsXG4gICAgZ3JvdXA6IGdyb3VwJDQsXG4gICAgYWNlTW9kZTogYWNlTW9kZSQzLFxuICAgIGNvZGVtaXJyb3JNb2RlOiBjb2RlbWlycm9yTW9kZSQyLFxuICAgIGNvZGVtaXJyb3JNaW1lVHlwZTogY29kZW1pcnJvck1pbWVUeXBlJDIsXG4gICAgZXh0ZW5zaW9uczogZXh0ZW5zaW9ucyQzLFxuICAgIGxhbmd1YWdlSWQ6IGxhbmd1YWdlSWQkMyxcbiAgICAnZGVmYXVsdCc6IFNDU1NcbiAgfSk7XG5cbiAgdmFyIHJlcXVpcmUkJDAkMiA9IGdldENqc0V4cG9ydEZyb21OYW1lc3BhY2UoQ1NTJDEpO1xuXG4gIHZhciByZXF1aXJlJCQxID0gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZShQb3N0Q1NTJDEpO1xuXG4gIHZhciByZXF1aXJlJCQyID0gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZShMZXNzJDEpO1xuXG4gIHZhciByZXF1aXJlJCQzID0gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZShTQ1NTJDEpO1xuXG4gIHZhciBsYW5ndWFnZXMgPSBbY3JlYXRlTGFuZ3VhZ2UocmVxdWlyZSQkMCQyLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGRhdGEsIHtcbiAgICAgIHNpbmNlOiBcIjEuNC4wXCIsXG4gICAgICBwYXJzZXJzOiBbXCJjc3NcIl0sXG4gICAgICB2c2NvZGVMYW5ndWFnZUlkczogW1wiY3NzXCJdXG4gICAgfSk7XG4gIH0pLCBjcmVhdGVMYW5ndWFnZShyZXF1aXJlJCQxLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGRhdGEsIHtcbiAgICAgIHNpbmNlOiBcIjEuNC4wXCIsXG4gICAgICBwYXJzZXJzOiBbXCJjc3NcIl0sXG4gICAgICB2c2NvZGVMYW5ndWFnZUlkczogW1wicG9zdGNzc1wiXSxcbiAgICAgIGV4dGVuc2lvbnM6IGRhdGEuZXh0ZW5zaW9ucy5jb25jYXQoXCIucG9zdGNzc1wiKVxuICAgIH0pO1xuICB9KSwgY3JlYXRlTGFuZ3VhZ2UocmVxdWlyZSQkMiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkYXRhLCB7XG4gICAgICBzaW5jZTogXCIxLjQuMFwiLFxuICAgICAgcGFyc2VyczogW1wibGVzc1wiXSxcbiAgICAgIHZzY29kZUxhbmd1YWdlSWRzOiBbXCJsZXNzXCJdXG4gICAgfSk7XG4gIH0pLCBjcmVhdGVMYW5ndWFnZShyZXF1aXJlJCQzLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGRhdGEsIHtcbiAgICAgIHNpbmNlOiBcIjEuNC4wXCIsXG4gICAgICBwYXJzZXJzOiBbXCJzY3NzXCJdLFxuICAgICAgdnNjb2RlTGFuZ3VhZ2VJZHM6IFtcInNjc3NcIl1cbiAgICB9KTtcbiAgfSldO1xuICB2YXIgcHJpbnRlcnMgPSB7XG4gICAgcG9zdGNzczogcHJpbnRlclBvc3Rjc3NcbiAgfTtcbiAgdmFyIGxhbmd1YWdlQ3NzID0ge1xuICAgIGxhbmd1YWdlczogbGFuZ3VhZ2VzLFxuICAgIG9wdGlvbnM6IG9wdGlvbnMkMixcbiAgICBwcmludGVyczogcHJpbnRlcnNcbiAgfTtcblxuICBmdW5jdGlvbiBoYXNQcmFnbWEkMih0ZXh0KSB7XG4gICAgcmV0dXJuIC9eXFxzKiNbXlxcblxcU10qQChmb3JtYXR8cHJldHRpZXIpXFxzKihcXG58JCkvLnRlc3QodGV4dCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnRQcmFnbWEkMyh0ZXh0KSB7XG4gICAgcmV0dXJuIFwiIyBAZm9ybWF0XFxuXFxuXCIgKyB0ZXh0O1xuICB9XG5cbiAgdmFyIHByYWdtYSQyID0ge1xuICAgIGhhc1ByYWdtYTogaGFzUHJhZ21hJDIsXG4gICAgaW5zZXJ0UHJhZ21hOiBpbnNlcnRQcmFnbWEkM1xuICB9O1xuXG4gIHZhciBfcmVxdWlyZSQkMCRidWlsZGVycyQyID0gZG9jLmJ1aWxkZXJzLFxuICAgICAgY29uY2F0JDYgPSBfcmVxdWlyZSQkMCRidWlsZGVycyQyLmNvbmNhdCxcbiAgICAgIGpvaW4kMyA9IF9yZXF1aXJlJCQwJGJ1aWxkZXJzJDIuam9pbixcbiAgICAgIGhhcmRsaW5lJDUgPSBfcmVxdWlyZSQkMCRidWlsZGVycyQyLmhhcmRsaW5lLFxuICAgICAgbGluZSQyID0gX3JlcXVpcmUkJDAkYnVpbGRlcnMkMi5saW5lLFxuICAgICAgc29mdGxpbmUkMiA9IF9yZXF1aXJlJCQwJGJ1aWxkZXJzJDIuc29mdGxpbmUsXG4gICAgICBncm91cCQ1ID0gX3JlcXVpcmUkJDAkYnVpbGRlcnMkMi5ncm91cCxcbiAgICAgIGluZGVudCQzID0gX3JlcXVpcmUkJDAkYnVpbGRlcnMkMi5pbmRlbnQsXG4gICAgICBpZkJyZWFrJDIgPSBfcmVxdWlyZSQkMCRidWlsZGVycyQyLmlmQnJlYWs7XG4gIHZhciBoYXNJZ25vcmVDb21tZW50JDIgPSB1dGlsLmhhc0lnbm9yZUNvbW1lbnQ7XG4gIHZhciBpc05leHRMaW5lRW1wdHkkMyA9IHV0aWxTaGFyZWQuaXNOZXh0TGluZUVtcHR5O1xuICB2YXIgaW5zZXJ0UHJhZ21hJDQgPSBwcmFnbWEkMi5pbnNlcnRQcmFnbWE7XG5cbiAgZnVuY3Rpb24gZ2VuZXJpY1ByaW50JDEocGF0aCwgb3B0aW9ucywgcHJpbnQpIHtcbiAgICB2YXIgbiA9IHBhdGguZ2V0VmFsdWUoKTtcblxuICAgIGlmICghbikge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gbjtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKG4ua2luZCkge1xuICAgICAgY2FzZSBcIkRvY3VtZW50XCI6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcGFydHMgPSBbXTtcbiAgICAgICAgICBwYXRoLm1hcChmdW5jdGlvbiAocGF0aENoaWxkLCBpbmRleCkge1xuICAgICAgICAgICAgcGFydHMucHVzaChjb25jYXQkNihbcGF0aENoaWxkLmNhbGwocHJpbnQpXSkpO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IG4uZGVmaW5pdGlvbnMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGhhcmRsaW5lJDUpO1xuXG4gICAgICAgICAgICAgIGlmIChpc05leHRMaW5lRW1wdHkkMyhvcHRpb25zLm9yaWdpbmFsVGV4dCwgcGF0aENoaWxkLmdldFZhbHVlKCksIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChoYXJkbGluZSQ1KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIFwiZGVmaW5pdGlvbnNcIik7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ2KFtjb25jYXQkNihwYXJ0cyksIGhhcmRsaW5lJDVdKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiT3BlcmF0aW9uRGVmaW5pdGlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGhhc09wZXJhdGlvbiA9IG9wdGlvbnMub3JpZ2luYWxUZXh0W29wdGlvbnMubG9jU3RhcnQobildICE9PSBcIntcIjtcbiAgICAgICAgICB2YXIgaGFzTmFtZSA9ICEhbi5uYW1lO1xuICAgICAgICAgIHJldHVybiBjb25jYXQkNihbaGFzT3BlcmF0aW9uID8gbi5vcGVyYXRpb24gOiBcIlwiLCBoYXNPcGVyYXRpb24gJiYgaGFzTmFtZSA/IGNvbmNhdCQ2KFtcIiBcIiwgcGF0aC5jYWxsKHByaW50LCBcIm5hbWVcIildKSA6IFwiXCIsIG4udmFyaWFibGVEZWZpbml0aW9ucyAmJiBuLnZhcmlhYmxlRGVmaW5pdGlvbnMubGVuZ3RoID8gZ3JvdXAkNShjb25jYXQkNihbXCIoXCIsIGluZGVudCQzKGNvbmNhdCQ2KFtzb2Z0bGluZSQyLCBqb2luJDMoY29uY2F0JDYoW2lmQnJlYWskMihcIlwiLCBcIiwgXCIpLCBzb2Z0bGluZSQyXSksIHBhdGgubWFwKHByaW50LCBcInZhcmlhYmxlRGVmaW5pdGlvbnNcIikpXSkpLCBzb2Z0bGluZSQyLCBcIilcIl0pKSA6IFwiXCIsIHByaW50RGlyZWN0aXZlcyhwYXRoLCBwcmludCwgbiksIG4uc2VsZWN0aW9uU2V0ID8gIWhhc09wZXJhdGlvbiAmJiAhaGFzTmFtZSA/IFwiXCIgOiBcIiBcIiA6IFwiXCIsIHBhdGguY2FsbChwcmludCwgXCJzZWxlY3Rpb25TZXRcIildKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiRnJhZ21lbnREZWZpbml0aW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDYoW1wiZnJhZ21lbnQgXCIsIHBhdGguY2FsbChwcmludCwgXCJuYW1lXCIpLCBuLnZhcmlhYmxlRGVmaW5pdGlvbnMgJiYgbi52YXJpYWJsZURlZmluaXRpb25zLmxlbmd0aCA/IGdyb3VwJDUoY29uY2F0JDYoW1wiKFwiLCBpbmRlbnQkMyhjb25jYXQkNihbc29mdGxpbmUkMiwgam9pbiQzKGNvbmNhdCQ2KFtpZkJyZWFrJDIoXCJcIiwgXCIsIFwiKSwgc29mdGxpbmUkMl0pLCBwYXRoLm1hcChwcmludCwgXCJ2YXJpYWJsZURlZmluaXRpb25zXCIpKV0pKSwgc29mdGxpbmUkMiwgXCIpXCJdKSkgOiBcIlwiLCBcIiBvbiBcIiwgcGF0aC5jYWxsKHByaW50LCBcInR5cGVDb25kaXRpb25cIiksIHByaW50RGlyZWN0aXZlcyhwYXRoLCBwcmludCwgbiksIFwiIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwic2VsZWN0aW9uU2V0XCIpXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIlNlbGVjdGlvblNldFwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ2KFtcIntcIiwgaW5kZW50JDMoY29uY2F0JDYoW2hhcmRsaW5lJDUsIGpvaW4kMyhoYXJkbGluZSQ1LCBwYXRoLmNhbGwoZnVuY3Rpb24gKHNlbGVjdGlvbnNQYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJpbnRTZXF1ZW5jZShzZWxlY3Rpb25zUGF0aCwgb3B0aW9ucywgcHJpbnQpO1xuICAgICAgICAgIH0sIFwic2VsZWN0aW9uc1wiKSldKSksIGhhcmRsaW5lJDUsIFwifVwiXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIkZpZWxkXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gZ3JvdXAkNShjb25jYXQkNihbbi5hbGlhcyA/IGNvbmNhdCQ2KFtwYXRoLmNhbGwocHJpbnQsIFwiYWxpYXNcIiksIFwiOiBcIl0pIDogXCJcIiwgcGF0aC5jYWxsKHByaW50LCBcIm5hbWVcIiksIG4uYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBncm91cCQ1KGNvbmNhdCQ2KFtcIihcIiwgaW5kZW50JDMoY29uY2F0JDYoW3NvZnRsaW5lJDIsIGpvaW4kMyhjb25jYXQkNihbaWZCcmVhayQyKFwiXCIsIFwiLCBcIiksIHNvZnRsaW5lJDJdKSwgcGF0aC5jYWxsKGZ1bmN0aW9uIChhcmdzUGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHByaW50U2VxdWVuY2UoYXJnc1BhdGgsIG9wdGlvbnMsIHByaW50KTtcbiAgICAgICAgICB9LCBcImFyZ3VtZW50c1wiKSldKSksIHNvZnRsaW5lJDIsIFwiKVwiXSkpIDogXCJcIiwgcHJpbnREaXJlY3RpdmVzKHBhdGgsIHByaW50LCBuKSwgbi5zZWxlY3Rpb25TZXQgPyBcIiBcIiA6IFwiXCIsIHBhdGguY2FsbChwcmludCwgXCJzZWxlY3Rpb25TZXRcIildKSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIk5hbWVcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBuLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJTdHJpbmdWYWx1ZVwiOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKG4uYmxvY2spIHtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQkNihbJ1wiXCJcIicsIGhhcmRsaW5lJDUsIGpvaW4kMyhoYXJkbGluZSQ1LCBuLnZhbHVlLnJlcGxhY2UoL1wiXCJcIi9nLCBcIlxcXFwkJlwiKS5zcGxpdChcIlxcblwiKSksIGhhcmRsaW5lJDUsICdcIlwiXCInXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ2KFsnXCInLCBuLnZhbHVlLnJlcGxhY2UoL1tcIlxcXFxdL2csIFwiXFxcXCQmXCIpLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpLCAnXCInXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIkludFZhbHVlXCI6XG4gICAgICBjYXNlIFwiRmxvYXRWYWx1ZVwiOlxuICAgICAgY2FzZSBcIkVudW1WYWx1ZVwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG4udmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIkJvb2xlYW5WYWx1ZVwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG4udmFsdWUgPyBcInRydWVcIiA6IFwiZmFsc2VcIjtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiTnVsbFZhbHVlXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIlZhcmlhYmxlXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDYoW1wiJFwiLCBwYXRoLmNhbGwocHJpbnQsIFwibmFtZVwiKV0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJMaXN0VmFsdWVcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBncm91cCQ1KGNvbmNhdCQ2KFtcIltcIiwgaW5kZW50JDMoY29uY2F0JDYoW3NvZnRsaW5lJDIsIGpvaW4kMyhjb25jYXQkNihbaWZCcmVhayQyKFwiXCIsIFwiLCBcIiksIHNvZnRsaW5lJDJdKSwgcGF0aC5tYXAocHJpbnQsIFwidmFsdWVzXCIpKV0pKSwgc29mdGxpbmUkMiwgXCJdXCJdKSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIk9iamVjdFZhbHVlXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gZ3JvdXAkNShjb25jYXQkNihbXCJ7XCIsIG9wdGlvbnMuYnJhY2tldFNwYWNpbmcgJiYgbi5maWVsZHMubGVuZ3RoID4gMCA/IFwiIFwiIDogXCJcIiwgaW5kZW50JDMoY29uY2F0JDYoW3NvZnRsaW5lJDIsIGpvaW4kMyhjb25jYXQkNihbaWZCcmVhayQyKFwiXCIsIFwiLCBcIiksIHNvZnRsaW5lJDJdKSwgcGF0aC5tYXAocHJpbnQsIFwiZmllbGRzXCIpKV0pKSwgc29mdGxpbmUkMiwgaWZCcmVhayQyKFwiXCIsIG9wdGlvbnMuYnJhY2tldFNwYWNpbmcgJiYgbi5maWVsZHMubGVuZ3RoID4gMCA/IFwiIFwiIDogXCJcIiksIFwifVwiXSkpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJPYmplY3RGaWVsZFwiOlxuICAgICAgY2FzZSBcIkFyZ3VtZW50XCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDYoW3BhdGguY2FsbChwcmludCwgXCJuYW1lXCIpLCBcIjogXCIsIHBhdGguY2FsbChwcmludCwgXCJ2YWx1ZVwiKV0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJEaXJlY3RpdmVcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBjb25jYXQkNihbXCJAXCIsIHBhdGguY2FsbChwcmludCwgXCJuYW1lXCIpLCBuLmFyZ3VtZW50cy5sZW5ndGggPiAwID8gZ3JvdXAkNShjb25jYXQkNihbXCIoXCIsIGluZGVudCQzKGNvbmNhdCQ2KFtzb2Z0bGluZSQyLCBqb2luJDMoY29uY2F0JDYoW2lmQnJlYWskMihcIlwiLCBcIiwgXCIpLCBzb2Z0bGluZSQyXSksIHBhdGguY2FsbChmdW5jdGlvbiAoYXJnc1BhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmludFNlcXVlbmNlKGFyZ3NQYXRoLCBvcHRpb25zLCBwcmludCk7XG4gICAgICAgICAgfSwgXCJhcmd1bWVudHNcIikpXSkpLCBzb2Z0bGluZSQyLCBcIilcIl0pKSA6IFwiXCJdKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiTmFtZWRUeXBlXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gcGF0aC5jYWxsKHByaW50LCBcIm5hbWVcIik7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIlZhcmlhYmxlRGVmaW5pdGlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ2KFtwYXRoLmNhbGwocHJpbnQsIFwidmFyaWFibGVcIiksIFwiOiBcIiwgcGF0aC5jYWxsKHByaW50LCBcInR5cGVcIiksIG4uZGVmYXVsdFZhbHVlID8gY29uY2F0JDYoW1wiID0gXCIsIHBhdGguY2FsbChwcmludCwgXCJkZWZhdWx0VmFsdWVcIildKSA6IFwiXCIsIHByaW50RGlyZWN0aXZlcyhwYXRoLCBwcmludCwgbildKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiVHlwZUV4dGVuc2lvbkRlZmluaXRpb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBjb25jYXQkNihbXCJleHRlbmQgXCIsIHBhdGguY2FsbChwcmludCwgXCJkZWZpbml0aW9uXCIpXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIk9iamVjdFR5cGVFeHRlbnNpb25cIjpcbiAgICAgIGNhc2UgXCJPYmplY3RUeXBlRGVmaW5pdGlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ2KFtwYXRoLmNhbGwocHJpbnQsIFwiZGVzY3JpcHRpb25cIiksIG4uZGVzY3JpcHRpb24gPyBoYXJkbGluZSQ1IDogXCJcIiwgbi5raW5kID09PSBcIk9iamVjdFR5cGVFeHRlbnNpb25cIiA/IFwiZXh0ZW5kIFwiIDogXCJcIiwgXCJ0eXBlIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwibmFtZVwiKSwgbi5pbnRlcmZhY2VzLmxlbmd0aCA+IDAgPyBjb25jYXQkNihbXCIgaW1wbGVtZW50cyBcIiwgam9pbiQzKGRldGVybWluZUludGVyZmFjZVNlcGFyYXRvcihvcHRpb25zLm9yaWdpbmFsVGV4dC5zdWJzdHIob3B0aW9ucy5sb2NTdGFydChuKSwgb3B0aW9ucy5sb2NFbmQobikpKSwgcGF0aC5tYXAocHJpbnQsIFwiaW50ZXJmYWNlc1wiKSldKSA6IFwiXCIsIHByaW50RGlyZWN0aXZlcyhwYXRoLCBwcmludCwgbiksIG4uZmllbGRzLmxlbmd0aCA+IDAgPyBjb25jYXQkNihbXCIge1wiLCBpbmRlbnQkMyhjb25jYXQkNihbaGFyZGxpbmUkNSwgam9pbiQzKGhhcmRsaW5lJDUsIHBhdGguY2FsbChmdW5jdGlvbiAoZmllbGRzUGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHByaW50U2VxdWVuY2UoZmllbGRzUGF0aCwgb3B0aW9ucywgcHJpbnQpO1xuICAgICAgICAgIH0sIFwiZmllbGRzXCIpKV0pKSwgaGFyZGxpbmUkNSwgXCJ9XCJdKSA6IFwiXCJdKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiRmllbGREZWZpbml0aW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDYoW3BhdGguY2FsbChwcmludCwgXCJkZXNjcmlwdGlvblwiKSwgbi5kZXNjcmlwdGlvbiA/IGhhcmRsaW5lJDUgOiBcIlwiLCBwYXRoLmNhbGwocHJpbnQsIFwibmFtZVwiKSwgbi5hcmd1bWVudHMubGVuZ3RoID4gMCA/IGdyb3VwJDUoY29uY2F0JDYoW1wiKFwiLCBpbmRlbnQkMyhjb25jYXQkNihbc29mdGxpbmUkMiwgam9pbiQzKGNvbmNhdCQ2KFtpZkJyZWFrJDIoXCJcIiwgXCIsIFwiKSwgc29mdGxpbmUkMl0pLCBwYXRoLmNhbGwoZnVuY3Rpb24gKGFyZ3NQYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJpbnRTZXF1ZW5jZShhcmdzUGF0aCwgb3B0aW9ucywgcHJpbnQpO1xuICAgICAgICAgIH0sIFwiYXJndW1lbnRzXCIpKV0pKSwgc29mdGxpbmUkMiwgXCIpXCJdKSkgOiBcIlwiLCBcIjogXCIsIHBhdGguY2FsbChwcmludCwgXCJ0eXBlXCIpLCBwcmludERpcmVjdGl2ZXMocGF0aCwgcHJpbnQsIG4pXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIkRpcmVjdGl2ZURlZmluaXRpb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBjb25jYXQkNihbcGF0aC5jYWxsKHByaW50LCBcImRlc2NyaXB0aW9uXCIpLCBuLmRlc2NyaXB0aW9uID8gaGFyZGxpbmUkNSA6IFwiXCIsIFwiZGlyZWN0aXZlIFwiLCBcIkBcIiwgcGF0aC5jYWxsKHByaW50LCBcIm5hbWVcIiksIG4uYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBncm91cCQ1KGNvbmNhdCQ2KFtcIihcIiwgaW5kZW50JDMoY29uY2F0JDYoW3NvZnRsaW5lJDIsIGpvaW4kMyhjb25jYXQkNihbaWZCcmVhayQyKFwiXCIsIFwiLCBcIiksIHNvZnRsaW5lJDJdKSwgcGF0aC5jYWxsKGZ1bmN0aW9uIChhcmdzUGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHByaW50U2VxdWVuY2UoYXJnc1BhdGgsIG9wdGlvbnMsIHByaW50KTtcbiAgICAgICAgICB9LCBcImFyZ3VtZW50c1wiKSldKSksIHNvZnRsaW5lJDIsIFwiKVwiXSkpIDogXCJcIiwgY29uY2F0JDYoW1wiIG9uIFwiLCBqb2luJDMoXCIgfCBcIiwgcGF0aC5tYXAocHJpbnQsIFwibG9jYXRpb25zXCIpKV0pXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIkVudW1UeXBlRXh0ZW5zaW9uXCI6XG4gICAgICBjYXNlIFwiRW51bVR5cGVEZWZpbml0aW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDYoW3BhdGguY2FsbChwcmludCwgXCJkZXNjcmlwdGlvblwiKSwgbi5kZXNjcmlwdGlvbiA/IGhhcmRsaW5lJDUgOiBcIlwiLCBuLmtpbmQgPT09IFwiRW51bVR5cGVFeHRlbnNpb25cIiA/IFwiZXh0ZW5kIFwiIDogXCJcIiwgXCJlbnVtIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwibmFtZVwiKSwgcHJpbnREaXJlY3RpdmVzKHBhdGgsIHByaW50LCBuKSwgbi52YWx1ZXMubGVuZ3RoID4gMCA/IGNvbmNhdCQ2KFtcIiB7XCIsIGluZGVudCQzKGNvbmNhdCQ2KFtoYXJkbGluZSQ1LCBqb2luJDMoaGFyZGxpbmUkNSwgcGF0aC5jYWxsKGZ1bmN0aW9uICh2YWx1ZXNQYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJpbnRTZXF1ZW5jZSh2YWx1ZXNQYXRoLCBvcHRpb25zLCBwcmludCk7XG4gICAgICAgICAgfSwgXCJ2YWx1ZXNcIikpXSkpLCBoYXJkbGluZSQ1LCBcIn1cIl0pIDogXCJcIl0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJFbnVtVmFsdWVEZWZpbml0aW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDYoW3BhdGguY2FsbChwcmludCwgXCJkZXNjcmlwdGlvblwiKSwgbi5kZXNjcmlwdGlvbiA/IGhhcmRsaW5lJDUgOiBcIlwiLCBwYXRoLmNhbGwocHJpbnQsIFwibmFtZVwiKSwgcHJpbnREaXJlY3RpdmVzKHBhdGgsIHByaW50LCBuKV0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJJbnB1dFZhbHVlRGVmaW5pdGlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ2KFtwYXRoLmNhbGwocHJpbnQsIFwiZGVzY3JpcHRpb25cIiksIG4uZGVzY3JpcHRpb24gPyBuLmRlc2NyaXB0aW9uLmJsb2NrID8gaGFyZGxpbmUkNSA6IGxpbmUkMiA6IFwiXCIsIHBhdGguY2FsbChwcmludCwgXCJuYW1lXCIpLCBcIjogXCIsIHBhdGguY2FsbChwcmludCwgXCJ0eXBlXCIpLCBuLmRlZmF1bHRWYWx1ZSA/IGNvbmNhdCQ2KFtcIiA9IFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiZGVmYXVsdFZhbHVlXCIpXSkgOiBcIlwiLCBwcmludERpcmVjdGl2ZXMocGF0aCwgcHJpbnQsIG4pXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIklucHV0T2JqZWN0VHlwZUV4dGVuc2lvblwiOlxuICAgICAgY2FzZSBcIklucHV0T2JqZWN0VHlwZURlZmluaXRpb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBjb25jYXQkNihbcGF0aC5jYWxsKHByaW50LCBcImRlc2NyaXB0aW9uXCIpLCBuLmRlc2NyaXB0aW9uID8gaGFyZGxpbmUkNSA6IFwiXCIsIG4ua2luZCA9PT0gXCJJbnB1dE9iamVjdFR5cGVFeHRlbnNpb25cIiA/IFwiZXh0ZW5kIFwiIDogXCJcIiwgXCJpbnB1dCBcIiwgcGF0aC5jYWxsKHByaW50LCBcIm5hbWVcIiksIHByaW50RGlyZWN0aXZlcyhwYXRoLCBwcmludCwgbiksIG4uZmllbGRzLmxlbmd0aCA+IDAgPyBjb25jYXQkNihbXCIge1wiLCBpbmRlbnQkMyhjb25jYXQkNihbaGFyZGxpbmUkNSwgam9pbiQzKGhhcmRsaW5lJDUsIHBhdGguY2FsbChmdW5jdGlvbiAoZmllbGRzUGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHByaW50U2VxdWVuY2UoZmllbGRzUGF0aCwgb3B0aW9ucywgcHJpbnQpO1xuICAgICAgICAgIH0sIFwiZmllbGRzXCIpKV0pKSwgaGFyZGxpbmUkNSwgXCJ9XCJdKSA6IFwiXCJdKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiU2NoZW1hRGVmaW5pdGlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ2KFtcInNjaGVtYVwiLCBwcmludERpcmVjdGl2ZXMocGF0aCwgcHJpbnQsIG4pLCBcIiB7XCIsIG4ub3BlcmF0aW9uVHlwZXMubGVuZ3RoID4gMCA/IGluZGVudCQzKGNvbmNhdCQ2KFtoYXJkbGluZSQ1LCBqb2luJDMoaGFyZGxpbmUkNSwgcGF0aC5jYWxsKGZ1bmN0aW9uIChvcHNQYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJpbnRTZXF1ZW5jZShvcHNQYXRoLCBvcHRpb25zLCBwcmludCk7XG4gICAgICAgICAgfSwgXCJvcGVyYXRpb25UeXBlc1wiKSldKSkgOiBcIlwiLCBoYXJkbGluZSQ1LCBcIn1cIl0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJPcGVyYXRpb25UeXBlRGVmaW5pdGlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ2KFtwYXRoLmNhbGwocHJpbnQsIFwib3BlcmF0aW9uXCIpLCBcIjogXCIsIHBhdGguY2FsbChwcmludCwgXCJ0eXBlXCIpXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIkludGVyZmFjZVR5cGVFeHRlbnNpb25cIjpcbiAgICAgIGNhc2UgXCJJbnRlcmZhY2VUeXBlRGVmaW5pdGlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ2KFtwYXRoLmNhbGwocHJpbnQsIFwiZGVzY3JpcHRpb25cIiksIG4uZGVzY3JpcHRpb24gPyBoYXJkbGluZSQ1IDogXCJcIiwgbi5raW5kID09PSBcIkludGVyZmFjZVR5cGVFeHRlbnNpb25cIiA/IFwiZXh0ZW5kIFwiIDogXCJcIiwgXCJpbnRlcmZhY2UgXCIsIHBhdGguY2FsbChwcmludCwgXCJuYW1lXCIpLCBwcmludERpcmVjdGl2ZXMocGF0aCwgcHJpbnQsIG4pLCBuLmZpZWxkcy5sZW5ndGggPiAwID8gY29uY2F0JDYoW1wiIHtcIiwgaW5kZW50JDMoY29uY2F0JDYoW2hhcmRsaW5lJDUsIGpvaW4kMyhoYXJkbGluZSQ1LCBwYXRoLmNhbGwoZnVuY3Rpb24gKGZpZWxkc1BhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmludFNlcXVlbmNlKGZpZWxkc1BhdGgsIG9wdGlvbnMsIHByaW50KTtcbiAgICAgICAgICB9LCBcImZpZWxkc1wiKSldKSksIGhhcmRsaW5lJDUsIFwifVwiXSkgOiBcIlwiXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIkZyYWdtZW50U3ByZWFkXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDYoW1wiLi4uXCIsIHBhdGguY2FsbChwcmludCwgXCJuYW1lXCIpLCBwcmludERpcmVjdGl2ZXMocGF0aCwgcHJpbnQsIG4pXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIklubGluZUZyYWdtZW50XCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDYoW1wiLi4uXCIsIG4udHlwZUNvbmRpdGlvbiA/IGNvbmNhdCQ2KFtcIiBvbiBcIiwgcGF0aC5jYWxsKHByaW50LCBcInR5cGVDb25kaXRpb25cIildKSA6IFwiXCIsIHByaW50RGlyZWN0aXZlcyhwYXRoLCBwcmludCwgbiksIFwiIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwic2VsZWN0aW9uU2V0XCIpXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIlVuaW9uVHlwZUV4dGVuc2lvblwiOlxuICAgICAgY2FzZSBcIlVuaW9uVHlwZURlZmluaXRpb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBncm91cCQ1KGNvbmNhdCQ2KFtwYXRoLmNhbGwocHJpbnQsIFwiZGVzY3JpcHRpb25cIiksIG4uZGVzY3JpcHRpb24gPyBoYXJkbGluZSQ1IDogXCJcIiwgZ3JvdXAkNShjb25jYXQkNihbbi5raW5kID09PSBcIlVuaW9uVHlwZUV4dGVuc2lvblwiID8gXCJleHRlbmQgXCIgOiBcIlwiLCBcInVuaW9uIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwibmFtZVwiKSwgcHJpbnREaXJlY3RpdmVzKHBhdGgsIHByaW50LCBuKSwgbi50eXBlcy5sZW5ndGggPiAwID8gY29uY2F0JDYoW1wiID1cIiwgaWZCcmVhayQyKFwiXCIsIFwiIFwiKSwgaW5kZW50JDMoY29uY2F0JDYoW2lmQnJlYWskMihjb25jYXQkNihbbGluZSQyLCBcIiAgXCJdKSksIGpvaW4kMyhjb25jYXQkNihbbGluZSQyLCBcInwgXCJdKSwgcGF0aC5tYXAocHJpbnQsIFwidHlwZXNcIikpXSkpXSkgOiBcIlwiXSkpXSkpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJTY2FsYXJUeXBlRXh0ZW5zaW9uXCI6XG4gICAgICBjYXNlIFwiU2NhbGFyVHlwZURlZmluaXRpb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBjb25jYXQkNihbcGF0aC5jYWxsKHByaW50LCBcImRlc2NyaXB0aW9uXCIpLCBuLmRlc2NyaXB0aW9uID8gaGFyZGxpbmUkNSA6IFwiXCIsIG4ua2luZCA9PT0gXCJTY2FsYXJUeXBlRXh0ZW5zaW9uXCIgPyBcImV4dGVuZCBcIiA6IFwiXCIsIFwic2NhbGFyIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwibmFtZVwiKSwgcHJpbnREaXJlY3RpdmVzKHBhdGgsIHByaW50LCBuKV0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJOb25OdWxsVHlwZVwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ2KFtwYXRoLmNhbGwocHJpbnQsIFwidHlwZVwiKSwgXCIhXCJdKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiTGlzdFR5cGVcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBjb25jYXQkNihbXCJbXCIsIHBhdGguY2FsbChwcmludCwgXCJ0eXBlXCIpLCBcIl1cIl0pO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gZ3JhcGhxbCB0eXBlOiBcIiArIEpTT04uc3RyaW5naWZ5KG4ua2luZCkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50RGlyZWN0aXZlcyhwYXRoLCBwcmludCwgbikge1xuICAgIGlmIChuLmRpcmVjdGl2ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uY2F0JDYoW1wiIFwiLCBncm91cCQ1KGluZGVudCQzKGNvbmNhdCQ2KFtzb2Z0bGluZSQyLCBqb2luJDMoY29uY2F0JDYoW2lmQnJlYWskMihcIlwiLCBcIiBcIiksIHNvZnRsaW5lJDJdKSwgcGF0aC5tYXAocHJpbnQsIFwiZGlyZWN0aXZlc1wiKSldKSkpXSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludFNlcXVlbmNlKHNlcXVlbmNlUGF0aCwgb3B0aW9ucywgcHJpbnQpIHtcbiAgICB2YXIgY291bnQgPSBzZXF1ZW5jZVBhdGguZ2V0VmFsdWUoKS5sZW5ndGg7XG4gICAgcmV0dXJuIHNlcXVlbmNlUGF0aC5tYXAoZnVuY3Rpb24gKHBhdGgsIGkpIHtcbiAgICAgIHZhciBwcmludGVkID0gcHJpbnQocGF0aCk7XG5cbiAgICAgIGlmIChpc05leHRMaW5lRW1wdHkkMyhvcHRpb25zLm9yaWdpbmFsVGV4dCwgcGF0aC5nZXRWYWx1ZSgpLCBvcHRpb25zKSAmJiBpIDwgY291bnQgLSAxKSB7XG4gICAgICAgIHJldHVybiBjb25jYXQkNihbcHJpbnRlZCwgaGFyZGxpbmUkNV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJpbnRlZDtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbkF0dGFjaENvbW1lbnQobm9kZSkge1xuICAgIHJldHVybiBub2RlLmtpbmQgJiYgbm9kZS5raW5kICE9PSBcIkNvbW1lbnRcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50Q29tbWVudCQxKGNvbW1lbnRQYXRoKSB7XG4gICAgdmFyIGNvbW1lbnQgPSBjb21tZW50UGF0aC5nZXRWYWx1ZSgpO1xuXG4gICAgaWYgKGNvbW1lbnQua2luZCA9PT0gXCJDb21tZW50XCIpIHtcbiAgICAgIHJldHVybiBcIiNcIiArIGNvbW1lbnQudmFsdWUudHJpbVJpZ2h0KCk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGEgY29tbWVudDogXCIgKyBKU09OLnN0cmluZ2lmeShjb21tZW50KSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXRlcm1pbmVJbnRlcmZhY2VTZXBhcmF0b3Iob3JpZ2luYWxTb3VyY2UpIHtcbiAgICB2YXIgc3RhcnQgPSBvcmlnaW5hbFNvdXJjZS5pbmRleE9mKFwiaW1wbGVtZW50c1wiKTtcblxuICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgaW1wbGVtZW50IGludGVyZmFjZXM6IFwiICsgb3JpZ2luYWxTb3VyY2UpO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBvcmlnaW5hbFNvdXJjZS5pbmRleE9mKFwie1wiKTtcblxuICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICBlbmQgPSBvcmlnaW5hbFNvdXJjZS5sZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9yaWdpbmFsU291cmNlLnN1YnN0cihzdGFydCwgZW5kKS5pbmNsdWRlcyhcIiZcIikgPyBcIiAmIFwiIDogXCIsIFwiO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW4kMShub2RlLCBuZXdOb2RlXG4gIC8qLCBwYXJlbnQqL1xuICApIHtcbiAgICBkZWxldGUgbmV3Tm9kZS5sb2M7XG4gICAgZGVsZXRlIG5ld05vZGUuY29tbWVudHM7XG4gIH1cblxuICB2YXIgcHJpbnRlckdyYXBocWwgPSB7XG4gICAgcHJpbnQ6IGdlbmVyaWNQcmludCQxLFxuICAgIG1hc3NhZ2VBc3ROb2RlOiBjbGVhbiQxLFxuICAgIGhhc1ByZXR0aWVySWdub3JlOiBoYXNJZ25vcmVDb21tZW50JDIsXG4gICAgaW5zZXJ0UHJhZ21hOiBpbnNlcnRQcmFnbWEkNCxcbiAgICBwcmludENvbW1lbnQ6IHByaW50Q29tbWVudCQxLFxuICAgIGNhbkF0dGFjaENvbW1lbnQ6IGNhbkF0dGFjaENvbW1lbnRcbiAgfTtcblxuICB2YXIgb3B0aW9ucyQzID0ge1xuICAgIGJyYWNrZXRTcGFjaW5nOiBjb21tb25PcHRpb25zLmJyYWNrZXRTcGFjaW5nXG4gIH07XG5cbiAgdmFyIG5hbWUkNSA9IFwiR3JhcGhRTFwiO1xuICB2YXIgdHlwZSQ0ID0gXCJkYXRhXCI7XG4gIHZhciBleHRlbnNpb25zJDQgPSBbXG4gIFx0XCIuZ3JhcGhxbFwiLFxuICBcdFwiLmdxbFwiLFxuICBcdFwiLmdyYXBocWxzXCJcbiAgXTtcbiAgdmFyIHRtU2NvcGUkNCA9IFwic291cmNlLmdyYXBocWxcIjtcbiAgdmFyIGFjZU1vZGUkNCA9IFwidGV4dFwiO1xuICB2YXIgbGFuZ3VhZ2VJZCQ0ID0gMTM5O1xuICB2YXIgR3JhcGhRTCA9IHtcbiAgXHRuYW1lOiBuYW1lJDUsXG4gIFx0dHlwZTogdHlwZSQ0LFxuICBcdGV4dGVuc2lvbnM6IGV4dGVuc2lvbnMkNCxcbiAgXHR0bVNjb3BlOiB0bVNjb3BlJDQsXG4gIFx0YWNlTW9kZTogYWNlTW9kZSQ0LFxuICBcdGxhbmd1YWdlSWQ6IGxhbmd1YWdlSWQkNFxuICB9O1xuXG4gIHZhciBHcmFwaFFMJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIG5hbWU6IG5hbWUkNSxcbiAgICB0eXBlOiB0eXBlJDQsXG4gICAgZXh0ZW5zaW9uczogZXh0ZW5zaW9ucyQ0LFxuICAgIHRtU2NvcGU6IHRtU2NvcGUkNCxcbiAgICBhY2VNb2RlOiBhY2VNb2RlJDQsXG4gICAgbGFuZ3VhZ2VJZDogbGFuZ3VhZ2VJZCQ0LFxuICAgICdkZWZhdWx0JzogR3JhcGhRTFxuICB9KTtcblxuICB2YXIgcmVxdWlyZSQkMCQzID0gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZShHcmFwaFFMJDEpO1xuXG4gIHZhciBsYW5ndWFnZXMkMSA9IFtjcmVhdGVMYW5ndWFnZShyZXF1aXJlJCQwJDMsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZGF0YSwge1xuICAgICAgc2luY2U6IFwiMS41LjBcIixcbiAgICAgIHBhcnNlcnM6IFtcImdyYXBocWxcIl0sXG4gICAgICB2c2NvZGVMYW5ndWFnZUlkczogW1wiZ3JhcGhxbFwiXVxuICAgIH0pO1xuICB9KV07XG4gIHZhciBwcmludGVycyQxID0ge1xuICAgIGdyYXBocWw6IHByaW50ZXJHcmFwaHFsXG4gIH07XG4gIHZhciBsYW5ndWFnZUdyYXBocWwgPSB7XG4gICAgbGFuZ3VhZ2VzOiBsYW5ndWFnZXMkMSxcbiAgICBvcHRpb25zOiBvcHRpb25zJDMsXG4gICAgcHJpbnRlcnM6IHByaW50ZXJzJDFcbiAgfTtcblxuICB2YXIgX3JlcXVpcmUkJDAkYnVpbGRlcnMkMyA9IGRvYy5idWlsZGVycyxcbiAgICAgIGNvbmNhdCQ3ID0gX3JlcXVpcmUkJDAkYnVpbGRlcnMkMy5jb25jYXQsXG4gICAgICBqb2luJDQgPSBfcmVxdWlyZSQkMCRidWlsZGVycyQzLmpvaW4sXG4gICAgICBzb2Z0bGluZSQzID0gX3JlcXVpcmUkJDAkYnVpbGRlcnMkMy5zb2Z0bGluZSxcbiAgICAgIGhhcmRsaW5lJDYgPSBfcmVxdWlyZSQkMCRidWlsZGVycyQzLmhhcmRsaW5lLFxuICAgICAgbGluZSQzID0gX3JlcXVpcmUkJDAkYnVpbGRlcnMkMy5saW5lLFxuICAgICAgZ3JvdXAkNiA9IF9yZXF1aXJlJCQwJGJ1aWxkZXJzJDMuZ3JvdXAsXG4gICAgICBpbmRlbnQkNCA9IF9yZXF1aXJlJCQwJGJ1aWxkZXJzJDMuaW5kZW50LFxuICAgICAgaWZCcmVhayQzID0gX3JlcXVpcmUkJDAkYnVpbGRlcnMkMy5pZkJyZWFrOyAvLyBodHRwOi8vdzNjLmdpdGh1Yi5pby9odG1sL3NpbmdsZS1wYWdlLmh0bWwjdm9pZC1lbGVtZW50c1xuXG4gIHZhciB2b2lkVGFncyA9IFtcImFyZWFcIiwgXCJiYXNlXCIsIFwiYnJcIiwgXCJjb2xcIiwgXCJlbWJlZFwiLCBcImhyXCIsIFwiaW1nXCIsIFwiaW5wdXRcIiwgXCJsaW5rXCIsIFwibWV0YVwiLCBcInBhcmFtXCIsIFwic291cmNlXCIsIFwidHJhY2tcIiwgXCJ3YnJcIl07IC8vIEZvcm1hdHRlciBiYXNlZCBvbiBAZ2xpbW1lcmpzL3N5bnRheCdzIGJ1aWx0LWluIHRlc3QgZm9ybWF0dGVyOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2xpbW1lcmpzL2dsaW1tZXItdm0vYmxvYi9tYXN0ZXIvcGFja2FnZXMvJTQwZ2xpbW1lci9zeW50YXgvbGliL2dlbmVyYXRpb24vcHJpbnQudHNcblxuICBmdW5jdGlvbiBwcmludENoaWxkcmVuKHBhdGgsIG9wdGlvbnMsIHByaW50KSB7XG4gICAgcmV0dXJuIGNvbmNhdCQ3KHBhdGgubWFwKGZ1bmN0aW9uIChjaGlsZFBhdGgsIGNoaWxkSW5kZXgpIHtcbiAgICAgIHZhciBjaGlsZE5vZGUgPSBwYXRoLmdldFZhbHVlKCk7XG4gICAgICB2YXIgaXNGaXJzdE5vZGUgPSBjaGlsZEluZGV4ID09PSAwO1xuICAgICAgdmFyIGlzTGFzdE5vZGUgPSBjaGlsZEluZGV4ID09IHBhdGguZ2V0UGFyZW50Tm9kZSgwKS5jaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgdmFyIGlzTGFzdE5vZGVJbk11bHRpTm9kZUxpc3QgPSBpc0xhc3ROb2RlICYmICFpc0ZpcnN0Tm9kZTtcbiAgICAgIHZhciBpc1doaXRlc3BhY2UgPSBpc1doaXRlc3BhY2VOb2RlKGNoaWxkTm9kZSk7XG5cbiAgICAgIGlmIChpc1doaXRlc3BhY2UgJiYgaXNMYXN0Tm9kZUluTXVsdGlOb2RlTGlzdCkge1xuICAgICAgICByZXR1cm4gcHJpbnQoY2hpbGRQYXRoLCBvcHRpb25zLCBwcmludCk7XG4gICAgICB9IGVsc2UgaWYgKGlzRmlyc3ROb2RlKSB7XG4gICAgICAgIHJldHVybiBjb25jYXQkNyhbc29mdGxpbmUkMywgcHJpbnQoY2hpbGRQYXRoLCBvcHRpb25zLCBwcmludCldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByaW50KGNoaWxkUGF0aCwgb3B0aW9ucywgcHJpbnQpO1xuICAgIH0sIFwiY2hpbGRyZW5cIikpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnQocGF0aCwgb3B0aW9ucywgcHJpbnQpIHtcbiAgICB2YXIgbiA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYqL1xuXG4gICAgaWYgKCFuKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKG4udHlwZSkge1xuICAgICAgY2FzZSBcIkJsb2NrXCI6XG4gICAgICBjYXNlIFwiUHJvZ3JhbVwiOlxuICAgICAgY2FzZSBcIlRlbXBsYXRlXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gZ3JvdXAkNihjb25jYXQkNyhwYXRoLm1hcChwcmludCwgXCJib2R5XCIpLmZpbHRlcihmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRleHQgIT09IFwiXCI7XG4gICAgICAgICAgfSkpKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiRWxlbWVudE5vZGVcIjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB0YWdGaXJzdENoYXIgPSBuLnRhZ1swXTtcbiAgICAgICAgICB2YXIgaXNMb2NhbCA9IG4udGFnLmluZGV4T2YoXCIuXCIpICE9PSAtMTtcbiAgICAgICAgICB2YXIgaXNHbGltbWVyQ29tcG9uZW50ID0gdGFnRmlyc3RDaGFyLnRvVXBwZXJDYXNlKCkgPT09IHRhZ0ZpcnN0Q2hhciB8fCBpc0xvY2FsO1xuICAgICAgICAgIHZhciBoYXNDaGlsZHJlbiA9IG4uY2hpbGRyZW4ubGVuZ3RoID4gMDtcbiAgICAgICAgICB2YXIgaGFzTm9uV2hpdGVzcGFjZUNoaWxkcmVuID0gbi5jaGlsZHJlbi5zb21lKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICByZXR1cm4gIWlzV2hpdGVzcGFjZU5vZGUobik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGlzVm9pZCA9IGlzR2xpbW1lckNvbXBvbmVudCAmJiAoIWhhc0NoaWxkcmVuIHx8ICFoYXNOb25XaGl0ZXNwYWNlQ2hpbGRyZW4pIHx8IHZvaWRUYWdzLmluZGV4T2Yobi50YWcpICE9PSAtMTtcbiAgICAgICAgICB2YXIgY2xvc2VUYWdGb3JOb0JyZWFrID0gaXNWb2lkID8gY29uY2F0JDcoW1wiIC8+XCIsIHNvZnRsaW5lJDNdKSA6IFwiPlwiO1xuICAgICAgICAgIHZhciBjbG9zZVRhZ0ZvckJyZWFrID0gaXNWb2lkID8gXCIvPlwiIDogXCI+XCI7XG5cbiAgICAgICAgICB2YXIgX2dldFBhcmFtcyA9IGZ1bmN0aW9uIF9nZXRQYXJhbXMocGF0aCwgcHJpbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRlbnQkNChjb25jYXQkNyhbbi5hdHRyaWJ1dGVzLmxlbmd0aCA/IGxpbmUkMyA6IFwiXCIsIGpvaW4kNChsaW5lJDMsIHBhdGgubWFwKHByaW50LCBcImF0dHJpYnV0ZXNcIikpLCBuLm1vZGlmaWVycy5sZW5ndGggPyBsaW5lJDMgOiBcIlwiLCBqb2luJDQobGluZSQzLCBwYXRoLm1hcChwcmludCwgXCJtb2RpZmllcnNcIikpLCBuLmNvbW1lbnRzLmxlbmd0aCA/IGxpbmUkMyA6IFwiXCIsIGpvaW4kNChsaW5lJDMsIHBhdGgubWFwKHByaW50LCBcImNvbW1lbnRzXCIpKV0pKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIG5leHROb2RlID0gZ2V0TmV4dE5vZGUocGF0aCk7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ3KFtncm91cCQ2KGNvbmNhdCQ3KFtcIjxcIiwgbi50YWcsIF9nZXRQYXJhbXMocGF0aCwgcHJpbnQpLCBuLmJsb2NrUGFyYW1zLmxlbmd0aCA/IFwiIGFzIHxcIi5jb25jYXQobi5ibG9ja1BhcmFtcy5qb2luKFwiIFwiKSwgXCJ8XCIpIDogXCJcIiwgaWZCcmVhayQzKHNvZnRsaW5lJDMsIFwiXCIpLCBpZkJyZWFrJDMoY2xvc2VUYWdGb3JCcmVhaywgY2xvc2VUYWdGb3JOb0JyZWFrKV0pKSwgIWlzVm9pZCA/IGdyb3VwJDYoY29uY2F0JDcoW2hhc05vbldoaXRlc3BhY2VDaGlsZHJlbiA/IGluZGVudCQ0KHByaW50Q2hpbGRyZW4ocGF0aCwgb3B0aW9ucywgcHJpbnQpKSA6IFwiXCIsIGlmQnJlYWskMyhoYXNDaGlsZHJlbiA/IGhhcmRsaW5lJDYgOiBcIlwiLCBcIlwiKSwgY29uY2F0JDcoW1wiPC9cIiwgbi50YWcsIFwiPlwiXSldKSkgOiBcIlwiLCBuZXh0Tm9kZSAmJiBuZXh0Tm9kZS50eXBlID09PSBcIkVsZW1lbnROb2RlXCIgPyBoYXJkbGluZSQ2IDogXCJcIl0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJCbG9ja1N0YXRlbWVudFwiOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHBwID0gcGF0aC5nZXRQYXJlbnROb2RlKDEpO1xuICAgICAgICAgIHZhciBpc0Vsc2VJZiA9IHBwICYmIHBwLmludmVyc2UgJiYgcHAuaW52ZXJzZS5ib2R5Lmxlbmd0aCA9PT0gMSAmJiBwcC5pbnZlcnNlLmJvZHlbMF0gPT09IG4gJiYgcHAuaW52ZXJzZS5ib2R5WzBdLnBhdGgucGFydHNbMF0gPT09IFwiaWZcIjtcbiAgICAgICAgICB2YXIgaGFzRWxzZUlmID0gbi5pbnZlcnNlICYmIG4uaW52ZXJzZS5ib2R5Lmxlbmd0aCA9PT0gMSAmJiBuLmludmVyc2UuYm9keVswXS50eXBlID09PSBcIkJsb2NrU3RhdGVtZW50XCIgJiYgbi5pbnZlcnNlLmJvZHlbMF0ucGF0aC5wYXJ0c1swXSA9PT0gXCJpZlwiO1xuICAgICAgICAgIHZhciBpbmRlbnRFbHNlID0gaGFzRWxzZUlmID8gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgIH0gOiBpbmRlbnQkNDtcblxuICAgICAgICAgIGlmIChuLmludmVyc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQkNyhbaXNFbHNlSWYgPyBjb25jYXQkNyhbXCJ7e2Vsc2UgXCIsIHByaW50UGF0aFBhcmFtcyhwYXRoLCBwcmludCksIFwifX1cIl0pIDogcHJpbnRPcGVuQmxvY2socGF0aCwgcHJpbnQpLCBpbmRlbnQkNChjb25jYXQkNyhbaGFyZGxpbmUkNiwgcGF0aC5jYWxsKHByaW50LCBcInByb2dyYW1cIildKSksIG4uaW52ZXJzZSAmJiAhaGFzRWxzZUlmID8gY29uY2F0JDcoW2hhcmRsaW5lJDYsIFwie3tlbHNlfX1cIl0pIDogXCJcIiwgbi5pbnZlcnNlID8gaW5kZW50RWxzZShjb25jYXQkNyhbaGFyZGxpbmUkNiwgcGF0aC5jYWxsKHByaW50LCBcImludmVyc2VcIildKSkgOiBcIlwiLCBpc0Vsc2VJZiA/IFwiXCIgOiBjb25jYXQkNyhbaGFyZGxpbmUkNiwgcHJpbnRDbG9zZUJsb2NrKHBhdGgsIHByaW50KV0pXSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0Vsc2VJZikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCQ3KFtjb25jYXQkNyhbXCJ7e2Vsc2UgXCIsIHByaW50UGF0aFBhcmFtcyhwYXRoLCBwcmludCksIFwifX1cIl0pLCBpbmRlbnQkNChjb25jYXQkNyhbaGFyZGxpbmUkNiwgcGF0aC5jYWxsKHByaW50LCBcInByb2dyYW1cIildKSldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2hhc05vbldoaXRlc3BhY2VDaGlsZHJlbiA9IG4ucHJvZ3JhbS5ib2R5LnNvbWUoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHJldHVybiAhaXNXaGl0ZXNwYWNlTm9kZShuKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiBjb25jYXQkNyhbcHJpbnRPcGVuQmxvY2socGF0aCwgcHJpbnQpLCBncm91cCQ2KGNvbmNhdCQ3KFtpbmRlbnQkNChjb25jYXQkNyhbc29mdGxpbmUkMywgcGF0aC5jYWxsKHByaW50LCBcInByb2dyYW1cIildKSksIF9oYXNOb25XaGl0ZXNwYWNlQ2hpbGRyZW4gPyBoYXJkbGluZSQ2IDogc29mdGxpbmUkMywgcHJpbnRDbG9zZUJsb2NrKHBhdGgsIHByaW50KV0pKV0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJFbGVtZW50TW9kaWZpZXJTdGF0ZW1lbnRcIjpcbiAgICAgIGNhc2UgXCJNdXN0YWNoZVN0YXRlbWVudFwiOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9wcCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgxKTtcblxuICAgICAgICAgIHZhciBpc0NvbmNhdCA9IF9wcCAmJiBfcHAudHlwZSA9PT0gXCJDb25jYXRTdGF0ZW1lbnRcIjtcbiAgICAgICAgICByZXR1cm4gZ3JvdXAkNihjb25jYXQkNyhbbi5lc2NhcGVkID09PSBmYWxzZSA/IFwie3t7XCIgOiBcInt7XCIsIHByaW50UGF0aFBhcmFtcyhwYXRoLCBwcmludCwge1xuICAgICAgICAgICAgZ3JvdXA6IGZhbHNlXG4gICAgICAgICAgfSksIGlzQ29uY2F0ID8gXCJcIiA6IHNvZnRsaW5lJDMsIG4uZXNjYXBlZCA9PT0gZmFsc2UgPyBcIn19fVwiIDogXCJ9fVwiXSkpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJTdWJFeHByZXNzaW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcGFyYW1zID0gZ2V0UGFyYW1zKHBhdGgsIHByaW50KTtcbiAgICAgICAgICB2YXIgcHJpbnRlZFBhcmFtcyA9IHBhcmFtcy5sZW5ndGggPiAwID8gaW5kZW50JDQoY29uY2F0JDcoW2xpbmUkMywgZ3JvdXAkNihqb2luJDQobGluZSQzLCBwYXJhbXMpKV0pKSA6IFwiXCI7XG4gICAgICAgICAgcmV0dXJuIGdyb3VwJDYoY29uY2F0JDcoW1wiKFwiLCBwcmludFBhdGgocGF0aCwgcHJpbnQpLCBwcmludGVkUGFyYW1zLCBzb2Z0bGluZSQzLCBcIilcIl0pKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiQXR0ck5vZGVcIjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpc1RleHQgPSBuLnZhbHVlLnR5cGUgPT09IFwiVGV4dE5vZGVcIjtcblxuICAgICAgICAgIGlmIChpc1RleHQgJiYgbi52YWx1ZS5sb2Muc3RhcnQuY29sdW1uID09PSBuLnZhbHVlLmxvYy5lbmQuY29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0JDcoW24ubmFtZV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB2YWx1ZSA9IHBhdGguY2FsbChwcmludCwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgICB2YXIgcXVvdGVkVmFsdWUgPSBpc1RleHQgPyBwcmludFN0cmluZ0xpdGVyYWwodmFsdWUucGFydHMuam9pbigpLCBvcHRpb25zKSA6IHZhbHVlO1xuICAgICAgICAgIHJldHVybiBjb25jYXQkNyhbbi5uYW1lLCBcIj1cIiwgcXVvdGVkVmFsdWVdKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiQ29uY2F0U3RhdGVtZW50XCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDcoWydcIicsIGdyb3VwJDYoaW5kZW50JDQoam9pbiQ0KHNvZnRsaW5lJDMsIHBhdGgubWFwKGZ1bmN0aW9uIChwYXJ0UGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHByaW50KHBhcnRQYXRoKTtcbiAgICAgICAgICB9LCBcInBhcnRzXCIpLmZpbHRlcihmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgcmV0dXJuIGEgIT09IFwiXCI7XG4gICAgICAgICAgfSkpKSksICdcIiddKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiSGFzaFwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ3KFtqb2luJDQobGluZSQzLCBwYXRoLm1hcChwcmludCwgXCJwYWlyc1wiKSldKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiSGFzaFBhaXJcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBjb25jYXQkNyhbbi5rZXksIFwiPVwiLCBwYXRoLmNhbGwocHJpbnQsIFwidmFsdWVcIildKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiVGV4dE5vZGVcIjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBtYXhMaW5lQnJlYWtzVG9QcmVzZXJ2ZSA9IDI7XG4gICAgICAgICAgdmFyIGlzRmlyc3RFbGVtZW50ID0gIWdldFByZXZpb3VzTm9kZShwYXRoKTtcbiAgICAgICAgICB2YXIgaXNMYXN0RWxlbWVudCA9ICFnZXROZXh0Tm9kZShwYXRoKTtcbiAgICAgICAgICB2YXIgaXNXaGl0ZXNwYWNlT25seSA9ICEvXFxTLy50ZXN0KG4uY2hhcnMpO1xuICAgICAgICAgIHZhciBsaW5lQnJlYWtzQ291bnQgPSBjb3VudE5ld0xpbmVzKG4uY2hhcnMpO1xuICAgICAgICAgIHZhciBoYXNCbG9ja1BhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgwKS50eXBlID09PSBcIkJsb2NrXCI7XG4gICAgICAgICAgdmFyIGhhc0VsZW1lbnRQYXJlbnQgPSBwYXRoLmdldFBhcmVudE5vZGUoMCkudHlwZSA9PT0gXCJFbGVtZW50Tm9kZVwiO1xuICAgICAgICAgIHZhciBoYXNUZW1wbGF0ZVBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgwKS50eXBlID09PSBcIlRlbXBsYXRlXCI7XG4gICAgICAgICAgdmFyIGxlYWRpbmdMaW5lQnJlYWtzQ291bnQgPSBjb3VudExlYWRpbmdOZXdMaW5lcyhuLmNoYXJzKTtcbiAgICAgICAgICB2YXIgdHJhaWxpbmdMaW5lQnJlYWtzQ291bnQgPSBjb3VudFRyYWlsaW5nTmV3TGluZXMobi5jaGFycyk7XG5cbiAgICAgICAgICBpZiAoKGlzRmlyc3RFbGVtZW50IHx8IGlzTGFzdEVsZW1lbnQpICYmIGlzV2hpdGVzcGFjZU9ubHkgJiYgKGhhc0Jsb2NrUGFyZW50IHx8IGhhc0VsZW1lbnRQYXJlbnQgfHwgaGFzVGVtcGxhdGVQYXJlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlT25seSAmJiBsaW5lQnJlYWtzQ291bnQpIHtcbiAgICAgICAgICAgIGxlYWRpbmdMaW5lQnJlYWtzQ291bnQgPSBNYXRoLm1pbihsaW5lQnJlYWtzQ291bnQsIG1heExpbmVCcmVha3NUb1ByZXNlcnZlKTtcbiAgICAgICAgICAgIHRyYWlsaW5nTGluZUJyZWFrc0NvdW50ID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzTmV4dE5vZGVPZlR5cGUocGF0aCwgXCJFbGVtZW50Tm9kZVwiKSB8fCBpc05leHROb2RlT2ZUeXBlKHBhdGgsIFwiQmxvY2tTdGF0ZW1lbnRcIikpIHtcbiAgICAgICAgICAgICAgdHJhaWxpbmdMaW5lQnJlYWtzQ291bnQgPSBNYXRoLm1heCh0cmFpbGluZ0xpbmVCcmVha3NDb3VudCwgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc1ByZXZpb3VzTm9kZU9mU29tZVR5cGUocGF0aCwgW1wiRWxlbWVudE5vZGVcIl0pIHx8IGlzUHJldmlvdXNOb2RlT2ZTb21lVHlwZShwYXRoLCBbXCJCbG9ja1N0YXRlbWVudFwiXSkpIHtcbiAgICAgICAgICAgICAgbGVhZGluZ0xpbmVCcmVha3NDb3VudCA9IE1hdGgubWF4KGxlYWRpbmdMaW5lQnJlYWtzQ291bnQsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBsZWFkaW5nU3BhY2UgPSBcIlwiO1xuICAgICAgICAgIHZhciB0cmFpbGluZ1NwYWNlID0gXCJcIjsgLy8gcHJlc2VydmUgYSBzcGFjZSBpbnNpZGUgb2YgYW4gYXR0cmlidXRlIG5vZGUgd2hlcmUgd2hpdGVzcGFjZSBwcmVzZW50LFxuICAgICAgICAgIC8vIHdoZW4gbmV4dCB0byBtdXN0YWNoZSBzdGF0ZW1lbnQuXG5cbiAgICAgICAgICB2YXIgaW5BdHRyTm9kZSA9IHBhdGguc3RhY2suaW5kZXhPZihcImF0dHJpYnV0ZXNcIikgPj0gMDtcblxuICAgICAgICAgIGlmIChpbkF0dHJOb2RlKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IHBhdGguZ2V0UGFyZW50Tm9kZSgwKTtcblxuICAgICAgICAgICAgdmFyIF9pc0NvbmNhdCA9IHBhcmVudE5vZGUudHlwZSA9PT0gXCJDb25jYXRTdGF0ZW1lbnRcIjtcblxuICAgICAgICAgICAgaWYgKF9pc0NvbmNhdCkge1xuICAgICAgICAgICAgICB2YXIgcGFydHMgPSBwYXJlbnROb2RlLnBhcnRzO1xuICAgICAgICAgICAgICB2YXIgcGFydEluZGV4ID0gcGFydHMuaW5kZXhPZihuKTtcblxuICAgICAgICAgICAgICBpZiAocGFydEluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0VHlwZSA9IHBhcnRzW3BhcnRJbmRleCAtIDFdLnR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIGlzTXVzdGFjaGUgPSBwYXJ0VHlwZSA9PT0gXCJNdXN0YWNoZVN0YXRlbWVudFwiO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzTXVzdGFjaGUpIHtcbiAgICAgICAgICAgICAgICAgIGxlYWRpbmdTcGFjZSA9IFwiIFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChwYXJ0SW5kZXggPCBwYXJ0cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9wYXJ0VHlwZSA9IHBhcnRzW3BhcnRJbmRleCArIDFdLnR5cGU7XG5cbiAgICAgICAgICAgICAgICB2YXIgX2lzTXVzdGFjaGUgPSBfcGFydFR5cGUgPT09IFwiTXVzdGFjaGVTdGF0ZW1lbnRcIjtcblxuICAgICAgICAgICAgICAgIGlmIChfaXNNdXN0YWNoZSkge1xuICAgICAgICAgICAgICAgICAgdHJhaWxpbmdTcGFjZSA9IFwiIFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodHJhaWxpbmdMaW5lQnJlYWtzQ291bnQgPT09IDAgJiYgaXNOZXh0Tm9kZU9mVHlwZShwYXRoLCBcIk11c3RhY2hlU3RhdGVtZW50XCIpKSB7XG4gICAgICAgICAgICAgIHRyYWlsaW5nU3BhY2UgPSBcIiBcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxlYWRpbmdMaW5lQnJlYWtzQ291bnQgPT09IDAgJiYgaXNQcmV2aW91c05vZGVPZlNvbWVUeXBlKHBhdGgsIFtcIk11c3RhY2hlU3RhdGVtZW50XCJdKSkge1xuICAgICAgICAgICAgICBsZWFkaW5nU3BhY2UgPSBcIiBcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzRmlyc3RFbGVtZW50KSB7XG4gICAgICAgICAgICAgIGxlYWRpbmdMaW5lQnJlYWtzQ291bnQgPSAwO1xuICAgICAgICAgICAgICBsZWFkaW5nU3BhY2UgPSBcIlwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNMYXN0RWxlbWVudCkge1xuICAgICAgICAgICAgICB0cmFpbGluZ0xpbmVCcmVha3NDb3VudCA9IDA7XG4gICAgICAgICAgICAgIHRyYWlsaW5nU3BhY2UgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb25jYXQkNyhbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGdlbmVyYXRlSGFyZGxpbmVzKGxlYWRpbmdMaW5lQnJlYWtzQ291bnQsIG1heExpbmVCcmVha3NUb1ByZXNlcnZlKSksIFtuLmNoYXJzLnJlcGxhY2UoL15bXFxzIF0rL2csIGxlYWRpbmdTcGFjZSkucmVwbGFjZSgvW1xccyBdKyQvLCB0cmFpbGluZ1NwYWNlKV0sIF90b0NvbnN1bWFibGVBcnJheShnZW5lcmF0ZUhhcmRsaW5lcyh0cmFpbGluZ0xpbmVCcmVha3NDb3VudCwgbWF4TGluZUJyZWFrc1RvUHJlc2VydmUpKSkuZmlsdGVyKEJvb2xlYW4pKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiTXVzdGFjaGVDb21tZW50U3RhdGVtZW50XCI6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZGFzaGVzID0gbi52YWx1ZS5pbmRleE9mKFwifX1cIikgPiAtMSA/IFwiLS1cIiA6IFwiXCI7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ3KFtcInt7IVwiLCBkYXNoZXMsIG4udmFsdWUsIGRhc2hlcywgXCJ9fVwiXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIlBhdGhFeHByZXNzaW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gbi5vcmlnaW5hbDtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiQm9vbGVhbkxpdGVyYWxcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcobi52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIkNvbW1lbnRTdGF0ZW1lbnRcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBjb25jYXQkNyhbXCI8IS0tXCIsIG4udmFsdWUsIFwiLS0+XCJdKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiU3RyaW5nTGl0ZXJhbFwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHByaW50U3RyaW5nTGl0ZXJhbChuLnZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiTnVtYmVyTGl0ZXJhbFwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyhuLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiVW5kZWZpbmVkTGl0ZXJhbFwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCI7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIk51bGxMaXRlcmFsXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgIH1cblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBnbGltbWVyIHR5cGU6IFwiICsgSlNPTi5zdHJpbmdpZnkobi50eXBlKSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQcmludHMgYSBzdHJpbmcgbGl0ZXJhbCB3aXRoIHRoZSBjb3JyZWN0IHN1cnJvdW5kaW5nIHF1b3RlcyBiYXNlZCBvblxuICAgKiBgb3B0aW9ucy5zaW5nbGVRdW90ZWAgYW5kIHRoZSBudW1iZXIgb2YgZXNjYXBlZCBxdW90ZXMgY29udGFpbmVkIGluXG4gICAqIHRoZSBzdHJpbmcgbGl0ZXJhbC4gVGhpcyBmdW5jdGlvbiBpcyB0aGUgZ2xpbW1lciBlcXVpdmFsZW50IG9mIGBwcmludFN0cmluZ2BcbiAgICogaW4gYGNvbW1vbi91dGlsYCwgYnV0IGhhcyBkaWZmZXJlbmNlcyBiZWNhdXNlIG9mIHRoZSB3YXkgZXNjYXBlZCBjaGFyYWN0ZXJzXG4gICAqIGFyZSB0cmVhdGVkIGluIGhicyBzdHJpbmcgbGl0ZXJhbHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdMaXRlcmFsIC0gdGhlIHN0cmluZyBsaXRlcmFsIHZhbHVlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gdGhlIHByZXR0aWVyIG9wdGlvbnMgb2JqZWN0XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gcHJpbnRTdHJpbmdMaXRlcmFsKHN0cmluZ0xpdGVyYWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgZG91YmxlID0ge1xuICAgICAgcXVvdGU6ICdcIicsXG4gICAgICByZWdleDogL1wiL2dcbiAgICB9O1xuICAgIHZhciBzaW5nbGUgPSB7XG4gICAgICBxdW90ZTogXCInXCIsXG4gICAgICByZWdleDogLycvZ1xuICAgIH07XG4gICAgdmFyIHByZWZlcnJlZCA9IG9wdGlvbnMuc2luZ2xlUXVvdGUgPyBzaW5nbGUgOiBkb3VibGU7XG4gICAgdmFyIGFsdGVybmF0ZSA9IHByZWZlcnJlZCA9PT0gc2luZ2xlID8gZG91YmxlIDogc2luZ2xlO1xuICAgIHZhciBzaG91bGRVc2VBbHRlcm5hdGVRdW90ZSA9IGZhbHNlOyAvLyBJZiBgc3RyaW5nTGl0ZXJhbGAgY29udGFpbnMgYXQgbGVhc3Qgb25lIG9mIHRoZSBxdW90ZSBwcmVmZXJyZWQgZm9yXG4gICAgLy8gZW5jbG9zaW5nIHRoZSBzdHJpbmcsIHdlIG1pZ2h0IHdhbnQgdG8gZW5jbG9zZSB3aXRoIHRoZSBhbHRlcm5hdGUgcXVvdGVcbiAgICAvLyBpbnN0ZWFkLCB0byBtaW5pbWl6ZSB0aGUgbnVtYmVyIG9mIGVzY2FwZWQgcXVvdGVzLlxuXG4gICAgaWYgKHN0cmluZ0xpdGVyYWwuaW5jbHVkZXMocHJlZmVycmVkLnF1b3RlKSB8fCBzdHJpbmdMaXRlcmFsLmluY2x1ZGVzKGFsdGVybmF0ZS5xdW90ZSkpIHtcbiAgICAgIHZhciBudW1QcmVmZXJyZWRRdW90ZXMgPSAoc3RyaW5nTGl0ZXJhbC5tYXRjaChwcmVmZXJyZWQucmVnZXgpIHx8IFtdKS5sZW5ndGg7XG4gICAgICB2YXIgbnVtQWx0ZXJuYXRlUXVvdGVzID0gKHN0cmluZ0xpdGVyYWwubWF0Y2goYWx0ZXJuYXRlLnJlZ2V4KSB8fCBbXSkubGVuZ3RoO1xuICAgICAgc2hvdWxkVXNlQWx0ZXJuYXRlUXVvdGUgPSBudW1QcmVmZXJyZWRRdW90ZXMgPiBudW1BbHRlcm5hdGVRdW90ZXM7XG4gICAgfVxuXG4gICAgdmFyIGVuY2xvc2luZ1F1b3RlID0gc2hvdWxkVXNlQWx0ZXJuYXRlUXVvdGUgPyBhbHRlcm5hdGUgOiBwcmVmZXJyZWQ7XG4gICAgdmFyIGVzY2FwZWRTdHJpbmdMaXRlcmFsID0gc3RyaW5nTGl0ZXJhbC5yZXBsYWNlKGVuY2xvc2luZ1F1b3RlLnJlZ2V4LCBcIlxcXFxcIi5jb25jYXQoZW5jbG9zaW5nUXVvdGUucXVvdGUpKTtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQoZW5jbG9zaW5nUXVvdGUucXVvdGUpLmNvbmNhdChlc2NhcGVkU3RyaW5nTGl0ZXJhbCkuY29uY2F0KGVuY2xvc2luZ1F1b3RlLnF1b3RlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50UGF0aChwYXRoLCBwcmludCkge1xuICAgIHJldHVybiBwYXRoLmNhbGwocHJpbnQsIFwicGF0aFwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBhcmFtcyhwYXRoLCBwcmludCkge1xuICAgIHZhciBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuXG4gICAgaWYgKG5vZGUucGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIHBhcnRzID0gcGFydHMuY29uY2F0KHBhdGgubWFwKHByaW50LCBcInBhcmFtc1wiKSk7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuaGFzaCAmJiBub2RlLmhhc2gucGFpcnMubGVuZ3RoID4gMCkge1xuICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwiaGFzaFwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnRzO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRQYXRoUGFyYW1zKHBhdGgsIHByaW50LCBvcHRpb25zKSB7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgZ3JvdXA6IHRydWVcbiAgICB9LCBvcHRpb25zIHx8IHt9KTtcbiAgICBwYXJ0cy5wdXNoKHByaW50UGF0aChwYXRoLCBwcmludCkpO1xuICAgIHBhcnRzID0gcGFydHMuY29uY2F0KGdldFBhcmFtcyhwYXRoLCBwcmludCkpO1xuXG4gICAgaWYgKCFvcHRpb25zLmdyb3VwKSB7XG4gICAgICByZXR1cm4gaW5kZW50JDQoam9pbiQ0KGxpbmUkMywgcGFydHMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZW50JDQoZ3JvdXAkNihqb2luJDQobGluZSQzLCBwYXJ0cykpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50QmxvY2tQYXJhbXMocGF0aCkge1xuICAgIHZhciBibG9jayA9IHBhdGguZ2V0VmFsdWUoKTtcblxuICAgIGlmICghYmxvY2sucHJvZ3JhbSB8fCAhYmxvY2sucHJvZ3JhbS5ibG9ja1BhcmFtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIHJldHVybiBjb25jYXQkNyhbXCIgYXMgfFwiLCBibG9jay5wcm9ncmFtLmJsb2NrUGFyYW1zLmpvaW4oXCIgXCIpLCBcInxcIl0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRPcGVuQmxvY2socGF0aCwgcHJpbnQpIHtcbiAgICByZXR1cm4gZ3JvdXAkNihjb25jYXQkNyhbXCJ7eyNcIiwgcHJpbnRQYXRoUGFyYW1zKHBhdGgsIHByaW50KSwgcHJpbnRCbG9ja1BhcmFtcyhwYXRoKSwgc29mdGxpbmUkMywgXCJ9fVwiXSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRDbG9zZUJsb2NrKHBhdGgsIHByaW50KSB7XG4gICAgcmV0dXJuIGNvbmNhdCQ3KFtcInt7L1wiLCBwYXRoLmNhbGwocHJpbnQsIFwicGF0aFwiKSwgXCJ9fVwiXSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc1doaXRlc3BhY2VOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIlRleHROb2RlXCIgJiYgIS9cXFMvLnRlc3Qobm9kZS5jaGFycyk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQcmV2aW91c05vZGUocGF0aCkge1xuICAgIHZhciBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIHZhciBwYXJlbnROb2RlID0gcGF0aC5nZXRQYXJlbnROb2RlKDApO1xuICAgIHZhciBjaGlsZHJlbiA9IHBhcmVudE5vZGUuY2hpbGRyZW4gfHwgcGFyZW50Tm9kZS5ib2R5O1xuXG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICB2YXIgbm9kZUluZGV4ID0gY2hpbGRyZW4uaW5kZXhPZihub2RlKTtcblxuICAgICAgaWYgKG5vZGVJbmRleCA+IDApIHtcbiAgICAgICAgdmFyIHByZXZpb3VzTm9kZSA9IGNoaWxkcmVuW25vZGVJbmRleCAtIDFdO1xuICAgICAgICByZXR1cm4gcHJldmlvdXNOb2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5leHROb2RlKHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IHBhdGguZ2V0UGFyZW50Tm9kZSgwKTtcbiAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnROb2RlLmNoaWxkcmVuIHx8IHBhcmVudE5vZGUuYm9keTtcblxuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgdmFyIG5vZGVJbmRleCA9IGNoaWxkcmVuLmluZGV4T2Yobm9kZSk7XG5cbiAgICAgIGlmIChub2RlSW5kZXggPCBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5leHROb2RlID0gY2hpbGRyZW5bbm9kZUluZGV4ICsgMV07XG4gICAgICAgIHJldHVybiBuZXh0Tm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1ByZXZpb3VzTm9kZU9mU29tZVR5cGUocGF0aCwgdHlwZXMpIHtcbiAgICB2YXIgcHJldmlvdXNOb2RlID0gZ2V0UHJldmlvdXNOb2RlKHBhdGgpO1xuXG4gICAgaWYgKHByZXZpb3VzTm9kZSkge1xuICAgICAgcmV0dXJuIHR5cGVzLnNvbWUoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHByZXZpb3VzTm9kZS50eXBlID09PSB0eXBlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOZXh0Tm9kZU9mVHlwZShwYXRoLCB0eXBlKSB7XG4gICAgdmFyIG5leHROb2RlID0gZ2V0TmV4dE5vZGUocGF0aCk7XG4gICAgcmV0dXJuIG5leHROb2RlICYmIG5leHROb2RlLnR5cGUgPT09IHR5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbiQyKGFzdCwgbmV3T2JqKSB7XG4gICAgZGVsZXRlIG5ld09iai5sb2M7XG4gICAgZGVsZXRlIG5ld09iai5zZWxmQ2xvc2luZzsgLy8gKEdsaW1tZXIvSFRNTCkgaWdub3JlIFRleHROb2RlIHdoaXRlc3BhY2VcblxuICAgIGlmIChhc3QudHlwZSA9PT0gXCJUZXh0Tm9kZVwiKSB7XG4gICAgICBpZiAoYXN0LmNoYXJzLnJlcGxhY2UoL1xccysvLCBcIlwiKSA9PT0gXCJcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgbmV3T2JqLmNoYXJzID0gYXN0LmNoYXJzLnJlcGxhY2UoL15cXHMrLywgXCJcIikucmVwbGFjZSgvXFxzKyQvLCBcIlwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb3VudE5ld0xpbmVzKHN0cmluZykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgc3RyaW5nID0gdHlwZW9mIHN0cmluZyA9PT0gXCJzdHJpbmdcIiA/IHN0cmluZyA6IFwiXCI7XG4gICAgcmV0dXJuIHN0cmluZy5zcGxpdChcIlxcblwiKS5sZW5ndGggLSAxO1xuICB9XG5cbiAgZnVuY3Rpb24gY291bnRMZWFkaW5nTmV3TGluZXMoc3RyaW5nKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBzdHJpbmcgPSB0eXBlb2Ygc3RyaW5nID09PSBcInN0cmluZ1wiID8gc3RyaW5nIDogXCJcIjtcbiAgICB2YXIgbmV3TGluZXMgPSAoc3RyaW5nLm1hdGNoKC9eKFteXFxTXFxyXFxuXSpbXFxyXFxuXSkrL2cpIHx8IFtdKVswXSB8fCBcIlwiO1xuICAgIHJldHVybiBjb3VudE5ld0xpbmVzKG5ld0xpbmVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvdW50VHJhaWxpbmdOZXdMaW5lcyhzdHJpbmcpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHN0cmluZyA9IHR5cGVvZiBzdHJpbmcgPT09IFwic3RyaW5nXCIgPyBzdHJpbmcgOiBcIlwiO1xuICAgIHZhciBuZXdMaW5lcyA9IChzdHJpbmcubWF0Y2goLyhbXFxyXFxuXVteXFxTXFxyXFxuXSopKyQvZykgfHwgW10pWzBdIHx8IFwiXCI7XG4gICAgcmV0dXJuIGNvdW50TmV3TGluZXMobmV3TGluZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVIYXJkbGluZXMoKSB7XG4gICAgdmFyIG51bWJlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICB2YXIgbWF4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgIHJldHVybiBuZXcgQXJyYXkoTWF0aC5taW4obnVtYmVyLCBtYXgpKS5maWxsKGhhcmRsaW5lJDYpO1xuICB9XG5cbiAgdmFyIHByaW50ZXJHbGltbWVyID0ge1xuICAgIHByaW50OiBwcmludCxcbiAgICBtYXNzYWdlQXN0Tm9kZTogY2xlYW4kMlxuICB9O1xuXG4gIHZhciBuYW1lJDYgPSBcIkhhbmRsZWJhcnNcIjtcbiAgdmFyIHR5cGUkNSA9IFwibWFya3VwXCI7XG4gIHZhciBncm91cCQ3ID0gXCJIVE1MXCI7XG4gIHZhciBhbGlhc2VzID0gW1xuICBcdFwiaGJzXCIsXG4gIFx0XCJodG1sYmFyc1wiXG4gIF07XG4gIHZhciBleHRlbnNpb25zJDUgPSBbXG4gIFx0XCIuaGFuZGxlYmFyc1wiLFxuICBcdFwiLmhic1wiXG4gIF07XG4gIHZhciB0bVNjb3BlJDUgPSBcInRleHQuaHRtbC5oYW5kbGViYXJzXCI7XG4gIHZhciBhY2VNb2RlJDUgPSBcImhhbmRsZWJhcnNcIjtcbiAgdmFyIGxhbmd1YWdlSWQkNSA9IDE1NTtcbiAgdmFyIEhhbmRsZWJhcnMgPSB7XG4gIFx0bmFtZTogbmFtZSQ2LFxuICBcdHR5cGU6IHR5cGUkNSxcbiAgXHRncm91cDogZ3JvdXAkNyxcbiAgXHRhbGlhc2VzOiBhbGlhc2VzLFxuICBcdGV4dGVuc2lvbnM6IGV4dGVuc2lvbnMkNSxcbiAgXHR0bVNjb3BlOiB0bVNjb3BlJDUsXG4gIFx0YWNlTW9kZTogYWNlTW9kZSQ1LFxuICBcdGxhbmd1YWdlSWQ6IGxhbmd1YWdlSWQkNVxuICB9O1xuXG4gIHZhciBIYW5kbGViYXJzJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIG5hbWU6IG5hbWUkNixcbiAgICB0eXBlOiB0eXBlJDUsXG4gICAgZ3JvdXA6IGdyb3VwJDcsXG4gICAgYWxpYXNlczogYWxpYXNlcyxcbiAgICBleHRlbnNpb25zOiBleHRlbnNpb25zJDUsXG4gICAgdG1TY29wZTogdG1TY29wZSQ1LFxuICAgIGFjZU1vZGU6IGFjZU1vZGUkNSxcbiAgICBsYW5ndWFnZUlkOiBsYW5ndWFnZUlkJDUsXG4gICAgJ2RlZmF1bHQnOiBIYW5kbGViYXJzXG4gIH0pO1xuXG4gIHZhciByZXF1aXJlJCQwJDQgPSBnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlKEhhbmRsZWJhcnMkMSk7XG5cbiAgdmFyIGxhbmd1YWdlcyQyID0gW2NyZWF0ZUxhbmd1YWdlKHJlcXVpcmUkJDAkNCwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkYXRhLCB7XG4gICAgICBzaW5jZTogbnVsbCxcbiAgICAgIC8vIHVucmVsZWFzZWRcbiAgICAgIHBhcnNlcnM6IFtcImdsaW1tZXJcIl0sXG4gICAgICB2c2NvZGVMYW5ndWFnZUlkczogW1wiaGFuZGxlYmFyc1wiXVxuICAgIH0pO1xuICB9KV07XG4gIHZhciBwcmludGVycyQyID0ge1xuICAgIGdsaW1tZXI6IHByaW50ZXJHbGltbWVyXG4gIH07XG4gIHZhciBsYW5ndWFnZUhhbmRsZWJhcnMgPSB7XG4gICAgbGFuZ3VhZ2VzOiBsYW5ndWFnZXMkMixcbiAgICBwcmludGVyczogcHJpbnRlcnMkMlxuICB9O1xuXG4gIHZhciBjbGVhbiQzID0gZnVuY3Rpb24gY2xlYW4oYXN0LCBuZXdOb2RlKSB7XG4gICAgZGVsZXRlIG5ld05vZGUuc291cmNlU3BhbjtcbiAgICBkZWxldGUgbmV3Tm9kZS5zdGFydFNvdXJjZVNwYW47XG4gICAgZGVsZXRlIG5ld05vZGUuZW5kU291cmNlU3BhbjtcbiAgICBkZWxldGUgbmV3Tm9kZS5uYW1lU3BhbjtcbiAgICBkZWxldGUgbmV3Tm9kZS52YWx1ZVNwYW47XG5cbiAgICBpZiAoYXN0LnR5cGUgPT09IFwidGV4dFwiIHx8IGFzdC50eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBtYXkgYmUgZm9ybWF0dGVkIGJ5IG11bHRpcGFyc2VyXG5cblxuICAgIGlmIChhc3QudHlwZSA9PT0gXCJ5YW1sXCIgfHwgYXN0LnR5cGUgPT09IFwidG9tbFwiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoYXN0LnR5cGUgPT09IFwiYXR0cmlidXRlXCIpIHtcbiAgICAgIGRlbGV0ZSBuZXdOb2RlLnZhbHVlO1xuICAgIH1cblxuICAgIGlmIChhc3QudHlwZSA9PT0gXCJkb2NUeXBlXCIpIHtcbiAgICAgIGRlbGV0ZSBuZXdOb2RlLnZhbHVlO1xuICAgIH1cbiAgfTtcblxuICB2YXIganNvbiA9IHtcbiAgICBcIkNTU19ESVNQTEFZX1RBR1NcIjoge1xuICAgICAgXCJhcmVhXCI6IFwibm9uZVwiLFxuICAgICAgXCJiYXNlXCI6IFwibm9uZVwiLFxuICAgICAgXCJiYXNlZm9udFwiOiBcIm5vbmVcIixcbiAgICAgIFwiZGF0YWxpc3RcIjogXCJub25lXCIsXG4gICAgICBcImhlYWRcIjogXCJub25lXCIsXG4gICAgICBcImxpbmtcIjogXCJub25lXCIsXG4gICAgICBcIm1ldGFcIjogXCJub25lXCIsXG4gICAgICBcIm5vZW1iZWRcIjogXCJub25lXCIsXG4gICAgICBcIm5vZnJhbWVzXCI6IFwibm9uZVwiLFxuICAgICAgXCJwYXJhbVwiOiBcIm5vbmVcIixcbiAgICAgIFwicnBcIjogXCJub25lXCIsXG4gICAgICBcInNjcmlwdFwiOiBcImJsb2NrXCIsXG4gICAgICBcInNvdXJjZVwiOiBcImJsb2NrXCIsXG4gICAgICBcInN0eWxlXCI6IFwibm9uZVwiLFxuICAgICAgXCJ0ZW1wbGF0ZVwiOiBcImlubGluZVwiLFxuICAgICAgXCJ0cmFja1wiOiBcImJsb2NrXCIsXG4gICAgICBcInRpdGxlXCI6IFwibm9uZVwiLFxuICAgICAgXCJodG1sXCI6IFwiYmxvY2tcIixcbiAgICAgIFwiYm9keVwiOiBcImJsb2NrXCIsXG4gICAgICBcImFkZHJlc3NcIjogXCJibG9ja1wiLFxuICAgICAgXCJibG9ja3F1b3RlXCI6IFwiYmxvY2tcIixcbiAgICAgIFwiY2VudGVyXCI6IFwiYmxvY2tcIixcbiAgICAgIFwiZGl2XCI6IFwiYmxvY2tcIixcbiAgICAgIFwiZmlndXJlXCI6IFwiYmxvY2tcIixcbiAgICAgIFwiZmlnY2FwdGlvblwiOiBcImJsb2NrXCIsXG4gICAgICBcImZvb3RlclwiOiBcImJsb2NrXCIsXG4gICAgICBcImZvcm1cIjogXCJibG9ja1wiLFxuICAgICAgXCJoZWFkZXJcIjogXCJibG9ja1wiLFxuICAgICAgXCJoclwiOiBcImJsb2NrXCIsXG4gICAgICBcImxlZ2VuZFwiOiBcImJsb2NrXCIsXG4gICAgICBcImxpc3RpbmdcIjogXCJibG9ja1wiLFxuICAgICAgXCJtYWluXCI6IFwiYmxvY2tcIixcbiAgICAgIFwicFwiOiBcImJsb2NrXCIsXG4gICAgICBcInBsYWludGV4dFwiOiBcImJsb2NrXCIsXG4gICAgICBcInByZVwiOiBcImJsb2NrXCIsXG4gICAgICBcInhtcFwiOiBcImJsb2NrXCIsXG4gICAgICBcInNsb3RcIjogXCJjb250ZW50c1wiLFxuICAgICAgXCJydWJ5XCI6IFwicnVieVwiLFxuICAgICAgXCJydFwiOiBcInJ1YnktdGV4dFwiLFxuICAgICAgXCJhcnRpY2xlXCI6IFwiYmxvY2tcIixcbiAgICAgIFwiYXNpZGVcIjogXCJibG9ja1wiLFxuICAgICAgXCJoMVwiOiBcImJsb2NrXCIsXG4gICAgICBcImgyXCI6IFwiYmxvY2tcIixcbiAgICAgIFwiaDNcIjogXCJibG9ja1wiLFxuICAgICAgXCJoNFwiOiBcImJsb2NrXCIsXG4gICAgICBcImg1XCI6IFwiYmxvY2tcIixcbiAgICAgIFwiaDZcIjogXCJibG9ja1wiLFxuICAgICAgXCJoZ3JvdXBcIjogXCJibG9ja1wiLFxuICAgICAgXCJuYXZcIjogXCJibG9ja1wiLFxuICAgICAgXCJzZWN0aW9uXCI6IFwiYmxvY2tcIixcbiAgICAgIFwiZGlyXCI6IFwiYmxvY2tcIixcbiAgICAgIFwiZGRcIjogXCJibG9ja1wiLFxuICAgICAgXCJkbFwiOiBcImJsb2NrXCIsXG4gICAgICBcImR0XCI6IFwiYmxvY2tcIixcbiAgICAgIFwib2xcIjogXCJibG9ja1wiLFxuICAgICAgXCJ1bFwiOiBcImJsb2NrXCIsXG4gICAgICBcImxpXCI6IFwibGlzdC1pdGVtXCIsXG4gICAgICBcInRhYmxlXCI6IFwidGFibGVcIixcbiAgICAgIFwiY2FwdGlvblwiOiBcInRhYmxlLWNhcHRpb25cIixcbiAgICAgIFwiY29sZ3JvdXBcIjogXCJ0YWJsZS1jb2x1bW4tZ3JvdXBcIixcbiAgICAgIFwiY29sXCI6IFwidGFibGUtY29sdW1uXCIsXG4gICAgICBcInRoZWFkXCI6IFwidGFibGUtaGVhZGVyLWdyb3VwXCIsXG4gICAgICBcInRib2R5XCI6IFwidGFibGUtcm93LWdyb3VwXCIsXG4gICAgICBcInRmb290XCI6IFwidGFibGUtZm9vdGVyLWdyb3VwXCIsXG4gICAgICBcInRyXCI6IFwidGFibGUtcm93XCIsXG4gICAgICBcInRkXCI6IFwidGFibGUtY2VsbFwiLFxuICAgICAgXCJ0aFwiOiBcInRhYmxlLWNlbGxcIixcbiAgICAgIFwiZmllbGRzZXRcIjogXCJibG9ja1wiLFxuICAgICAgXCJidXR0b25cIjogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgIFwidmlkZW9cIjogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgIFwiYXVkaW9cIjogXCJpbmxpbmUtYmxvY2tcIlxuICAgIH0sXG4gICAgXCJDU1NfRElTUExBWV9ERUZBVUxUXCI6IFwiaW5saW5lXCIsXG4gICAgXCJDU1NfV0hJVEVfU1BBQ0VfVEFHU1wiOiB7XG4gICAgICBcImxpc3RpbmdcIjogXCJwcmVcIixcbiAgICAgIFwicGxhaW50ZXh0XCI6IFwicHJlXCIsXG4gICAgICBcInByZVwiOiBcInByZVwiLFxuICAgICAgXCJ4bXBcIjogXCJwcmVcIixcbiAgICAgIFwibm9iclwiOiBcIm5vd3JhcFwiLFxuICAgICAgXCJ0YWJsZVwiOiBcImluaXRpYWxcIixcbiAgICAgIFwidGV4dGFyZWFcIjogXCJwcmUtd3JhcFwiXG4gICAgfSxcbiAgICBcIkNTU19XSElURV9TUEFDRV9ERUZBVUxUXCI6IFwibm9ybWFsXCJcbiAgfTtcblxuICB2YXIgYSA9IFtcbiAgXHRcImFjY2Vzc2tleVwiLFxuICBcdFwiY2hhcnNldFwiLFxuICBcdFwiY29vcmRzXCIsXG4gIFx0XCJkb3dubG9hZFwiLFxuICBcdFwiaHJlZlwiLFxuICBcdFwiaHJlZmxhbmdcIixcbiAgXHRcIm5hbWVcIixcbiAgXHRcInBpbmdcIixcbiAgXHRcInJlZmVycmVycG9saWN5XCIsXG4gIFx0XCJyZWxcIixcbiAgXHRcInJldlwiLFxuICBcdFwic2hhcGVcIixcbiAgXHRcInRhYmluZGV4XCIsXG4gIFx0XCJ0YXJnZXRcIixcbiAgXHRcInR5cGVcIlxuICBdO1xuICB2YXIgYWJiciA9IFtcbiAgXHRcInRpdGxlXCJcbiAgXTtcbiAgdmFyIGFwcGxldCA9IFtcbiAgXHRcImFsaWduXCIsXG4gIFx0XCJhbHRcIixcbiAgXHRcImFyY2hpdmVcIixcbiAgXHRcImNvZGVcIixcbiAgXHRcImNvZGViYXNlXCIsXG4gIFx0XCJoZWlnaHRcIixcbiAgXHRcImhzcGFjZVwiLFxuICBcdFwibmFtZVwiLFxuICBcdFwib2JqZWN0XCIsXG4gIFx0XCJ2c3BhY2VcIixcbiAgXHRcIndpZHRoXCJcbiAgXTtcbiAgdmFyIGFyZWEgPSBbXG4gIFx0XCJhY2Nlc3NrZXlcIixcbiAgXHRcImFsdFwiLFxuICBcdFwiY29vcmRzXCIsXG4gIFx0XCJkb3dubG9hZFwiLFxuICBcdFwiaHJlZlwiLFxuICBcdFwiaHJlZmxhbmdcIixcbiAgXHRcIm5vaHJlZlwiLFxuICBcdFwicGluZ1wiLFxuICBcdFwicmVmZXJyZXJwb2xpY3lcIixcbiAgXHRcInJlbFwiLFxuICBcdFwic2hhcGVcIixcbiAgXHRcInRhYmluZGV4XCIsXG4gIFx0XCJ0YXJnZXRcIixcbiAgXHRcInR5cGVcIlxuICBdO1xuICB2YXIgYXVkaW8gPSBbXG4gIFx0XCJhdXRvcGxheVwiLFxuICBcdFwiY29udHJvbHNcIixcbiAgXHRcImNyb3Nzb3JpZ2luXCIsXG4gIFx0XCJsb29wXCIsXG4gIFx0XCJtdXRlZFwiLFxuICBcdFwicHJlbG9hZFwiLFxuICBcdFwic3JjXCJcbiAgXTtcbiAgdmFyIGJhc2UgPSBbXG4gIFx0XCJocmVmXCIsXG4gIFx0XCJ0YXJnZXRcIlxuICBdO1xuICB2YXIgYmFzZWZvbnQgPSBbXG4gIFx0XCJjb2xvclwiLFxuICBcdFwiZmFjZVwiLFxuICBcdFwic2l6ZVwiXG4gIF07XG4gIHZhciBiZG8gPSBbXG4gIFx0XCJkaXJcIlxuICBdO1xuICB2YXIgYmxvY2txdW90ZSA9IFtcbiAgXHRcImNpdGVcIlxuICBdO1xuICB2YXIgYm9keSA9IFtcbiAgXHRcImFsaW5rXCIsXG4gIFx0XCJiYWNrZ3JvdW5kXCIsXG4gIFx0XCJiZ2NvbG9yXCIsXG4gIFx0XCJsaW5rXCIsXG4gIFx0XCJ0ZXh0XCIsXG4gIFx0XCJ2bGlua1wiXG4gIF07XG4gIHZhciBiciA9IFtcbiAgXHRcImNsZWFyXCJcbiAgXTtcbiAgdmFyIGJ1dHRvbiA9IFtcbiAgXHRcImFjY2Vzc2tleVwiLFxuICBcdFwiYXV0b2ZvY3VzXCIsXG4gIFx0XCJkaXNhYmxlZFwiLFxuICBcdFwiZm9ybVwiLFxuICBcdFwiZm9ybWFjdGlvblwiLFxuICBcdFwiZm9ybWVuY3R5cGVcIixcbiAgXHRcImZvcm1tZXRob2RcIixcbiAgXHRcImZvcm1ub3ZhbGlkYXRlXCIsXG4gIFx0XCJmb3JtdGFyZ2V0XCIsXG4gIFx0XCJuYW1lXCIsXG4gIFx0XCJ0YWJpbmRleFwiLFxuICBcdFwidHlwZVwiLFxuICBcdFwidmFsdWVcIlxuICBdO1xuICB2YXIgY2FudmFzID0gW1xuICBcdFwiaGVpZ2h0XCIsXG4gIFx0XCJ3aWR0aFwiXG4gIF07XG4gIHZhciBjYXB0aW9uID0gW1xuICBcdFwiYWxpZ25cIlxuICBdO1xuICB2YXIgY29sID0gW1xuICBcdFwiYWxpZ25cIixcbiAgXHRcImNoYXJcIixcbiAgXHRcImNoYXJvZmZcIixcbiAgXHRcInNwYW5cIixcbiAgXHRcInZhbGlnblwiLFxuICBcdFwid2lkdGhcIlxuICBdO1xuICB2YXIgY29sZ3JvdXAgPSBbXG4gIFx0XCJhbGlnblwiLFxuICBcdFwiY2hhclwiLFxuICBcdFwiY2hhcm9mZlwiLFxuICBcdFwic3BhblwiLFxuICBcdFwidmFsaWduXCIsXG4gIFx0XCJ3aWR0aFwiXG4gIF07XG4gIHZhciBkYXRhID0gW1xuICBcdFwidmFsdWVcIlxuICBdO1xuICB2YXIgZGVsID0gW1xuICBcdFwiY2l0ZVwiLFxuICBcdFwiZGF0ZXRpbWVcIlxuICBdO1xuICB2YXIgZGV0YWlscyA9IFtcbiAgXHRcIm9wZW5cIlxuICBdO1xuICB2YXIgZGZuID0gW1xuICBcdFwidGl0bGVcIlxuICBdO1xuICB2YXIgZGlhbG9nID0gW1xuICBcdFwib3BlblwiXG4gIF07XG4gIHZhciBkaXIgPSBbXG4gIFx0XCJjb21wYWN0XCJcbiAgXTtcbiAgdmFyIGRpdiA9IFtcbiAgXHRcImFsaWduXCJcbiAgXTtcbiAgdmFyIGRsID0gW1xuICBcdFwiY29tcGFjdFwiXG4gIF07XG4gIHZhciBlbWJlZCQxID0gW1xuICBcdFwiaGVpZ2h0XCIsXG4gIFx0XCJzcmNcIixcbiAgXHRcInR5cGVcIixcbiAgXHRcIndpZHRoXCJcbiAgXTtcbiAgdmFyIGZpZWxkc2V0ID0gW1xuICBcdFwiZGlzYWJsZWRcIixcbiAgXHRcImZvcm1cIixcbiAgXHRcIm5hbWVcIlxuICBdO1xuICB2YXIgZm9udCA9IFtcbiAgXHRcImNvbG9yXCIsXG4gIFx0XCJmYWNlXCIsXG4gIFx0XCJzaXplXCJcbiAgXTtcbiAgdmFyIGZvcm0gPSBbXG4gIFx0XCJhY2NlcHRcIixcbiAgXHRcImFjY2VwdC1jaGFyc2V0XCIsXG4gIFx0XCJhY3Rpb25cIixcbiAgXHRcImF1dG9jb21wbGV0ZVwiLFxuICBcdFwiZW5jdHlwZVwiLFxuICBcdFwibWV0aG9kXCIsXG4gIFx0XCJuYW1lXCIsXG4gIFx0XCJub3ZhbGlkYXRlXCIsXG4gIFx0XCJ0YXJnZXRcIlxuICBdO1xuICB2YXIgZnJhbWUgPSBbXG4gIFx0XCJmcmFtZWJvcmRlclwiLFxuICBcdFwibG9uZ2Rlc2NcIixcbiAgXHRcIm1hcmdpbmhlaWdodFwiLFxuICBcdFwibWFyZ2lud2lkdGhcIixcbiAgXHRcIm5hbWVcIixcbiAgXHRcIm5vcmVzaXplXCIsXG4gIFx0XCJzY3JvbGxpbmdcIixcbiAgXHRcInNyY1wiXG4gIF07XG4gIHZhciBmcmFtZXNldCA9IFtcbiAgXHRcImNvbHNcIixcbiAgXHRcInJvd3NcIlxuICBdO1xuICB2YXIgaDEgPSBbXG4gIFx0XCJhbGlnblwiXG4gIF07XG4gIHZhciBoMiA9IFtcbiAgXHRcImFsaWduXCJcbiAgXTtcbiAgdmFyIGgzID0gW1xuICBcdFwiYWxpZ25cIlxuICBdO1xuICB2YXIgaDQgPSBbXG4gIFx0XCJhbGlnblwiXG4gIF07XG4gIHZhciBoNSA9IFtcbiAgXHRcImFsaWduXCJcbiAgXTtcbiAgdmFyIGg2ID0gW1xuICBcdFwiYWxpZ25cIlxuICBdO1xuICB2YXIgaGVhZCA9IFtcbiAgXHRcInByb2ZpbGVcIlxuICBdO1xuICB2YXIgaHIgPSBbXG4gIFx0XCJhbGlnblwiLFxuICBcdFwibm9zaGFkZVwiLFxuICBcdFwic2l6ZVwiLFxuICBcdFwid2lkdGhcIlxuICBdO1xuICB2YXIgaHRtbCA9IFtcbiAgXHRcIm1hbmlmZXN0XCIsXG4gIFx0XCJ2ZXJzaW9uXCJcbiAgXTtcbiAgdmFyIGlmcmFtZSA9IFtcbiAgXHRcImFsaWduXCIsXG4gIFx0XCJhbGxvd1wiLFxuICBcdFwiYWxsb3dmdWxsc2NyZWVuXCIsXG4gIFx0XCJhbGxvd3BheW1lbnRyZXF1ZXN0XCIsXG4gIFx0XCJhbGxvd3VzZXJtZWRpYVwiLFxuICBcdFwiZnJhbWVib3JkZXJcIixcbiAgXHRcImhlaWdodFwiLFxuICBcdFwibG9uZ2Rlc2NcIixcbiAgXHRcIm1hcmdpbmhlaWdodFwiLFxuICBcdFwibWFyZ2lud2lkdGhcIixcbiAgXHRcIm5hbWVcIixcbiAgXHRcInJlZmVycmVycG9saWN5XCIsXG4gIFx0XCJzYW5kYm94XCIsXG4gIFx0XCJzY3JvbGxpbmdcIixcbiAgXHRcInNyY1wiLFxuICBcdFwic3JjZG9jXCIsXG4gIFx0XCJ3aWR0aFwiXG4gIF07XG4gIHZhciBpbWcgPSBbXG4gIFx0XCJhbGlnblwiLFxuICBcdFwiYWx0XCIsXG4gIFx0XCJib3JkZXJcIixcbiAgXHRcImNyb3Nzb3JpZ2luXCIsXG4gIFx0XCJkZWNvZGluZ1wiLFxuICBcdFwiaGVpZ2h0XCIsXG4gIFx0XCJoc3BhY2VcIixcbiAgXHRcImlzbWFwXCIsXG4gIFx0XCJsb25nZGVzY1wiLFxuICBcdFwibmFtZVwiLFxuICBcdFwicmVmZXJyZXJwb2xpY3lcIixcbiAgXHRcInNpemVzXCIsXG4gIFx0XCJzcmNcIixcbiAgXHRcInNyY3NldFwiLFxuICBcdFwidXNlbWFwXCIsXG4gIFx0XCJ2c3BhY2VcIixcbiAgXHRcIndpZHRoXCJcbiAgXTtcbiAgdmFyIGlucHV0ID0gW1xuICBcdFwiYWNjZXB0XCIsXG4gIFx0XCJhY2Nlc3NrZXlcIixcbiAgXHRcImFsaWduXCIsXG4gIFx0XCJhbHRcIixcbiAgXHRcImF1dG9jb21wbGV0ZVwiLFxuICBcdFwiYXV0b2ZvY3VzXCIsXG4gIFx0XCJjaGVja2VkXCIsXG4gIFx0XCJkaXJuYW1lXCIsXG4gIFx0XCJkaXNhYmxlZFwiLFxuICBcdFwiZm9ybVwiLFxuICBcdFwiZm9ybWFjdGlvblwiLFxuICBcdFwiZm9ybWVuY3R5cGVcIixcbiAgXHRcImZvcm1tZXRob2RcIixcbiAgXHRcImZvcm1ub3ZhbGlkYXRlXCIsXG4gIFx0XCJmb3JtdGFyZ2V0XCIsXG4gIFx0XCJoZWlnaHRcIixcbiAgXHRcImlzbWFwXCIsXG4gIFx0XCJsaXN0XCIsXG4gIFx0XCJtYXhcIixcbiAgXHRcIm1heGxlbmd0aFwiLFxuICBcdFwibWluXCIsXG4gIFx0XCJtaW5sZW5ndGhcIixcbiAgXHRcIm11bHRpcGxlXCIsXG4gIFx0XCJuYW1lXCIsXG4gIFx0XCJwYXR0ZXJuXCIsXG4gIFx0XCJwbGFjZWhvbGRlclwiLFxuICBcdFwicmVhZG9ubHlcIixcbiAgXHRcInJlcXVpcmVkXCIsXG4gIFx0XCJzaXplXCIsXG4gIFx0XCJzcmNcIixcbiAgXHRcInN0ZXBcIixcbiAgXHRcInRhYmluZGV4XCIsXG4gIFx0XCJ0aXRsZVwiLFxuICBcdFwidHlwZVwiLFxuICBcdFwidXNlbWFwXCIsXG4gIFx0XCJ2YWx1ZVwiLFxuICBcdFwid2lkdGhcIlxuICBdO1xuICB2YXIgaW5zID0gW1xuICBcdFwiY2l0ZVwiLFxuICBcdFwiZGF0ZXRpbWVcIlxuICBdO1xuICB2YXIgaXNpbmRleCA9IFtcbiAgXHRcInByb21wdFwiXG4gIF07XG4gIHZhciBsYWJlbCA9IFtcbiAgXHRcImFjY2Vzc2tleVwiLFxuICBcdFwiZm9yXCIsXG4gIFx0XCJmb3JtXCJcbiAgXTtcbiAgdmFyIGxlZ2VuZCA9IFtcbiAgXHRcImFjY2Vzc2tleVwiLFxuICBcdFwiYWxpZ25cIlxuICBdO1xuICB2YXIgbGkgPSBbXG4gIFx0XCJ0eXBlXCIsXG4gIFx0XCJ2YWx1ZVwiXG4gIF07XG4gIHZhciBsaW5rJDEgPSBbXG4gIFx0XCJhc1wiLFxuICBcdFwiY2hhcnNldFwiLFxuICBcdFwiY29sb3JcIixcbiAgXHRcImNyb3Nzb3JpZ2luXCIsXG4gIFx0XCJocmVmXCIsXG4gIFx0XCJocmVmbGFuZ1wiLFxuICBcdFwiaW1hZ2VzaXplc1wiLFxuICBcdFwiaW1hZ2VzcmNzZXRcIixcbiAgXHRcImludGVncml0eVwiLFxuICBcdFwibWVkaWFcIixcbiAgXHRcIm5vbmNlXCIsXG4gIFx0XCJyZWZlcnJlcnBvbGljeVwiLFxuICBcdFwicmVsXCIsXG4gIFx0XCJyZXZcIixcbiAgXHRcInNpemVzXCIsXG4gIFx0XCJ0YXJnZXRcIixcbiAgXHRcInRpdGxlXCIsXG4gIFx0XCJ0eXBlXCJcbiAgXTtcbiAgdmFyIG1hcCA9IFtcbiAgXHRcIm5hbWVcIlxuICBdO1xuICB2YXIgbWVudSA9IFtcbiAgXHRcImNvbXBhY3RcIlxuICBdO1xuICB2YXIgbWV0YSA9IFtcbiAgXHRcImNoYXJzZXRcIixcbiAgXHRcImNvbnRlbnRcIixcbiAgXHRcImh0dHAtZXF1aXZcIixcbiAgXHRcIm5hbWVcIixcbiAgXHRcInNjaGVtZVwiXG4gIF07XG4gIHZhciBtZXRlciA9IFtcbiAgXHRcImhpZ2hcIixcbiAgXHRcImxvd1wiLFxuICBcdFwibWF4XCIsXG4gIFx0XCJtaW5cIixcbiAgXHRcIm9wdGltdW1cIixcbiAgXHRcInZhbHVlXCJcbiAgXTtcbiAgdmFyIG9iamVjdCA9IFtcbiAgXHRcImFsaWduXCIsXG4gIFx0XCJhcmNoaXZlXCIsXG4gIFx0XCJib3JkZXJcIixcbiAgXHRcImNsYXNzaWRcIixcbiAgXHRcImNvZGViYXNlXCIsXG4gIFx0XCJjb2RldHlwZVwiLFxuICBcdFwiZGF0YVwiLFxuICBcdFwiZGVjbGFyZVwiLFxuICBcdFwiZm9ybVwiLFxuICBcdFwiaGVpZ2h0XCIsXG4gIFx0XCJoc3BhY2VcIixcbiAgXHRcIm5hbWVcIixcbiAgXHRcInN0YW5kYnlcIixcbiAgXHRcInRhYmluZGV4XCIsXG4gIFx0XCJ0eXBlXCIsXG4gIFx0XCJ0eXBlbXVzdG1hdGNoXCIsXG4gIFx0XCJ1c2VtYXBcIixcbiAgXHRcInZzcGFjZVwiLFxuICBcdFwid2lkdGhcIlxuICBdO1xuICB2YXIgb2wgPSBbXG4gIFx0XCJjb21wYWN0XCIsXG4gIFx0XCJyZXZlcnNlZFwiLFxuICBcdFwic3RhcnRcIixcbiAgXHRcInR5cGVcIlxuICBdO1xuICB2YXIgb3B0Z3JvdXAgPSBbXG4gIFx0XCJkaXNhYmxlZFwiLFxuICBcdFwibGFiZWxcIlxuICBdO1xuICB2YXIgb3B0aW9uID0gW1xuICBcdFwiZGlzYWJsZWRcIixcbiAgXHRcImxhYmVsXCIsXG4gIFx0XCJzZWxlY3RlZFwiLFxuICBcdFwidmFsdWVcIlxuICBdO1xuICB2YXIgb3V0cHV0ID0gW1xuICBcdFwiZm9yXCIsXG4gIFx0XCJmb3JtXCIsXG4gIFx0XCJuYW1lXCJcbiAgXTtcbiAgdmFyIHAgPSBbXG4gIFx0XCJhbGlnblwiXG4gIF07XG4gIHZhciBwYXJhbSA9IFtcbiAgXHRcIm5hbWVcIixcbiAgXHRcInR5cGVcIixcbiAgXHRcInZhbHVlXCIsXG4gIFx0XCJ2YWx1ZXR5cGVcIlxuICBdO1xuICB2YXIgcHJlID0gW1xuICBcdFwid2lkdGhcIlxuICBdO1xuICB2YXIgcHJvZ3Jlc3MgPSBbXG4gIFx0XCJtYXhcIixcbiAgXHRcInZhbHVlXCJcbiAgXTtcbiAgdmFyIHEgPSBbXG4gIFx0XCJjaXRlXCJcbiAgXTtcbiAgdmFyIHNjcmlwdCA9IFtcbiAgXHRcImFzeW5jXCIsXG4gIFx0XCJjaGFyc2V0XCIsXG4gIFx0XCJjcm9zc29yaWdpblwiLFxuICBcdFwiZGVmZXJcIixcbiAgXHRcImludGVncml0eVwiLFxuICBcdFwibGFuZ3VhZ2VcIixcbiAgXHRcIm5vbW9kdWxlXCIsXG4gIFx0XCJub25jZVwiLFxuICBcdFwicmVmZXJyZXJwb2xpY3lcIixcbiAgXHRcInNyY1wiLFxuICBcdFwidHlwZVwiXG4gIF07XG4gIHZhciBzZWxlY3QgPSBbXG4gIFx0XCJhdXRvY29tcGxldGVcIixcbiAgXHRcImF1dG9mb2N1c1wiLFxuICBcdFwiZGlzYWJsZWRcIixcbiAgXHRcImZvcm1cIixcbiAgXHRcIm11bHRpcGxlXCIsXG4gIFx0XCJuYW1lXCIsXG4gIFx0XCJyZXF1aXJlZFwiLFxuICBcdFwic2l6ZVwiLFxuICBcdFwidGFiaW5kZXhcIlxuICBdO1xuICB2YXIgc2xvdCA9IFtcbiAgXHRcIm5hbWVcIlxuICBdO1xuICB2YXIgc291cmNlID0gW1xuICBcdFwibWVkaWFcIixcbiAgXHRcInNpemVzXCIsXG4gIFx0XCJzcmNcIixcbiAgXHRcInNyY3NldFwiLFxuICBcdFwidHlwZVwiXG4gIF07XG4gIHZhciBzdHlsZSA9IFtcbiAgXHRcIm1lZGlhXCIsXG4gIFx0XCJub25jZVwiLFxuICBcdFwidGl0bGVcIixcbiAgXHRcInR5cGVcIlxuICBdO1xuICB2YXIgdGFibGUgPSBbXG4gIFx0XCJhbGlnblwiLFxuICBcdFwiYmdjb2xvclwiLFxuICBcdFwiYm9yZGVyXCIsXG4gIFx0XCJjZWxscGFkZGluZ1wiLFxuICBcdFwiY2VsbHNwYWNpbmdcIixcbiAgXHRcImZyYW1lXCIsXG4gIFx0XCJydWxlc1wiLFxuICBcdFwic3VtbWFyeVwiLFxuICBcdFwid2lkdGhcIlxuICBdO1xuICB2YXIgdGJvZHkgPSBbXG4gIFx0XCJhbGlnblwiLFxuICBcdFwiY2hhclwiLFxuICBcdFwiY2hhcm9mZlwiLFxuICBcdFwidmFsaWduXCJcbiAgXTtcbiAgdmFyIHRkID0gW1xuICBcdFwiYWJiclwiLFxuICBcdFwiYWxpZ25cIixcbiAgXHRcImF4aXNcIixcbiAgXHRcImJnY29sb3JcIixcbiAgXHRcImNoYXJcIixcbiAgXHRcImNoYXJvZmZcIixcbiAgXHRcImNvbHNwYW5cIixcbiAgXHRcImhlYWRlcnNcIixcbiAgXHRcImhlaWdodFwiLFxuICBcdFwibm93cmFwXCIsXG4gIFx0XCJyb3dzcGFuXCIsXG4gIFx0XCJzY29wZVwiLFxuICBcdFwidmFsaWduXCIsXG4gIFx0XCJ3aWR0aFwiXG4gIF07XG4gIHZhciB0ZXh0YXJlYSA9IFtcbiAgXHRcImFjY2Vzc2tleVwiLFxuICBcdFwiYXV0b2NvbXBsZXRlXCIsXG4gIFx0XCJhdXRvZm9jdXNcIixcbiAgXHRcImNvbHNcIixcbiAgXHRcImRpcm5hbWVcIixcbiAgXHRcImRpc2FibGVkXCIsXG4gIFx0XCJmb3JtXCIsXG4gIFx0XCJtYXhsZW5ndGhcIixcbiAgXHRcIm1pbmxlbmd0aFwiLFxuICBcdFwibmFtZVwiLFxuICBcdFwicGxhY2Vob2xkZXJcIixcbiAgXHRcInJlYWRvbmx5XCIsXG4gIFx0XCJyZXF1aXJlZFwiLFxuICBcdFwicm93c1wiLFxuICBcdFwidGFiaW5kZXhcIixcbiAgXHRcIndyYXBcIlxuICBdO1xuICB2YXIgdGZvb3QgPSBbXG4gIFx0XCJhbGlnblwiLFxuICBcdFwiY2hhclwiLFxuICBcdFwiY2hhcm9mZlwiLFxuICBcdFwidmFsaWduXCJcbiAgXTtcbiAgdmFyIHRoID0gW1xuICBcdFwiYWJiclwiLFxuICBcdFwiYWxpZ25cIixcbiAgXHRcImF4aXNcIixcbiAgXHRcImJnY29sb3JcIixcbiAgXHRcImNoYXJcIixcbiAgXHRcImNoYXJvZmZcIixcbiAgXHRcImNvbHNwYW5cIixcbiAgXHRcImhlYWRlcnNcIixcbiAgXHRcImhlaWdodFwiLFxuICBcdFwibm93cmFwXCIsXG4gIFx0XCJyb3dzcGFuXCIsXG4gIFx0XCJzY29wZVwiLFxuICBcdFwidmFsaWduXCIsXG4gIFx0XCJ3aWR0aFwiXG4gIF07XG4gIHZhciB0aGVhZCA9IFtcbiAgXHRcImFsaWduXCIsXG4gIFx0XCJjaGFyXCIsXG4gIFx0XCJjaGFyb2ZmXCIsXG4gIFx0XCJ2YWxpZ25cIlxuICBdO1xuICB2YXIgdGltZSA9IFtcbiAgXHRcImRhdGV0aW1lXCJcbiAgXTtcbiAgdmFyIHRyID0gW1xuICBcdFwiYWxpZ25cIixcbiAgXHRcImJnY29sb3JcIixcbiAgXHRcImNoYXJcIixcbiAgXHRcImNoYXJvZmZcIixcbiAgXHRcInZhbGlnblwiXG4gIF07XG4gIHZhciB0cmFjayA9IFtcbiAgXHRcImRlZmF1bHRcIixcbiAgXHRcImtpbmRcIixcbiAgXHRcImxhYmVsXCIsXG4gIFx0XCJzcmNcIixcbiAgXHRcInNyY2xhbmdcIlxuICBdO1xuICB2YXIgdWwgPSBbXG4gIFx0XCJjb21wYWN0XCIsXG4gIFx0XCJ0eXBlXCJcbiAgXTtcbiAgdmFyIHZpZGVvID0gW1xuICBcdFwiYXV0b3BsYXlcIixcbiAgXHRcImNvbnRyb2xzXCIsXG4gIFx0XCJjcm9zc29yaWdpblwiLFxuICBcdFwiaGVpZ2h0XCIsXG4gIFx0XCJsb29wXCIsXG4gIFx0XCJtdXRlZFwiLFxuICBcdFwicGxheXNpbmxpbmVcIixcbiAgXHRcInBvc3RlclwiLFxuICBcdFwicHJlbG9hZFwiLFxuICBcdFwic3JjXCIsXG4gIFx0XCJ3aWR0aFwiXG4gIF07XG4gIHZhciBpbmRleCQxID0ge1xuICBcdFwiKlwiOiBbXG4gIFx0XCJhY2Nlc3NrZXlcIixcbiAgXHRcImF1dG9jYXBpdGFsaXplXCIsXG4gIFx0XCJhdXRvZm9jdXNcIixcbiAgXHRcImNsYXNzXCIsXG4gIFx0XCJjb250ZW50ZWRpdGFibGVcIixcbiAgXHRcImRpclwiLFxuICBcdFwiZHJhZ2dhYmxlXCIsXG4gIFx0XCJlbnRlcmtleWhpbnRcIixcbiAgXHRcImhpZGRlblwiLFxuICBcdFwiaWRcIixcbiAgXHRcImlucHV0bW9kZVwiLFxuICBcdFwiaXNcIixcbiAgXHRcIml0ZW1pZFwiLFxuICBcdFwiaXRlbXByb3BcIixcbiAgXHRcIml0ZW1yZWZcIixcbiAgXHRcIml0ZW1zY29wZVwiLFxuICBcdFwiaXRlbXR5cGVcIixcbiAgXHRcImxhbmdcIixcbiAgXHRcIm5vbmNlXCIsXG4gIFx0XCJzbG90XCIsXG4gIFx0XCJzcGVsbGNoZWNrXCIsXG4gIFx0XCJzdHlsZVwiLFxuICBcdFwidGFiaW5kZXhcIixcbiAgXHRcInRpdGxlXCIsXG4gIFx0XCJ0cmFuc2xhdGVcIlxuICBdLFxuICBcdGE6IGEsXG4gIFx0YWJicjogYWJicixcbiAgXHRhcHBsZXQ6IGFwcGxldCxcbiAgXHRhcmVhOiBhcmVhLFxuICBcdGF1ZGlvOiBhdWRpbyxcbiAgXHRiYXNlOiBiYXNlLFxuICBcdGJhc2Vmb250OiBiYXNlZm9udCxcbiAgXHRiZG86IGJkbyxcbiAgXHRibG9ja3F1b3RlOiBibG9ja3F1b3RlLFxuICBcdGJvZHk6IGJvZHksXG4gIFx0YnI6IGJyLFxuICBcdGJ1dHRvbjogYnV0dG9uLFxuICBcdGNhbnZhczogY2FudmFzLFxuICBcdGNhcHRpb246IGNhcHRpb24sXG4gIFx0Y29sOiBjb2wsXG4gIFx0Y29sZ3JvdXA6IGNvbGdyb3VwLFxuICBcdGRhdGE6IGRhdGEsXG4gIFx0ZGVsOiBkZWwsXG4gIFx0ZGV0YWlsczogZGV0YWlscyxcbiAgXHRkZm46IGRmbixcbiAgXHRkaWFsb2c6IGRpYWxvZyxcbiAgXHRkaXI6IGRpcixcbiAgXHRkaXY6IGRpdixcbiAgXHRkbDogZGwsXG4gIFx0ZW1iZWQ6IGVtYmVkJDEsXG4gIFx0ZmllbGRzZXQ6IGZpZWxkc2V0LFxuICBcdGZvbnQ6IGZvbnQsXG4gIFx0Zm9ybTogZm9ybSxcbiAgXHRmcmFtZTogZnJhbWUsXG4gIFx0ZnJhbWVzZXQ6IGZyYW1lc2V0LFxuICBcdGgxOiBoMSxcbiAgXHRoMjogaDIsXG4gIFx0aDM6IGgzLFxuICBcdGg0OiBoNCxcbiAgXHRoNTogaDUsXG4gIFx0aDY6IGg2LFxuICBcdGhlYWQ6IGhlYWQsXG4gIFx0aHI6IGhyLFxuICBcdGh0bWw6IGh0bWwsXG4gIFx0aWZyYW1lOiBpZnJhbWUsXG4gIFx0aW1nOiBpbWcsXG4gIFx0aW5wdXQ6IGlucHV0LFxuICBcdGluczogaW5zLFxuICBcdGlzaW5kZXg6IGlzaW5kZXgsXG4gIFx0bGFiZWw6IGxhYmVsLFxuICBcdGxlZ2VuZDogbGVnZW5kLFxuICBcdGxpOiBsaSxcbiAgXHRsaW5rOiBsaW5rJDEsXG4gIFx0bWFwOiBtYXAsXG4gIFx0bWVudTogbWVudSxcbiAgXHRtZXRhOiBtZXRhLFxuICBcdG1ldGVyOiBtZXRlcixcbiAgXHRvYmplY3Q6IG9iamVjdCxcbiAgXHRvbDogb2wsXG4gIFx0b3B0Z3JvdXA6IG9wdGdyb3VwLFxuICBcdG9wdGlvbjogb3B0aW9uLFxuICBcdG91dHB1dDogb3V0cHV0LFxuICBcdHA6IHAsXG4gIFx0cGFyYW06IHBhcmFtLFxuICBcdHByZTogcHJlLFxuICBcdHByb2dyZXNzOiBwcm9ncmVzcyxcbiAgXHRxOiBxLFxuICBcdHNjcmlwdDogc2NyaXB0LFxuICBcdHNlbGVjdDogc2VsZWN0LFxuICBcdHNsb3Q6IHNsb3QsXG4gIFx0c291cmNlOiBzb3VyY2UsXG4gIFx0c3R5bGU6IHN0eWxlLFxuICBcdHRhYmxlOiB0YWJsZSxcbiAgXHR0Ym9keTogdGJvZHksXG4gIFx0dGQ6IHRkLFxuICBcdHRleHRhcmVhOiB0ZXh0YXJlYSxcbiAgXHR0Zm9vdDogdGZvb3QsXG4gIFx0dGg6IHRoLFxuICBcdHRoZWFkOiB0aGVhZCxcbiAgXHR0aW1lOiB0aW1lLFxuICBcdHRyOiB0cixcbiAgXHR0cmFjazogdHJhY2ssXG4gIFx0dWw6IHVsLFxuICBcdHZpZGVvOiB2aWRlb1xuICB9O1xuXG4gIHZhciBodG1sRWxlbWVudEF0dHJpYnV0ZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGE6IGEsXG4gICAgYWJicjogYWJicixcbiAgICBhcHBsZXQ6IGFwcGxldCxcbiAgICBhcmVhOiBhcmVhLFxuICAgIGF1ZGlvOiBhdWRpbyxcbiAgICBiYXNlOiBiYXNlLFxuICAgIGJhc2Vmb250OiBiYXNlZm9udCxcbiAgICBiZG86IGJkbyxcbiAgICBibG9ja3F1b3RlOiBibG9ja3F1b3RlLFxuICAgIGJvZHk6IGJvZHksXG4gICAgYnI6IGJyLFxuICAgIGJ1dHRvbjogYnV0dG9uLFxuICAgIGNhbnZhczogY2FudmFzLFxuICAgIGNhcHRpb246IGNhcHRpb24sXG4gICAgY29sOiBjb2wsXG4gICAgY29sZ3JvdXA6IGNvbGdyb3VwLFxuICAgIGRhdGE6IGRhdGEsXG4gICAgZGVsOiBkZWwsXG4gICAgZGV0YWlsczogZGV0YWlscyxcbiAgICBkZm46IGRmbixcbiAgICBkaWFsb2c6IGRpYWxvZyxcbiAgICBkaXI6IGRpcixcbiAgICBkaXY6IGRpdixcbiAgICBkbDogZGwsXG4gICAgZW1iZWQ6IGVtYmVkJDEsXG4gICAgZmllbGRzZXQ6IGZpZWxkc2V0LFxuICAgIGZvbnQ6IGZvbnQsXG4gICAgZm9ybTogZm9ybSxcbiAgICBmcmFtZTogZnJhbWUsXG4gICAgZnJhbWVzZXQ6IGZyYW1lc2V0LFxuICAgIGgxOiBoMSxcbiAgICBoMjogaDIsXG4gICAgaDM6IGgzLFxuICAgIGg0OiBoNCxcbiAgICBoNTogaDUsXG4gICAgaDY6IGg2LFxuICAgIGhlYWQ6IGhlYWQsXG4gICAgaHI6IGhyLFxuICAgIGh0bWw6IGh0bWwsXG4gICAgaWZyYW1lOiBpZnJhbWUsXG4gICAgaW1nOiBpbWcsXG4gICAgaW5wdXQ6IGlucHV0LFxuICAgIGluczogaW5zLFxuICAgIGlzaW5kZXg6IGlzaW5kZXgsXG4gICAgbGFiZWw6IGxhYmVsLFxuICAgIGxlZ2VuZDogbGVnZW5kLFxuICAgIGxpOiBsaSxcbiAgICBsaW5rOiBsaW5rJDEsXG4gICAgbWFwOiBtYXAsXG4gICAgbWVudTogbWVudSxcbiAgICBtZXRhOiBtZXRhLFxuICAgIG1ldGVyOiBtZXRlcixcbiAgICBvYmplY3Q6IG9iamVjdCxcbiAgICBvbDogb2wsXG4gICAgb3B0Z3JvdXA6IG9wdGdyb3VwLFxuICAgIG9wdGlvbjogb3B0aW9uLFxuICAgIG91dHB1dDogb3V0cHV0LFxuICAgIHA6IHAsXG4gICAgcGFyYW06IHBhcmFtLFxuICAgIHByZTogcHJlLFxuICAgIHByb2dyZXNzOiBwcm9ncmVzcyxcbiAgICBxOiBxLFxuICAgIHNjcmlwdDogc2NyaXB0LFxuICAgIHNlbGVjdDogc2VsZWN0LFxuICAgIHNsb3Q6IHNsb3QsXG4gICAgc291cmNlOiBzb3VyY2UsXG4gICAgc3R5bGU6IHN0eWxlLFxuICAgIHRhYmxlOiB0YWJsZSxcbiAgICB0Ym9keTogdGJvZHksXG4gICAgdGQ6IHRkLFxuICAgIHRleHRhcmVhOiB0ZXh0YXJlYSxcbiAgICB0Zm9vdDogdGZvb3QsXG4gICAgdGg6IHRoLFxuICAgIHRoZWFkOiB0aGVhZCxcbiAgICB0aW1lOiB0aW1lLFxuICAgIHRyOiB0cixcbiAgICB0cmFjazogdHJhY2ssXG4gICAgdWw6IHVsLFxuICAgIHZpZGVvOiB2aWRlbyxcbiAgICAnZGVmYXVsdCc6IGluZGV4JDFcbiAgfSk7XG5cbiAgdmFyIGh0bWxFbGVtZW50QXR0cmlidXRlcyQxID0gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZShodG1sRWxlbWVudEF0dHJpYnV0ZXMpO1xuXG4gIHZhciBDU1NfRElTUExBWV9UQUdTID0ganNvbi5DU1NfRElTUExBWV9UQUdTLFxuICAgICAgQ1NTX0RJU1BMQVlfREVGQVVMVCA9IGpzb24uQ1NTX0RJU1BMQVlfREVGQVVMVCxcbiAgICAgIENTU19XSElURV9TUEFDRV9UQUdTID0ganNvbi5DU1NfV0hJVEVfU1BBQ0VfVEFHUyxcbiAgICAgIENTU19XSElURV9TUEFDRV9ERUZBVUxUID0ganNvbi5DU1NfV0hJVEVfU1BBQ0VfREVGQVVMVDtcbiAgdmFyIEhUTUxfVEFHUyA9IGFycmF5VG9NYXAoaHRtbFRhZ05hbWVzJDEpO1xuICB2YXIgSFRNTF9FTEVNRU5UX0FUVFJJQlVURVMgPSBtYXBPYmplY3QoaHRtbEVsZW1lbnRBdHRyaWJ1dGVzJDEsIGFycmF5VG9NYXApO1xuXG4gIGZ1bmN0aW9uIGFycmF5VG9NYXAoYXJyYXkpIHtcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGFycmF5W1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgbWFwW3ZhbHVlXSA9IHRydWU7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFwO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwT2JqZWN0KG9iamVjdCwgZm4pIHtcbiAgICB2YXIgbmV3T2JqZWN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIGZvciAodmFyIF9pID0gMCwgX09iamVjdCRrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgX2kgPCBfT2JqZWN0JGtleXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIga2V5ID0gX09iamVjdCRrZXlzW19pXTtcbiAgICAgIG5ld09iamVjdFtrZXldID0gZm4ob2JqZWN0W2tleV0sIGtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld09iamVjdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZFByZXNlcnZlQ29udGVudChub2RlLCBvcHRpb25zKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJlbGVtZW50XCIgJiYgbm9kZS5mdWxsTmFtZSA9PT0gXCJ0ZW1wbGF0ZVwiICYmIG5vZGUuYXR0ck1hcC5sYW5nICYmIG5vZGUuYXR0ck1hcC5sYW5nICE9PSBcImh0bWxcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyB1bnRlcm1pbmF0ZWQgbm9kZSBpbiBpZSBjb25kaXRpb25hbCBjb21tZW50XG4gICAgLy8gZS5nLiA8IS0tW2lmIGx0IElFIDldPjxodG1sPjwhW2VuZGlmXS0tPlxuXG5cbiAgICBpZiAobm9kZS50eXBlID09PSBcImllQ29uZGl0aW9uYWxDb21tZW50XCIgJiYgbm9kZS5sYXN0Q2hpbGQgJiYgIW5vZGUubGFzdENoaWxkLmlzU2VsZkNsb3NpbmcgJiYgIW5vZGUubGFzdENoaWxkLmVuZFNvdXJjZVNwYW4pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gaW5jb21wbGV0ZSBodG1sIGluIGllIGNvbmRpdGlvbmFsIGNvbW1lbnRcbiAgICAvLyBlLmcuIDwhLS1baWYgbHQgSUUgOV0+PC9kaXY+PCFbZW5kaWZdLS0+XG5cblxuICAgIGlmIChub2RlLnR5cGUgPT09IFwiaWVDb25kaXRpb25hbENvbW1lbnRcIiAmJiAhbm9kZS5jb21wbGV0ZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyB0b3AtbGV2ZWwgZWxlbWVudHMgKGV4Y2x1ZGluZyA8dGVtcGxhdGU+LCA8c3R5bGU+IGFuZCA8c2NyaXB0PikgaW4gVnVlIFNGQyBhcmUgY29uc2lkZXJlZCBjdXN0b20gYmxvY2tcbiAgICAvLyBjdXN0b20gYmxvY2tzIGNhbiBiZSB3cml0dGVuIGluIG90aGVyIGxhbmd1YWdlcyBzbyB3ZSBzaG91bGQgcHJlc2VydmUgdGhlbSB0byBub3QgYnJlYWsgdGhlIGNvZGVcblxuXG4gICAgaWYgKG9wdGlvbnMucGFyc2VyID09PSBcInZ1ZVwiICYmIG5vZGUudHlwZSA9PT0gXCJlbGVtZW50XCIgJiYgbm9kZS5wYXJlbnQudHlwZSA9PT0gXCJyb290XCIgJiYgW1widGVtcGxhdGVcIiwgXCJzdHlsZVwiLCBcInNjcmlwdFwiLCAvLyB2dWUgcGFyc2VyIGNhbiBiZSB1c2VkIGZvciB2dWUgZG9tIHRlbXBsYXRlIGFzIHdlbGwsIHNvIHdlIHNob3VsZCBzdGlsbCBmb3JtYXQgdG9wLWxldmVsIDxodG1sPlxuICAgIFwiaHRtbFwiXS5pbmRleE9mKG5vZGUuZnVsbE5hbWUpID09PSAtMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBUT0RPOiBoYW5kbGUgbm9uLXRleHQgY2hpbGRyZW4gaW4gPHByZT5cblxuXG4gICAgaWYgKGlzUHJlTGlrZU5vZGUobm9kZSkgJiYgbm9kZS5jaGlsZHJlbi5zb21lKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkLnR5cGUgIT09IFwidGV4dFwiICYmIGNoaWxkLnR5cGUgIT09IFwiaW50ZXJwb2xhdGlvblwiO1xuICAgIH0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNQcmV0dGllcklnbm9yZShub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJhdHRyaWJ1dGVcIiB8fCBpc1RleHRMaWtlTm9kZShub2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghbm9kZS5wYXJlbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5vZGUuaW5kZXggIT09IFwibnVtYmVyXCIgfHwgbm9kZS5pbmRleCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBwcmV2Tm9kZSA9IG5vZGUucGFyZW50LmNoaWxkcmVuW25vZGUuaW5kZXggLSAxXTtcbiAgICByZXR1cm4gaXNQcmV0dGllcklnbm9yZShwcmV2Tm9kZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc1ByZXR0aWVySWdub3JlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcImNvbW1lbnRcIiAmJiBub2RlLnZhbHVlLnRyaW0oKSA9PT0gXCJwcmV0dGllci1pZ25vcmVcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFByZXR0aWVySWdub3JlQXR0cmlidXRlQ29tbWVudERhdGEodmFsdWUpIHtcbiAgICB2YXIgbWF0Y2ggPSB2YWx1ZS50cmltKCkubWF0Y2goL15wcmV0dGllci1pZ25vcmUtYXR0cmlidXRlKD86XFxzKyhbXl0rKSk/JC8pO1xuXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghbWF0Y2hbMV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRjaFsxXS5zcGxpdCgvXFxzKy8pO1xuICB9XG4gIC8qKiB0aGVyZSdzIG5vIG9wZW5pbmcvY2xvc2luZyB0YWcgb3IgaXQncyBjb25zaWRlcmVkIG5vdCBicmVha2FibGUgKi9cblxuXG4gIGZ1bmN0aW9uIGlzVGV4dExpa2VOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcInRleHRcIiB8fCBub2RlLnR5cGUgPT09IFwiY29tbWVudFwiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTY3JpcHRMaWtlVGFnKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcImVsZW1lbnRcIiAmJiAobm9kZS5mdWxsTmFtZSA9PT0gXCJzY3JpcHRcIiB8fCBub2RlLmZ1bGxOYW1lID09PSBcInN0eWxlXCIgfHwgbm9kZS5mdWxsTmFtZSA9PT0gXCJzdmc6c3R5bGVcIik7XG4gIH1cblxuICBmdW5jdGlvbiBpc0Zyb250TWF0dGVyTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJ5YW1sXCIgfHwgbm9kZS50eXBlID09PSBcInRvbWxcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbkhhdmVJbnRlcnBvbGF0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5jaGlsZHJlbiAmJiAhaXNTY3JpcHRMaWtlVGFnKG5vZGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNXaGl0ZXNwYWNlU2Vuc2l0aXZlTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIGlzU2NyaXB0TGlrZVRhZyhub2RlKSB8fCBub2RlLnR5cGUgPT09IFwiaW50ZXJwb2xhdGlvblwiIHx8IGlzSW5kZW50YXRpb25TZW5zaXRpdmVOb2RlKG5vZGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNJbmRlbnRhdGlvblNlbnNpdGl2ZU5vZGUobm9kZSkge1xuICAgIHJldHVybiBnZXROb2RlQ3NzU3R5bGVXaGl0ZVNwYWNlKG5vZGUpLnN0YXJ0c1dpdGgoXCJwcmVcIik7XG4gIH1cblxuICBmdW5jdGlvbiBpc0xlYWRpbmdTcGFjZVNlbnNpdGl2ZU5vZGUobm9kZSkge1xuICAgIHZhciBpc0xlYWRpbmdTcGFjZVNlbnNpdGl2ZSA9IF9pc0xlYWRpbmdTcGFjZVNlbnNpdGl2ZU5vZGUoKTtcblxuICAgIGlmIChpc0xlYWRpbmdTcGFjZVNlbnNpdGl2ZSAmJiAhbm9kZS5wcmV2ICYmIG5vZGUucGFyZW50ICYmIG5vZGUucGFyZW50LnRhZ0RlZmluaXRpb24gJiYgbm9kZS5wYXJlbnQudGFnRGVmaW5pdGlvbi5pZ25vcmVGaXJzdExmKSB7XG4gICAgICByZXR1cm4gbm9kZS50eXBlID09PSBcImludGVycG9sYXRpb25cIjtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNMZWFkaW5nU3BhY2VTZW5zaXRpdmU7XG5cbiAgICBmdW5jdGlvbiBfaXNMZWFkaW5nU3BhY2VTZW5zaXRpdmVOb2RlKCkge1xuICAgICAgaWYgKGlzRnJvbnRNYXR0ZXJOb2RlKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKChub2RlLnR5cGUgPT09IFwidGV4dFwiIHx8IG5vZGUudHlwZSA9PT0gXCJpbnRlcnBvbGF0aW9uXCIpICYmIG5vZGUucHJldiAmJiAobm9kZS5wcmV2LnR5cGUgPT09IFwidGV4dFwiIHx8IG5vZGUucHJldi50eXBlID09PSBcImludGVycG9sYXRpb25cIikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghbm9kZS5wYXJlbnQgfHwgbm9kZS5wYXJlbnQuY3NzRGlzcGxheSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNQcmVMaWtlTm9kZShub2RlLnBhcmVudCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghbm9kZS5wcmV2ICYmIChub2RlLnBhcmVudC50eXBlID09PSBcInJvb3RcIiB8fCBpc1NjcmlwdExpa2VUYWcobm9kZS5wYXJlbnQpIHx8ICFpc0ZpcnN0Q2hpbGRMZWFkaW5nU3BhY2VTZW5zaXRpdmVDc3NEaXNwbGF5KG5vZGUucGFyZW50LmNzc0Rpc3BsYXkpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnByZXYgJiYgIWlzTmV4dExlYWRpbmdTcGFjZVNlbnNpdGl2ZUNzc0Rpc3BsYXkobm9kZS5wcmV2LmNzc0Rpc3BsYXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlTm9kZShub2RlKSB7XG4gICAgaWYgKGlzRnJvbnRNYXR0ZXJOb2RlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKChub2RlLnR5cGUgPT09IFwidGV4dFwiIHx8IG5vZGUudHlwZSA9PT0gXCJpbnRlcnBvbGF0aW9uXCIpICYmIG5vZGUubmV4dCAmJiAobm9kZS5uZXh0LnR5cGUgPT09IFwidGV4dFwiIHx8IG5vZGUubmV4dC50eXBlID09PSBcImludGVycG9sYXRpb25cIikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghbm9kZS5wYXJlbnQgfHwgbm9kZS5wYXJlbnQuY3NzRGlzcGxheSA9PT0gXCJub25lXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaXNQcmVMaWtlTm9kZShub2RlLnBhcmVudCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghbm9kZS5uZXh0ICYmIChub2RlLnBhcmVudC50eXBlID09PSBcInJvb3RcIiB8fCBpc1NjcmlwdExpa2VUYWcobm9kZS5wYXJlbnQpIHx8ICFpc0xhc3RDaGlsZFRyYWlsaW5nU3BhY2VTZW5zaXRpdmVDc3NEaXNwbGF5KG5vZGUucGFyZW50LmNzc0Rpc3BsYXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChub2RlLm5leHQgJiYgIWlzUHJldlRyYWlsaW5nU3BhY2VTZW5zaXRpdmVDc3NEaXNwbGF5KG5vZGUubmV4dC5jc3NEaXNwbGF5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNEYW5nbGluZ1NwYWNlU2Vuc2l0aXZlTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIGlzRGFuZ2xpbmdTcGFjZVNlbnNpdGl2ZUNzc0Rpc3BsYXkobm9kZS5jc3NEaXNwbGF5KSAmJiAhaXNTY3JpcHRMaWtlVGFnKG5vZGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9yY2VOZXh0RW1wdHlMaW5lKG5vZGUpIHtcbiAgICByZXR1cm4gaXNGcm9udE1hdHRlck5vZGUobm9kZSkgfHwgbm9kZS5uZXh0ICYmIG5vZGUuc291cmNlU3Bhbi5lbmQubGluZSArIDEgPCBub2RlLm5leHQuc291cmNlU3Bhbi5zdGFydC5saW5lO1xuICB9XG4gIC8qKiBmaXJzdENoaWxkIGxlYWRpbmdTcGFjZXMgYW5kIGxhc3RDaGlsZCB0cmFpbGluZ1NwYWNlcyAqL1xuXG5cbiAgZnVuY3Rpb24gZm9yY2VCcmVha0NvbnRlbnQobm9kZSkge1xuICAgIHJldHVybiBmb3JjZUJyZWFrQ2hpbGRyZW4obm9kZSkgfHwgbm9kZS50eXBlID09PSBcImVsZW1lbnRcIiAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAhPT0gMCAmJiAoW1wiYm9keVwiLCBcInNjcmlwdFwiLCBcInN0eWxlXCJdLmluZGV4T2Yobm9kZS5uYW1lKSAhPT0gLTEgfHwgbm9kZS5jaGlsZHJlbi5zb21lKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgcmV0dXJuIGhhc05vblRleHRDaGlsZChjaGlsZCk7XG4gICAgfSkpIHx8IG5vZGUuZmlyc3RDaGlsZCAmJiBub2RlLmZpcnN0Q2hpbGQgPT09IG5vZGUubGFzdENoaWxkICYmIGhhc0xlYWRpbmdMaW5lQnJlYWsobm9kZS5maXJzdENoaWxkKSAmJiAoIW5vZGUubGFzdENoaWxkLmlzVHJhaWxpbmdTcGFjZVNlbnNpdGl2ZSB8fCBoYXNUcmFpbGluZ0xpbmVCcmVhayhub2RlLmxhc3RDaGlsZCkpO1xuICB9XG4gIC8qKiBzcGFjZXMgYmV0d2VlbiBjaGlsZHJlbiAqL1xuXG5cbiAgZnVuY3Rpb24gZm9yY2VCcmVha0NoaWxkcmVuKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcImVsZW1lbnRcIiAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAhPT0gMCAmJiAoW1wiaHRtbFwiLCBcImhlYWRcIiwgXCJ1bFwiLCBcIm9sXCIsIFwic2VsZWN0XCJdLmluZGV4T2Yobm9kZS5uYW1lKSAhPT0gLTEgfHwgbm9kZS5jc3NEaXNwbGF5LnN0YXJ0c1dpdGgoXCJ0YWJsZVwiKSAmJiBub2RlLmNzc0Rpc3BsYXkgIT09IFwidGFibGUtY2VsbFwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZWZlckhhcmRsaW5lQXNMZWFkaW5nU3BhY2VzKG5vZGUpIHtcbiAgICByZXR1cm4gcHJlZmVySGFyZGxpbmVBc1N1cnJvdW5kaW5nU3BhY2VzKG5vZGUpIHx8IG5vZGUucHJldiAmJiBwcmVmZXJIYXJkbGluZUFzVHJhaWxpbmdTcGFjZXMobm9kZS5wcmV2KSB8fCBoYXNTdXJyb3VuZGluZ0xpbmVCcmVhayhub2RlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZWZlckhhcmRsaW5lQXNUcmFpbGluZ1NwYWNlcyhub2RlKSB7XG4gICAgcmV0dXJuIHByZWZlckhhcmRsaW5lQXNTdXJyb3VuZGluZ1NwYWNlcyhub2RlKSB8fCBub2RlLnR5cGUgPT09IFwiZWxlbWVudFwiICYmIG5vZGUuZnVsbE5hbWUgPT09IFwiYnJcIiB8fCBoYXNTdXJyb3VuZGluZ0xpbmVCcmVhayhub2RlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc1N1cnJvdW5kaW5nTGluZUJyZWFrKG5vZGUpIHtcbiAgICByZXR1cm4gaGFzTGVhZGluZ0xpbmVCcmVhayhub2RlKSAmJiBoYXNUcmFpbGluZ0xpbmVCcmVhayhub2RlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0xlYWRpbmdMaW5lQnJlYWsobm9kZSkge1xuICAgIHJldHVybiBub2RlLmhhc0xlYWRpbmdTcGFjZXMgJiYgKG5vZGUucHJldiA/IG5vZGUucHJldi5zb3VyY2VTcGFuLmVuZC5saW5lIDwgbm9kZS5zb3VyY2VTcGFuLnN0YXJ0LmxpbmUgOiBub2RlLnBhcmVudC50eXBlID09PSBcInJvb3RcIiB8fCBub2RlLnBhcmVudC5zdGFydFNvdXJjZVNwYW4uZW5kLmxpbmUgPCBub2RlLnNvdXJjZVNwYW4uc3RhcnQubGluZSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNUcmFpbGluZ0xpbmVCcmVhayhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuaGFzVHJhaWxpbmdTcGFjZXMgJiYgKG5vZGUubmV4dCA/IG5vZGUubmV4dC5zb3VyY2VTcGFuLnN0YXJ0LmxpbmUgPiBub2RlLnNvdXJjZVNwYW4uZW5kLmxpbmUgOiBub2RlLnBhcmVudC50eXBlID09PSBcInJvb3RcIiB8fCBub2RlLnBhcmVudC5lbmRTb3VyY2VTcGFuLnN0YXJ0LmxpbmUgPiBub2RlLnNvdXJjZVNwYW4uZW5kLmxpbmUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlZmVySGFyZGxpbmVBc1N1cnJvdW5kaW5nU3BhY2VzKG5vZGUpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcImllQ29uZGl0aW9uYWxDb21tZW50XCI6XG4gICAgICBjYXNlIFwiY29tbWVudFwiOlxuICAgICAgY2FzZSBcImRpcmVjdGl2ZVwiOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgY2FzZSBcImVsZW1lbnRcIjpcbiAgICAgICAgcmV0dXJuIFtcInNjcmlwdFwiLCBcInNlbGVjdFwiXS5pbmRleE9mKG5vZGUubmFtZSkgIT09IC0xO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExhc3REZXNjZW5kYW50KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5sYXN0Q2hpbGQgPyBnZXRMYXN0RGVzY2VuZGFudChub2RlLmxhc3RDaGlsZCkgOiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzTm9uVGV4dENoaWxkKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5jaGlsZHJlbiAmJiBub2RlLmNoaWxkcmVuLnNvbWUoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQudHlwZSAhPT0gXCJ0ZXh0XCI7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbmZlclNjcmlwdFBhcnNlcihub2RlKSB7XG4gICAgaWYgKG5vZGUubmFtZSA9PT0gXCJzY3JpcHRcIiAmJiAhbm9kZS5hdHRyTWFwLnNyYykge1xuICAgICAgaWYgKCFub2RlLmF0dHJNYXAubGFuZyAmJiAhbm9kZS5hdHRyTWFwLnR5cGUgfHwgbm9kZS5hdHRyTWFwLnR5cGUgPT09IFwibW9kdWxlXCIgfHwgbm9kZS5hdHRyTWFwLnR5cGUgPT09IFwidGV4dC9qYXZhc2NyaXB0XCIgfHwgbm9kZS5hdHRyTWFwLnR5cGUgPT09IFwidGV4dC9iYWJlbFwiIHx8IG5vZGUuYXR0ck1hcC50eXBlID09PSBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIikge1xuICAgICAgICByZXR1cm4gXCJiYWJlbFwiO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5hdHRyTWFwLnR5cGUgPT09IFwiYXBwbGljYXRpb24veC10eXBlc2NyaXB0XCIgfHwgbm9kZS5hdHRyTWFwLmxhbmcgPT09IFwidHNcIiB8fCBub2RlLmF0dHJNYXAubGFuZyA9PT0gXCJ0c3hcIikge1xuICAgICAgICByZXR1cm4gXCJ0eXBlc2NyaXB0XCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLmF0dHJNYXAudHlwZSA9PT0gXCJ0ZXh0L21hcmtkb3duXCIpIHtcbiAgICAgICAgcmV0dXJuIFwibWFya2Rvd25cIjtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUuYXR0ck1hcC50eXBlLmVuZHNXaXRoKFwianNvblwiKSB8fCBub2RlLmF0dHJNYXAudHlwZS5lbmRzV2l0aChcImltcG9ydG1hcFwiKSkge1xuICAgICAgICByZXR1cm4gXCJqc29uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vZGUubmFtZSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgICBpZiAoIW5vZGUuYXR0ck1hcC5sYW5nIHx8IG5vZGUuYXR0ck1hcC5sYW5nID09PSBcInBvc3Rjc3NcIiB8fCBub2RlLmF0dHJNYXAubGFuZyA9PT0gXCJjc3NcIikge1xuICAgICAgICByZXR1cm4gXCJjc3NcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUuYXR0ck1hcC5sYW5nID09PSBcInNjc3NcIikge1xuICAgICAgICByZXR1cm4gXCJzY3NzXCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLmF0dHJNYXAubGFuZyA9PT0gXCJsZXNzXCIpIHtcbiAgICAgICAgcmV0dXJuIFwibGVzc1wiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNCbG9ja0xpa2VDc3NEaXNwbGF5KGNzc0Rpc3BsYXkpIHtcbiAgICByZXR1cm4gY3NzRGlzcGxheSA9PT0gXCJibG9ja1wiIHx8IGNzc0Rpc3BsYXkgPT09IFwibGlzdC1pdGVtXCIgfHwgY3NzRGlzcGxheS5zdGFydHNXaXRoKFwidGFibGVcIik7XG4gIH1cblxuICBmdW5jdGlvbiBpc0ZpcnN0Q2hpbGRMZWFkaW5nU3BhY2VTZW5zaXRpdmVDc3NEaXNwbGF5KGNzc0Rpc3BsYXkpIHtcbiAgICByZXR1cm4gIWlzQmxvY2tMaWtlQ3NzRGlzcGxheShjc3NEaXNwbGF5KSAmJiBjc3NEaXNwbGF5ICE9PSBcImlubGluZS1ibG9ja1wiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNMYXN0Q2hpbGRUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlQ3NzRGlzcGxheShjc3NEaXNwbGF5KSB7XG4gICAgcmV0dXJuICFpc0Jsb2NrTGlrZUNzc0Rpc3BsYXkoY3NzRGlzcGxheSkgJiYgY3NzRGlzcGxheSAhPT0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUHJldlRyYWlsaW5nU3BhY2VTZW5zaXRpdmVDc3NEaXNwbGF5KGNzc0Rpc3BsYXkpIHtcbiAgICByZXR1cm4gIWlzQmxvY2tMaWtlQ3NzRGlzcGxheShjc3NEaXNwbGF5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTmV4dExlYWRpbmdTcGFjZVNlbnNpdGl2ZUNzc0Rpc3BsYXkoY3NzRGlzcGxheSkge1xuICAgIHJldHVybiAhaXNCbG9ja0xpa2VDc3NEaXNwbGF5KGNzc0Rpc3BsYXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNEYW5nbGluZ1NwYWNlU2Vuc2l0aXZlQ3NzRGlzcGxheShjc3NEaXNwbGF5KSB7XG4gICAgcmV0dXJuICFpc0Jsb2NrTGlrZUNzc0Rpc3BsYXkoY3NzRGlzcGxheSkgJiYgY3NzRGlzcGxheSAhPT0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUHJlTGlrZU5vZGUobm9kZSkge1xuICAgIHJldHVybiBnZXROb2RlQ3NzU3R5bGVXaGl0ZVNwYWNlKG5vZGUpLnN0YXJ0c1dpdGgoXCJwcmVcIik7XG4gIH1cblxuICBmdW5jdGlvbiBjb3VudFBhcmVudHMocGF0aCkge1xuICAgIHZhciBwcmVkaWNhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgdmFyIGNvdW50ZXIgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IHBhdGguc3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB2YWx1ZSA9IHBhdGguc3RhY2tbaV07XG5cbiAgICAgIGlmICh2YWx1ZSAmJiBfdHlwZW9mKHZhbHVlKSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICBjb3VudGVyKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNQYXJlbnQobm9kZSwgZm4pIHtcbiAgICB2YXIgY3VycmVudCA9IG5vZGU7XG5cbiAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgaWYgKGZuKGN1cnJlbnQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Tm9kZUNzc1N0eWxlRGlzcGxheShub2RlLCBvcHRpb25zKSB7XG4gICAgaWYgKG5vZGUucHJldiAmJiBub2RlLnByZXYudHlwZSA9PT0gXCJjb21tZW50XCIpIHtcbiAgICAgIC8vIDwhLS0gZGlzcGxheTogYmxvY2sgLS0+XG4gICAgICB2YXIgbWF0Y2ggPSBub2RlLnByZXYudmFsdWUubWF0Y2goL15cXHMqZGlzcGxheTpcXHMqKFthLXpdKylcXHMqJC8pO1xuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoWzFdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpc0luU3ZnRm9yZWlnbk9iamVjdCA9IGZhbHNlO1xuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJlbGVtZW50XCIgJiYgbm9kZS5uYW1lc3BhY2UgPT09IFwic3ZnXCIpIHtcbiAgICAgIGlmIChoYXNQYXJlbnQobm9kZSwgZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICByZXR1cm4gcGFyZW50LmZ1bGxOYW1lID09PSBcInN2Zzpmb3JlaWduT2JqZWN0XCI7XG4gICAgICB9KSkge1xuICAgICAgICBpc0luU3ZnRm9yZWlnbk9iamVjdCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbm9kZS5uYW1lID09PSBcInN2Z1wiID8gXCJpbmxpbmUtYmxvY2tcIiA6IFwiYmxvY2tcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKG9wdGlvbnMuaHRtbFdoaXRlc3BhY2VTZW5zaXRpdml0eSkge1xuICAgICAgY2FzZSBcInN0cmljdFwiOlxuICAgICAgICByZXR1cm4gXCJpbmxpbmVcIjtcblxuICAgICAgY2FzZSBcImlnbm9yZVwiOlxuICAgICAgICByZXR1cm4gXCJibG9ja1wiO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbm9kZS50eXBlID09PSBcImVsZW1lbnRcIiAmJiAoIW5vZGUubmFtZXNwYWNlIHx8IGlzSW5TdmdGb3JlaWduT2JqZWN0KSAmJiBDU1NfRElTUExBWV9UQUdTW25vZGUubmFtZV0gfHwgQ1NTX0RJU1BMQVlfREVGQVVMVDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXROb2RlQ3NzU3R5bGVXaGl0ZVNwYWNlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcImVsZW1lbnRcIiAmJiAhbm9kZS5uYW1lc3BhY2UgJiYgQ1NTX1dISVRFX1NQQUNFX1RBR1Nbbm9kZS5uYW1lXSB8fCBDU1NfV0hJVEVfU1BBQ0VfREVGQVVMVDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1pbkluZGVudGF0aW9uKHRleHQpIHtcbiAgICB2YXIgbWluSW5kZW50YXRpb24gPSBJbmZpbml0eTtcbiAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSB0ZXh0LnNwbGl0KFwiXFxuXCIpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG4gICAgICAgIHZhciBsaW5lVGV4dCA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICBpZiAobGluZVRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoL1xcUy8udGVzdChsaW5lVGV4dFswXSkpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmRlbnRhdGlvbiA9IGxpbmVUZXh0Lm1hdGNoKC9eXFxzKi8pWzBdLmxlbmd0aDtcblxuICAgICAgICBpZiAobGluZVRleHQubGVuZ3RoID09PSBpbmRlbnRhdGlvbikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGVudGF0aW9uIDwgbWluSW5kZW50YXRpb24pIHtcbiAgICAgICAgICBtaW5JbmRlbnRhdGlvbiA9IGluZGVudGF0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1pbkluZGVudGF0aW9uID09PSBJbmZpbml0eSA/IDAgOiBtaW5JbmRlbnRhdGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZGVudFN0cmluZyh0ZXh0KSB7XG4gICAgdmFyIG1pbkluZGVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZ2V0TWluSW5kZW50YXRpb24odGV4dCk7XG4gICAgcmV0dXJuIG1pbkluZGVudCA9PT0gMCA/IHRleHQgOiB0ZXh0LnNwbGl0KFwiXFxuXCIpLm1hcChmdW5jdGlvbiAobGluZVRleHQpIHtcbiAgICAgIHJldHVybiBsaW5lVGV4dC5zbGljZShtaW5JbmRlbnQpO1xuICAgIH0pLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVQYXJ0cyhwYXJ0cykge1xuICAgIHZhciBuZXdQYXJ0cyA9IFtdO1xuICAgIHZhciByZXN0UGFydHMgPSBwYXJ0cy5zbGljZSgpO1xuXG4gICAgd2hpbGUgKHJlc3RQYXJ0cy5sZW5ndGggIT09IDApIHtcbiAgICAgIHZhciBwYXJ0ID0gcmVzdFBhcnRzLnNoaWZ0KCk7XG5cbiAgICAgIGlmICghcGFydCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJjb25jYXRcIikge1xuICAgICAgICBBcnJheS5wcm90b3R5cGUudW5zaGlmdC5hcHBseShyZXN0UGFydHMsIHBhcnQucGFydHMpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld1BhcnRzLmxlbmd0aCAhPT0gMCAmJiB0eXBlb2YgbmV3UGFydHNbbmV3UGFydHMubGVuZ3RoIC0gMV0gPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHBhcnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbmV3UGFydHMucHVzaChuZXdQYXJ0cy5wb3AoKSArIHBhcnQpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbmV3UGFydHMucHVzaChwYXJ0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3UGFydHM7XG4gIH1cblxuICBmdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gICAgcmV0dXJuIHg7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGROb3RQcmludENsb3NpbmdUYWcobm9kZSwgb3B0aW9ucykge1xuICAgIHJldHVybiAhbm9kZS5pc1NlbGZDbG9zaW5nICYmICFub2RlLmVuZFNvdXJjZVNwYW4gJiYgKGhhc1ByZXR0aWVySWdub3JlKG5vZGUpIHx8IHNob3VsZFByZXNlcnZlQ29udGVudChub2RlLnBhcmVudCwgb3B0aW9ucykpO1xuICB9XG5cbiAgZnVuY3Rpb24gY291bnRDaGFycyh0ZXh0LCBjaGFyKSB7XG4gICAgdmFyIGNvdW50ZXIgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGV4dFtpXSA9PT0gY2hhcikge1xuICAgICAgICBjb3VudGVyKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH1cblxuICBmdW5jdGlvbiB1bmVzY2FwZVF1b3RlRW50aXRpZXModGV4dCkge1xuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoLyZhcG9zOy9nLCBcIidcIikucmVwbGFjZSgvJnF1b3Q7L2csICdcIicpO1xuICB9XG5cbiAgdmFyIHV0aWxzJDMgPSB7XG4gICAgSFRNTF9FTEVNRU5UX0FUVFJJQlVURVM6IEhUTUxfRUxFTUVOVF9BVFRSSUJVVEVTLFxuICAgIEhUTUxfVEFHUzogSFRNTF9UQUdTLFxuICAgIGNhbkhhdmVJbnRlcnBvbGF0aW9uOiBjYW5IYXZlSW50ZXJwb2xhdGlvbixcbiAgICBjb3VudENoYXJzOiBjb3VudENoYXJzLFxuICAgIGNvdW50UGFyZW50czogY291bnRQYXJlbnRzLFxuICAgIGRlZGVudFN0cmluZzogZGVkZW50U3RyaW5nLFxuICAgIGZvcmNlQnJlYWtDaGlsZHJlbjogZm9yY2VCcmVha0NoaWxkcmVuLFxuICAgIGZvcmNlQnJlYWtDb250ZW50OiBmb3JjZUJyZWFrQ29udGVudCxcbiAgICBmb3JjZU5leHRFbXB0eUxpbmU6IGZvcmNlTmV4dEVtcHR5TGluZSxcbiAgICBnZXRMYXN0RGVzY2VuZGFudDogZ2V0TGFzdERlc2NlbmRhbnQsXG4gICAgZ2V0Tm9kZUNzc1N0eWxlRGlzcGxheTogZ2V0Tm9kZUNzc1N0eWxlRGlzcGxheSxcbiAgICBnZXROb2RlQ3NzU3R5bGVXaGl0ZVNwYWNlOiBnZXROb2RlQ3NzU3R5bGVXaGl0ZVNwYWNlLFxuICAgIGdldFByZXR0aWVySWdub3JlQXR0cmlidXRlQ29tbWVudERhdGE6IGdldFByZXR0aWVySWdub3JlQXR0cmlidXRlQ29tbWVudERhdGEsXG4gICAgaGFzUHJldHRpZXJJZ25vcmU6IGhhc1ByZXR0aWVySWdub3JlLFxuICAgIGlkZW50aXR5OiBpZGVudGl0eSxcbiAgICBpbmZlclNjcmlwdFBhcnNlcjogaW5mZXJTY3JpcHRQYXJzZXIsXG4gICAgaXNEYW5nbGluZ1NwYWNlU2Vuc2l0aXZlTm9kZTogaXNEYW5nbGluZ1NwYWNlU2Vuc2l0aXZlTm9kZSxcbiAgICBpc0Zyb250TWF0dGVyTm9kZTogaXNGcm9udE1hdHRlck5vZGUsXG4gICAgaXNJbmRlbnRhdGlvblNlbnNpdGl2ZU5vZGU6IGlzSW5kZW50YXRpb25TZW5zaXRpdmVOb2RlLFxuICAgIGlzTGVhZGluZ1NwYWNlU2Vuc2l0aXZlTm9kZTogaXNMZWFkaW5nU3BhY2VTZW5zaXRpdmVOb2RlLFxuICAgIGlzUHJlTGlrZU5vZGU6IGlzUHJlTGlrZU5vZGUsXG4gICAgaXNTY3JpcHRMaWtlVGFnOiBpc1NjcmlwdExpa2VUYWcsXG4gICAgaXNUZXh0TGlrZU5vZGU6IGlzVGV4dExpa2VOb2RlLFxuICAgIGlzVHJhaWxpbmdTcGFjZVNlbnNpdGl2ZU5vZGU6IGlzVHJhaWxpbmdTcGFjZVNlbnNpdGl2ZU5vZGUsXG4gICAgaXNXaGl0ZXNwYWNlU2Vuc2l0aXZlTm9kZTogaXNXaGl0ZXNwYWNlU2Vuc2l0aXZlTm9kZSxcbiAgICBub3JtYWxpemVQYXJ0czogbm9ybWFsaXplUGFydHMsXG4gICAgcHJlZmVySGFyZGxpbmVBc0xlYWRpbmdTcGFjZXM6IHByZWZlckhhcmRsaW5lQXNMZWFkaW5nU3BhY2VzLFxuICAgIHByZWZlckhhcmRsaW5lQXNUcmFpbGluZ1NwYWNlczogcHJlZmVySGFyZGxpbmVBc1RyYWlsaW5nU3BhY2VzLFxuICAgIHNob3VsZE5vdFByaW50Q2xvc2luZ1RhZzogc2hvdWxkTm90UHJpbnRDbG9zaW5nVGFnLFxuICAgIHNob3VsZFByZXNlcnZlQ29udGVudDogc2hvdWxkUHJlc2VydmVDb250ZW50LFxuICAgIHVuZXNjYXBlUXVvdGVFbnRpdGllczogdW5lc2NhcGVRdW90ZUVudGl0aWVzXG4gIH07XG5cbiAgdmFyIGNhbkhhdmVJbnRlcnBvbGF0aW9uJDEgPSB1dGlscyQzLmNhbkhhdmVJbnRlcnBvbGF0aW9uLFxuICAgICAgZ2V0Tm9kZUNzc1N0eWxlRGlzcGxheSQxID0gdXRpbHMkMy5nZXROb2RlQ3NzU3R5bGVEaXNwbGF5LFxuICAgICAgaXNEYW5nbGluZ1NwYWNlU2Vuc2l0aXZlTm9kZSQxID0gdXRpbHMkMy5pc0RhbmdsaW5nU3BhY2VTZW5zaXRpdmVOb2RlLFxuICAgICAgaXNJbmRlbnRhdGlvblNlbnNpdGl2ZU5vZGUkMSA9IHV0aWxzJDMuaXNJbmRlbnRhdGlvblNlbnNpdGl2ZU5vZGUsXG4gICAgICBpc0xlYWRpbmdTcGFjZVNlbnNpdGl2ZU5vZGUkMSA9IHV0aWxzJDMuaXNMZWFkaW5nU3BhY2VTZW5zaXRpdmVOb2RlLFxuICAgICAgaXNUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlTm9kZSQxID0gdXRpbHMkMy5pc1RyYWlsaW5nU3BhY2VTZW5zaXRpdmVOb2RlLFxuICAgICAgaXNXaGl0ZXNwYWNlU2Vuc2l0aXZlTm9kZSQxID0gdXRpbHMkMy5pc1doaXRlc3BhY2VTZW5zaXRpdmVOb2RlO1xuICB2YXIgUFJFUFJPQ0VTU19QSVBFTElORSA9IFtyZW1vdmVJZ25vcmFibGVGaXJzdExmLCBtZXJnZUllQ29uZGl0b25hbFN0YXJ0RW5kQ29tbWVudEludG9FbGVtZW50T3BlbmluZ1RhZywgbWVyZ2VDZGF0YUludG9UZXh0LCBleHRyYWN0SW50ZXJwb2xhdGlvbiwgZXh0cmFjdFdoaXRlc3BhY2VzLCBhZGRDc3NEaXNwbGF5LCBhZGRJc1NlbGZDbG9zaW5nLCBhZGRIYXNIdG1Db21wb25lbnRDbG9zaW5nVGFnLCBhZGRJc1NwYWNlU2Vuc2l0aXZlLCBtZXJnZVNpbXBsZUVsZW1lbnRJbnRvVGV4dF07XG5cbiAgZnVuY3Rpb24gcHJlcHJvY2Vzcyhhc3QsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IFBSRVBST0NFU1NfUElQRUxJTkVbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgIHZhciBmbiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICBhc3QgPSBmbihhc3QsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFzdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUlnbm9yYWJsZUZpcnN0TGYoYXN0XG4gIC8qLCBvcHRpb25zICovXG4gICkge1xuICAgIHJldHVybiBhc3QubWFwKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBpZiAobm9kZS50eXBlID09PSBcImVsZW1lbnRcIiAmJiBub2RlLnRhZ0RlZmluaXRpb24uaWdub3JlRmlyc3RMZiAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAhPT0gMCAmJiBub2RlLmNoaWxkcmVuWzBdLnR5cGUgPT09IFwidGV4dFwiICYmIG5vZGUuY2hpbGRyZW5bMF0udmFsdWVbMF0gPT09IFwiXFxuXCIpIHtcbiAgICAgICAgdmFyIHRleHQgPSBub2RlLmNoaWxkcmVuWzBdO1xuICAgICAgICByZXR1cm4gbm9kZS5jbG9uZSh7XG4gICAgICAgICAgY2hpbGRyZW46IHRleHQudmFsdWUubGVuZ3RoID09PSAxID8gbm9kZS5jaGlsZHJlbi5zbGljZSgxKSA6IFtdLmNvbmNhdCh0ZXh0LmNsb25lKHtcbiAgICAgICAgICAgIHZhbHVlOiB0ZXh0LnZhbHVlLnNsaWNlKDEpXG4gICAgICAgICAgfSksIG5vZGUuY2hpbGRyZW4uc2xpY2UoMSkpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlSWVDb25kaXRvbmFsU3RhcnRFbmRDb21tZW50SW50b0VsZW1lbnRPcGVuaW5nVGFnKGFzdFxuICAvKiwgb3B0aW9ucyAqL1xuICApIHtcbiAgICAvKipcbiAgICAgKiAgICAgPCEtLVtpZiAuLi5dPjwhLS0+PHRhcmdldD48IS0tPCFbZW5kaWZdLS0+XG4gICAgICovXG4gICAgdmFyIGlzVGFyZ2V0ID0gZnVuY3Rpb24gaXNUYXJnZXQobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJlbGVtZW50XCIgJiYgbm9kZS5wcmV2ICYmIG5vZGUucHJldi50eXBlID09PSBcImllQ29uZGl0aW9uYWxTdGFydENvbW1lbnRcIiAmJiBub2RlLnByZXYuc291cmNlU3Bhbi5lbmQub2Zmc2V0ID09PSBub2RlLnN0YXJ0U291cmNlU3Bhbi5zdGFydC5vZmZzZXQgJiYgbm9kZS5maXJzdENoaWxkICYmIG5vZGUuZmlyc3RDaGlsZC50eXBlID09PSBcImllQ29uZGl0aW9uYWxFbmRDb21tZW50XCIgJiYgbm9kZS5maXJzdENoaWxkLnNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0ID09PSBub2RlLnN0YXJ0U291cmNlU3Bhbi5lbmQub2Zmc2V0O1xuICAgIH07XG5cbiAgICByZXR1cm4gYXN0Lm1hcChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGlzVGFyZ2V0UmVzdWx0cyA9IG5vZGUuY2hpbGRyZW4ubWFwKGlzVGFyZ2V0KTtcblxuICAgICAgICBpZiAoaXNUYXJnZXRSZXN1bHRzLnNvbWUoQm9vbGVhbikpIHtcbiAgICAgICAgICB2YXIgbmV3Q2hpbGRyZW4gPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcblxuICAgICAgICAgICAgaWYgKGlzVGFyZ2V0UmVzdWx0c1tpICsgMV0pIHtcbiAgICAgICAgICAgICAgLy8gaWVDb25kaXRpb25hbFN0YXJ0Q29tbWVudFxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzVGFyZ2V0UmVzdWx0c1tpXSkge1xuICAgICAgICAgICAgICB2YXIgaWVDb25kaXRpb25hbFN0YXJ0Q29tbWVudCA9IGNoaWxkLnByZXY7XG4gICAgICAgICAgICAgIHZhciBpZUNvbmRpdGlvbmFsRW5kQ29tbWVudCA9IGNoaWxkLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgIHZhciBQYXJzZVNvdXJjZVNwYW4gPSBjaGlsZC5zb3VyY2VTcGFuLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgICB2YXIgc3RhcnRTb3VyY2VTcGFuID0gbmV3IFBhcnNlU291cmNlU3BhbihpZUNvbmRpdGlvbmFsU3RhcnRDb21tZW50LnNvdXJjZVNwYW4uc3RhcnQsIGllQ29uZGl0aW9uYWxFbmRDb21tZW50LnNvdXJjZVNwYW4uZW5kKTtcbiAgICAgICAgICAgICAgdmFyIHNvdXJjZVNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKHN0YXJ0U291cmNlU3Bhbi5zdGFydCwgY2hpbGQuc291cmNlU3Bhbi5lbmQpO1xuICAgICAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKGNoaWxkLmNsb25lKHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb246IGllQ29uZGl0aW9uYWxTdGFydENvbW1lbnQuY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgIHNvdXJjZVNwYW46IHNvdXJjZVNwYW4sXG4gICAgICAgICAgICAgICAgc3RhcnRTb3VyY2VTcGFuOiBzdGFydFNvdXJjZVNwYW4sXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkLmNoaWxkcmVuLnNsaWNlKDEpXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBub2RlLmNsb25lKHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBuZXdDaGlsZHJlblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VOb2RlSW50b1RleHQoYXN0LCBzaG91bGRNZXJnZSwgZ2V0VmFsdWUpIHtcbiAgICByZXR1cm4gYXN0Lm1hcChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHNob3VsZE1lcmdlUmVzdWx0cyA9IG5vZGUuY2hpbGRyZW4ubWFwKHNob3VsZE1lcmdlKTtcblxuICAgICAgICBpZiAoc2hvdWxkTWVyZ2VSZXN1bHRzLnNvbWUoQm9vbGVhbikpIHtcbiAgICAgICAgICB2YXIgbmV3Q2hpbGRyZW4gPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT09IFwidGV4dFwiICYmICFzaG91bGRNZXJnZVJlc3VsdHNbaV0pIHtcbiAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmV3Q2hpbGQgPSBjaGlsZC50eXBlID09PSBcInRleHRcIiA/IGNoaWxkIDogY2hpbGQuY2xvbmUoe1xuICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKGNoaWxkKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChuZXdDaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgbmV3Q2hpbGRyZW5bbmV3Q2hpbGRyZW4ubGVuZ3RoIC0gMV0udHlwZSAhPT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaChuZXdDaGlsZCk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGFzdENoaWxkID0gbmV3Q2hpbGRyZW4ucG9wKCk7XG4gICAgICAgICAgICB2YXIgUGFyc2VTb3VyY2VTcGFuID0gbGFzdENoaWxkLnNvdXJjZVNwYW4uY29uc3RydWN0b3I7XG4gICAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKGxhc3RDaGlsZC5jbG9uZSh7XG4gICAgICAgICAgICAgIHZhbHVlOiBsYXN0Q2hpbGQudmFsdWUgKyBuZXdDaGlsZC52YWx1ZSxcbiAgICAgICAgICAgICAgc291cmNlU3BhbjogbmV3IFBhcnNlU291cmNlU3BhbihsYXN0Q2hpbGQuc291cmNlU3Bhbi5zdGFydCwgbmV3Q2hpbGQuc291cmNlU3Bhbi5lbmQpXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5vZGUuY2xvbmUoe1xuICAgICAgICAgICAgY2hpbGRyZW46IG5ld0NoaWxkcmVuXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUNkYXRhSW50b1RleHQoYXN0XG4gIC8qLCBvcHRpb25zICovXG4gICkge1xuICAgIHJldHVybiBtZXJnZU5vZGVJbnRvVGV4dChhc3QsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS50eXBlID09PSBcImNkYXRhXCI7XG4gICAgfSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBcIjwhW0NEQVRBW1wiLmNvbmNhdChub2RlLnZhbHVlLCBcIl1dPlwiKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlU2ltcGxlRWxlbWVudEludG9UZXh0KGFzdFxuICAvKiwgb3B0aW9ucyAqL1xuICApIHtcbiAgICB2YXIgaXNTaW1wbGVFbGVtZW50ID0gZnVuY3Rpb24gaXNTaW1wbGVFbGVtZW50KG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiZWxlbWVudFwiICYmIG5vZGUuYXR0cnMubGVuZ3RoID09PSAwICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIG5vZGUuZmlyc3RDaGlsZC50eXBlID09PSBcInRleHRcIiAmJiAvLyBcXHhBMDogbm9uLWJyZWFraW5nIHdoaXRlc3BhY2VcbiAgICAgICEvW15cXFNcXHhBMF0vLnRlc3Qobm9kZS5jaGlsZHJlblswXS52YWx1ZSkgJiYgIW5vZGUuZmlyc3RDaGlsZC5oYXNMZWFkaW5nU3BhY2VzICYmICFub2RlLmZpcnN0Q2hpbGQuaGFzVHJhaWxpbmdTcGFjZXMgJiYgbm9kZS5pc0xlYWRpbmdTcGFjZVNlbnNpdGl2ZSAmJiAhbm9kZS5oYXNMZWFkaW5nU3BhY2VzICYmIG5vZGUuaXNUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlICYmICFub2RlLmhhc1RyYWlsaW5nU3BhY2VzICYmIG5vZGUucHJldiAmJiBub2RlLnByZXYudHlwZSA9PT0gXCJ0ZXh0XCIgJiYgbm9kZS5uZXh0ICYmIG5vZGUubmV4dC50eXBlID09PSBcInRleHRcIjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGFzdC5tYXAoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBpc1NpbXBsZUVsZW1lbnRSZXN1bHRzID0gbm9kZS5jaGlsZHJlbi5tYXAoaXNTaW1wbGVFbGVtZW50KTtcblxuICAgICAgICBpZiAoaXNTaW1wbGVFbGVtZW50UmVzdWx0cy5zb21lKEJvb2xlYW4pKSB7XG4gICAgICAgICAgdmFyIG5ld0NoaWxkcmVuID0gW107XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG5cbiAgICAgICAgICAgIGlmIChpc1NpbXBsZUVsZW1lbnRSZXN1bHRzW2ldKSB7XG4gICAgICAgICAgICAgIHZhciBsYXN0Q2hpbGQgPSBuZXdDaGlsZHJlbi5wb3AoKTtcbiAgICAgICAgICAgICAgdmFyIG5leHRDaGlsZCA9IG5vZGUuY2hpbGRyZW5bKytpXTtcbiAgICAgICAgICAgICAgdmFyIFBhcnNlU291cmNlU3BhbiA9IG5vZGUuc291cmNlU3Bhbi5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgICAgdmFyIGlzVHJhaWxpbmdTcGFjZVNlbnNpdGl2ZSA9IG5leHRDaGlsZC5pc1RyYWlsaW5nU3BhY2VTZW5zaXRpdmUsXG4gICAgICAgICAgICAgICAgICBoYXNUcmFpbGluZ1NwYWNlcyA9IG5leHRDaGlsZC5oYXNUcmFpbGluZ1NwYWNlcztcbiAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaChsYXN0Q2hpbGQuY2xvbmUoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBsYXN0Q2hpbGQudmFsdWUgKyBcIjxcIi5jb25jYXQoY2hpbGQucmF3TmFtZSwgXCI+XCIpICsgY2hpbGQuZmlyc3RDaGlsZC52YWx1ZSArIFwiPC9cIi5jb25jYXQoY2hpbGQucmF3TmFtZSwgXCI+XCIpICsgbmV4dENoaWxkLnZhbHVlLFxuICAgICAgICAgICAgICAgIHNvdXJjZVNwYW46IG5ldyBQYXJzZVNvdXJjZVNwYW4obGFzdENoaWxkLnNvdXJjZVNwYW4uc3RhcnQsIG5leHRDaGlsZC5zb3VyY2VTcGFuLmVuZCksXG4gICAgICAgICAgICAgICAgaXNUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlOiBpc1RyYWlsaW5nU3BhY2VTZW5zaXRpdmUsXG4gICAgICAgICAgICAgICAgaGFzVHJhaWxpbmdTcGFjZXM6IGhhc1RyYWlsaW5nU3BhY2VzXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBub2RlLmNsb25lKHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBuZXdDaGlsZHJlblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0cmFjdEludGVycG9sYXRpb24oYXN0LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucGFyc2VyID09PSBcImh0bWxcIikge1xuICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG5cbiAgICB2YXIgaW50ZXJwb2xhdGlvblJlZ2V4ID0gL1xce1xceyhbXFxzXFxTXSs/KVxcfVxcfS9nO1xuICAgIHJldHVybiBhc3QubWFwKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBpZiAoIWNhbkhhdmVJbnRlcnBvbGF0aW9uJDEobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdDaGlsZHJlbiA9IFtdO1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBub2RlLmNoaWxkcmVuW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBQYXJzZVNvdXJjZVNwYW4gPSBjaGlsZC5zb3VyY2VTcGFuLmNvbnN0cnVjdG9yO1xuICAgICAgICAgIHZhciBzdGFydFNvdXJjZVNwYW4gPSBjaGlsZC5zb3VyY2VTcGFuLnN0YXJ0O1xuICAgICAgICAgIHZhciBlbmRTb3VyY2VTcGFuID0gbnVsbDtcbiAgICAgICAgICB2YXIgY29tcG9uZW50cyA9IGNoaWxkLnZhbHVlLnNwbGl0KGludGVycG9sYXRpb25SZWdleCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyssIHN0YXJ0U291cmNlU3BhbiA9IGVuZFNvdXJjZVNwYW4pIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbXBvbmVudHNbaV07XG5cbiAgICAgICAgICAgIGlmIChpICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICBlbmRTb3VyY2VTcGFuID0gc3RhcnRTb3VyY2VTcGFuLm1vdmVCeSh2YWx1ZS5sZW5ndGgpO1xuXG4gICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgc291cmNlU3BhbjogbmV3IFBhcnNlU291cmNlU3BhbihzdGFydFNvdXJjZVNwYW4sIGVuZFNvdXJjZVNwYW4pXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZW5kU291cmNlU3BhbiA9IHN0YXJ0U291cmNlU3Bhbi5tb3ZlQnkodmFsdWUubGVuZ3RoICsgNCk7IC8vIGB7e2AgKyBgfX1gXG5cbiAgICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiBcImludGVycG9sYXRpb25cIixcbiAgICAgICAgICAgICAgc291cmNlU3BhbjogbmV3IFBhcnNlU291cmNlU3BhbihzdGFydFNvdXJjZVNwYW4sIGVuZFNvdXJjZVNwYW4pLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogdmFsdWUubGVuZ3RoID09PSAwID8gW10gOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBzb3VyY2VTcGFuOiBuZXcgUGFyc2VTb3VyY2VTcGFuKHN0YXJ0U291cmNlU3Bhbi5tb3ZlQnkoMiksIGVuZFNvdXJjZVNwYW4ubW92ZUJ5KC0yKSlcbiAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yMiA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlLmNsb25lKHtcbiAgICAgICAgY2hpbGRyZW46IG5ld0NoaWxkcmVuXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogLSBhZGQgYGhhc0xlYWRpbmdTcGFjZXNgIGZpZWxkXG4gICAqIC0gYWRkIGBoYXNUcmFpbGluZ1NwYWNlc2AgZmllbGRcbiAgICogLSBhZGQgYGhhc0RhbmdsaW5nU3BhY2VzYCBmaWVsZCBmb3IgcGFyZW50IG5vZGVzXG4gICAqIC0gYWRkIGBpc1doaXRlc3BhY2VTZW5zaXRpdmVgLCBgaXNJbmRlbnRhdGlvblNlbnNpdGl2ZWAgZmllbGQgZm9yIHRleHQgbm9kZXNcbiAgICogLSByZW1vdmUgaW5zZW5zaXRpdmUgd2hpdGVzcGFjZXNcbiAgICovXG5cblxuICBmdW5jdGlvbiBleHRyYWN0V2hpdGVzcGFjZXMoYXN0XG4gIC8qLCBvcHRpb25zKi9cbiAgKSB7XG4gICAgdmFyIFRZUEVfV0hJVEVTUEFDRSA9IFwid2hpdGVzcGFjZVwiO1xuICAgIHJldHVybiBhc3QubWFwKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBub2RlLmNoaWxkcmVuWzBdLnR5cGUgPT09IFwidGV4dFwiICYmIG5vZGUuY2hpbGRyZW5bMF0udmFsdWUudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbm9kZS5jbG9uZSh7XG4gICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgIGhhc0RhbmdsaW5nU3BhY2VzOiBub2RlLmNoaWxkcmVuLmxlbmd0aCAhPT0gMFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzV2hpdGVzcGFjZVNlbnNpdGl2ZSA9IGlzV2hpdGVzcGFjZVNlbnNpdGl2ZU5vZGUkMShub2RlKTtcbiAgICAgIHZhciBpc0luZGVudGF0aW9uU2Vuc2l0aXZlID0gaXNJbmRlbnRhdGlvblNlbnNpdGl2ZU5vZGUkMShub2RlKTtcbiAgICAgIHJldHVybiBub2RlLmNsb25lKHtcbiAgICAgICAgaXNXaGl0ZXNwYWNlU2Vuc2l0aXZlOiBpc1doaXRlc3BhY2VTZW5zaXRpdmUsXG4gICAgICAgIGlzSW5kZW50YXRpb25TZW5zaXRpdmU6IGlzSW5kZW50YXRpb25TZW5zaXRpdmUsXG4gICAgICAgIGNoaWxkcmVuOiBub2RlLmNoaWxkcmVuIC8vIGV4dHJhY3Qgd2hpdGVzcGFjZSBub2Rlc1xuICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChuZXdDaGlsZHJlbiwgY2hpbGQpIHtcbiAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gXCJ0ZXh0XCIgfHwgaXNXaGl0ZXNwYWNlU2Vuc2l0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3Q2hpbGRyZW4uY29uY2F0KGNoaWxkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbG9jYWxDaGlsZHJlbiA9IFtdO1xuXG4gICAgICAgICAgdmFyIF9jaGlsZCR2YWx1ZSRtYXRjaCA9IGNoaWxkLnZhbHVlLm1hdGNoKC9eKFxccyopKFtcXHNcXFNdKj8pKFxccyopJC8pLFxuICAgICAgICAgICAgICBfY2hpbGQkdmFsdWUkbWF0Y2gyID0gX3NsaWNlZFRvQXJyYXkoX2NoaWxkJHZhbHVlJG1hdGNoLCA0KSxcbiAgICAgICAgICAgICAgbGVhZGluZ1NwYWNlcyA9IF9jaGlsZCR2YWx1ZSRtYXRjaDJbMV0sXG4gICAgICAgICAgICAgIHRleHQgPSBfY2hpbGQkdmFsdWUkbWF0Y2gyWzJdLFxuICAgICAgICAgICAgICB0cmFpbGluZ1NwYWNlcyA9IF9jaGlsZCR2YWx1ZSRtYXRjaDJbM107XG5cbiAgICAgICAgICBpZiAobGVhZGluZ1NwYWNlcykge1xuICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZTogVFlQRV9XSElURVNQQUNFXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgUGFyc2VTb3VyY2VTcGFuID0gY2hpbGQuc291cmNlU3Bhbi5jb25zdHJ1Y3RvcjtcblxuICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IHRleHQsXG4gICAgICAgICAgICAgIHNvdXJjZVNwYW46IG5ldyBQYXJzZVNvdXJjZVNwYW4oY2hpbGQuc291cmNlU3Bhbi5zdGFydC5tb3ZlQnkobGVhZGluZ1NwYWNlcy5sZW5ndGgpLCBjaGlsZC5zb3VyY2VTcGFuLmVuZC5tb3ZlQnkoLXRyYWlsaW5nU3BhY2VzLmxlbmd0aCkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHJhaWxpbmdTcGFjZXMpIHtcbiAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGU6IFRZUEVfV0hJVEVTUEFDRVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5ld0NoaWxkcmVuLmNvbmNhdChsb2NhbENoaWxkcmVuKTtcbiAgICAgICAgfSwgW10pIC8vIHNldCBoYXNMZWFkaW5nU3BhY2VzL2hhc1RyYWlsaW5nU3BhY2VzIGFuZCBmaWx0ZXIgd2hpdGVzcGFjZSBub2Rlc1xuICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChuZXdDaGlsZHJlbiwgY2hpbGQsIGksIGNoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFRZUEVfV0hJVEVTUEFDRSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ld0NoaWxkcmVuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBoYXNMZWFkaW5nU3BhY2VzID0gaSAhPT0gMCAmJiBjaGlsZHJlbltpIC0gMV0udHlwZSA9PT0gVFlQRV9XSElURVNQQUNFO1xuICAgICAgICAgIHZhciBoYXNUcmFpbGluZ1NwYWNlcyA9IGkgIT09IGNoaWxkcmVuLmxlbmd0aCAtIDEgJiYgY2hpbGRyZW5baSArIDFdLnR5cGUgPT09IFRZUEVfV0hJVEVTUEFDRTtcbiAgICAgICAgICByZXR1cm4gbmV3Q2hpbGRyZW4uY29uY2F0KE9iamVjdC5hc3NpZ24oe30sIGNoaWxkLCB7XG4gICAgICAgICAgICBoYXNMZWFkaW5nU3BhY2VzOiBoYXNMZWFkaW5nU3BhY2VzLFxuICAgICAgICAgICAgaGFzVHJhaWxpbmdTcGFjZXM6IGhhc1RyYWlsaW5nU3BhY2VzXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9LCBbXSlcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkSXNTZWxmQ2xvc2luZyhhc3RcbiAgLyosIG9wdGlvbnMgKi9cbiAgKSB7XG4gICAgcmV0dXJuIGFzdC5tYXAoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5vZGUsIHtcbiAgICAgICAgaXNTZWxmQ2xvc2luZzogIW5vZGUuY2hpbGRyZW4gfHwgbm9kZS50eXBlID09PSBcImVsZW1lbnRcIiAmJiAobm9kZS50YWdEZWZpbml0aW9uLmlzVm9pZCB8fCAvLyBzZWxmLWNsb3NpbmdcbiAgICAgICAgbm9kZS5zdGFydFNvdXJjZVNwYW4gPT09IG5vZGUuZW5kU291cmNlU3BhbilcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkSGFzSHRtQ29tcG9uZW50Q2xvc2luZ1RhZyhhc3QsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXN0Lm1hcChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUudHlwZSAhPT0gXCJlbGVtZW50XCIgPyBub2RlIDogT2JqZWN0LmFzc2lnbihub2RlLCB7XG4gICAgICAgIGhhc0h0bUNvbXBvbmVudENsb3NpbmdUYWc6IG5vZGUuZW5kU291cmNlU3BhbiAmJiAvXjxcXHMqXFwvXFxzKlxcL1xccyo+JC8udGVzdChvcHRpb25zLm9yaWdpbmFsVGV4dC5zbGljZShub2RlLmVuZFNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0LCBub2RlLmVuZFNvdXJjZVNwYW4uZW5kLm9mZnNldCkpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZENzc0Rpc3BsYXkoYXN0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGFzdC5tYXAoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5vZGUsIHtcbiAgICAgICAgY3NzRGlzcGxheTogZ2V0Tm9kZUNzc1N0eWxlRGlzcGxheSQxKG5vZGUsIG9wdGlvbnMpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogLSBhZGQgYGlzTGVhZGluZ1NwYWNlU2Vuc2l0aXZlYCBmaWVsZFxuICAgKiAtIGFkZCBgaXNUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlYCBmaWVsZFxuICAgKiAtIGFkZCBgaXNEYW5nbGluZ1NwYWNlU2Vuc2l0aXZlYCBmaWVsZCBmb3IgcGFyZW50IG5vZGVzXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYWRkSXNTcGFjZVNlbnNpdGl2ZShhc3RcbiAgLyosIG9wdGlvbnMgKi9cbiAgKSB7XG4gICAgcmV0dXJuIGFzdC5tYXAoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmICghbm9kZS5jaGlsZHJlbikge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBub2RlLmNsb25lKHtcbiAgICAgICAgICBpc0RhbmdsaW5nU3BhY2VTZW5zaXRpdmU6IGlzRGFuZ2xpbmdTcGFjZVNlbnNpdGl2ZU5vZGUkMShub2RlKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGUuY2xvbmUoe1xuICAgICAgICBjaGlsZHJlbjogbm9kZS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNoaWxkLCB7XG4gICAgICAgICAgICBpc0xlYWRpbmdTcGFjZVNlbnNpdGl2ZTogaXNMZWFkaW5nU3BhY2VTZW5zaXRpdmVOb2RlJDEoY2hpbGQpLFxuICAgICAgICAgICAgaXNUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlOiBpc1RyYWlsaW5nU3BhY2VTZW5zaXRpdmVOb2RlJDEoY2hpbGQpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pLm1hcChmdW5jdGlvbiAoY2hpbGQsIGluZGV4LCBjaGlsZHJlbikge1xuICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjaGlsZCwge1xuICAgICAgICAgICAgaXNMZWFkaW5nU3BhY2VTZW5zaXRpdmU6IGluZGV4ID09PSAwID8gY2hpbGQuaXNMZWFkaW5nU3BhY2VTZW5zaXRpdmUgOiBjaGlsZHJlbltpbmRleCAtIDFdLmlzVHJhaWxpbmdTcGFjZVNlbnNpdGl2ZSAmJiBjaGlsZC5pc0xlYWRpbmdTcGFjZVNlbnNpdGl2ZSxcbiAgICAgICAgICAgIGlzVHJhaWxpbmdTcGFjZVNlbnNpdGl2ZTogaW5kZXggPT09IGNoaWxkcmVuLmxlbmd0aCAtIDEgPyBjaGlsZC5pc1RyYWlsaW5nU3BhY2VTZW5zaXRpdmUgOiBjaGlsZHJlbltpbmRleCArIDFdLmlzTGVhZGluZ1NwYWNlU2Vuc2l0aXZlICYmIGNoaWxkLmlzVHJhaWxpbmdTcGFjZVNlbnNpdGl2ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgcHJlcHJvY2Vzc18xID0gcHJlcHJvY2VzcztcblxuICBmdW5jdGlvbiBoYXNQcmFnbWEkMyh0ZXh0KSB7XG4gICAgcmV0dXJuIC9eXFxzKjwhLS1cXHMqQChmb3JtYXR8cHJldHRpZXIpXFxzKi0tPi8udGVzdCh0ZXh0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydFByYWdtYSQ1KHRleHQpIHtcbiAgICByZXR1cm4gXCI8IS0tIEBmb3JtYXQgLS0+XFxuXFxuXCIgKyB0ZXh0LnJlcGxhY2UoL15cXHMqXFxuLywgXCJcIik7XG4gIH1cblxuICB2YXIgcHJhZ21hJDMgPSB7XG4gICAgaGFzUHJhZ21hOiBoYXNQcmFnbWEkMyxcbiAgICBpbnNlcnRQcmFnbWE6IGluc2VydFByYWdtYSQ1XG4gIH07XG5cbiAgdmFyIF9yZXF1aXJlJCQwJGJ1aWxkZXJzJDQgPSBkb2MuYnVpbGRlcnMsXG4gICAgICBjb25jYXQkOCA9IF9yZXF1aXJlJCQwJGJ1aWxkZXJzJDQuY29uY2F0LFxuICAgICAgZ3JvdXAkOCA9IF9yZXF1aXJlJCQwJGJ1aWxkZXJzJDQuZ3JvdXA7XG4gIC8qKlxuICAgKiAgICAgdi1mb3I9XCIuLi4gaW4gLi4uXCJcbiAgICogICAgIHYtZm9yPVwiLi4uIG9mIC4uLlwiXG4gICAqICAgICB2LWZvcj1cIiguLi4sIC4uLikgaW4gLi4uXCJcbiAgICogICAgIHYtZm9yPVwiKC4uLiwgLi4uKSBvZiAuLi5cIlxuICAgKi9cblxuICBmdW5jdGlvbiBwcmludFZ1ZUZvcih2YWx1ZSwgdGV4dFRvRG9jKSB7XG4gICAgdmFyIF9wYXJzZVZ1ZUZvciA9IHBhcnNlVnVlRm9yKHZhbHVlKSxcbiAgICAgICAgbGVmdCA9IF9wYXJzZVZ1ZUZvci5sZWZ0LFxuICAgICAgICBvcGVyYXRvciA9IF9wYXJzZVZ1ZUZvci5vcGVyYXRvcixcbiAgICAgICAgcmlnaHQgPSBfcGFyc2VWdWVGb3IucmlnaHQ7XG5cbiAgICByZXR1cm4gY29uY2F0JDgoW2dyb3VwJDgodGV4dFRvRG9jKFwiZnVuY3Rpb24gXyhcIi5jb25jYXQobGVmdCwgXCIpIHt9XCIpLCB7XG4gICAgICBwYXJzZXI6IFwiYmFiZWxcIixcbiAgICAgIF9faXNWdWVGb3JCaW5kaW5nTGVmdDogdHJ1ZVxuICAgIH0pKSwgXCIgXCIsIG9wZXJhdG9yLCBcIiBcIiwgdGV4dFRvRG9jKHJpZ2h0LCB7XG4gICAgICBwYXJzZXI6IFwiX19qc19leHByZXNzaW9uXCJcbiAgICB9KV0pO1xuICB9IC8vIG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS9ibG9iL3YyLjUuMTcvc3JjL2NvbXBpbGVyL3BhcnNlci9pbmRleC5qcyNMMzcwLUwzODdcblxuXG4gIGZ1bmN0aW9uIHBhcnNlVnVlRm9yKHZhbHVlKSB7XG4gICAgdmFyIGZvckFsaWFzUkUgPSAvKFteXSo/KVxccysoaW58b2YpXFxzKyhbXl0qKS87XG4gICAgdmFyIGZvckl0ZXJhdG9yUkUgPSAvLChbXix9XFxdXSopKD86LChbXix9XFxdXSopKT8kLztcbiAgICB2YXIgc3RyaXBQYXJlbnNSRSA9IC9eXFwofFxcKSQvZztcbiAgICB2YXIgaW5NYXRjaCA9IHZhbHVlLm1hdGNoKGZvckFsaWFzUkUpO1xuXG4gICAgaWYgKCFpbk1hdGNoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIHJlcy5mb3IgPSBpbk1hdGNoWzNdLnRyaW0oKTtcbiAgICB2YXIgYWxpYXMgPSBpbk1hdGNoWzFdLnRyaW0oKS5yZXBsYWNlKHN0cmlwUGFyZW5zUkUsIFwiXCIpO1xuICAgIHZhciBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG5cbiAgICBpZiAoaXRlcmF0b3JNYXRjaCkge1xuICAgICAgcmVzLmFsaWFzID0gYWxpYXMucmVwbGFjZShmb3JJdGVyYXRvclJFLCBcIlwiKTtcbiAgICAgIHJlcy5pdGVyYXRvcjEgPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcblxuICAgICAgaWYgKGl0ZXJhdG9yTWF0Y2hbMl0pIHtcbiAgICAgICAgcmVzLml0ZXJhdG9yMiA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXMuYWxpYXMgPSBhbGlhcztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogXCJcIi5jb25jYXQoW3Jlcy5hbGlhcywgcmVzLml0ZXJhdG9yMSwgcmVzLml0ZXJhdG9yMl0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIsXCIpKSxcbiAgICAgIG9wZXJhdG9yOiBpbk1hdGNoWzJdLFxuICAgICAgcmlnaHQ6IHJlcy5mb3JcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRWdWVTbG90U2NvcGUodmFsdWUsIHRleHRUb0RvYykge1xuICAgIHJldHVybiB0ZXh0VG9Eb2MoXCJmdW5jdGlvbiBfKFwiLmNvbmNhdCh2YWx1ZSwgXCIpIHt9XCIpLCB7XG4gICAgICBwYXJzZXI6IFwiYmFiZWxcIixcbiAgICAgIF9faXNWdWVTbG90U2NvcGU6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVnVlRXZlbnRCaW5kaW5nRXhwcmVzc2lvbihldmVudEJpbmRpbmdWYWx1ZSkge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUvYmxvYi92Mi41LjE3L3NyYy9jb21waWxlci9jb2RlZ2VuL2V2ZW50cy5qcyNMMy1MNFxuICAgIC8vIGFycm93IGZ1bmN0aW9uIG9yIGFub255bW91cyBmdW5jdGlvblxuICAgIHZhciBmbkV4cFJFID0gL14oW1xcdyRfXSt8XFwoW14pXSo/XFwpKVxccyo9PnxeZnVuY3Rpb25cXHMqXFwoLzsgLy8gc2ltcGxlIG1lbWJlciBleHByZXNzaW9uIGNoYWluIChhLCBhLmIsIGFbJ2InXSwgYVtcImJcIl0sIGFbMF0sIGFbYl0pXG5cbiAgICB2YXIgc2ltcGxlUGF0aFJFID0gL15bQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWydbXiddKj8nXXxcXFtcIlteXCJdKj9cIl18XFxbXFxkK118XFxbW0EtWmEtel8kXVtcXHckXSpdKSokLzsgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS9ibG9iL3YyLjUuMTcvc3JjL2NvbXBpbGVyL2hlbHBlcnMuanMjTDEwNFxuXG4gICAgdmFyIHZhbHVlID0gZXZlbnRCaW5kaW5nVmFsdWUudHJpbSgpO1xuICAgIHJldHVybiBmbkV4cFJFLnRlc3QodmFsdWUpIHx8IHNpbXBsZVBhdGhSRS50ZXN0KHZhbHVlKTtcbiAgfVxuXG4gIHZhciBzeW50YXhWdWUgPSB7XG4gICAgaXNWdWVFdmVudEJpbmRpbmdFeHByZXNzaW9uOiBpc1Z1ZUV2ZW50QmluZGluZ0V4cHJlc3Npb24sXG4gICAgcHJpbnRWdWVGb3I6IHByaW50VnVlRm9yLFxuICAgIHByaW50VnVlU2xvdFNjb3BlOiBwcmludFZ1ZVNsb3RTY29wZVxuICB9O1xuXG4gIHZhciBwYXJzZVNyY3NldCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAvKipcbiAgICAgKiBTcmNzZXQgUGFyc2VyXG4gICAgICpcbiAgICAgKiBCeSBBbGV4IEJlbGwgfCAgTUlUIExpY2Vuc2VcbiAgICAgKlxuICAgICAqIEpTIFBhcnNlciBmb3IgdGhlIHN0cmluZyB2YWx1ZSB0aGF0IGFwcGVhcnMgaW4gbWFya3VwIDxpbWcgc3Jjc2V0PVwiaGVyZVwiPlxuICAgICAqXG4gICAgICogQHJldHVybnMgQXJyYXkgW3t1cmw6IF8sIGQ6IF8sIHc6IF8sIGg6X30sIC4uLl1cbiAgICAgKlxuICAgICAqIEJhc2VkIHN1cGVyIGR1cGVyIGNsb3NlbHkgb24gdGhlIHJlZmVyZW5jZSBhbGdvcml0aG0gYXQ6XG4gICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI3BhcnNlLWEtc3Jjc2V0LWF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogTW9zdCBjb21tZW50cyBhcmUgY29waWVkIGluIGRpcmVjdGx5IGZyb20gdGhlIHNwZWNcbiAgICAgKiAoZXhjZXB0IGZvciBjb21tZW50cyBpbiBwYXJlbnMpLlxuICAgICAqL1xuICAgIChmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgICAgaWYgKCBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICAvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLCBidXRcbiAgICAgICAgLy8gb25seSBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG4gICAgICAgIC8vIGxpa2UgTm9kZS5cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxuICAgICAgICByb290LnBhcnNlU3Jjc2V0ID0gZmFjdG9yeSgpO1xuICAgICAgfVxuICAgIH0pKGNvbW1vbmpzR2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyAxLiBMZXQgaW5wdXQgYmUgdGhlIHZhbHVlIHBhc3NlZCB0byB0aGlzIGFsZ29yaXRobS5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGxvZ2dlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5sb2dnZXIgfHwgY29uc29sZTsgLy8gVVRJTElUWSBGVU5DVElPTlNcbiAgICAgICAgLy8gTWFudWFsIGlzIGZhc3RlciB0aGFuIFJlZ0V4XG4gICAgICAgIC8vIGh0dHA6Ly9iam9ybi50aXBsaW5nLmNvbS9zdGF0ZS1hbmQtcmVndWxhci1leHByZXNzaW9ucy1pbi1qYXZhc2NyaXB0XG4gICAgICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL3doaXRlc3BhY2UtY2hhcmFjdGVyLzVcblxuICAgICAgICBmdW5jdGlvbiBpc1NwYWNlKGMpIHtcbiAgICAgICAgICByZXR1cm4gYyA9PT0gXCIgXCIgfHwgLy8gc3BhY2VcbiAgICAgICAgICBjID09PSBcIlxcdFwiIHx8IC8vIGhvcml6b250YWwgdGFiXG4gICAgICAgICAgYyA9PT0gXCJcXG5cIiB8fCAvLyBuZXcgbGluZVxuICAgICAgICAgIGMgPT09IFwiXFxmXCIgfHwgLy8gZm9ybSBmZWVkXG4gICAgICAgICAgYyA9PT0gXCJcXHJcIjsgLy8gY2FycmlhZ2UgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb2xsZWN0Q2hhcmFjdGVycyhyZWdFeCkge1xuICAgICAgICAgIHZhciBjaGFycyxcbiAgICAgICAgICAgICAgbWF0Y2ggPSByZWdFeC5leGVjKGlucHV0LnN1YnN0cmluZyhwb3MpKTtcblxuICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY2hhcnMgPSBtYXRjaFswXTtcbiAgICAgICAgICAgIHBvcyArPSBjaGFycy5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gY2hhcnM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuICAgICAgICAgICAgLy8gKERvbid0IHVzZSBcXHMsIHRvIGF2b2lkIG1hdGNoaW5nIG5vbi1icmVha2luZyBzcGFjZSlcbiAgICAgICAgcmVnZXhMZWFkaW5nU3BhY2VzID0gL15bIFxcdFxcblxcclxcdTAwMGNdKy8sXG4gICAgICAgICAgICByZWdleExlYWRpbmdDb21tYXNPclNwYWNlcyA9IC9eWywgXFx0XFxuXFxyXFx1MDAwY10rLyxcbiAgICAgICAgICAgIHJlZ2V4TGVhZGluZ05vdFNwYWNlcyA9IC9eW14gXFx0XFxuXFxyXFx1MDAwY10rLyxcbiAgICAgICAgICAgIHJlZ2V4VHJhaWxpbmdDb21tYXMgPSAvWyxdKyQvLFxuICAgICAgICAgICAgcmVnZXhOb25OZWdhdGl2ZUludGVnZXIgPSAvXlxcZCskLyxcbiAgICAgICAgICAgIC8vICggUG9zaXRpdmUgb3IgbmVnYXRpdmUgb3IgdW5zaWduZWQgaW50ZWdlcnMgb3IgZGVjaW1hbHMsIHdpdGhvdXQgb3Igd2l0aG91dCBleHBvbmVudHMuXG4gICAgICAgIC8vIE11c3QgaW5jbHVkZSBhdCBsZWFzdCBvbmUgZGlnaXQuXG4gICAgICAgIC8vIEFjY29yZGluZyB0byBzcGVjIHRlc3RzIGFueSBkZWNpbWFsIHBvaW50IG11c3QgYmUgZm9sbG93ZWQgYnkgYSBkaWdpdC5cbiAgICAgICAgLy8gTm8gbGVhZGluZyBwbHVzIHNpZ24gaXMgYWxsb3dlZC4pXG4gICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZnJhc3RydWN0dXJlLmh0bWwjdmFsaWQtZmxvYXRpbmctcG9pbnQtbnVtYmVyXG4gICAgICAgIHJlZ2V4RmxvYXRpbmdQb2ludCA9IC9eLT8oPzpbMC05XSt8WzAtOV0qXFwuWzAtOV0rKSg/OltlRV1bKy1dP1swLTldKyk/JC8sXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBkZXNjcmlwdG9ycyxcbiAgICAgICAgICAgIGN1cnJlbnREZXNjcmlwdG9yLFxuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgLy8gMi4gTGV0IHBvc2l0aW9uIGJlIGEgcG9pbnRlciBpbnRvIGlucHV0LCBpbml0aWFsbHkgcG9pbnRpbmcgYXQgdGhlIHN0YXJ0XG4gICAgICAgIC8vICAgIG9mIHRoZSBzdHJpbmcuXG4gICAgICAgIHBvcyA9IDAsXG4gICAgICAgICAgICAvLyAzLiBMZXQgY2FuZGlkYXRlcyBiZSBhbiBpbml0aWFsbHkgZW1wdHkgc291cmNlIHNldC5cbiAgICAgICAgY2FuZGlkYXRlcyA9IFtdOyAvLyA0LiBTcGxpdHRpbmcgbG9vcDogQ29sbGVjdCBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgdGhhdCBhcmUgc3BhY2VcbiAgICAgICAgLy8gICAgY2hhcmFjdGVycyBvciBVKzAwMkMgQ09NTUEgY2hhcmFjdGVycy4gSWYgYW55IFUrMDAyQyBDT01NQSBjaGFyYWN0ZXJzXG4gICAgICAgIC8vICAgIHdlcmUgY29sbGVjdGVkLCB0aGF0IGlzIGEgcGFyc2UgZXJyb3IuXG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb2xsZWN0Q2hhcmFjdGVycyhyZWdleExlYWRpbmdDb21tYXNPclNwYWNlcyk7IC8vIDUuIElmIHBvc2l0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiBpbnB1dCwgcmV0dXJuIGNhbmRpZGF0ZXMgYW5kIGFib3J0IHRoZXNlIHN0ZXBzLlxuXG4gICAgICAgICAgaWYgKHBvcyA+PSBpbnB1dExlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZXM7IC8vICh3ZSdyZSBkb25lLCB0aGlzIGlzIHRoZSBzb2xlIHJldHVybiBwYXRoKVxuICAgICAgICAgIH0gLy8gNi4gQ29sbGVjdCBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgdGhhdCBhcmUgbm90IHNwYWNlIGNoYXJhY3RlcnMsXG4gICAgICAgICAgLy8gICAgYW5kIGxldCB0aGF0IGJlIHVybC5cblxuXG4gICAgICAgICAgdXJsID0gY29sbGVjdENoYXJhY3RlcnMocmVnZXhMZWFkaW5nTm90U3BhY2VzKTsgLy8gNy4gTGV0IGRlc2NyaXB0b3JzIGJlIGEgbmV3IGVtcHR5IGxpc3QuXG5cbiAgICAgICAgICBkZXNjcmlwdG9ycyA9IFtdOyAvLyA4LiBJZiB1cmwgZW5kcyB3aXRoIGEgVSswMDJDIENPTU1BIGNoYXJhY3RlciAoLCksIGZvbGxvdyB0aGVzZSBzdWJzdGVwczpcbiAgICAgICAgICAvL1x0XHQoMSkuIFJlbW92ZSBhbGwgdHJhaWxpbmcgVSswMDJDIENPTU1BIGNoYXJhY3RlcnMgZnJvbSB1cmwuIElmIHRoaXMgcmVtb3ZlZFxuICAgICAgICAgIC8vICAgICAgICAgbW9yZSB0aGFuIG9uZSBjaGFyYWN0ZXIsIHRoYXQgaXMgYSBwYXJzZSBlcnJvci5cblxuICAgICAgICAgIGlmICh1cmwuc2xpY2UoLTEpID09PSBcIixcIikge1xuICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UocmVnZXhUcmFpbGluZ0NvbW1hcywgXCJcIik7IC8vIChKdW1wIGFoZWFkIHRvIHN0ZXAgOSB0byBza2lwIHRva2VuaXphdGlvbiBhbmQganVzdCBwdXNoIHRoZSBjYW5kaWRhdGUpLlxuXG4gICAgICAgICAgICBwYXJzZURlc2NyaXB0b3JzKCk7IC8vXHRPdGhlcndpc2UsIGZvbGxvdyB0aGVzZSBzdWJzdGVwczpcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9rZW5pemUoKTtcbiAgICAgICAgICB9IC8vIChjbG9zZSBlbHNlIG9mIHN0ZXAgOClcbiAgICAgICAgICAvLyAxNi4gUmV0dXJuIHRvIHRoZSBzdGVwIGxhYmVsZWQgc3BsaXR0aW5nIGxvb3AuXG5cbiAgICAgICAgfSAvLyAoQ2xvc2Ugb2YgYmlnIHdoaWxlIGxvb3AuKVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb2tlbml6ZXMgZGVzY3JpcHRvciBwcm9wZXJ0aWVzIHByaW9yIHRvIHBhcnNpbmdcbiAgICAgICAgICogUmV0dXJucyB1bmRlZmluZWQuXG4gICAgICAgICAqL1xuXG5cbiAgICAgICAgZnVuY3Rpb24gdG9rZW5pemUoKSB7XG4gICAgICAgICAgLy8gOC4xLiBEZXNjcmlwdG9yIHRva2VuaXNlcjogU2tpcCB3aGl0ZXNwYWNlXG4gICAgICAgICAgY29sbGVjdENoYXJhY3RlcnMocmVnZXhMZWFkaW5nU3BhY2VzKTsgLy8gOC4yLiBMZXQgY3VycmVudCBkZXNjcmlwdG9yIGJlIHRoZSBlbXB0eSBzdHJpbmcuXG5cbiAgICAgICAgICBjdXJyZW50RGVzY3JpcHRvciA9IFwiXCI7IC8vIDguMy4gTGV0IHN0YXRlIGJlIGluIGRlc2NyaXB0b3IuXG5cbiAgICAgICAgICBzdGF0ZSA9IFwiaW4gZGVzY3JpcHRvclwiO1xuXG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIC8vIDguNC4gTGV0IGMgYmUgdGhlIGNoYXJhY3RlciBhdCBwb3NpdGlvbi5cbiAgICAgICAgICAgIGMgPSBpbnB1dC5jaGFyQXQocG9zKTsgLy8gIERvIHRoZSBmb2xsb3dpbmcgZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZSBvZiBzdGF0ZS5cbiAgICAgICAgICAgIC8vICBGb3IgdGhlIHB1cnBvc2Ugb2YgdGhpcyBzdGVwLCBcIkVPRlwiIGlzIGEgc3BlY2lhbCBjaGFyYWN0ZXIgcmVwcmVzZW50aW5nXG4gICAgICAgICAgICAvLyAgdGhhdCBwb3NpdGlvbiBpcyBwYXN0IHRoZSBlbmQgb2YgaW5wdXQuXG4gICAgICAgICAgICAvLyBJbiBkZXNjcmlwdG9yXG5cbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gXCJpbiBkZXNjcmlwdG9yXCIpIHtcbiAgICAgICAgICAgICAgLy8gRG8gdGhlIGZvbGxvd2luZywgZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZSBvZiBjOlxuICAgICAgICAgICAgICAvLyBTcGFjZSBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgLy8gSWYgY3VycmVudCBkZXNjcmlwdG9yIGlzIG5vdCBlbXB0eSwgYXBwZW5kIGN1cnJlbnQgZGVzY3JpcHRvciB0b1xuICAgICAgICAgICAgICAvLyBkZXNjcmlwdG9ycyBhbmQgbGV0IGN1cnJlbnQgZGVzY3JpcHRvciBiZSB0aGUgZW1wdHkgc3RyaW5nLlxuICAgICAgICAgICAgICAvLyBTZXQgc3RhdGUgdG8gYWZ0ZXIgZGVzY3JpcHRvci5cbiAgICAgICAgICAgICAgaWYgKGlzU3BhY2UoYykpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudERlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3JzLnB1c2goY3VycmVudERlc2NyaXB0b3IpO1xuICAgICAgICAgICAgICAgICAgY3VycmVudERlc2NyaXB0b3IgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgc3RhdGUgPSBcImFmdGVyIGRlc2NyaXB0b3JcIjtcbiAgICAgICAgICAgICAgICB9IC8vIFUrMDAyQyBDT01NQSAoLClcbiAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHBvc2l0aW9uIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBpbiBpbnB1dC4gSWYgY3VycmVudCBkZXNjcmlwdG9yXG4gICAgICAgICAgICAgICAgLy8gaXMgbm90IGVtcHR5LCBhcHBlbmQgY3VycmVudCBkZXNjcmlwdG9yIHRvIGRlc2NyaXB0b3JzLiBKdW1wIHRvIHRoZSBzdGVwXG4gICAgICAgICAgICAgICAgLy8gbGFiZWxlZCBkZXNjcmlwdG9yIHBhcnNlci5cblxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgcG9zICs9IDE7XG5cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudERlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3JzLnB1c2goY3VycmVudERlc2NyaXB0b3IpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhcnNlRGVzY3JpcHRvcnMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIFUrMDAyOCBMRUZUIFBBUkVOVEhFU0lTICgoKVxuICAgICAgICAgICAgICAgIC8vIEFwcGVuZCBjIHRvIGN1cnJlbnQgZGVzY3JpcHRvci4gU2V0IHN0YXRlIHRvIGluIHBhcmVucy5cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSBcIihcIikge1xuICAgICAgICAgICAgICAgIGN1cnJlbnREZXNjcmlwdG9yID0gY3VycmVudERlc2NyaXB0b3IgKyBjO1xuICAgICAgICAgICAgICAgIHN0YXRlID0gXCJpbiBwYXJlbnNcIjsgLy8gRU9GXG4gICAgICAgICAgICAgICAgLy8gSWYgY3VycmVudCBkZXNjcmlwdG9yIGlzIG5vdCBlbXB0eSwgYXBwZW5kIGN1cnJlbnQgZGVzY3JpcHRvciB0b1xuICAgICAgICAgICAgICAgIC8vIGRlc2NyaXB0b3JzLiBKdW1wIHRvIHRoZSBzdGVwIGxhYmVsZWQgZGVzY3JpcHRvciBwYXJzZXIuXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RGVzY3JpcHRvcikge1xuICAgICAgICAgICAgICAgICAgZGVzY3JpcHRvcnMucHVzaChjdXJyZW50RGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGFyc2VEZXNjcmlwdG9ycygpO1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gQW55dGhpbmcgZWxzZVxuICAgICAgICAgICAgICAgIC8vIEFwcGVuZCBjIHRvIGN1cnJlbnQgZGVzY3JpcHRvci5cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50RGVzY3JpcHRvciA9IGN1cnJlbnREZXNjcmlwdG9yICsgYztcbiAgICAgICAgICAgICAgfSAvLyAoZW5kIFwiaW4gZGVzY3JpcHRvclwiXG4gICAgICAgICAgICAgIC8vIEluIHBhcmVuc1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBcImluIHBhcmVuc1wiKSB7XG4gICAgICAgICAgICAgIC8vIFUrMDAyOSBSSUdIVCBQQVJFTlRIRVNJUyAoKSlcbiAgICAgICAgICAgICAgLy8gQXBwZW5kIGMgdG8gY3VycmVudCBkZXNjcmlwdG9yLiBTZXQgc3RhdGUgdG8gaW4gZGVzY3JpcHRvci5cbiAgICAgICAgICAgICAgaWYgKGMgPT09IFwiKVwiKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudERlc2NyaXB0b3IgPSBjdXJyZW50RGVzY3JpcHRvciArIGM7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBcImluIGRlc2NyaXB0b3JcIjsgLy8gRU9GXG4gICAgICAgICAgICAgICAgLy8gQXBwZW5kIGN1cnJlbnQgZGVzY3JpcHRvciB0byBkZXNjcmlwdG9ycy4gSnVtcCB0byB0aGUgc3RlcCBsYWJlbGVkXG4gICAgICAgICAgICAgICAgLy8gZGVzY3JpcHRvciBwYXJzZXIuXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3JzLnB1c2goY3VycmVudERlc2NyaXB0b3IpO1xuICAgICAgICAgICAgICAgIHBhcnNlRGVzY3JpcHRvcnMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIEFueXRoaW5nIGVsc2VcbiAgICAgICAgICAgICAgICAvLyBBcHBlbmQgYyB0byBjdXJyZW50IGRlc2NyaXB0b3IuXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudERlc2NyaXB0b3IgPSBjdXJyZW50RGVzY3JpcHRvciArIGM7XG4gICAgICAgICAgICAgIH0gLy8gQWZ0ZXIgZGVzY3JpcHRvclxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBcImFmdGVyIGRlc2NyaXB0b3JcIikge1xuICAgICAgICAgICAgICAvLyBEbyB0aGUgZm9sbG93aW5nLCBkZXBlbmRpbmcgb24gdGhlIHZhbHVlIG9mIGM6XG4gICAgICAgICAgICAgIC8vIFNwYWNlIGNoYXJhY3RlcjogU3RheSBpbiB0aGlzIHN0YXRlLlxuICAgICAgICAgICAgICBpZiAoaXNTcGFjZShjKSkgOyBlbHNlIGlmIChjID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VEZXNjcmlwdG9ycygpO1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gQW55dGhpbmcgZWxzZVxuICAgICAgICAgICAgICAgIC8vIFNldCBzdGF0ZSB0byBpbiBkZXNjcmlwdG9yLiBTZXQgcG9zaXRpb24gdG8gdGhlIHByZXZpb3VzIGNoYXJhY3RlciBpbiBpbnB1dC5cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IFwiaW4gZGVzY3JpcHRvclwiO1xuICAgICAgICAgICAgICAgIHBvcyAtPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIEFkdmFuY2UgcG9zaXRpb24gdG8gdGhlIG5leHQgY2hhcmFjdGVyIGluIGlucHV0LlxuXG5cbiAgICAgICAgICAgIHBvcyArPSAxOyAvLyBSZXBlYXQgdGhpcyBzdGVwLlxuICAgICAgICAgIH0gLy8gKGNsb3NlIHdoaWxlIHRydWUgbG9vcClcblxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGRlc2NyaXB0b3IgcHJvcGVydGllcyB0byBhIGNhbmRpZGF0ZSwgcHVzaGVzIHRvIHRoZSBjYW5kaWRhdGVzIGFycmF5XG4gICAgICAgICAqIEByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgICAqL1xuICAgICAgICAvLyBEZWNsYXJlZCBvdXRzaWRlIG9mIHRoZSB3aGlsZSBsb29wIHNvIHRoYXQgaXQncyBvbmx5IGNyZWF0ZWQgb25jZS5cblxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlRGVzY3JpcHRvcnMoKSB7XG4gICAgICAgICAgLy8gOS4gRGVzY3JpcHRvciBwYXJzZXI6IExldCBlcnJvciBiZSBuby5cbiAgICAgICAgICB2YXIgcEVycm9yID0gZmFsc2UsXG4gICAgICAgICAgICAgIC8vIDEwLiBMZXQgd2lkdGggYmUgYWJzZW50LlxuICAgICAgICAgIC8vIDExLiBMZXQgZGVuc2l0eSBiZSBhYnNlbnQuXG4gICAgICAgICAgLy8gMTIuIExldCBmdXR1cmUtY29tcGF0LWggYmUgYWJzZW50LiAoV2UncmUgaW1wbGVtZW50aW5nIGl0IG5vdyBhcyBoKVxuICAgICAgICAgIHcsXG4gICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICAgIGgsXG4gICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgIGNhbmRpZGF0ZSA9IHt9LFxuICAgICAgICAgICAgICBkZXNjLFxuICAgICAgICAgICAgICBsYXN0Q2hhcixcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIGludFZhbCxcbiAgICAgICAgICAgICAgZmxvYXRWYWw7IC8vIDEzLiBGb3IgZWFjaCBkZXNjcmlwdG9yIGluIGRlc2NyaXB0b3JzLCBydW4gdGhlIGFwcHJvcHJpYXRlIHNldCBvZiBzdGVwc1xuICAgICAgICAgIC8vIGZyb20gdGhlIGZvbGxvd2luZyBsaXN0OlxuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRlc2NyaXB0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkZXNjID0gZGVzY3JpcHRvcnNbaV07XG4gICAgICAgICAgICBsYXN0Q2hhciA9IGRlc2NbZGVzYy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhbHVlID0gZGVzYy5zdWJzdHJpbmcoMCwgZGVzYy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGludFZhbCA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgICAgICAgICBmbG9hdFZhbCA9IHBhcnNlRmxvYXQodmFsdWUpOyAvLyBJZiB0aGUgZGVzY3JpcHRvciBjb25zaXN0cyBvZiBhIHZhbGlkIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyIGZvbGxvd2VkIGJ5XG4gICAgICAgICAgICAvLyBhIFUrMDA3NyBMQVRJTiBTTUFMTCBMRVRURVIgVyBjaGFyYWN0ZXJcblxuICAgICAgICAgICAgaWYgKHJlZ2V4Tm9uTmVnYXRpdmVJbnRlZ2VyLnRlc3QodmFsdWUpICYmIGxhc3RDaGFyID09PSBcIndcIikge1xuICAgICAgICAgICAgICAvLyBJZiB3aWR0aCBhbmQgZGVuc2l0eSBhcmUgbm90IGJvdGggYWJzZW50LCB0aGVuIGxldCBlcnJvciBiZSB5ZXMuXG4gICAgICAgICAgICAgIGlmICh3IHx8IGQpIHtcbiAgICAgICAgICAgICAgICBwRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICB9IC8vIEFwcGx5IHRoZSBydWxlcyBmb3IgcGFyc2luZyBub24tbmVnYXRpdmUgaW50ZWdlcnMgdG8gdGhlIGRlc2NyaXB0b3IuXG4gICAgICAgICAgICAgIC8vIElmIHRoZSByZXN1bHQgaXMgemVybywgbGV0IGVycm9yIGJlIHllcy5cbiAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBsZXQgd2lkdGggYmUgdGhlIHJlc3VsdC5cblxuXG4gICAgICAgICAgICAgIGlmIChpbnRWYWwgPT09IDApIHtcbiAgICAgICAgICAgICAgICBwRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHcgPSBpbnRWYWw7XG4gICAgICAgICAgICAgIH0gLy8gSWYgdGhlIGRlc2NyaXB0b3IgY29uc2lzdHMgb2YgYSB2YWxpZCBmbG9hdGluZy1wb2ludCBudW1iZXIgZm9sbG93ZWQgYnlcbiAgICAgICAgICAgICAgLy8gYSBVKzAwNzggTEFUSU4gU01BTEwgTEVUVEVSIFggY2hhcmFjdGVyXG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVnZXhGbG9hdGluZ1BvaW50LnRlc3QodmFsdWUpICYmIGxhc3RDaGFyID09PSBcInhcIikge1xuICAgICAgICAgICAgICAvLyBJZiB3aWR0aCwgZGVuc2l0eSBhbmQgZnV0dXJlLWNvbXBhdC1oIGFyZSBub3QgYWxsIGFic2VudCwgdGhlbiBsZXQgZXJyb3JcbiAgICAgICAgICAgICAgLy8gYmUgeWVzLlxuICAgICAgICAgICAgICBpZiAodyB8fCBkIHx8IGgpIHtcbiAgICAgICAgICAgICAgICBwRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICB9IC8vIEFwcGx5IHRoZSBydWxlcyBmb3IgcGFyc2luZyBmbG9hdGluZy1wb2ludCBudW1iZXIgdmFsdWVzIHRvIHRoZSBkZXNjcmlwdG9yLlxuICAgICAgICAgICAgICAvLyBJZiB0aGUgcmVzdWx0IGlzIGxlc3MgdGhhbiB6ZXJvLCBsZXQgZXJyb3IgYmUgeWVzLiBPdGhlcndpc2UsIGxldCBkZW5zaXR5XG4gICAgICAgICAgICAgIC8vIGJlIHRoZSByZXN1bHQuXG5cblxuICAgICAgICAgICAgICBpZiAoZmxvYXRWYWwgPCAwKSB7XG4gICAgICAgICAgICAgICAgcEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkID0gZmxvYXRWYWw7XG4gICAgICAgICAgICAgIH0gLy8gSWYgdGhlIGRlc2NyaXB0b3IgY29uc2lzdHMgb2YgYSB2YWxpZCBub24tbmVnYXRpdmUgaW50ZWdlciBmb2xsb3dlZCBieVxuICAgICAgICAgICAgICAvLyBhIFUrMDA2OCBMQVRJTiBTTUFMTCBMRVRURVIgSCBjaGFyYWN0ZXJcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChyZWdleE5vbk5lZ2F0aXZlSW50ZWdlci50ZXN0KHZhbHVlKSAmJiBsYXN0Q2hhciA9PT0gXCJoXCIpIHtcbiAgICAgICAgICAgICAgLy8gSWYgaGVpZ2h0IGFuZCBkZW5zaXR5IGFyZSBub3QgYm90aCBhYnNlbnQsIHRoZW4gbGV0IGVycm9yIGJlIHllcy5cbiAgICAgICAgICAgICAgaWYgKGggfHwgZCkge1xuICAgICAgICAgICAgICAgIHBFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgIH0gLy8gQXBwbHkgdGhlIHJ1bGVzIGZvciBwYXJzaW5nIG5vbi1uZWdhdGl2ZSBpbnRlZ2VycyB0byB0aGUgZGVzY3JpcHRvci5cbiAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlc3VsdCBpcyB6ZXJvLCBsZXQgZXJyb3IgYmUgeWVzLiBPdGhlcndpc2UsIGxldCBmdXR1cmUtY29tcGF0LWhcbiAgICAgICAgICAgICAgLy8gYmUgdGhlIHJlc3VsdC5cblxuXG4gICAgICAgICAgICAgIGlmIChpbnRWYWwgPT09IDApIHtcbiAgICAgICAgICAgICAgICBwRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGggPSBpbnRWYWw7XG4gICAgICAgICAgICAgIH0gLy8gQW55dGhpbmcgZWxzZSwgTGV0IGVycm9yIGJlIHllcy5cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIChjbG9zZSBzdGVwIDEzIGZvciBsb29wKVxuICAgICAgICAgIC8vIDE1LiBJZiBlcnJvciBpcyBzdGlsbCBubywgdGhlbiBhcHBlbmQgYSBuZXcgaW1hZ2Ugc291cmNlIHRvIGNhbmRpZGF0ZXMgd2hvc2VcbiAgICAgICAgICAvLyBVUkwgaXMgdXJsLCBhc3NvY2lhdGVkIHdpdGggYSB3aWR0aCB3aWR0aCBpZiBub3QgYWJzZW50IGFuZCBhIHBpeGVsXG4gICAgICAgICAgLy8gZGVuc2l0eSBkZW5zaXR5IGlmIG5vdCBhYnNlbnQuIE90aGVyd2lzZSwgdGhlcmUgaXMgYSBwYXJzZSBlcnJvci5cblxuXG4gICAgICAgICAgaWYgKCFwRXJyb3IpIHtcbiAgICAgICAgICAgIGNhbmRpZGF0ZS51cmwgPSB1cmw7XG5cbiAgICAgICAgICAgIGlmICh3KSB7XG4gICAgICAgICAgICAgIGNhbmRpZGF0ZS53ID0gdztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGQpIHtcbiAgICAgICAgICAgICAgY2FuZGlkYXRlLmQgPSBkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaCkge1xuICAgICAgICAgICAgICBjYW5kaWRhdGUuaCA9IGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaChjYW5kaWRhdGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobG9nZ2VyICYmIGxvZ2dlci5lcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiSW52YWxpZCBzcmNzZXQgZGVzY3JpcHRvciBmb3VuZCBpbiAnXCIgKyBpbnB1dCArIFwiJyBhdCAnXCIgKyBkZXNjICsgXCInLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gKGNsb3NlIHBhcnNlRGVzY3JpcHRvcnMgZm4pXG5cbiAgICAgIH07XG4gICAgfSk7XG4gIH0pO1xuXG4gIHZhciBfcmVxdWlyZSQkMCRidWlsZGVycyQ1ID0gZG9jLmJ1aWxkZXJzLFxuICAgICAgY29uY2F0JDkgPSBfcmVxdWlyZSQkMCRidWlsZGVycyQ1LmNvbmNhdCxcbiAgICAgIGlmQnJlYWskNCA9IF9yZXF1aXJlJCQwJGJ1aWxkZXJzJDUuaWZCcmVhayxcbiAgICAgIGpvaW4kNSA9IF9yZXF1aXJlJCQwJGJ1aWxkZXJzJDUuam9pbixcbiAgICAgIGxpbmUkNCA9IF9yZXF1aXJlJCQwJGJ1aWxkZXJzJDUubGluZTtcblxuICBmdW5jdGlvbiBwcmludEltZ1NyY3NldCh2YWx1ZSkge1xuICAgIHZhciBzcmNzZXQgPSBwYXJzZVNyY3NldCh2YWx1ZSwge1xuICAgICAgbG9nZ2VyOiB7XG4gICAgICAgIGVycm9yOiBmdW5jdGlvbiBlcnJvcihtZXNzYWdlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIGhhc1cgPSBzcmNzZXQuc29tZShmdW5jdGlvbiAoc3JjKSB7XG4gICAgICByZXR1cm4gc3JjLnc7XG4gICAgfSk7XG4gICAgdmFyIGhhc0ggPSBzcmNzZXQuc29tZShmdW5jdGlvbiAoc3JjKSB7XG4gICAgICByZXR1cm4gc3JjLmg7XG4gICAgfSk7XG4gICAgdmFyIGhhc1ggPSBzcmNzZXQuc29tZShmdW5jdGlvbiAoc3JjKSB7XG4gICAgICByZXR1cm4gc3JjLmQ7XG4gICAgfSk7XG5cbiAgICBpZiAoaGFzVyArIGhhc0ggKyBoYXNYICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXhlZCBkZXNjcmlwdG9yIGluIHNyY3NldCBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgIH1cblxuICAgIHZhciBrZXkgPSBoYXNXID8gXCJ3XCIgOiBoYXNIID8gXCJoXCIgOiBcImRcIjtcbiAgICB2YXIgdW5pdCA9IGhhc1cgPyBcIndcIiA6IGhhc0ggPyBcImhcIiA6IFwieFwiO1xuXG4gICAgdmFyIGdldE1heCA9IGZ1bmN0aW9uIGdldE1heCh2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCB2YWx1ZXMpO1xuICAgIH07XG5cbiAgICB2YXIgdXJscyA9IHNyY3NldC5tYXAoZnVuY3Rpb24gKHNyYykge1xuICAgICAgcmV0dXJuIHNyYy51cmw7XG4gICAgfSk7XG4gICAgdmFyIG1heFVybExlbmd0aCA9IGdldE1heCh1cmxzLm1hcChmdW5jdGlvbiAodXJsKSB7XG4gICAgICByZXR1cm4gdXJsLmxlbmd0aDtcbiAgICB9KSk7XG4gICAgdmFyIGRlc2NyaXB0b3JzID0gc3Jjc2V0Lm1hcChmdW5jdGlvbiAoc3JjKSB7XG4gICAgICByZXR1cm4gc3JjW2tleV07XG4gICAgfSkubWFwKGZ1bmN0aW9uIChkZXNjcmlwdG9yKSB7XG4gICAgICByZXR1cm4gZGVzY3JpcHRvciA/IGRlc2NyaXB0b3IudG9TdHJpbmcoKSA6IFwiXCI7XG4gICAgfSk7XG4gICAgdmFyIGRlc2NyaXB0b3JMZWZ0TGVuZ3RocyA9IGRlc2NyaXB0b3JzLm1hcChmdW5jdGlvbiAoZGVzY3JpcHRvcikge1xuICAgICAgdmFyIGluZGV4ID0gZGVzY3JpcHRvci5pbmRleE9mKFwiLlwiKTtcbiAgICAgIHJldHVybiBpbmRleCA9PT0gLTEgPyBkZXNjcmlwdG9yLmxlbmd0aCA6IGluZGV4O1xuICAgIH0pO1xuICAgIHZhciBtYXhEZXNjcmlwdG9yTGVmdExlbmd0aCA9IGdldE1heChkZXNjcmlwdG9yTGVmdExlbmd0aHMpO1xuICAgIHJldHVybiBqb2luJDUoY29uY2F0JDkoW1wiLFwiLCBsaW5lJDRdKSwgdXJscy5tYXAoZnVuY3Rpb24gKHVybCwgaW5kZXgpIHtcbiAgICAgIHZhciBwYXJ0cyA9IFt1cmxdO1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9yc1tpbmRleF07XG5cbiAgICAgIGlmIChkZXNjcmlwdG9yKSB7XG4gICAgICAgIHZhciB1cmxQYWRkaW5nID0gbWF4VXJsTGVuZ3RoIC0gdXJsLmxlbmd0aCArIDE7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yUGFkZGluZyA9IG1heERlc2NyaXB0b3JMZWZ0TGVuZ3RoIC0gZGVzY3JpcHRvckxlZnRMZW5ndGhzW2luZGV4XTtcbiAgICAgICAgdmFyIGFsaWdubWVudCA9IFwiIFwiLnJlcGVhdCh1cmxQYWRkaW5nICsgZGVzY3JpcHRvclBhZGRpbmcpO1xuICAgICAgICBwYXJ0cy5wdXNoKGlmQnJlYWskNChhbGlnbm1lbnQsIFwiIFwiKSwgZGVzY3JpcHRvciArIHVuaXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29uY2F0JDkocGFydHMpO1xuICAgIH0pKTtcbiAgfVxuXG4gIHZhciBzeW50YXhBdHRyaWJ1dGUgPSB7XG4gICAgcHJpbnRJbWdTcmNzZXQ6IHByaW50SW1nU3Jjc2V0XG4gIH07XG5cbiAgdmFyIGJ1aWxkZXJzID0gZG9jLmJ1aWxkZXJzLFxuICAgICAgX3JlcXVpcmUkJDAkdXRpbHMgPSBkb2MudXRpbHMsXG4gICAgICBzdHJpcFRyYWlsaW5nSGFyZGxpbmUkMSA9IF9yZXF1aXJlJCQwJHV0aWxzLnN0cmlwVHJhaWxpbmdIYXJkbGluZSxcbiAgICAgIG1hcERvYyQ0ID0gX3JlcXVpcmUkJDAkdXRpbHMubWFwRG9jO1xuICB2YXIgYnJlYWtQYXJlbnQkMiA9IGJ1aWxkZXJzLmJyZWFrUGFyZW50LFxuICAgICAgZGVkZW50VG9Sb290JDEgPSBidWlsZGVycy5kZWRlbnRUb1Jvb3QsXG4gICAgICBmaWxsJDMgPSBidWlsZGVycy5maWxsLFxuICAgICAgZ3JvdXAkOSA9IGJ1aWxkZXJzLmdyb3VwLFxuICAgICAgaGFyZGxpbmUkNyA9IGJ1aWxkZXJzLmhhcmRsaW5lLFxuICAgICAgaWZCcmVhayQ1ID0gYnVpbGRlcnMuaWZCcmVhayxcbiAgICAgIGluZGVudCQ1ID0gYnVpbGRlcnMuaW5kZW50LFxuICAgICAgam9pbiQ2ID0gYnVpbGRlcnMuam9pbixcbiAgICAgIGxpbmUkNSA9IGJ1aWxkZXJzLmxpbmUsXG4gICAgICBsaXRlcmFsbGluZSQyID0gYnVpbGRlcnMubGl0ZXJhbGxpbmUsXG4gICAgICBtYXJrQXNSb290JDIgPSBidWlsZGVycy5tYXJrQXNSb290LFxuICAgICAgc29mdGxpbmUkNCA9IGJ1aWxkZXJzLnNvZnRsaW5lO1xuICB2YXIgY291bnRDaGFycyQxID0gdXRpbHMkMy5jb3VudENoYXJzLFxuICAgICAgY291bnRQYXJlbnRzJDEgPSB1dGlscyQzLmNvdW50UGFyZW50cyxcbiAgICAgIGRlZGVudFN0cmluZyQxID0gdXRpbHMkMy5kZWRlbnRTdHJpbmcsXG4gICAgICBmb3JjZUJyZWFrQ2hpbGRyZW4kMSA9IHV0aWxzJDMuZm9yY2VCcmVha0NoaWxkcmVuLFxuICAgICAgZm9yY2VCcmVha0NvbnRlbnQkMSA9IHV0aWxzJDMuZm9yY2VCcmVha0NvbnRlbnQsXG4gICAgICBmb3JjZU5leHRFbXB0eUxpbmUkMSA9IHV0aWxzJDMuZm9yY2VOZXh0RW1wdHlMaW5lLFxuICAgICAgZ2V0TGFzdERlc2NlbmRhbnQkMSA9IHV0aWxzJDMuZ2V0TGFzdERlc2NlbmRhbnQsXG4gICAgICBnZXRQcmV0dGllcklnbm9yZUF0dHJpYnV0ZUNvbW1lbnREYXRhJDEgPSB1dGlscyQzLmdldFByZXR0aWVySWdub3JlQXR0cmlidXRlQ29tbWVudERhdGEsXG4gICAgICBoYXNQcmV0dGllcklnbm9yZSQxID0gdXRpbHMkMy5oYXNQcmV0dGllcklnbm9yZSxcbiAgICAgIGluZmVyU2NyaXB0UGFyc2VyJDEgPSB1dGlscyQzLmluZmVyU2NyaXB0UGFyc2VyLFxuICAgICAgaXNTY3JpcHRMaWtlVGFnJDEgPSB1dGlscyQzLmlzU2NyaXB0TGlrZVRhZyxcbiAgICAgIGlzVGV4dExpa2VOb2RlJDEgPSB1dGlscyQzLmlzVGV4dExpa2VOb2RlLFxuICAgICAgbm9ybWFsaXplUGFydHMkMSA9IHV0aWxzJDMubm9ybWFsaXplUGFydHMsXG4gICAgICBwcmVmZXJIYXJkbGluZUFzTGVhZGluZ1NwYWNlcyQxID0gdXRpbHMkMy5wcmVmZXJIYXJkbGluZUFzTGVhZGluZ1NwYWNlcyxcbiAgICAgIHNob3VsZE5vdFByaW50Q2xvc2luZ1RhZyQxID0gdXRpbHMkMy5zaG91bGROb3RQcmludENsb3NpbmdUYWcsXG4gICAgICBzaG91bGRQcmVzZXJ2ZUNvbnRlbnQkMSA9IHV0aWxzJDMuc2hvdWxkUHJlc2VydmVDb250ZW50LFxuICAgICAgdW5lc2NhcGVRdW90ZUVudGl0aWVzJDEgPSB1dGlscyQzLnVuZXNjYXBlUXVvdGVFbnRpdGllcztcbiAgdmFyIHJlcGxhY2VFbmRPZkxpbmVXaXRoJDEgPSB1dGlsLnJlcGxhY2VFbmRPZkxpbmVXaXRoO1xuICB2YXIgaW5zZXJ0UHJhZ21hJDYgPSBwcmFnbWEkMy5pbnNlcnRQcmFnbWE7XG4gIHZhciBwcmludFZ1ZUZvciQxID0gc3ludGF4VnVlLnByaW50VnVlRm9yLFxuICAgICAgcHJpbnRWdWVTbG90U2NvcGUkMSA9IHN5bnRheFZ1ZS5wcmludFZ1ZVNsb3RTY29wZSxcbiAgICAgIGlzVnVlRXZlbnRCaW5kaW5nRXhwcmVzc2lvbiQxID0gc3ludGF4VnVlLmlzVnVlRXZlbnRCaW5kaW5nRXhwcmVzc2lvbjtcbiAgdmFyIHByaW50SW1nU3Jjc2V0JDEgPSBzeW50YXhBdHRyaWJ1dGUucHJpbnRJbWdTcmNzZXQ7XG5cbiAgZnVuY3Rpb24gY29uY2F0JGEocGFydHMpIHtcbiAgICB2YXIgbmV3UGFydHMgPSBub3JtYWxpemVQYXJ0cyQxKHBhcnRzKTtcbiAgICByZXR1cm4gbmV3UGFydHMubGVuZ3RoID09PSAwID8gXCJcIiA6IG5ld1BhcnRzLmxlbmd0aCA9PT0gMSA/IG5ld1BhcnRzWzBdIDogYnVpbGRlcnMuY29uY2F0KG5ld1BhcnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVtYmVkJDIocGF0aCwgcHJpbnQsIHRleHRUb0RvYywgb3B0aW9ucykge1xuICAgIHZhciBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuXG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoaXNTY3JpcHRMaWtlVGFnJDEobm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VyID0gaW5mZXJTY3JpcHRQYXJzZXIkMShub2RlLnBhcmVudCk7XG5cbiAgICAgICAgICAgIGlmIChwYXJzZXIpIHtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcGFyc2VyID09PSBcIm1hcmtkb3duXCIgPyBkZWRlbnRTdHJpbmckMShub2RlLnZhbHVlLnJlcGxhY2UoL15bXlxcU1xcbl0qP1xcbi8sIFwiXCIpKSA6IG5vZGUudmFsdWU7XG4gICAgICAgICAgICAgIHJldHVybiBidWlsZGVycy5jb25jYXQoW2NvbmNhdCRhKFticmVha1BhcmVudCQyLCBwcmludE9wZW5pbmdUYWdQcmVmaXgobm9kZSwgb3B0aW9ucyksIHN0cmlwVHJhaWxpbmdIYXJkbGluZSQxKHRleHRUb0RvYyh2YWx1ZSwge1xuICAgICAgICAgICAgICAgIHBhcnNlcjogcGFyc2VyXG4gICAgICAgICAgICAgIH0pKSwgcHJpbnRDbG9zaW5nVGFnU3VmZml4KG5vZGUsIG9wdGlvbnMpXSldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUucGFyZW50LnR5cGUgPT09IFwiaW50ZXJwb2xhdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0JGEoW2luZGVudCQ1KGNvbmNhdCRhKFtsaW5lJDUsIHRleHRUb0RvYyhub2RlLnZhbHVlLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgX19pc0luSHRtbEludGVycG9sYXRpb246IHRydWUgLy8gdG8gYXZvaWQgdW5leHBlY3RlZCBgfX1gXG5cbiAgICAgICAgICAgIH0sIG9wdGlvbnMucGFyc2VyID09PSBcImFuZ3VsYXJcIiA/IHtcbiAgICAgICAgICAgICAgcGFyc2VyOiBcIl9fbmdfaW50ZXJwb2xhdGlvblwiLFxuICAgICAgICAgICAgICB0cmFpbGluZ0NvbW1hOiBcIm5vbmVcIlxuICAgICAgICAgICAgfSA6IG9wdGlvbnMucGFyc2VyID09PSBcInZ1ZVwiID8ge1xuICAgICAgICAgICAgICBwYXJzZXI6IFwiX192dWVfZXhwcmVzc2lvblwiXG4gICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICBwYXJzZXI6IFwiX19qc19leHByZXNzaW9uXCJcbiAgICAgICAgICAgIH0pKV0pKSwgbm9kZS5wYXJlbnQubmV4dCAmJiBuZWVkc1RvQm9ycm93UHJldkNsb3NpbmdUYWdFbmRNYXJrZXIobm9kZS5wYXJlbnQubmV4dCkgPyBcIiBcIiA6IGxpbmUkNV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJhdHRyaWJ1dGVcIjpcbiAgICAgICAge1xuICAgICAgICAgIGlmICghbm9kZS52YWx1ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSAvLyBsaXQtaHRtbDogaHRtbGA8bXktZWxlbWVudCBvYmo9JHtvYmp9PjwvbXktZWxlbWVudD5gXG5cblxuICAgICAgICAgIGlmICgvXlBSRVRUSUVSX0hUTUxfUExBQ0VIT0xERVJfXFxkK19cXGQrX0lOX0pTJC8udGVzdChvcHRpb25zLm9yaWdpbmFsVGV4dC5zbGljZShub2RlLnZhbHVlU3Bhbi5zdGFydC5vZmZzZXQsIG5vZGUudmFsdWVTcGFuLmVuZC5vZmZzZXQpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCRhKFtub2RlLnJhd05hbWUsIFwiPVwiLCBub2RlLnZhbHVlXSk7XG4gICAgICAgICAgfSAvLyBsd2M6IGh0bWxgPG15LWVsZW1lbnQgZGF0YS1mb3I9e3ZhbHVlfT48L215LWVsZW1lbnQ+YFxuXG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5wYXJzZXIgPT09IFwibHdjXCIpIHtcbiAgICAgICAgICAgIHZhciBpbnRlcnBvbGF0aW9uUmVnZXggPSAvXlxce1tcXHNcXFNdKlxcfSQvO1xuXG4gICAgICAgICAgICBpZiAoaW50ZXJwb2xhdGlvblJlZ2V4LnRlc3Qob3B0aW9ucy5vcmlnaW5hbFRleHQuc2xpY2Uobm9kZS52YWx1ZVNwYW4uc3RhcnQub2Zmc2V0LCBub2RlLnZhbHVlU3Bhbi5lbmQub2Zmc2V0KSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCRhKFtub2RlLnJhd05hbWUsIFwiPVwiLCBub2RlLnZhbHVlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGVtYmVkZGVkQXR0cmlidXRlVmFsdWVEb2MgPSBwcmludEVtYmVkZGVkQXR0cmlidXRlVmFsdWUobm9kZSwgZnVuY3Rpb24gKGNvZGUsIG9wdHMpIHtcbiAgICAgICAgICAgIHJldHVybiAoLy8gc3RyaWN0bHkgcHJlZmVyIHNpbmdsZSBxdW90ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSBodG1sIGVudGl0eSBlc2NhcGVcbiAgICAgICAgICAgICAgdGV4dFRvRG9jKGNvZGUsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIF9faXNJbkh0bWxBdHRyaWJ1dGU6IHRydWVcbiAgICAgICAgICAgICAgfSwgb3B0cykpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgICAgaWYgKGVtYmVkZGVkQXR0cmlidXRlVmFsdWVEb2MpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQkYShbbm9kZS5yYXdOYW1lLCAnPVwiJywgZ3JvdXAkOShtYXBEb2MkNChlbWJlZGRlZEF0dHJpYnV0ZVZhbHVlRG9jLCBmdW5jdGlvbiAoZG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZG9jID09PSBcInN0cmluZ1wiID8gZG9jLnJlcGxhY2UoL1wiL2csIFwiJnF1b3Q7XCIpIDogZG9jO1xuICAgICAgICAgICAgfSkpLCAnXCInXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInlhbWxcIjpcbiAgICAgICAgcmV0dXJuIG1hcmtBc1Jvb3QkMihjb25jYXQkYShbXCItLS1cIiwgaGFyZGxpbmUkNywgbm9kZS52YWx1ZS50cmltKCkubGVuZ3RoID09PSAwID8gXCJcIiA6IHRleHRUb0RvYyhub2RlLnZhbHVlLCB7XG4gICAgICAgICAgcGFyc2VyOiBcInlhbWxcIlxuICAgICAgICB9KSwgXCItLS1cIl0pKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmljUHJpbnQkMihwYXRoLCBvcHRpb25zLCBwcmludCkge1xuICAgIHZhciBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuXG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJyb290XCI6XG4gICAgICAgIC8vIHVzZSBvcmlnaW5hbCBjb25jYXQgdG8gbm90IGJyZWFrIHN0cmlwVHJhaWxpbmdIYXJkbGluZVxuICAgICAgICByZXR1cm4gYnVpbGRlcnMuY29uY2F0KFtncm91cCQ5KHByaW50Q2hpbGRyZW4kMShwYXRoLCBvcHRpb25zLCBwcmludCkpLCBoYXJkbGluZSQ3XSk7XG5cbiAgICAgIGNhc2UgXCJlbGVtZW50XCI6XG4gICAgICBjYXNlIFwiaWVDb25kaXRpb25hbENvbW1lbnRcIjpcbiAgICAgICAge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIGRvIG5vdCBicmVhazpcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqICAgICA8ZGl2Pnt7XG4gICAgICAgICAgICogICAgICAgICB+XG4gICAgICAgICAgICogICAgICAgaW50ZXJwb2xhdGlvblxuICAgICAgICAgICAqICAgICB9fTwvZGl2PlxuICAgICAgICAgICAqICAgICAgICAgICAgflxuICAgICAgICAgICAqXG4gICAgICAgICAgICogZXhjZXB0aW9uOiBicmVhayBpZiB0aGUgb3BlbmluZyB0YWcgYnJlYWtzXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiAgICAgPGRpdlxuICAgICAgICAgICAqICAgICAgIGxvbmdcbiAgICAgICAgICAgKiAgICAgICAgICAgflxuICAgICAgICAgICAqICAgICAgID57e1xuICAgICAgICAgICAqICAgICAgICAgaW50ZXJwb2xhdGlvblxuICAgICAgICAgICAqICAgICAgIH19PC9kaXZcbiAgICAgICAgICAgKiAgICAgICAgICAgICAgflxuICAgICAgICAgICAqICAgICA+XG4gICAgICAgICAgICovXG4gICAgICAgICAgdmFyIHNob3VsZEh1Z0NvbnRlbnQgPSBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBub2RlLmZpcnN0Q2hpbGQudHlwZSA9PT0gXCJpbnRlcnBvbGF0aW9uXCIgJiYgbm9kZS5maXJzdENoaWxkLmlzTGVhZGluZ1NwYWNlU2Vuc2l0aXZlICYmICFub2RlLmZpcnN0Q2hpbGQuaGFzTGVhZGluZ1NwYWNlcyAmJiBub2RlLmxhc3RDaGlsZC5pc1RyYWlsaW5nU3BhY2VTZW5zaXRpdmUgJiYgIW5vZGUubGFzdENoaWxkLmhhc1RyYWlsaW5nU3BhY2VzO1xuICAgICAgICAgIHZhciBhdHRyR3JvdXBJZCA9IFN5bWJvbChcImVsZW1lbnQtYXR0ci1ncm91cC1pZFwiKTtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JGEoW2dyb3VwJDkoY29uY2F0JGEoW2dyb3VwJDkocHJpbnRPcGVuaW5nVGFnKHBhdGgsIG9wdGlvbnMsIHByaW50KSwge1xuICAgICAgICAgICAgaWQ6IGF0dHJHcm91cElkXG4gICAgICAgICAgfSksIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwID8gbm9kZS5oYXNEYW5nbGluZ1NwYWNlcyAmJiBub2RlLmlzRGFuZ2xpbmdTcGFjZVNlbnNpdGl2ZSA/IGxpbmUkNSA6IFwiXCIgOiBjb25jYXQkYShbZm9yY2VCcmVha0NvbnRlbnQkMShub2RlKSA/IGJyZWFrUGFyZW50JDIgOiBcIlwiLCBmdW5jdGlvbiAoY2hpbGRyZW5Eb2MpIHtcbiAgICAgICAgICAgIHJldHVybiBzaG91bGRIdWdDb250ZW50ID8gaWZCcmVhayQ1KGluZGVudCQ1KGNoaWxkcmVuRG9jKSwgY2hpbGRyZW5Eb2MsIHtcbiAgICAgICAgICAgICAgZ3JvdXBJZDogYXR0ckdyb3VwSWRcbiAgICAgICAgICAgIH0pIDogaXNTY3JpcHRMaWtlVGFnJDEobm9kZSkgJiYgbm9kZS5wYXJlbnQudHlwZSA9PT0gXCJyb290XCIgJiYgb3B0aW9ucy5wYXJzZXIgPT09IFwidnVlXCIgJiYgIW9wdGlvbnMudnVlSW5kZW50U2NyaXB0QW5kU3R5bGUgPyBjaGlsZHJlbkRvYyA6IGluZGVudCQ1KGNoaWxkcmVuRG9jKTtcbiAgICAgICAgICB9KGNvbmNhdCRhKFtzaG91bGRIdWdDb250ZW50ID8gaWZCcmVhayQ1KHNvZnRsaW5lJDQsIFwiXCIsIHtcbiAgICAgICAgICAgIGdyb3VwSWQ6IGF0dHJHcm91cElkXG4gICAgICAgICAgfSkgOiBub2RlLmZpcnN0Q2hpbGQuaGFzTGVhZGluZ1NwYWNlcyAmJiBub2RlLmZpcnN0Q2hpbGQuaXNMZWFkaW5nU3BhY2VTZW5zaXRpdmUgPyBsaW5lJDUgOiBub2RlLmZpcnN0Q2hpbGQudHlwZSA9PT0gXCJ0ZXh0XCIgJiYgbm9kZS5pc1doaXRlc3BhY2VTZW5zaXRpdmUgJiYgbm9kZS5pc0luZGVudGF0aW9uU2Vuc2l0aXZlID8gZGVkZW50VG9Sb290JDEoc29mdGxpbmUkNCkgOiBzb2Z0bGluZSQ0LCBwcmludENoaWxkcmVuJDEocGF0aCwgb3B0aW9ucywgcHJpbnQpXSkpLCAobm9kZS5uZXh0ID8gbmVlZHNUb0JvcnJvd1ByZXZDbG9zaW5nVGFnRW5kTWFya2VyKG5vZGUubmV4dCkgOiBuZWVkc1RvQm9ycm93TGFzdENoaWxkQ2xvc2luZ1RhZ0VuZE1hcmtlcihub2RlLnBhcmVudCkpID8gbm9kZS5sYXN0Q2hpbGQuaGFzVHJhaWxpbmdTcGFjZXMgJiYgbm9kZS5sYXN0Q2hpbGQuaXNUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlID8gXCIgXCIgOiBcIlwiIDogc2hvdWxkSHVnQ29udGVudCA/IGlmQnJlYWskNShzb2Z0bGluZSQ0LCBcIlwiLCB7XG4gICAgICAgICAgICBncm91cElkOiBhdHRyR3JvdXBJZFxuICAgICAgICAgIH0pIDogbm9kZS5sYXN0Q2hpbGQuaGFzVHJhaWxpbmdTcGFjZXMgJiYgbm9kZS5sYXN0Q2hpbGQuaXNUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlID8gbGluZSQ1IDogKG5vZGUubGFzdENoaWxkLnR5cGUgPT09IFwiY29tbWVudFwiIHx8IG5vZGUubGFzdENoaWxkLnR5cGUgPT09IFwidGV4dFwiICYmIG5vZGUuaXNXaGl0ZXNwYWNlU2Vuc2l0aXZlICYmIG5vZGUuaXNJbmRlbnRhdGlvblNlbnNpdGl2ZSkgJiYgbmV3IFJlZ0V4cChcIlxcXFxuXFxcXHN7XCIuY29uY2F0KG9wdGlvbnMudGFiV2lkdGggKiBjb3VudFBhcmVudHMkMShwYXRoLCBmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgcmV0dXJuIG4ucGFyZW50ICYmIG4ucGFyZW50LnR5cGUgIT09IFwicm9vdFwiO1xuICAgICAgICAgIH0pLCBcIn0kXCIpKS50ZXN0KG5vZGUubGFzdENoaWxkLnZhbHVlKSA/XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogICAgIDxkaXY+XG4gICAgICAgICAgICogICAgICAgPHByZT5cbiAgICAgICAgICAgKiAgICAgICAgIHNvbWV0aGluZ1xuICAgICAgICAgICAqICAgICAgIDwvcHJlPlxuICAgICAgICAgICAqICAgICAgICAgICAgflxuICAgICAgICAgICAqICAgICA8L2Rpdj5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBcIlwiIDogc29mdGxpbmUkNF0pXSkpLCBwcmludENsb3NpbmdUYWcobm9kZSwgb3B0aW9ucyldKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiaWVDb25kaXRpb25hbFN0YXJ0Q29tbWVudFwiOlxuICAgICAgY2FzZSBcImllQ29uZGl0aW9uYWxFbmRDb21tZW50XCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkYShbcHJpbnRPcGVuaW5nVGFnU3RhcnQobm9kZSksIHByaW50Q2xvc2luZ1RhZ0VuZChub2RlKV0pO1xuXG4gICAgICBjYXNlIFwiaW50ZXJwb2xhdGlvblwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGEoW3ByaW50T3BlbmluZ1RhZ1N0YXJ0KG5vZGUsIG9wdGlvbnMpLCBjb25jYXQkYShwYXRoLm1hcChwcmludCwgXCJjaGlsZHJlblwiKSksIHByaW50Q2xvc2luZ1RhZ0VuZChub2RlLCBvcHRpb25zKV0pO1xuXG4gICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKG5vZGUucGFyZW50LnR5cGUgPT09IFwiaW50ZXJwb2xhdGlvblwiKSB7XG4gICAgICAgICAgICAvLyByZXBsYWNlIHRoZSB0cmFpbGluZyBsaXRlcmFsbGluZSB3aXRoIGhhcmRsaW5lIGZvciBiZXR0ZXIgcmVhZGFiaWxpdHlcbiAgICAgICAgICAgIHZhciB0cmFpbGluZ05ld2xpbmVSZWdleCA9IC9cXG5bXlxcU1xcbl0qPyQvO1xuICAgICAgICAgICAgdmFyIGhhc1RyYWlsaW5nTmV3bGluZSA9IHRyYWlsaW5nTmV3bGluZVJlZ2V4LnRlc3Qobm9kZS52YWx1ZSk7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBoYXNUcmFpbGluZ05ld2xpbmUgPyBub2RlLnZhbHVlLnJlcGxhY2UodHJhaWxpbmdOZXdsaW5lUmVnZXgsIFwiXCIpIDogbm9kZS52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQkYShbY29uY2F0JGEocmVwbGFjZUVuZE9mTGluZVdpdGgkMSh2YWx1ZSwgbGl0ZXJhbGxpbmUkMikpLCBoYXNUcmFpbGluZ05ld2xpbmUgPyBoYXJkbGluZSQ3IDogXCJcIl0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmaWxsJDMobm9ybWFsaXplUGFydHMkMShbXS5jb25jYXQocHJpbnRPcGVuaW5nVGFnUHJlZml4KG5vZGUsIG9wdGlvbnMpLCBnZXRUZXh0VmFsdWVQYXJ0cyhub2RlKSwgcHJpbnRDbG9zaW5nVGFnU3VmZml4KG5vZGUsIG9wdGlvbnMpKSkpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJkb2NUeXBlXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkYShbZ3JvdXAkOShjb25jYXQkYShbcHJpbnRPcGVuaW5nVGFnU3RhcnQobm9kZSwgb3B0aW9ucyksIFwiIFwiLCBub2RlLnZhbHVlLnJlcGxhY2UoL15odG1sXFxiL2ksIFwiaHRtbFwiKS5yZXBsYWNlKC9cXHMrL2csIFwiIFwiKV0pKSwgcHJpbnRDbG9zaW5nVGFnRW5kKG5vZGUsIG9wdGlvbnMpXSk7XG5cbiAgICAgIGNhc2UgXCJjb21tZW50XCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JGEoW3ByaW50T3BlbmluZ1RhZ1ByZWZpeChub2RlLCBvcHRpb25zKSwgY29uY2F0JGEocmVwbGFjZUVuZE9mTGluZVdpdGgkMShvcHRpb25zLm9yaWdpbmFsVGV4dC5zbGljZShvcHRpb25zLmxvY1N0YXJ0KG5vZGUpLCBvcHRpb25zLmxvY0VuZChub2RlKSksIGxpdGVyYWxsaW5lJDIpKSwgcHJpbnRDbG9zaW5nVGFnU3VmZml4KG5vZGUsIG9wdGlvbnMpXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcImF0dHJpYnV0ZVwiOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKG5vZGUudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnJhd05hbWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF92YWx1ZSA9IHVuZXNjYXBlUXVvdGVFbnRpdGllcyQxKG5vZGUudmFsdWUpO1xuXG4gICAgICAgICAgdmFyIHNpbmdsZVF1b3RlQ291bnQgPSBjb3VudENoYXJzJDEoX3ZhbHVlLCBcIidcIik7XG4gICAgICAgICAgdmFyIGRvdWJsZVF1b3RlQ291bnQgPSBjb3VudENoYXJzJDEoX3ZhbHVlLCAnXCInKTtcbiAgICAgICAgICB2YXIgcXVvdGUgPSBzaW5nbGVRdW90ZUNvdW50IDwgZG91YmxlUXVvdGVDb3VudCA/IFwiJ1wiIDogJ1wiJztcbiAgICAgICAgICByZXR1cm4gY29uY2F0JGEoW25vZGUucmF3TmFtZSwgY29uY2F0JGEoW1wiPVwiLCBxdW90ZSwgY29uY2F0JGEocmVwbGFjZUVuZE9mTGluZVdpdGgkMShxdW90ZSA9PT0gJ1wiJyA/IF92YWx1ZS5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKSA6IF92YWx1ZS5yZXBsYWNlKC8nL2csIFwiJmFwb3M7XCIpLCBsaXRlcmFsbGluZSQyKSksIHF1b3RlXSldKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwieWFtbFwiOlxuICAgICAgY2FzZSBcInRvbWxcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRhKHJlcGxhY2VFbmRPZkxpbmVXaXRoJDEobm9kZS5yYXcsIGxpdGVyYWxsaW5lJDIpKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBub2RlIHR5cGUgXCIuY29uY2F0KG5vZGUudHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50Q2hpbGRyZW4kMShwYXRoLCBvcHRpb25zLCBwcmludCkge1xuICAgIHZhciBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuXG4gICAgaWYgKGZvcmNlQnJlYWtDaGlsZHJlbiQxKG5vZGUpKSB7XG4gICAgICByZXR1cm4gY29uY2F0JGEoW2JyZWFrUGFyZW50JDIsIGNvbmNhdCRhKHBhdGgubWFwKGZ1bmN0aW9uIChjaGlsZFBhdGgpIHtcbiAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGNoaWxkUGF0aC5nZXRWYWx1ZSgpO1xuICAgICAgICB2YXIgcHJldkJldHdlZW5MaW5lID0gIWNoaWxkTm9kZS5wcmV2ID8gXCJcIiA6IHByaW50QmV0d2VlbkxpbmUoY2hpbGROb2RlLnByZXYsIGNoaWxkTm9kZSk7XG4gICAgICAgIHJldHVybiBjb25jYXQkYShbIXByZXZCZXR3ZWVuTGluZSA/IFwiXCIgOiBjb25jYXQkYShbcHJldkJldHdlZW5MaW5lLCBmb3JjZU5leHRFbXB0eUxpbmUkMShjaGlsZE5vZGUucHJldikgPyBoYXJkbGluZSQ3IDogXCJcIl0pLCBwcmludENoaWxkKGNoaWxkUGF0aCldKTtcbiAgICAgIH0sIFwiY2hpbGRyZW5cIikpXSk7XG4gICAgfVxuXG4gICAgdmFyIGdyb3VwSWRzID0gbm9kZS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFN5bWJvbChcIlwiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29uY2F0JGEocGF0aC5tYXAoZnVuY3Rpb24gKGNoaWxkUGF0aCwgY2hpbGRJbmRleCkge1xuICAgICAgdmFyIGNoaWxkTm9kZSA9IGNoaWxkUGF0aC5nZXRWYWx1ZSgpO1xuXG4gICAgICBpZiAoaXNUZXh0TGlrZU5vZGUkMShjaGlsZE5vZGUpKSB7XG4gICAgICAgIGlmIChjaGlsZE5vZGUucHJldiAmJiBpc1RleHRMaWtlTm9kZSQxKGNoaWxkTm9kZS5wcmV2KSkge1xuICAgICAgICAgIHZhciBfcHJldkJldHdlZW5MaW5lID0gcHJpbnRCZXR3ZWVuTGluZShjaGlsZE5vZGUucHJldiwgY2hpbGROb2RlKTtcblxuICAgICAgICAgIGlmIChfcHJldkJldHdlZW5MaW5lKSB7XG4gICAgICAgICAgICBpZiAoZm9yY2VOZXh0RW1wdHlMaW5lJDEoY2hpbGROb2RlLnByZXYpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb25jYXQkYShbaGFyZGxpbmUkNywgaGFyZGxpbmUkNywgcHJpbnRDaGlsZChjaGlsZFBhdGgpXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjb25jYXQkYShbX3ByZXZCZXR3ZWVuTGluZSwgcHJpbnRDaGlsZChjaGlsZFBhdGgpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByaW50Q2hpbGQoY2hpbGRQYXRoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZXZQYXJ0cyA9IFtdO1xuICAgICAgdmFyIGxlYWRpbmdQYXJ0cyA9IFtdO1xuICAgICAgdmFyIHRyYWlsaW5nUGFydHMgPSBbXTtcbiAgICAgIHZhciBuZXh0UGFydHMgPSBbXTtcbiAgICAgIHZhciBwcmV2QmV0d2VlbkxpbmUgPSBjaGlsZE5vZGUucHJldiA/IHByaW50QmV0d2VlbkxpbmUoY2hpbGROb2RlLnByZXYsIGNoaWxkTm9kZSkgOiBcIlwiO1xuICAgICAgdmFyIG5leHRCZXR3ZWVuTGluZSA9IGNoaWxkTm9kZS5uZXh0ID8gcHJpbnRCZXR3ZWVuTGluZShjaGlsZE5vZGUsIGNoaWxkTm9kZS5uZXh0KSA6IFwiXCI7XG5cbiAgICAgIGlmIChwcmV2QmV0d2VlbkxpbmUpIHtcbiAgICAgICAgaWYgKGZvcmNlTmV4dEVtcHR5TGluZSQxKGNoaWxkTm9kZS5wcmV2KSkge1xuICAgICAgICAgIHByZXZQYXJ0cy5wdXNoKGhhcmRsaW5lJDcsIGhhcmRsaW5lJDcpO1xuICAgICAgICB9IGVsc2UgaWYgKHByZXZCZXR3ZWVuTGluZSA9PT0gaGFyZGxpbmUkNykge1xuICAgICAgICAgIHByZXZQYXJ0cy5wdXNoKGhhcmRsaW5lJDcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpc1RleHRMaWtlTm9kZSQxKGNoaWxkTm9kZS5wcmV2KSkge1xuICAgICAgICAgICAgbGVhZGluZ1BhcnRzLnB1c2gocHJldkJldHdlZW5MaW5lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVhZGluZ1BhcnRzLnB1c2goaWZCcmVhayQ1KFwiXCIsIHNvZnRsaW5lJDQsIHtcbiAgICAgICAgICAgICAgZ3JvdXBJZDogZ3JvdXBJZHNbY2hpbGRJbmRleCAtIDFdXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0QmV0d2VlbkxpbmUpIHtcbiAgICAgICAgaWYgKGZvcmNlTmV4dEVtcHR5TGluZSQxKGNoaWxkTm9kZSkpIHtcbiAgICAgICAgICBpZiAoaXNUZXh0TGlrZU5vZGUkMShjaGlsZE5vZGUubmV4dCkpIHtcbiAgICAgICAgICAgIG5leHRQYXJ0cy5wdXNoKGhhcmRsaW5lJDcsIGhhcmRsaW5lJDcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChuZXh0QmV0d2VlbkxpbmUgPT09IGhhcmRsaW5lJDcpIHtcbiAgICAgICAgICBpZiAoaXNUZXh0TGlrZU5vZGUkMShjaGlsZE5vZGUubmV4dCkpIHtcbiAgICAgICAgICAgIG5leHRQYXJ0cy5wdXNoKGhhcmRsaW5lJDcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cmFpbGluZ1BhcnRzLnB1c2gobmV4dEJldHdlZW5MaW5lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29uY2F0JGEoW10uY29uY2F0KHByZXZQYXJ0cywgZ3JvdXAkOShjb25jYXQkYShbY29uY2F0JGEobGVhZGluZ1BhcnRzKSwgZ3JvdXAkOShjb25jYXQkYShbcHJpbnRDaGlsZChjaGlsZFBhdGgpLCBjb25jYXQkYSh0cmFpbGluZ1BhcnRzKV0pLCB7XG4gICAgICAgIGlkOiBncm91cElkc1tjaGlsZEluZGV4XVxuICAgICAgfSldKSksIG5leHRQYXJ0cykpO1xuICAgIH0sIFwiY2hpbGRyZW5cIikpO1xuXG4gICAgZnVuY3Rpb24gcHJpbnRDaGlsZChjaGlsZFBhdGgpIHtcbiAgICAgIHZhciBjaGlsZCA9IGNoaWxkUGF0aC5nZXRWYWx1ZSgpO1xuXG4gICAgICBpZiAoaGFzUHJldHRpZXJJZ25vcmUkMShjaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRhKFtdLmNvbmNhdChwcmludE9wZW5pbmdUYWdQcmVmaXgoY2hpbGQsIG9wdGlvbnMpLCByZXBsYWNlRW5kT2ZMaW5lV2l0aCQxKG9wdGlvbnMub3JpZ2luYWxUZXh0LnNsaWNlKG9wdGlvbnMubG9jU3RhcnQoY2hpbGQpICsgKGNoaWxkLnByZXYgJiYgbmVlZHNUb0JvcnJvd05leHRPcGVuaW5nVGFnU3RhcnRNYXJrZXIoY2hpbGQucHJldikgPyBwcmludE9wZW5pbmdUYWdTdGFydE1hcmtlcihjaGlsZCkubGVuZ3RoIDogMCksIG9wdGlvbnMubG9jRW5kKGNoaWxkKSAtIChjaGlsZC5uZXh0ICYmIG5lZWRzVG9Cb3Jyb3dQcmV2Q2xvc2luZ1RhZ0VuZE1hcmtlcihjaGlsZC5uZXh0KSA/IHByaW50Q2xvc2luZ1RhZ0VuZE1hcmtlcihjaGlsZCwgb3B0aW9ucykubGVuZ3RoIDogMCkpLCBsaXRlcmFsbGluZSQyKSwgcHJpbnRDbG9zaW5nVGFnU3VmZml4KGNoaWxkLCBvcHRpb25zKSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkUHJlc2VydmVDb250ZW50JDEoY2hpbGQsIG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBjb25jYXQkYShbXS5jb25jYXQocHJpbnRPcGVuaW5nVGFnUHJlZml4KGNoaWxkLCBvcHRpb25zKSwgZ3JvdXAkOShwcmludE9wZW5pbmdUYWcoY2hpbGRQYXRoLCBvcHRpb25zLCBwcmludCkpLCByZXBsYWNlRW5kT2ZMaW5lV2l0aCQxKG9wdGlvbnMub3JpZ2luYWxUZXh0LnNsaWNlKGNoaWxkLnN0YXJ0U291cmNlU3Bhbi5lbmQub2Zmc2V0ICsgKGNoaWxkLmZpcnN0Q2hpbGQgJiYgbmVlZHNUb0JvcnJvd1BhcmVudE9wZW5pbmdUYWdFbmRNYXJrZXIoY2hpbGQuZmlyc3RDaGlsZCkgPyAtcHJpbnRPcGVuaW5nVGFnRW5kTWFya2VyKGNoaWxkKS5sZW5ndGggOiAwKSwgY2hpbGQuZW5kU291cmNlU3Bhbi5zdGFydC5vZmZzZXQgKyAoY2hpbGQubGFzdENoaWxkICYmIG5lZWRzVG9Cb3Jyb3dQYXJlbnRDbG9zaW5nVGFnU3RhcnRNYXJrZXIoY2hpbGQubGFzdENoaWxkKSA/IHByaW50Q2xvc2luZ1RhZ1N0YXJ0TWFya2VyKGNoaWxkLCBvcHRpb25zKS5sZW5ndGggOiBuZWVkc1RvQm9ycm93TGFzdENoaWxkQ2xvc2luZ1RhZ0VuZE1hcmtlcihjaGlsZCkgPyAtcHJpbnRDbG9zaW5nVGFnRW5kTWFya2VyKGNoaWxkLmxhc3RDaGlsZCwgb3B0aW9ucykubGVuZ3RoIDogMCkpLCBsaXRlcmFsbGluZSQyKSwgcHJpbnRDbG9zaW5nVGFnKGNoaWxkLCBvcHRpb25zKSwgcHJpbnRDbG9zaW5nVGFnU3VmZml4KGNoaWxkLCBvcHRpb25zKSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJpbnQoY2hpbGRQYXRoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmludEJldHdlZW5MaW5lKHByZXZOb2RlLCBuZXh0Tm9kZSkge1xuICAgICAgcmV0dXJuIGlzVGV4dExpa2VOb2RlJDEocHJldk5vZGUpICYmIGlzVGV4dExpa2VOb2RlJDEobmV4dE5vZGUpID8gcHJldk5vZGUuaXNUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlID8gcHJldk5vZGUuaGFzVHJhaWxpbmdTcGFjZXMgPyBwcmVmZXJIYXJkbGluZUFzTGVhZGluZ1NwYWNlcyQxKG5leHROb2RlKSA/IGhhcmRsaW5lJDcgOiBsaW5lJDUgOiBcIlwiIDogcHJlZmVySGFyZGxpbmVBc0xlYWRpbmdTcGFjZXMkMShuZXh0Tm9kZSkgPyBoYXJkbGluZSQ3IDogc29mdGxpbmUkNCA6IG5lZWRzVG9Cb3Jyb3dOZXh0T3BlbmluZ1RhZ1N0YXJ0TWFya2VyKHByZXZOb2RlKSAmJiAoXG4gICAgICAvKipcbiAgICAgICAqICAgICAxMjM8YVxuICAgICAgICogICAgICAgICAgflxuICAgICAgICogICAgICAgPjxiPlxuICAgICAgICovXG4gICAgICBuZXh0Tm9kZS5maXJzdENoaWxkIHx8XG4gICAgICAvKipcbiAgICAgICAqICAgICAxMjM8IS0tXG4gICAgICAgKiAgICAgICAgICAgIH5cbiAgICAgICAqICAgICAtLT5cbiAgICAgICAqL1xuICAgICAgbmV4dE5vZGUuaXNTZWxmQ2xvc2luZyB8fFxuICAgICAgLyoqXG4gICAgICAgKiAgICAgMTIzPHNwYW5cbiAgICAgICAqICAgICAgICAgICAgIH5cbiAgICAgICAqICAgICAgIGF0dHJcbiAgICAgICAqL1xuICAgICAgbmV4dE5vZGUudHlwZSA9PT0gXCJlbGVtZW50XCIgJiYgbmV4dE5vZGUuYXR0cnMubGVuZ3RoICE9PSAwKSB8fFxuICAgICAgLyoqXG4gICAgICAgKiAgICAgPGltZ1xuICAgICAgICogICAgICAgc3JjPVwibG9uZ1wiXG4gICAgICAgKiAgICAgICAgICAgICAgICAgflxuICAgICAgICogICAgIC8+MTIzXG4gICAgICAgKi9cbiAgICAgIHByZXZOb2RlLnR5cGUgPT09IFwiZWxlbWVudFwiICYmIHByZXZOb2RlLmlzU2VsZkNsb3NpbmcgJiYgbmVlZHNUb0JvcnJvd1ByZXZDbG9zaW5nVGFnRW5kTWFya2VyKG5leHROb2RlKSA/IFwiXCIgOiAhbmV4dE5vZGUuaXNMZWFkaW5nU3BhY2VTZW5zaXRpdmUgfHwgcHJlZmVySGFyZGxpbmVBc0xlYWRpbmdTcGFjZXMkMShuZXh0Tm9kZSkgfHxcbiAgICAgIC8qKlxuICAgICAgICogICAgICAgV2FudCB0byB3cml0ZSB1cyBhIGxldHRlcj8gVXNlIG91cjxhXG4gICAgICAgKiAgICAgICAgID48Yj48YT5tYWlsaW5nIGFkZHJlc3M8L2E+PC9iPjwvYVxuICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB+XG4gICAgICAgKiAgICAgICA+LlxuICAgICAgICovXG4gICAgICBuZWVkc1RvQm9ycm93UHJldkNsb3NpbmdUYWdFbmRNYXJrZXIobmV4dE5vZGUpICYmIHByZXZOb2RlLmxhc3RDaGlsZCAmJiBuZWVkc1RvQm9ycm93UGFyZW50Q2xvc2luZ1RhZ1N0YXJ0TWFya2VyKHByZXZOb2RlLmxhc3RDaGlsZCkgJiYgcHJldk5vZGUubGFzdENoaWxkLmxhc3RDaGlsZCAmJiBuZWVkc1RvQm9ycm93UGFyZW50Q2xvc2luZ1RhZ1N0YXJ0TWFya2VyKHByZXZOb2RlLmxhc3RDaGlsZC5sYXN0Q2hpbGQpID8gaGFyZGxpbmUkNyA6IG5leHROb2RlLmhhc0xlYWRpbmdTcGFjZXMgPyBsaW5lJDUgOiBzb2Z0bGluZSQ0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50T3BlbmluZ1RhZyhwYXRoLCBvcHRpb25zLCBwcmludCkge1xuICAgIHZhciBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIHZhciBmb3JjZU5vdFRvQnJlYWtBdHRyQ29udGVudCA9IG5vZGUudHlwZSA9PT0gXCJlbGVtZW50XCIgJiYgbm9kZS5mdWxsTmFtZSA9PT0gXCJzY3JpcHRcIiAmJiBub2RlLmF0dHJzLmxlbmd0aCA9PT0gMSAmJiBub2RlLmF0dHJzWzBdLmZ1bGxOYW1lID09PSBcInNyY1wiICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwO1xuICAgIHJldHVybiBjb25jYXQkYShbcHJpbnRPcGVuaW5nVGFnU3RhcnQobm9kZSwgb3B0aW9ucyksICFub2RlLmF0dHJzIHx8IG5vZGUuYXR0cnMubGVuZ3RoID09PSAwID8gbm9kZS5pc1NlbGZDbG9zaW5nID9cbiAgICAvKipcbiAgICAgKiAgICAgPGJyIC8+XG4gICAgICogICAgICAgIF5cbiAgICAgKi9cbiAgICBcIiBcIiA6IFwiXCIgOiBjb25jYXQkYShbaW5kZW50JDUoY29uY2F0JGEoW2ZvcmNlTm90VG9CcmVha0F0dHJDb250ZW50ID8gXCIgXCIgOiBsaW5lJDUsIGpvaW4kNihsaW5lJDUsIGZ1bmN0aW9uIChpZ25vcmVBdHRyaWJ1dGVEYXRhKSB7XG4gICAgICB2YXIgaGFzUHJldHRpZXJJZ25vcmVBdHRyaWJ1dGUgPSB0eXBlb2YgaWdub3JlQXR0cmlidXRlRGF0YSA9PT0gXCJib29sZWFuXCIgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpZ25vcmVBdHRyaWJ1dGVEYXRhO1xuICAgICAgfSA6IEFycmF5LmlzQXJyYXkoaWdub3JlQXR0cmlidXRlRGF0YSkgPyBmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICByZXR1cm4gaWdub3JlQXR0cmlidXRlRGF0YS5pbmRleE9mKGF0dHIucmF3TmFtZSkgIT09IC0xO1xuICAgICAgfSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBwYXRoLm1hcChmdW5jdGlvbiAoYXR0clBhdGgpIHtcbiAgICAgICAgdmFyIGF0dHIgPSBhdHRyUGF0aC5nZXRWYWx1ZSgpO1xuICAgICAgICByZXR1cm4gaGFzUHJldHRpZXJJZ25vcmVBdHRyaWJ1dGUoYXR0cikgPyBjb25jYXQkYShyZXBsYWNlRW5kT2ZMaW5lV2l0aCQxKG9wdGlvbnMub3JpZ2luYWxUZXh0LnNsaWNlKG9wdGlvbnMubG9jU3RhcnQoYXR0ciksIG9wdGlvbnMubG9jRW5kKGF0dHIpKSwgbGl0ZXJhbGxpbmUkMikpIDogcHJpbnQoYXR0clBhdGgpO1xuICAgICAgfSwgXCJhdHRyc1wiKTtcbiAgICB9KG5vZGUucHJldiAmJiBub2RlLnByZXYudHlwZSA9PT0gXCJjb21tZW50XCIgJiYgZ2V0UHJldHRpZXJJZ25vcmVBdHRyaWJ1dGVDb21tZW50RGF0YSQxKG5vZGUucHJldi52YWx1ZSkpKV0pKSxcbiAgICAvKipcbiAgICAgKiAgICAgMTIzPGFcbiAgICAgKiAgICAgICBhdHRyXG4gICAgICogICAgICAgICAgIH5cbiAgICAgKiAgICAgICA+NDU2XG4gICAgICovXG4gICAgbm9kZS5maXJzdENoaWxkICYmIG5lZWRzVG9Cb3Jyb3dQYXJlbnRPcGVuaW5nVGFnRW5kTWFya2VyKG5vZGUuZmlyc3RDaGlsZCkgfHxcbiAgICAvKipcbiAgICAgKiAgICAgPHNwYW5cbiAgICAgKiAgICAgICA+MTIzPG1ldGFcbiAgICAgKiAgICAgICAgICAgICAgICB+XG4gICAgICogICAgIC8+PC9zcGFuPlxuICAgICAqL1xuICAgIG5vZGUuaXNTZWxmQ2xvc2luZyAmJiBuZWVkc1RvQm9ycm93TGFzdENoaWxkQ2xvc2luZ1RhZ0VuZE1hcmtlcihub2RlLnBhcmVudCkgPyBcIlwiIDogbm9kZS5pc1NlbGZDbG9zaW5nID8gZm9yY2VOb3RUb0JyZWFrQXR0ckNvbnRlbnQgPyBcIiBcIiA6IGxpbmUkNSA6IGZvcmNlTm90VG9CcmVha0F0dHJDb250ZW50ID8gXCJcIiA6IHNvZnRsaW5lJDRdKSwgbm9kZS5pc1NlbGZDbG9zaW5nID8gXCJcIiA6IHByaW50T3BlbmluZ1RhZ0VuZChub2RlKV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRPcGVuaW5nVGFnU3RhcnQobm9kZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBub2RlLnByZXYgJiYgbmVlZHNUb0JvcnJvd05leHRPcGVuaW5nVGFnU3RhcnRNYXJrZXIobm9kZS5wcmV2KSA/IFwiXCIgOiBjb25jYXQkYShbcHJpbnRPcGVuaW5nVGFnUHJlZml4KG5vZGUsIG9wdGlvbnMpLCBwcmludE9wZW5pbmdUYWdTdGFydE1hcmtlcihub2RlKV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRPcGVuaW5nVGFnRW5kKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5maXJzdENoaWxkICYmIG5lZWRzVG9Cb3Jyb3dQYXJlbnRPcGVuaW5nVGFnRW5kTWFya2VyKG5vZGUuZmlyc3RDaGlsZCkgPyBcIlwiIDogcHJpbnRPcGVuaW5nVGFnRW5kTWFya2VyKG5vZGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRDbG9zaW5nVGFnKG5vZGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gY29uY2F0JGEoW25vZGUuaXNTZWxmQ2xvc2luZyA/IFwiXCIgOiBwcmludENsb3NpbmdUYWdTdGFydChub2RlLCBvcHRpb25zKSwgcHJpbnRDbG9zaW5nVGFnRW5kKG5vZGUsIG9wdGlvbnMpXSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludENsb3NpbmdUYWdTdGFydChub2RlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5vZGUubGFzdENoaWxkICYmIG5lZWRzVG9Cb3Jyb3dQYXJlbnRDbG9zaW5nVGFnU3RhcnRNYXJrZXIobm9kZS5sYXN0Q2hpbGQpID8gXCJcIiA6IGNvbmNhdCRhKFtwcmludENsb3NpbmdUYWdQcmVmaXgobm9kZSwgb3B0aW9ucyksIHByaW50Q2xvc2luZ1RhZ1N0YXJ0TWFya2VyKG5vZGUsIG9wdGlvbnMpXSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludENsb3NpbmdUYWdFbmQobm9kZSwgb3B0aW9ucykge1xuICAgIHJldHVybiAobm9kZS5uZXh0ID8gbmVlZHNUb0JvcnJvd1ByZXZDbG9zaW5nVGFnRW5kTWFya2VyKG5vZGUubmV4dCkgOiBuZWVkc1RvQm9ycm93TGFzdENoaWxkQ2xvc2luZ1RhZ0VuZE1hcmtlcihub2RlLnBhcmVudCkpID8gXCJcIiA6IGNvbmNhdCRhKFtwcmludENsb3NpbmdUYWdFbmRNYXJrZXIobm9kZSwgb3B0aW9ucyksIHByaW50Q2xvc2luZ1RhZ1N1ZmZpeChub2RlLCBvcHRpb25zKV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbmVlZHNUb0JvcnJvd05leHRPcGVuaW5nVGFnU3RhcnRNYXJrZXIobm9kZSkge1xuICAgIC8qKlxuICAgICAqICAgICAxMjM8cFxuICAgICAqICAgICAgICBeXlxuICAgICAqICAgICA+XG4gICAgICovXG4gICAgcmV0dXJuIG5vZGUubmV4dCAmJiAhaXNUZXh0TGlrZU5vZGUkMShub2RlLm5leHQpICYmIGlzVGV4dExpa2VOb2RlJDEobm9kZSkgJiYgbm9kZS5pc1RyYWlsaW5nU3BhY2VTZW5zaXRpdmUgJiYgIW5vZGUuaGFzVHJhaWxpbmdTcGFjZXM7XG4gIH1cblxuICBmdW5jdGlvbiBuZWVkc1RvQm9ycm93UGFyZW50T3BlbmluZ1RhZ0VuZE1hcmtlcihub2RlKSB7XG4gICAgLyoqXG4gICAgICogICAgIDxwXG4gICAgICogICAgICAgPjEyM1xuICAgICAqICAgICAgIF5cbiAgICAgKlxuICAgICAqICAgICA8cFxuICAgICAqICAgICAgID48YVxuICAgICAqICAgICAgIF5cbiAgICAgKi9cbiAgICByZXR1cm4gIW5vZGUucHJldiAmJiBub2RlLmlzTGVhZGluZ1NwYWNlU2Vuc2l0aXZlICYmICFub2RlLmhhc0xlYWRpbmdTcGFjZXM7XG4gIH1cblxuICBmdW5jdGlvbiBuZWVkc1RvQm9ycm93UHJldkNsb3NpbmdUYWdFbmRNYXJrZXIobm9kZSkge1xuICAgIC8qKlxuICAgICAqICAgICA8cD48L3BcbiAgICAgKiAgICAgPjEyM1xuICAgICAqICAgICBeXG4gICAgICpcbiAgICAgKiAgICAgPHA+PC9wXG4gICAgICogICAgID48YVxuICAgICAqICAgICBeXG4gICAgICovXG4gICAgcmV0dXJuIG5vZGUucHJldiAmJiAhaXNUZXh0TGlrZU5vZGUkMShub2RlLnByZXYpICYmIG5vZGUuaXNMZWFkaW5nU3BhY2VTZW5zaXRpdmUgJiYgIW5vZGUuaGFzTGVhZGluZ1NwYWNlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIG5lZWRzVG9Cb3Jyb3dMYXN0Q2hpbGRDbG9zaW5nVGFnRW5kTWFya2VyKG5vZGUpIHtcbiAgICAvKipcbiAgICAgKiAgICAgPHBcbiAgICAgKiAgICAgICA+PGE+PC9hXG4gICAgICogICAgICAgPjwvcFxuICAgICAqICAgICAgIF5cbiAgICAgKiAgICAgPlxuICAgICAqL1xuICAgIHJldHVybiBub2RlLmxhc3RDaGlsZCAmJiBub2RlLmxhc3RDaGlsZC5pc1RyYWlsaW5nU3BhY2VTZW5zaXRpdmUgJiYgIW5vZGUubGFzdENoaWxkLmhhc1RyYWlsaW5nU3BhY2VzICYmICFpc1RleHRMaWtlTm9kZSQxKGdldExhc3REZXNjZW5kYW50JDEobm9kZS5sYXN0Q2hpbGQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5lZWRzVG9Cb3Jyb3dQYXJlbnRDbG9zaW5nVGFnU3RhcnRNYXJrZXIobm9kZSkge1xuICAgIC8qKlxuICAgICAqICAgICA8cD5cbiAgICAgKiAgICAgICAxMjM8L3BcbiAgICAgKiAgICAgICAgICBeXl5cbiAgICAgKiAgICAgPlxuICAgICAqXG4gICAgICogICAgICAgICAxMjM8L2JcbiAgICAgKiAgICAgICA+PC9hXG4gICAgICogICAgICAgIF5eXlxuICAgICAqICAgICA+XG4gICAgICovXG4gICAgcmV0dXJuICFub2RlLm5leHQgJiYgIW5vZGUuaGFzVHJhaWxpbmdTcGFjZXMgJiYgbm9kZS5pc1RyYWlsaW5nU3BhY2VTZW5zaXRpdmUgJiYgaXNUZXh0TGlrZU5vZGUkMShnZXRMYXN0RGVzY2VuZGFudCQxKG5vZGUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50T3BlbmluZ1RhZ1ByZWZpeChub2RlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5lZWRzVG9Cb3Jyb3dQYXJlbnRPcGVuaW5nVGFnRW5kTWFya2VyKG5vZGUpID8gcHJpbnRPcGVuaW5nVGFnRW5kTWFya2VyKG5vZGUucGFyZW50KSA6IG5lZWRzVG9Cb3Jyb3dQcmV2Q2xvc2luZ1RhZ0VuZE1hcmtlcihub2RlKSA/IHByaW50Q2xvc2luZ1RhZ0VuZE1hcmtlcihub2RlLnByZXYsIG9wdGlvbnMpIDogXCJcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50Q2xvc2luZ1RhZ1ByZWZpeChub2RlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5lZWRzVG9Cb3Jyb3dMYXN0Q2hpbGRDbG9zaW5nVGFnRW5kTWFya2VyKG5vZGUpID8gcHJpbnRDbG9zaW5nVGFnRW5kTWFya2VyKG5vZGUubGFzdENoaWxkLCBvcHRpb25zKSA6IFwiXCI7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludENsb3NpbmdUYWdTdWZmaXgobm9kZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZWVkc1RvQm9ycm93UGFyZW50Q2xvc2luZ1RhZ1N0YXJ0TWFya2VyKG5vZGUpID8gcHJpbnRDbG9zaW5nVGFnU3RhcnRNYXJrZXIobm9kZS5wYXJlbnQsIG9wdGlvbnMpIDogbmVlZHNUb0JvcnJvd05leHRPcGVuaW5nVGFnU3RhcnRNYXJrZXIobm9kZSkgPyBwcmludE9wZW5pbmdUYWdTdGFydE1hcmtlcihub2RlLm5leHQpIDogXCJcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50T3BlbmluZ1RhZ1N0YXJ0TWFya2VyKG5vZGUpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcImllQ29uZGl0aW9uYWxDb21tZW50XCI6XG4gICAgICBjYXNlIFwiaWVDb25kaXRpb25hbFN0YXJ0Q29tbWVudFwiOlxuICAgICAgICByZXR1cm4gXCI8IS0tW2lmIFwiLmNvbmNhdChub2RlLmNvbmRpdGlvbik7XG5cbiAgICAgIGNhc2UgXCJpZUNvbmRpdGlvbmFsRW5kQ29tbWVudFwiOlxuICAgICAgICByZXR1cm4gXCI8IS0tPCFcIjtcblxuICAgICAgY2FzZSBcImludGVycG9sYXRpb25cIjpcbiAgICAgICAgcmV0dXJuIFwie3tcIjtcblxuICAgICAgY2FzZSBcImRvY1R5cGVcIjpcbiAgICAgICAgcmV0dXJuIFwiPCFET0NUWVBFXCI7XG5cbiAgICAgIGNhc2UgXCJlbGVtZW50XCI6XG4gICAgICAgIGlmIChub2RlLmNvbmRpdGlvbikge1xuICAgICAgICAgIHJldHVybiBcIjwhLS1baWYgXCIuY29uY2F0KG5vZGUuY29uZGl0aW9uLCBcIl0+PCEtLT48XCIpLmNvbmNhdChub2RlLnJhd05hbWUpO1xuICAgICAgICB9XG5cbiAgICAgIC8vIGZhbGwgdGhyb3VnaFxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCI8XCIuY29uY2F0KG5vZGUucmF3TmFtZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRPcGVuaW5nVGFnRW5kTWFya2VyKG5vZGUpIHtcbiAgICBhc3NlcnQoIW5vZGUuaXNTZWxmQ2xvc2luZyk7XG5cbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcImllQ29uZGl0aW9uYWxDb21tZW50XCI6XG4gICAgICAgIHJldHVybiBcIl0+XCI7XG5cbiAgICAgIGNhc2UgXCJlbGVtZW50XCI6XG4gICAgICAgIGlmIChub2RlLmNvbmRpdGlvbikge1xuICAgICAgICAgIHJldHVybiBcIj48IS0tPCFbZW5kaWZdLS0+XCI7XG4gICAgICAgIH1cblxuICAgICAgLy8gZmFsbCB0aHJvdWdoXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBcIj5cIjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcmludENsb3NpbmdUYWdTdGFydE1hcmtlcihub2RlLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0KCFub2RlLmlzU2VsZkNsb3NpbmcpO1xuXG4gICAgaWYgKHNob3VsZE5vdFByaW50Q2xvc2luZ1RhZyQxKG5vZGUsIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcImllQ29uZGl0aW9uYWxDb21tZW50XCI6XG4gICAgICAgIHJldHVybiBcIjwhXCI7XG5cbiAgICAgIGNhc2UgXCJlbGVtZW50XCI6XG4gICAgICAgIGlmIChub2RlLmhhc0h0bUNvbXBvbmVudENsb3NpbmdUYWcpIHtcbiAgICAgICAgICByZXR1cm4gXCI8Ly9cIjtcbiAgICAgICAgfVxuXG4gICAgICAvLyBmYWxsIHRocm91Z2hcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFwiPC9cIi5jb25jYXQobm9kZS5yYXdOYW1lKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcmludENsb3NpbmdUYWdFbmRNYXJrZXIobm9kZSwgb3B0aW9ucykge1xuICAgIGlmIChzaG91bGROb3RQcmludENsb3NpbmdUYWckMShub2RlLCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJpZUNvbmRpdGlvbmFsQ29tbWVudFwiOlxuICAgICAgY2FzZSBcImllQ29uZGl0aW9uYWxFbmRDb21tZW50XCI6XG4gICAgICAgIHJldHVybiBcIltlbmRpZl0tLT5cIjtcblxuICAgICAgY2FzZSBcImllQ29uZGl0aW9uYWxTdGFydENvbW1lbnRcIjpcbiAgICAgICAgcmV0dXJuIFwiXT48IS0tPlwiO1xuXG4gICAgICBjYXNlIFwiaW50ZXJwb2xhdGlvblwiOlxuICAgICAgICByZXR1cm4gXCJ9fVwiO1xuXG4gICAgICBjYXNlIFwiZWxlbWVudFwiOlxuICAgICAgICBpZiAobm9kZS5pc1NlbGZDbG9zaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIFwiLz5cIjtcbiAgICAgICAgfVxuXG4gICAgICAvLyBmYWxsIHRocm91Z2hcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFwiPlwiO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRleHRWYWx1ZVBhcnRzKG5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG5vZGUudmFsdWU7XG4gICAgcmV0dXJuIG5vZGUucGFyZW50LmlzV2hpdGVzcGFjZVNlbnNpdGl2ZSA/IG5vZGUucGFyZW50LmlzSW5kZW50YXRpb25TZW5zaXRpdmUgPyByZXBsYWNlRW5kT2ZMaW5lV2l0aCQxKHZhbHVlLCBsaXRlcmFsbGluZSQyKSA6IHJlcGxhY2VFbmRPZkxpbmVXaXRoJDEoZGVkZW50U3RyaW5nJDEodmFsdWUucmVwbGFjZSgvXlxccyo/XFxufFxcblxccyo/JC9nLCBcIlwiKSksIGhhcmRsaW5lJDcpIDogLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2FzY2lpLXdoaXRlc3BhY2VcbiAgICBqb2luJDYobGluZSQ1LCB2YWx1ZS5zcGxpdCgvW1xcdFxcblxcZlxcciBdKy8pKS5wYXJ0cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50RW1iZWRkZWRBdHRyaWJ1dGVWYWx1ZShub2RlLCBvcmlnaW5hbFRleHRUb0RvYywgb3B0aW9ucykge1xuICAgIHZhciBpc0tleU1hdGNoZWQgPSBmdW5jdGlvbiBpc0tleU1hdGNoZWQocGF0dGVybnMpIHtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm5zLmpvaW4oXCJ8XCIpKS50ZXN0KG5vZGUuZnVsbE5hbWUpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiB1bmVzY2FwZVF1b3RlRW50aXRpZXMkMShub2RlLnZhbHVlKTtcbiAgICB9O1xuXG4gICAgdmFyIHNob3VsZEh1ZyA9IGZhbHNlO1xuXG4gICAgdmFyIF9fb25IdG1sQmluZGluZ1Jvb3QgPSBmdW5jdGlvbiBfX29uSHRtbEJpbmRpbmdSb290KHJvb3QpIHtcbiAgICAgIHZhciByb290Tm9kZSA9IHJvb3QudHlwZSA9PT0gXCJOR1Jvb3RcIiA/IHJvb3Qubm9kZS50eXBlID09PSBcIk5HTWljcm9zeW50YXhcIiAmJiByb290Lm5vZGUuYm9keS5sZW5ndGggPT09IDEgJiYgcm9vdC5ub2RlLmJvZHlbMF0udHlwZSA9PT0gXCJOR01pY3Jvc3ludGF4RXhwcmVzc2lvblwiID8gcm9vdC5ub2RlLmJvZHlbMF0uZXhwcmVzc2lvbiA6IHJvb3Qubm9kZSA6IHJvb3QudHlwZSA9PT0gXCJKc0V4cHJlc3Npb25Sb290XCIgPyByb290Lm5vZGUgOiByb290O1xuXG4gICAgICBpZiAocm9vdE5vZGUgJiYgKHJvb3ROb2RlLnR5cGUgPT09IFwiT2JqZWN0RXhwcmVzc2lvblwiIHx8IHJvb3ROb2RlLnR5cGUgPT09IFwiQXJyYXlFeHByZXNzaW9uXCIpKSB7XG4gICAgICAgIHNob3VsZEh1ZyA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBwcmludEh1ZyA9IGZ1bmN0aW9uIHByaW50SHVnKGRvYykge1xuICAgICAgcmV0dXJuIGdyb3VwJDkoZG9jKTtcbiAgICB9O1xuXG4gICAgdmFyIHByaW50RXhwYW5kID0gZnVuY3Rpb24gcHJpbnRFeHBhbmQoZG9jKSB7XG4gICAgICByZXR1cm4gZ3JvdXAkOShjb25jYXQkYShbaW5kZW50JDUoY29uY2F0JGEoW3NvZnRsaW5lJDQsIGRvY10pKSwgc29mdGxpbmUkNF0pKTtcbiAgICB9O1xuXG4gICAgdmFyIHByaW50TWF5YmVIdWcgPSBmdW5jdGlvbiBwcmludE1heWJlSHVnKGRvYykge1xuICAgICAgcmV0dXJuIHNob3VsZEh1ZyA/IHByaW50SHVnKGRvYykgOiBwcmludEV4cGFuZChkb2MpO1xuICAgIH07XG5cbiAgICB2YXIgdGV4dFRvRG9jID0gZnVuY3Rpb24gdGV4dFRvRG9jKGNvZGUsIG9wdHMpIHtcbiAgICAgIHJldHVybiBvcmlnaW5hbFRleHRUb0RvYyhjb2RlLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgX19vbkh0bWxCaW5kaW5nUm9vdDogX19vbkh0bWxCaW5kaW5nUm9vdFxuICAgICAgfSwgb3B0cykpO1xuICAgIH07XG5cbiAgICBpZiAobm9kZS5mdWxsTmFtZSA9PT0gXCJzcmNzZXRcIiAmJiAobm9kZS5wYXJlbnQuZnVsbE5hbWUgPT09IFwiaW1nXCIgfHwgbm9kZS5wYXJlbnQuZnVsbE5hbWUgPT09IFwic291cmNlXCIpKSB7XG4gICAgICByZXR1cm4gcHJpbnRFeHBhbmQocHJpbnRJbWdTcmNzZXQkMShnZXRWYWx1ZSgpKSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucGFyc2VyID09PSBcInZ1ZVwiKSB7XG4gICAgICBpZiAobm9kZS5mdWxsTmFtZSA9PT0gXCJ2LWZvclwiKSB7XG4gICAgICAgIHJldHVybiBwcmludFZ1ZUZvciQxKGdldFZhbHVlKCksIHRleHRUb0RvYyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLmZ1bGxOYW1lID09PSBcInNsb3Qtc2NvcGVcIikge1xuICAgICAgICByZXR1cm4gcHJpbnRWdWVTbG90U2NvcGUkMShnZXRWYWx1ZSgpLCB0ZXh0VG9Eb2MpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiAgICAgQGNsaWNrPVwianNTdGF0ZW1lbnRcIlxuICAgICAgICogICAgIEBjbGljaz1cImpzRXhwcmVzc2lvblwiXG4gICAgICAgKiAgICAgdi1vbjpjbGljaz1cImpzU3RhdGVtZW50XCJcbiAgICAgICAqICAgICB2LW9uOmNsaWNrPVwianNFeHByZXNzaW9uXCJcbiAgICAgICAqL1xuXG5cbiAgICAgIHZhciB2dWVFdmVudEJpbmRpbmdQYXR0ZXJucyA9IFtcIl5AXCIsIFwiXnYtb246XCJdO1xuICAgICAgLyoqXG4gICAgICAgKiAgICAgOmNsYXNzPVwidnVlRXhwcmVzc2lvblwiXG4gICAgICAgKiAgICAgdi1iaW5kOmlkPVwidnVlRXhwcmVzc2lvblwiXG4gICAgICAgKi9cblxuICAgICAgdmFyIHZ1ZUV4cHJlc3Npb25CaW5kaW5nUGF0dGVybnMgPSBbXCJeOlwiLCBcIl52LWJpbmQ6XCJdO1xuICAgICAgLyoqXG4gICAgICAgKiAgICAgdi1pZj1cImpzRXhwcmVzc2lvblwiXG4gICAgICAgKi9cblxuICAgICAgdmFyIGpzRXhwcmVzc2lvbkJpbmRpbmdQYXR0ZXJucyA9IFtcIl52LVwiXTtcblxuICAgICAgaWYgKGlzS2V5TWF0Y2hlZCh2dWVFdmVudEJpbmRpbmdQYXR0ZXJucykpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZ2V0VmFsdWUoKTtcbiAgICAgICAgcmV0dXJuIHByaW50TWF5YmVIdWcoaXNWdWVFdmVudEJpbmRpbmdFeHByZXNzaW9uJDEodmFsdWUpID8gdGV4dFRvRG9jKHZhbHVlLCB7XG4gICAgICAgICAgcGFyc2VyOiBcIl9fanNfZXhwcmVzc2lvblwiXG4gICAgICAgIH0pIDogc3RyaXBUcmFpbGluZ0hhcmRsaW5lJDEodGV4dFRvRG9jKHZhbHVlLCB7XG4gICAgICAgICAgcGFyc2VyOiBcIl9fdnVlX2V2ZW50X2JpbmRpbmdcIlxuICAgICAgICB9KSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNLZXlNYXRjaGVkKHZ1ZUV4cHJlc3Npb25CaW5kaW5nUGF0dGVybnMpKSB7XG4gICAgICAgIHJldHVybiBwcmludE1heWJlSHVnKHRleHRUb0RvYyhnZXRWYWx1ZSgpLCB7XG4gICAgICAgICAgcGFyc2VyOiBcIl9fdnVlX2V4cHJlc3Npb25cIlxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0tleU1hdGNoZWQoanNFeHByZXNzaW9uQmluZGluZ1BhdHRlcm5zKSkge1xuICAgICAgICByZXR1cm4gcHJpbnRNYXliZUh1Zyh0ZXh0VG9Eb2MoZ2V0VmFsdWUoKSwge1xuICAgICAgICAgIHBhcnNlcjogXCJfX2pzX2V4cHJlc3Npb25cIlxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucGFyc2VyID09PSBcImFuZ3VsYXJcIikge1xuICAgICAgdmFyIG5nVGV4dFRvRG9jID0gZnVuY3Rpb24gbmdUZXh0VG9Eb2MoY29kZSwgb3B0cykge1xuICAgICAgICByZXR1cm4gKC8vIGFuZ3VsYXIgZG9lcyBub3QgYWxsb3cgdHJhaWxpbmcgY29tbWFcbiAgICAgICAgICB0ZXh0VG9Eb2MoY29kZSwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICB0cmFpbGluZ0NvbW1hOiBcIm5vbmVcIlxuICAgICAgICAgIH0sIG9wdHMpKVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogICAgICpkaXJlY3RpdmU9XCJhbmd1bGFyRGlyZWN0aXZlXCJcbiAgICAgICAqL1xuXG5cbiAgICAgIHZhciBuZ0RpcmVjdGl2ZUJpbmRpbmdQYXR0ZXJucyA9IFtcIl5cXFxcKlwiXTtcbiAgICAgIC8qKlxuICAgICAgICogICAgIChjbGljayk9XCJhbmd1bGFyU3RhdGVtZW50XCJcbiAgICAgICAqICAgICBvbi1jbGljaz1cImFuZ3VsYXJTdGF0ZW1lbnRcIlxuICAgICAgICovXG5cbiAgICAgIHZhciBuZ1N0YXRlbWVudEJpbmRpbmdQYXR0ZXJucyA9IFtcIl5cXFxcKC4rXFxcXCkkXCIsIFwiXm9uLVwiXTtcbiAgICAgIC8qKlxuICAgICAgICogICAgIFt0YXJnZXRdPVwiYW5ndWxhckV4cHJlc3Npb25cIlxuICAgICAgICogICAgIGJpbmQtdGFyZ2V0PVwiYW5ndWxhckV4cHJlc3Npb25cIlxuICAgICAgICogICAgIFsodGFyZ2V0KV09XCJhbmd1bGFyRXhwcmVzc2lvblwiXG4gICAgICAgKiAgICAgYmluZG9uLXRhcmdldD1cImFuZ3VsYXJFeHByZXNzaW9uXCJcbiAgICAgICAqL1xuXG4gICAgICB2YXIgbmdFeHByZXNzaW9uQmluZGluZ1BhdHRlcm5zID0gW1wiXlxcXFxbLitcXFxcXSRcIiwgXCJeYmluZChvbik/LVwiXTtcbiAgICAgIC8qKlxuICAgICAgICogICAgIGkxOG49XCJsb25nRGVzY3JpcHRpb25cIlxuICAgICAgICogICAgIGkxOG4tYXR0cj1cImxvbmdEZXNjcmlwdGlvblwiXG4gICAgICAgKi9cblxuICAgICAgdmFyIG5nSTE4blBhdHRlcm5zID0gW1wiXmkxOG4oLS4rKT8kXCJdO1xuXG4gICAgICBpZiAoaXNLZXlNYXRjaGVkKG5nU3RhdGVtZW50QmluZGluZ1BhdHRlcm5zKSkge1xuICAgICAgICByZXR1cm4gcHJpbnRNYXliZUh1ZyhuZ1RleHRUb0RvYyhnZXRWYWx1ZSgpLCB7XG4gICAgICAgICAgcGFyc2VyOiBcIl9fbmdfYWN0aW9uXCJcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNLZXlNYXRjaGVkKG5nRXhwcmVzc2lvbkJpbmRpbmdQYXR0ZXJucykpIHtcbiAgICAgICAgcmV0dXJuIHByaW50TWF5YmVIdWcobmdUZXh0VG9Eb2MoZ2V0VmFsdWUoKSwge1xuICAgICAgICAgIHBhcnNlcjogXCJfX25nX2JpbmRpbmdcIlxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0tleU1hdGNoZWQobmdJMThuUGF0dGVybnMpKSB7XG4gICAgICAgIHJldHVybiBwcmludEV4cGFuZChmaWxsJDMoZ2V0VGV4dFZhbHVlUGFydHMobm9kZSwgZ2V0VmFsdWUoKSkpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzS2V5TWF0Y2hlZChuZ0RpcmVjdGl2ZUJpbmRpbmdQYXR0ZXJucykpIHtcbiAgICAgICAgcmV0dXJuIHByaW50TWF5YmVIdWcobmdUZXh0VG9Eb2MoZ2V0VmFsdWUoKSwge1xuICAgICAgICAgIHBhcnNlcjogXCJfX25nX2RpcmVjdGl2ZVwiXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGludGVycG9sYXRpb25SZWdleCA9IC9cXHtcXHsoW1xcc1xcU10rPylcXH1cXH0vZztcblxuICAgICAgdmFyIF92YWx1ZTIgPSBnZXRWYWx1ZSgpO1xuXG4gICAgICBpZiAoaW50ZXJwb2xhdGlvblJlZ2V4LnRlc3QoX3ZhbHVlMikpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gW107XG5cbiAgICAgICAgX3ZhbHVlMi5zcGxpdChpbnRlcnBvbGF0aW9uUmVnZXgpLmZvckVhY2goZnVuY3Rpb24gKHBhcnQsIGluZGV4KSB7XG4gICAgICAgICAgaWYgKGluZGV4ICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgcGFydHMucHVzaChjb25jYXQkYShyZXBsYWNlRW5kT2ZMaW5lV2l0aCQxKHBhcnQsIGxpdGVyYWxsaW5lJDIpKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHBhcnRzLnB1c2goZ3JvdXAkOShjb25jYXQkYShbXCJ7e1wiLCBpbmRlbnQkNShjb25jYXQkYShbbGluZSQ1LCBuZ1RleHRUb0RvYyhwYXJ0LCB7XG4gICAgICAgICAgICAgICAgcGFyc2VyOiBcIl9fbmdfaW50ZXJwb2xhdGlvblwiLFxuICAgICAgICAgICAgICAgIF9faXNJbkh0bWxJbnRlcnBvbGF0aW9uOiB0cnVlIC8vIHRvIGF2b2lkIHVuZXhwZWN0ZWQgYH19YFxuXG4gICAgICAgICAgICAgIH0pXSkpLCBsaW5lJDUsIFwifX1cIl0pKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHBhcnRzLnB1c2goXCJ7e1wiLCBjb25jYXQkYShyZXBsYWNlRW5kT2ZMaW5lV2l0aCQxKHBhcnQsIGxpdGVyYWxsaW5lJDIpKSwgXCJ9fVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBncm91cCQ5KGNvbmNhdCRhKHBhcnRzKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcHJpbnRlckh0bWwgPSB7XG4gICAgcHJlcHJvY2VzczogcHJlcHJvY2Vzc18xLFxuICAgIHByaW50OiBnZW5lcmljUHJpbnQkMixcbiAgICBpbnNlcnRQcmFnbWE6IGluc2VydFByYWdtYSQ2LFxuICAgIG1hc3NhZ2VBc3ROb2RlOiBjbGVhbiQzLFxuICAgIGVtYmVkOiBlbWJlZCQyXG4gIH07XG5cbiAgdmFyIENBVEVHT1JZX0hUTUwgPSBcIkhUTUxcIjsgLy8gZm9ybWF0IGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmV0dGllci9wcmV0dGllci9ibG9iL21hc3Rlci9zcmMvbWFpbi9jb3JlLW9wdGlvbnMuanNcblxuICB2YXIgb3B0aW9ucyQ0ID0ge1xuICAgIGh0bWxXaGl0ZXNwYWNlU2Vuc2l0aXZpdHk6IHtcbiAgICAgIHNpbmNlOiBcIjEuMTUuMFwiLFxuICAgICAgY2F0ZWdvcnk6IENBVEVHT1JZX0hUTUwsXG4gICAgICB0eXBlOiBcImNob2ljZVwiLFxuICAgICAgZGVmYXVsdDogXCJjc3NcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkhvdyB0byBoYW5kbGUgd2hpdGVzcGFjZXMgaW4gSFRNTC5cIixcbiAgICAgIGNob2ljZXM6IFt7XG4gICAgICAgIHZhbHVlOiBcImNzc1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJSZXNwZWN0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIENTUyBkaXNwbGF5IHByb3BlcnR5LlwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcInN0cmljdFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJXaGl0ZXNwYWNlcyBhcmUgY29uc2lkZXJlZCBzZW5zaXRpdmUuXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwiaWdub3JlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIldoaXRlc3BhY2VzIGFyZSBjb25zaWRlcmVkIGluc2Vuc2l0aXZlLlwiXG4gICAgICB9XVxuICAgIH0sXG4gICAgdnVlSW5kZW50U2NyaXB0QW5kU3R5bGU6IHtcbiAgICAgIHNpbmNlOiBcIjEuMTkuMFwiLFxuICAgICAgY2F0ZWdvcnk6IENBVEVHT1JZX0hUTUwsXG4gICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgZGVzY3JpcHRpb246IFwiSW5kZW50IHNjcmlwdCBhbmQgc3R5bGUgdGFncyBpbiBWdWUgZmlsZXMuXCJcbiAgICB9XG4gIH07XG5cbiAgdmFyIG5hbWUkNyA9IFwiSFRNTFwiO1xuICB2YXIgdHlwZSQ2ID0gXCJtYXJrdXBcIjtcbiAgdmFyIHRtU2NvcGUkNiA9IFwidGV4dC5odG1sLmJhc2ljXCI7XG4gIHZhciBhY2VNb2RlJDYgPSBcImh0bWxcIjtcbiAgdmFyIGNvZGVtaXJyb3JNb2RlJDMgPSBcImh0bWxtaXhlZFwiO1xuICB2YXIgY29kZW1pcnJvck1pbWVUeXBlJDMgPSBcInRleHQvaHRtbFwiO1xuICB2YXIgY29sb3IkMSA9IFwiI2UzNGMyNlwiO1xuICB2YXIgYWxpYXNlcyQxID0gW1xuICBcdFwieGh0bWxcIlxuICBdO1xuICB2YXIgZXh0ZW5zaW9ucyQ2ID0gW1xuICBcdFwiLmh0bWxcIixcbiAgXHRcIi5odG1cIixcbiAgXHRcIi5odG1sLmhsXCIsXG4gIFx0XCIuaW5jXCIsXG4gIFx0XCIuc3RcIixcbiAgXHRcIi54aHRcIixcbiAgXHRcIi54aHRtbFwiXG4gIF07XG4gIHZhciBsYW5ndWFnZUlkJDYgPSAxNDY7XG4gIHZhciBIVE1MID0ge1xuICBcdG5hbWU6IG5hbWUkNyxcbiAgXHR0eXBlOiB0eXBlJDYsXG4gIFx0dG1TY29wZTogdG1TY29wZSQ2LFxuICBcdGFjZU1vZGU6IGFjZU1vZGUkNixcbiAgXHRjb2RlbWlycm9yTW9kZTogY29kZW1pcnJvck1vZGUkMyxcbiAgXHRjb2RlbWlycm9yTWltZVR5cGU6IGNvZGVtaXJyb3JNaW1lVHlwZSQzLFxuICBcdGNvbG9yOiBjb2xvciQxLFxuICBcdGFsaWFzZXM6IGFsaWFzZXMkMSxcbiAgXHRleHRlbnNpb25zOiBleHRlbnNpb25zJDYsXG4gIFx0bGFuZ3VhZ2VJZDogbGFuZ3VhZ2VJZCQ2XG4gIH07XG5cbiAgdmFyIEhUTUwkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgbmFtZTogbmFtZSQ3LFxuICAgIHR5cGU6IHR5cGUkNixcbiAgICB0bVNjb3BlOiB0bVNjb3BlJDYsXG4gICAgYWNlTW9kZTogYWNlTW9kZSQ2LFxuICAgIGNvZGVtaXJyb3JNb2RlOiBjb2RlbWlycm9yTW9kZSQzLFxuICAgIGNvZGVtaXJyb3JNaW1lVHlwZTogY29kZW1pcnJvck1pbWVUeXBlJDMsXG4gICAgY29sb3I6IGNvbG9yJDEsXG4gICAgYWxpYXNlczogYWxpYXNlcyQxLFxuICAgIGV4dGVuc2lvbnM6IGV4dGVuc2lvbnMkNixcbiAgICBsYW5ndWFnZUlkOiBsYW5ndWFnZUlkJDYsXG4gICAgJ2RlZmF1bHQnOiBIVE1MXG4gIH0pO1xuXG4gIHZhciBuYW1lJDggPSBcIlZ1ZVwiO1xuICB2YXIgdHlwZSQ3ID0gXCJtYXJrdXBcIjtcbiAgdmFyIGNvbG9yJDIgPSBcIiMyYzNlNTBcIjtcbiAgdmFyIGV4dGVuc2lvbnMkNyA9IFtcbiAgXHRcIi52dWVcIlxuICBdO1xuICB2YXIgdG1TY29wZSQ3ID0gXCJ0ZXh0Lmh0bWwudnVlXCI7XG4gIHZhciBhY2VNb2RlJDcgPSBcImh0bWxcIjtcbiAgdmFyIGxhbmd1YWdlSWQkNyA9IDM5MTtcbiAgdmFyIFZ1ZSA9IHtcbiAgXHRuYW1lOiBuYW1lJDgsXG4gIFx0dHlwZTogdHlwZSQ3LFxuICBcdGNvbG9yOiBjb2xvciQyLFxuICBcdGV4dGVuc2lvbnM6IGV4dGVuc2lvbnMkNyxcbiAgXHR0bVNjb3BlOiB0bVNjb3BlJDcsXG4gIFx0YWNlTW9kZTogYWNlTW9kZSQ3LFxuICBcdGxhbmd1YWdlSWQ6IGxhbmd1YWdlSWQkN1xuICB9O1xuXG4gIHZhciBWdWUkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgbmFtZTogbmFtZSQ4LFxuICAgIHR5cGU6IHR5cGUkNyxcbiAgICBjb2xvcjogY29sb3IkMixcbiAgICBleHRlbnNpb25zOiBleHRlbnNpb25zJDcsXG4gICAgdG1TY29wZTogdG1TY29wZSQ3LFxuICAgIGFjZU1vZGU6IGFjZU1vZGUkNyxcbiAgICBsYW5ndWFnZUlkOiBsYW5ndWFnZUlkJDcsXG4gICAgJ2RlZmF1bHQnOiBWdWVcbiAgfSk7XG5cbiAgdmFyIHJlcXVpcmUkJDAkNSA9IGdldENqc0V4cG9ydEZyb21OYW1lc3BhY2UoSFRNTCQxKTtcblxuICB2YXIgcmVxdWlyZSQkMSQxID0gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZShWdWUkMSk7XG5cbiAgdmFyIGxhbmd1YWdlcyQzID0gW2NyZWF0ZUxhbmd1YWdlKHJlcXVpcmUkJDAkNSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkYXRhLCB7XG4gICAgICBuYW1lOiBcIkFuZ3VsYXJcIixcbiAgICAgIHNpbmNlOiBcIjEuMTUuMFwiLFxuICAgICAgcGFyc2VyczogW1wiYW5ndWxhclwiXSxcbiAgICAgIHZzY29kZUxhbmd1YWdlSWRzOiBbXCJodG1sXCJdLFxuICAgICAgZXh0ZW5zaW9uczogW1wiLmNvbXBvbmVudC5odG1sXCJdLFxuICAgICAgZmlsZW5hbWVzOiBbXVxuICAgIH0pO1xuICB9KSwgY3JlYXRlTGFuZ3VhZ2UocmVxdWlyZSQkMCQ1LCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGRhdGEsIHtcbiAgICAgIHNpbmNlOiBcIjEuMTUuMFwiLFxuICAgICAgcGFyc2VyczogW1wiaHRtbFwiXSxcbiAgICAgIHZzY29kZUxhbmd1YWdlSWRzOiBbXCJodG1sXCJdLFxuICAgICAgZXh0ZW5zaW9uczogZGF0YS5leHRlbnNpb25zLmNvbmNhdChbXCIubWptbFwiIC8vIE1KTUwgaXMgY29uc2lkZXJlZCBYTUwgaW4gTGluZ3Vpc3QgYnV0IGl0IHNob3VsZCBiZSBmb3JtYXR0ZWQgYXMgSFRNTFxuICAgICAgXSlcbiAgICB9KTtcbiAgfSksIGNyZWF0ZUxhbmd1YWdlKHJlcXVpcmUkJDAkNSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkYXRhLCB7XG4gICAgICBuYW1lOiBcIkxpZ2h0bmluZyBXZWIgQ29tcG9uZW50c1wiLFxuICAgICAgc2luY2U6IFwiMS4xNy4wXCIsXG4gICAgICBwYXJzZXJzOiBbXCJsd2NcIl0sXG4gICAgICB2c2NvZGVMYW5ndWFnZUlkczogW1wiaHRtbFwiXSxcbiAgICAgIGV4dGVuc2lvbnM6IFtdLFxuICAgICAgZmlsZW5hbWVzOiBbXVxuICAgIH0pO1xuICB9KSwgY3JlYXRlTGFuZ3VhZ2UocmVxdWlyZSQkMSQxLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGRhdGEsIHtcbiAgICAgIHNpbmNlOiBcIjEuMTAuMFwiLFxuICAgICAgcGFyc2VyczogW1widnVlXCJdLFxuICAgICAgdnNjb2RlTGFuZ3VhZ2VJZHM6IFtcInZ1ZVwiXVxuICAgIH0pO1xuICB9KV07XG4gIHZhciBwcmludGVycyQzID0ge1xuICAgIGh0bWw6IHByaW50ZXJIdG1sXG4gIH07XG4gIHZhciBsYW5ndWFnZUh0bWwgPSB7XG4gICAgbGFuZ3VhZ2VzOiBsYW5ndWFnZXMkMyxcbiAgICBwcmludGVyczogcHJpbnRlcnMkMyxcbiAgICBvcHRpb25zOiBvcHRpb25zJDRcbiAgfTtcblxuICB2YXIgYWRkTGVhZGluZ0NvbW1lbnQkMiA9IHV0aWxTaGFyZWQuYWRkTGVhZGluZ0NvbW1lbnQsXG4gICAgICBhZGRUcmFpbGluZ0NvbW1lbnQkMiA9IHV0aWxTaGFyZWQuYWRkVHJhaWxpbmdDb21tZW50LFxuICAgICAgYWRkRGFuZ2xpbmdDb21tZW50JDIgPSB1dGlsU2hhcmVkLmFkZERhbmdsaW5nQ29tbWVudDtcblxuICBmdW5jdGlvbiBoYW5kbGVPd25MaW5lQ29tbWVudChjb21tZW50LCB0ZXh0LCBvcHRpb25zLCBhc3QsIGlzTGFzdENvbW1lbnQpIHtcbiAgICB2YXIgcHJlY2VkaW5nTm9kZSA9IGNvbW1lbnQucHJlY2VkaW5nTm9kZSxcbiAgICAgICAgZW5jbG9zaW5nTm9kZSA9IGNvbW1lbnQuZW5jbG9zaW5nTm9kZSxcbiAgICAgICAgZm9sbG93aW5nTm9kZSA9IGNvbW1lbnQuZm9sbG93aW5nTm9kZTtcblxuICAgIGlmIChoYW5kbGVMYXN0RnVuY3Rpb25BcmdDb21tZW50cyh0ZXh0LCBwcmVjZWRpbmdOb2RlLCBlbmNsb3NpbmdOb2RlLCBmb2xsb3dpbmdOb2RlLCBjb21tZW50LCBvcHRpb25zKSB8fCBoYW5kbGVNZW1iZXJFeHByZXNzaW9uQ29tbWVudHMoZW5jbG9zaW5nTm9kZSwgZm9sbG93aW5nTm9kZSwgY29tbWVudCkgfHwgaGFuZGxlSWZTdGF0ZW1lbnRDb21tZW50cyh0ZXh0LCBwcmVjZWRpbmdOb2RlLCBlbmNsb3NpbmdOb2RlLCBmb2xsb3dpbmdOb2RlLCBjb21tZW50LCBvcHRpb25zKSB8fCBoYW5kbGVXaGlsZUNvbW1lbnRzKHRleHQsIHByZWNlZGluZ05vZGUsIGVuY2xvc2luZ05vZGUsIGZvbGxvd2luZ05vZGUsIGNvbW1lbnQsIG9wdGlvbnMpIHx8IGhhbmRsZVRyeVN0YXRlbWVudENvbW1lbnRzKGVuY2xvc2luZ05vZGUsIHByZWNlZGluZ05vZGUsIGZvbGxvd2luZ05vZGUsIGNvbW1lbnQpIHx8IGhhbmRsZUNsYXNzQ29tbWVudHMoZW5jbG9zaW5nTm9kZSwgcHJlY2VkaW5nTm9kZSwgZm9sbG93aW5nTm9kZSwgY29tbWVudCkgfHwgaGFuZGxlSW1wb3J0U3BlY2lmaWVyQ29tbWVudHMoZW5jbG9zaW5nTm9kZSwgY29tbWVudCkgfHwgaGFuZGxlRm9yQ29tbWVudHMoZW5jbG9zaW5nTm9kZSwgcHJlY2VkaW5nTm9kZSwgY29tbWVudCkgfHwgaGFuZGxlVW5pb25UeXBlQ29tbWVudHMocHJlY2VkaW5nTm9kZSwgZW5jbG9zaW5nTm9kZSwgZm9sbG93aW5nTm9kZSwgY29tbWVudCkgfHwgaGFuZGxlT25seUNvbW1lbnRzKGVuY2xvc2luZ05vZGUsIGFzdCwgY29tbWVudCwgaXNMYXN0Q29tbWVudCkgfHwgaGFuZGxlSW1wb3J0RGVjbGFyYXRpb25Db21tZW50cyh0ZXh0LCBlbmNsb3NpbmdOb2RlLCBwcmVjZWRpbmdOb2RlLCBjb21tZW50LCBvcHRpb25zKSB8fCBoYW5kbGVBc3NpZ25tZW50UGF0dGVybkNvbW1lbnRzKGVuY2xvc2luZ05vZGUsIGNvbW1lbnQpIHx8IGhhbmRsZU1ldGhvZE5hbWVDb21tZW50cyh0ZXh0LCBlbmNsb3NpbmdOb2RlLCBwcmVjZWRpbmdOb2RlLCBjb21tZW50LCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlRW5kT2ZMaW5lQ29tbWVudChjb21tZW50LCB0ZXh0LCBvcHRpb25zLCBhc3QsIGlzTGFzdENvbW1lbnQpIHtcbiAgICB2YXIgcHJlY2VkaW5nTm9kZSA9IGNvbW1lbnQucHJlY2VkaW5nTm9kZSxcbiAgICAgICAgZW5jbG9zaW5nTm9kZSA9IGNvbW1lbnQuZW5jbG9zaW5nTm9kZSxcbiAgICAgICAgZm9sbG93aW5nTm9kZSA9IGNvbW1lbnQuZm9sbG93aW5nTm9kZTtcblxuICAgIGlmIChoYW5kbGVMYXN0RnVuY3Rpb25BcmdDb21tZW50cyh0ZXh0LCBwcmVjZWRpbmdOb2RlLCBlbmNsb3NpbmdOb2RlLCBmb2xsb3dpbmdOb2RlLCBjb21tZW50LCBvcHRpb25zKSB8fCBoYW5kbGVDb25kaXRpb25hbEV4cHJlc3Npb25Db21tZW50cyhlbmNsb3NpbmdOb2RlLCBwcmVjZWRpbmdOb2RlLCBmb2xsb3dpbmdOb2RlLCBjb21tZW50LCB0ZXh0LCBvcHRpb25zKSB8fCBoYW5kbGVJbXBvcnRTcGVjaWZpZXJDb21tZW50cyhlbmNsb3NpbmdOb2RlLCBjb21tZW50KSB8fCBoYW5kbGVJZlN0YXRlbWVudENvbW1lbnRzKHRleHQsIHByZWNlZGluZ05vZGUsIGVuY2xvc2luZ05vZGUsIGZvbGxvd2luZ05vZGUsIGNvbW1lbnQsIG9wdGlvbnMpIHx8IGhhbmRsZVdoaWxlQ29tbWVudHModGV4dCwgcHJlY2VkaW5nTm9kZSwgZW5jbG9zaW5nTm9kZSwgZm9sbG93aW5nTm9kZSwgY29tbWVudCwgb3B0aW9ucykgfHwgaGFuZGxlVHJ5U3RhdGVtZW50Q29tbWVudHMoZW5jbG9zaW5nTm9kZSwgcHJlY2VkaW5nTm9kZSwgZm9sbG93aW5nTm9kZSwgY29tbWVudCkgfHwgaGFuZGxlQ2xhc3NDb21tZW50cyhlbmNsb3NpbmdOb2RlLCBwcmVjZWRpbmdOb2RlLCBmb2xsb3dpbmdOb2RlLCBjb21tZW50KSB8fCBoYW5kbGVMYWJlbGVkU3RhdGVtZW50Q29tbWVudHMoZW5jbG9zaW5nTm9kZSwgY29tbWVudCkgfHwgaGFuZGxlQ2FsbEV4cHJlc3Npb25Db21tZW50cyhwcmVjZWRpbmdOb2RlLCBlbmNsb3NpbmdOb2RlLCBjb21tZW50KSB8fCBoYW5kbGVQcm9wZXJ0eUNvbW1lbnRzKGVuY2xvc2luZ05vZGUsIGNvbW1lbnQpIHx8IGhhbmRsZU9ubHlDb21tZW50cyhlbmNsb3NpbmdOb2RlLCBhc3QsIGNvbW1lbnQsIGlzTGFzdENvbW1lbnQpIHx8IGhhbmRsZVR5cGVBbGlhc0NvbW1lbnRzKGVuY2xvc2luZ05vZGUsIGZvbGxvd2luZ05vZGUsIGNvbW1lbnQpIHx8IGhhbmRsZVZhcmlhYmxlRGVjbGFyYXRvckNvbW1lbnRzKGVuY2xvc2luZ05vZGUsIGZvbGxvd2luZ05vZGUsIGNvbW1lbnQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVSZW1haW5pbmdDb21tZW50KGNvbW1lbnQsIHRleHQsIG9wdGlvbnMsIGFzdCwgaXNMYXN0Q29tbWVudCkge1xuICAgIHZhciBwcmVjZWRpbmdOb2RlID0gY29tbWVudC5wcmVjZWRpbmdOb2RlLFxuICAgICAgICBlbmNsb3NpbmdOb2RlID0gY29tbWVudC5lbmNsb3NpbmdOb2RlLFxuICAgICAgICBmb2xsb3dpbmdOb2RlID0gY29tbWVudC5mb2xsb3dpbmdOb2RlO1xuXG4gICAgaWYgKGhhbmRsZUlmU3RhdGVtZW50Q29tbWVudHModGV4dCwgcHJlY2VkaW5nTm9kZSwgZW5jbG9zaW5nTm9kZSwgZm9sbG93aW5nTm9kZSwgY29tbWVudCwgb3B0aW9ucykgfHwgaGFuZGxlV2hpbGVDb21tZW50cyh0ZXh0LCBwcmVjZWRpbmdOb2RlLCBlbmNsb3NpbmdOb2RlLCBmb2xsb3dpbmdOb2RlLCBjb21tZW50LCBvcHRpb25zKSB8fCBoYW5kbGVPYmplY3RQcm9wZXJ0eUFzc2lnbm1lbnQoZW5jbG9zaW5nTm9kZSwgcHJlY2VkaW5nTm9kZSwgY29tbWVudCkgfHwgaGFuZGxlQ29tbWVudEluRW1wdHlQYXJlbnModGV4dCwgZW5jbG9zaW5nTm9kZSwgY29tbWVudCwgb3B0aW9ucykgfHwgaGFuZGxlTWV0aG9kTmFtZUNvbW1lbnRzKHRleHQsIGVuY2xvc2luZ05vZGUsIHByZWNlZGluZ05vZGUsIGNvbW1lbnQsIG9wdGlvbnMpIHx8IGhhbmRsZU9ubHlDb21tZW50cyhlbmNsb3NpbmdOb2RlLCBhc3QsIGNvbW1lbnQsIGlzTGFzdENvbW1lbnQpIHx8IGhhbmRsZUNvbW1lbnRBZnRlckFycm93UGFyYW1zKHRleHQsIGVuY2xvc2luZ05vZGUsIGNvbW1lbnQsIG9wdGlvbnMpIHx8IGhhbmRsZUZ1bmN0aW9uTmFtZUNvbW1lbnRzKHRleHQsIGVuY2xvc2luZ05vZGUsIHByZWNlZGluZ05vZGUsIGNvbW1lbnQsIG9wdGlvbnMpIHx8IGhhbmRsZVRTTWFwcGVkVHlwZUNvbW1lbnRzKHRleHQsIGVuY2xvc2luZ05vZGUsIHByZWNlZGluZ05vZGUsIGZvbGxvd2luZ05vZGUsIGNvbW1lbnQpIHx8IGhhbmRsZUJyZWFrQW5kQ29udGludWVTdGF0ZW1lbnRDb21tZW50cyhlbmNsb3NpbmdOb2RlLCBjb21tZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkQmxvY2tTdGF0ZW1lbnRGaXJzdENvbW1lbnQobm9kZSwgY29tbWVudCkge1xuICAgIHZhciBib2R5ID0gbm9kZS5ib2R5LmZpbHRlcihmdW5jdGlvbiAobikge1xuICAgICAgcmV0dXJuIG4udHlwZSAhPT0gXCJFbXB0eVN0YXRlbWVudFwiO1xuICAgIH0pO1xuXG4gICAgaWYgKGJvZHkubGVuZ3RoID09PSAwKSB7XG4gICAgICBhZGREYW5nbGluZ0NvbW1lbnQkMihub2RlLCBjb21tZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkTGVhZGluZ0NvbW1lbnQkMihib2R5WzBdLCBjb21tZW50KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRCbG9ja09yTm90Q29tbWVudChub2RlLCBjb21tZW50KSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJCbG9ja1N0YXRlbWVudFwiKSB7XG4gICAgICBhZGRCbG9ja1N0YXRlbWVudEZpcnN0Q29tbWVudChub2RlLCBjb21tZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkTGVhZGluZ0NvbW1lbnQkMihub2RlLCBjb21tZW50KTtcbiAgICB9XG4gIH0gLy8gVGhlcmUgYXJlIG9mdGVuIGNvbW1lbnRzIGJlZm9yZSB0aGUgZWxzZSBjbGF1c2Ugb2YgaWYgc3RhdGVtZW50cyBsaWtlXG4gIC8vXG4gIC8vICAgaWYgKDEpIHsgLi4uIH1cbiAgLy8gICAvLyBjb21tZW50XG4gIC8vICAgZWxzZSB7IC4uLiB9XG4gIC8vXG4gIC8vIFRoZXkgYXJlIGJlaW5nIGF0dGFjaGVkIGFzIGxlYWRpbmcgY29tbWVudHMgb2YgdGhlIEJsb2NrRXhwcmVzc2lvbiB3aGljaFxuICAvLyBpcyBub3Qgd2VsbCBwcmludGVkLiBXaGF0IHdlIHdhbnQgaXMgdG8gaW5zdGVhZCBtb3ZlIHRoZSBjb21tZW50IGluc2lkZVxuICAvLyBvZiB0aGUgYmxvY2sgYW5kIG1ha2UgaXQgbGVhZGluZ0NvbW1lbnQgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGJsb2NrXG4gIC8vIG9yIGRhbmdsaW5nIGNvbW1lbnQgb2YgdGhlIGJsb2NrIGlmIHRoZXJlIGlzIG5vdGhpbmcgaW5zaWRlXG4gIC8vXG4gIC8vICAgaWYgKDEpIHsgLi4uIH1cbiAgLy8gICBlbHNlIHtcbiAgLy8gICAgIC8vIGNvbW1lbnRcbiAgLy8gICAgIC4uLlxuICAvLyAgIH1cblxuXG4gIGZ1bmN0aW9uIGhhbmRsZUlmU3RhdGVtZW50Q29tbWVudHModGV4dCwgcHJlY2VkaW5nTm9kZSwgZW5jbG9zaW5nTm9kZSwgZm9sbG93aW5nTm9kZSwgY29tbWVudCwgb3B0aW9ucykge1xuICAgIGlmICghZW5jbG9zaW5nTm9kZSB8fCBlbmNsb3NpbmdOb2RlLnR5cGUgIT09IFwiSWZTdGF0ZW1lbnRcIiB8fCAhZm9sbG93aW5nTm9kZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gV2UgdW5mb3J0dW5hdGVseSBoYXZlIG5vIHdheSB1c2luZyB0aGUgQVNUIG9yIGxvY2F0aW9uIG9mIG5vZGVzIHRvIGtub3dcbiAgICAvLyBpZiB0aGUgY29tbWVudCBpcyBwb3NpdGlvbmVkIGJlZm9yZSB0aGUgY29uZGl0aW9uIHBhcmVudGhlc2lzOlxuICAgIC8vICAgaWYgKGEgLyogY29tbWVudCAqLykge31cbiAgICAvLyBUaGUgb25seSB3b3JrYXJvdW5kIEkgZm91bmQgaXMgdG8gbG9vayBhdCB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gc2VlIGlmXG4gICAgLy8gaXQgaXMgYSApLlxuXG5cbiAgICB2YXIgbmV4dENoYXJhY3RlciA9IHV0aWwuZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3Rlcih0ZXh0LCBjb21tZW50LCBvcHRpb25zLmxvY0VuZCk7XG5cbiAgICBpZiAobmV4dENoYXJhY3RlciA9PT0gXCIpXCIpIHtcbiAgICAgIGFkZFRyYWlsaW5nQ29tbWVudCQyKHByZWNlZGluZ05vZGUsIGNvbW1lbnQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBDb21tZW50cyBiZWZvcmUgYGVsc2VgOlxuICAgIC8vIC0gdHJlYXQgYXMgdHJhaWxpbmcgY29tbWVudHMgb2YgdGhlIGNvbnNlcXVlbnQsIGlmIGl0J3MgYSBCbG9ja1N0YXRlbWVudFxuICAgIC8vIC0gdHJlYXQgYXMgYSBkYW5nbGluZyBjb21tZW50IG90aGVyd2lzZVxuXG5cbiAgICBpZiAocHJlY2VkaW5nTm9kZSA9PT0gZW5jbG9zaW5nTm9kZS5jb25zZXF1ZW50ICYmIGZvbGxvd2luZ05vZGUgPT09IGVuY2xvc2luZ05vZGUuYWx0ZXJuYXRlKSB7XG4gICAgICBpZiAocHJlY2VkaW5nTm9kZS50eXBlID09PSBcIkJsb2NrU3RhdGVtZW50XCIpIHtcbiAgICAgICAgYWRkVHJhaWxpbmdDb21tZW50JDIocHJlY2VkaW5nTm9kZSwgY29tbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGREYW5nbGluZ0NvbW1lbnQkMihlbmNsb3NpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGZvbGxvd2luZ05vZGUudHlwZSA9PT0gXCJCbG9ja1N0YXRlbWVudFwiKSB7XG4gICAgICBhZGRCbG9ja1N0YXRlbWVudEZpcnN0Q29tbWVudChmb2xsb3dpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChmb2xsb3dpbmdOb2RlLnR5cGUgPT09IFwiSWZTdGF0ZW1lbnRcIikge1xuICAgICAgYWRkQmxvY2tPck5vdENvbW1lbnQoZm9sbG93aW5nTm9kZS5jb25zZXF1ZW50LCBjb21tZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gRm9yIGNvbW1lbnRzIHBvc2l0aW9uZWQgYWZ0ZXIgdGhlIGNvbmRpdGlvbiBwYXJlbnRoZXNpcyBpbiBhbiBpZiBzdGF0ZW1lbnRcbiAgICAvLyBiZWZvcmUgdGhlIGNvbnNlcXVlbnQgd2l0aG91dCBicmFja2V0cyBvbiwgc3VjaCBhc1xuICAgIC8vIGlmIChhKSAvKiBjb21tZW50ICovIHRydWUsXG4gICAgLy8gd2UgbG9vayBhdCB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gc2VlIGlmIHRoZSBmb2xsb3dpbmcgbm9kZVxuICAgIC8vIGlzIHRoZSBjb25zZXF1ZW50IGZvciB0aGUgaWYgc3RhdGVtZW50XG5cblxuICAgIGlmIChlbmNsb3NpbmdOb2RlLmNvbnNlcXVlbnQgPT09IGZvbGxvd2luZ05vZGUpIHtcbiAgICAgIGFkZExlYWRpbmdDb21tZW50JDIoZm9sbG93aW5nTm9kZSwgY29tbWVudCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVXaGlsZUNvbW1lbnRzKHRleHQsIHByZWNlZGluZ05vZGUsIGVuY2xvc2luZ05vZGUsIGZvbGxvd2luZ05vZGUsIGNvbW1lbnQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIWVuY2xvc2luZ05vZGUgfHwgZW5jbG9zaW5nTm9kZS50eXBlICE9PSBcIldoaWxlU3RhdGVtZW50XCIgfHwgIWZvbGxvd2luZ05vZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIFdlIHVuZm9ydHVuYXRlbHkgaGF2ZSBubyB3YXkgdXNpbmcgdGhlIEFTVCBvciBsb2NhdGlvbiBvZiBub2RlcyB0byBrbm93XG4gICAgLy8gaWYgdGhlIGNvbW1lbnQgaXMgcG9zaXRpb25lZCBiZWZvcmUgdGhlIGNvbmRpdGlvbiBwYXJlbnRoZXNpczpcbiAgICAvLyAgIHdoaWxlIChhIC8qIGNvbW1lbnQgKi8pIHt9XG4gICAgLy8gVGhlIG9ubHkgd29ya2Fyb3VuZCBJIGZvdW5kIGlzIHRvIGxvb2sgYXQgdGhlIG5leHQgY2hhcmFjdGVyIHRvIHNlZSBpZlxuICAgIC8vIGl0IGlzIGEgKS5cblxuXG4gICAgdmFyIG5leHRDaGFyYWN0ZXIgPSB1dGlsLmdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXIodGV4dCwgY29tbWVudCwgb3B0aW9ucy5sb2NFbmQpO1xuXG4gICAgaWYgKG5leHRDaGFyYWN0ZXIgPT09IFwiKVwiKSB7XG4gICAgICBhZGRUcmFpbGluZ0NvbW1lbnQkMihwcmVjZWRpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChmb2xsb3dpbmdOb2RlLnR5cGUgPT09IFwiQmxvY2tTdGF0ZW1lbnRcIikge1xuICAgICAgYWRkQmxvY2tTdGF0ZW1lbnRGaXJzdENvbW1lbnQoZm9sbG93aW5nTm9kZSwgY29tbWVudCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gU2FtZSBhcyBJZlN0YXRlbWVudCBidXQgZm9yIFRyeVN0YXRlbWVudFxuXG5cbiAgZnVuY3Rpb24gaGFuZGxlVHJ5U3RhdGVtZW50Q29tbWVudHMoZW5jbG9zaW5nTm9kZSwgcHJlY2VkaW5nTm9kZSwgZm9sbG93aW5nTm9kZSwgY29tbWVudCkge1xuICAgIGlmICghZW5jbG9zaW5nTm9kZSB8fCBlbmNsb3NpbmdOb2RlLnR5cGUgIT09IFwiVHJ5U3RhdGVtZW50XCIgJiYgZW5jbG9zaW5nTm9kZS50eXBlICE9PSBcIkNhdGNoQ2xhdXNlXCIgfHwgIWZvbGxvd2luZ05vZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZW5jbG9zaW5nTm9kZS50eXBlID09PSBcIkNhdGNoQ2xhdXNlXCIgJiYgcHJlY2VkaW5nTm9kZSkge1xuICAgICAgYWRkVHJhaWxpbmdDb21tZW50JDIocHJlY2VkaW5nTm9kZSwgY29tbWVudCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZm9sbG93aW5nTm9kZS50eXBlID09PSBcIkJsb2NrU3RhdGVtZW50XCIpIHtcbiAgICAgIGFkZEJsb2NrU3RhdGVtZW50Rmlyc3RDb21tZW50KGZvbGxvd2luZ05vZGUsIGNvbW1lbnQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGZvbGxvd2luZ05vZGUudHlwZSA9PT0gXCJUcnlTdGF0ZW1lbnRcIikge1xuICAgICAgYWRkQmxvY2tPck5vdENvbW1lbnQoZm9sbG93aW5nTm9kZS5maW5hbGl6ZXIsIGNvbW1lbnQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGZvbGxvd2luZ05vZGUudHlwZSA9PT0gXCJDYXRjaENsYXVzZVwiKSB7XG4gICAgICBhZGRCbG9ja09yTm90Q29tbWVudChmb2xsb3dpbmdOb2RlLmJvZHksIGNvbW1lbnQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTWVtYmVyRXhwcmVzc2lvbkNvbW1lbnRzKGVuY2xvc2luZ05vZGUsIGZvbGxvd2luZ05vZGUsIGNvbW1lbnQpIHtcbiAgICBpZiAoZW5jbG9zaW5nTm9kZSAmJiAoZW5jbG9zaW5nTm9kZS50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiB8fCBlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIpICYmIGZvbGxvd2luZ05vZGUgJiYgZm9sbG93aW5nTm9kZS50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgYWRkTGVhZGluZ0NvbW1lbnQkMihlbmNsb3NpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUNvbmRpdGlvbmFsRXhwcmVzc2lvbkNvbW1lbnRzKGVuY2xvc2luZ05vZGUsIHByZWNlZGluZ05vZGUsIGZvbGxvd2luZ05vZGUsIGNvbW1lbnQsIHRleHQsIG9wdGlvbnMpIHtcbiAgICB2YXIgaXNTYW1lTGluZUFzUHJlY2VkaW5nTm9kZSA9IHByZWNlZGluZ05vZGUgJiYgIXV0aWwuaGFzTmV3bGluZUluUmFuZ2UodGV4dCwgb3B0aW9ucy5sb2NFbmQocHJlY2VkaW5nTm9kZSksIG9wdGlvbnMubG9jU3RhcnQoY29tbWVudCkpO1xuXG4gICAgaWYgKCghcHJlY2VkaW5nTm9kZSB8fCAhaXNTYW1lTGluZUFzUHJlY2VkaW5nTm9kZSkgJiYgZW5jbG9zaW5nTm9kZSAmJiBlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIgJiYgZm9sbG93aW5nTm9kZSkge1xuICAgICAgYWRkTGVhZGluZ0NvbW1lbnQkMihmb2xsb3dpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU9iamVjdFByb3BlcnR5QXNzaWdubWVudChlbmNsb3NpbmdOb2RlLCBwcmVjZWRpbmdOb2RlLCBjb21tZW50KSB7XG4gICAgaWYgKGVuY2xvc2luZ05vZGUgJiYgKGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJPYmplY3RQcm9wZXJ0eVwiIHx8IGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJQcm9wZXJ0eVwiKSAmJiBlbmNsb3NpbmdOb2RlLnNob3J0aGFuZCAmJiBlbmNsb3NpbmdOb2RlLmtleSA9PT0gcHJlY2VkaW5nTm9kZSAmJiBlbmNsb3NpbmdOb2RlLnZhbHVlLnR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIikge1xuICAgICAgYWRkVHJhaWxpbmdDb21tZW50JDIoZW5jbG9zaW5nTm9kZS52YWx1ZS5sZWZ0LCBjb21tZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUNsYXNzQ29tbWVudHMoZW5jbG9zaW5nTm9kZSwgcHJlY2VkaW5nTm9kZSwgZm9sbG93aW5nTm9kZSwgY29tbWVudCkge1xuICAgIGlmIChlbmNsb3NpbmdOb2RlICYmIChlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiQ2xhc3NEZWNsYXJhdGlvblwiIHx8IGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJDbGFzc0V4cHJlc3Npb25cIikgJiYgZW5jbG9zaW5nTm9kZS5kZWNvcmF0b3JzICYmIGVuY2xvc2luZ05vZGUuZGVjb3JhdG9ycy5sZW5ndGggPiAwICYmICEoZm9sbG93aW5nTm9kZSAmJiBmb2xsb3dpbmdOb2RlLnR5cGUgPT09IFwiRGVjb3JhdG9yXCIpKSB7XG4gICAgICBpZiAoIWVuY2xvc2luZ05vZGUuZGVjb3JhdG9ycyB8fCBlbmNsb3NpbmdOb2RlLmRlY29yYXRvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGFkZExlYWRpbmdDb21tZW50JDIoZW5jbG9zaW5nTm9kZSwgY29tbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRUcmFpbGluZ0NvbW1lbnQkMihlbmNsb3NpbmdOb2RlLmRlY29yYXRvcnNbZW5jbG9zaW5nTm9kZS5kZWNvcmF0b3JzLmxlbmd0aCAtIDFdLCBjb21tZW50KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTWV0aG9kTmFtZUNvbW1lbnRzKHRleHQsIGVuY2xvc2luZ05vZGUsIHByZWNlZGluZ05vZGUsIGNvbW1lbnQsIG9wdGlvbnMpIHtcbiAgICAvLyBUaGlzIGlzIG9ubHkgbmVlZGVkIGZvciBlc3RyZWUgcGFyc2VycyAoZmxvdywgdHlwZXNjcmlwdCkgdG8gYXR0YWNoXG4gICAgLy8gYWZ0ZXIgYSBtZXRob2QgbmFtZTpcbiAgICAvLyBvYmogPSB7IGZuIC8qY29tbWVudCovKCkge30gfTtcbiAgICBpZiAoZW5jbG9zaW5nTm9kZSAmJiBwcmVjZWRpbmdOb2RlICYmIChlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiUHJvcGVydHlcIiB8fCBlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiTWV0aG9kRGVmaW5pdGlvblwiKSAmJiBwcmVjZWRpbmdOb2RlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGVuY2xvc2luZ05vZGUua2V5ID09PSBwcmVjZWRpbmdOb2RlICYmIC8vIHNwZWNpYWwgUHJvcGVydHkgY2FzZTogeyBrZXk6IC8qY29tbWVudCovKHZhbHVlKSB9O1xuICAgIC8vIGNvbW1lbnQgc2hvdWxkIGJlIGF0dGFjaGVkIHRvIHZhbHVlIGluc3RlYWQgb2Yga2V5XG4gICAgdXRpbC5nZXROZXh0Tm9uU3BhY2VOb25Db21tZW50Q2hhcmFjdGVyKHRleHQsIHByZWNlZGluZ05vZGUsIG9wdGlvbnMubG9jRW5kKSAhPT0gXCI6XCIpIHtcbiAgICAgIGFkZFRyYWlsaW5nQ29tbWVudCQyKHByZWNlZGluZ05vZGUsIGNvbW1lbnQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBQcmludCBjb21tZW50cyBiZXR3ZWVuIGRlY29yYXRvcnMgYW5kIGNsYXNzIG1ldGhvZHMgYXMgYSB0cmFpbGluZyBjb21tZW50XG4gICAgLy8gb24gdGhlIGRlY29yYXRvciBub2RlIGluc3RlYWQgb2YgdGhlIG1ldGhvZCBub2RlXG5cblxuICAgIGlmIChwcmVjZWRpbmdOb2RlICYmIGVuY2xvc2luZ05vZGUgJiYgcHJlY2VkaW5nTm9kZS50eXBlID09PSBcIkRlY29yYXRvclwiICYmIChlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiQ2xhc3NNZXRob2RcIiB8fCBlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiQ2xhc3NQcm9wZXJ0eVwiIHx8IGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJUU0Fic3RyYWN0Q2xhc3NQcm9wZXJ0eVwiIHx8IGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJUU0Fic3RyYWN0TWV0aG9kRGVmaW5pdGlvblwiIHx8IGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJNZXRob2REZWZpbml0aW9uXCIpKSB7XG4gICAgICBhZGRUcmFpbGluZ0NvbW1lbnQkMihwcmVjZWRpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUZ1bmN0aW9uTmFtZUNvbW1lbnRzKHRleHQsIGVuY2xvc2luZ05vZGUsIHByZWNlZGluZ05vZGUsIGNvbW1lbnQsIG9wdGlvbnMpIHtcbiAgICBpZiAodXRpbC5nZXROZXh0Tm9uU3BhY2VOb25Db21tZW50Q2hhcmFjdGVyKHRleHQsIGNvbW1lbnQsIG9wdGlvbnMubG9jRW5kKSAhPT0gXCIoXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAocHJlY2VkaW5nTm9kZSAmJiBlbmNsb3NpbmdOb2RlICYmIChlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiIHx8IGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIiB8fCBlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiQ2xhc3NNZXRob2RcIiB8fCBlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiTWV0aG9kRGVmaW5pdGlvblwiIHx8IGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJPYmplY3RNZXRob2RcIikpIHtcbiAgICAgIGFkZFRyYWlsaW5nQ29tbWVudCQyKHByZWNlZGluZ05vZGUsIGNvbW1lbnQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ29tbWVudEFmdGVyQXJyb3dQYXJhbXModGV4dCwgZW5jbG9zaW5nTm9kZSwgY29tbWVudCwgb3B0aW9ucykge1xuICAgIGlmICghKGVuY2xvc2luZ05vZGUgJiYgZW5jbG9zaW5nTm9kZS50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gdXRpbFNoYXJlZC5nZXROZXh0Tm9uU3BhY2VOb25Db21tZW50Q2hhcmFjdGVySW5kZXgodGV4dCwgY29tbWVudCwgb3B0aW9ucyk7XG5cbiAgICBpZiAodGV4dC5zdWJzdHIoaW5kZXgsIDIpID09PSBcIj0+XCIpIHtcbiAgICAgIGFkZERhbmdsaW5nQ29tbWVudCQyKGVuY2xvc2luZ05vZGUsIGNvbW1lbnQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ29tbWVudEluRW1wdHlQYXJlbnModGV4dCwgZW5jbG9zaW5nTm9kZSwgY29tbWVudCwgb3B0aW9ucykge1xuICAgIGlmICh1dGlsLmdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXIodGV4dCwgY29tbWVudCwgb3B0aW9ucy5sb2NFbmQpICE9PSBcIilcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gT25seSBhZGQgZGFuZ2xpbmcgY29tbWVudHMgdG8gZml4IHRoZSBjYXNlIHdoZW4gbm8gcGFyYW1zIGFyZSBwcmVzZW50LFxuICAgIC8vIGkuZS4gYSBmdW5jdGlvbiB3aXRob3V0IGFueSBhcmd1bWVudC5cblxuXG4gICAgaWYgKGVuY2xvc2luZ05vZGUgJiYgKChlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiIHx8IGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIiB8fCBlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiB8fCBlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiQ2xhc3NNZXRob2RcIiB8fCBlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiT2JqZWN0TWV0aG9kXCIpICYmIGVuY2xvc2luZ05vZGUucGFyYW1zLmxlbmd0aCA9PT0gMCB8fCAoZW5jbG9zaW5nTm9kZS50eXBlID09PSBcIkNhbGxFeHByZXNzaW9uXCIgfHwgZW5jbG9zaW5nTm9kZS50eXBlID09PSBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIiB8fCBlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiTmV3RXhwcmVzc2lvblwiKSAmJiBlbmNsb3NpbmdOb2RlLmFyZ3VtZW50cy5sZW5ndGggPT09IDApKSB7XG4gICAgICBhZGREYW5nbGluZ0NvbW1lbnQkMihlbmNsb3NpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChlbmNsb3NpbmdOb2RlICYmIGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJNZXRob2REZWZpbml0aW9uXCIgJiYgZW5jbG9zaW5nTm9kZS52YWx1ZS5wYXJhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBhZGREYW5nbGluZ0NvbW1lbnQkMihlbmNsb3NpbmdOb2RlLnZhbHVlLCBjb21tZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUxhc3RGdW5jdGlvbkFyZ0NvbW1lbnRzKHRleHQsIHByZWNlZGluZ05vZGUsIGVuY2xvc2luZ05vZGUsIGZvbGxvd2luZ05vZGUsIGNvbW1lbnQsIG9wdGlvbnMpIHtcbiAgICAvLyBUeXBlIGRlZmluaXRpb25zIGZ1bmN0aW9uc1xuICAgIGlmIChwcmVjZWRpbmdOb2RlICYmIHByZWNlZGluZ05vZGUudHlwZSA9PT0gXCJGdW5jdGlvblR5cGVQYXJhbVwiICYmIGVuY2xvc2luZ05vZGUgJiYgZW5jbG9zaW5nTm9kZS50eXBlID09PSBcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIiAmJiBmb2xsb3dpbmdOb2RlICYmIGZvbGxvd2luZ05vZGUudHlwZSAhPT0gXCJGdW5jdGlvblR5cGVQYXJhbVwiKSB7XG4gICAgICBhZGRUcmFpbGluZ0NvbW1lbnQkMihwcmVjZWRpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gUmVhbCBmdW5jdGlvbnNcblxuXG4gICAgaWYgKHByZWNlZGluZ05vZGUgJiYgKHByZWNlZGluZ05vZGUudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgfHwgcHJlY2VkaW5nTm9kZS50eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpICYmIGVuY2xvc2luZ05vZGUgJiYgKGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiIHx8IGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIiB8fCBlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiIHx8IGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJPYmplY3RNZXRob2RcIiB8fCBlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiQ2xhc3NNZXRob2RcIikgJiYgdXRpbC5nZXROZXh0Tm9uU3BhY2VOb25Db21tZW50Q2hhcmFjdGVyKHRleHQsIGNvbW1lbnQsIG9wdGlvbnMubG9jRW5kKSA9PT0gXCIpXCIpIHtcbiAgICAgIGFkZFRyYWlsaW5nQ29tbWVudCQyKHByZWNlZGluZ05vZGUsIGNvbW1lbnQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGVuY2xvc2luZ05vZGUgJiYgZW5jbG9zaW5nTm9kZS50eXBlID09PSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiAmJiBmb2xsb3dpbmdOb2RlICYmIGZvbGxvd2luZ05vZGUudHlwZSA9PT0gXCJCbG9ja1N0YXRlbWVudFwiKSB7XG4gICAgICB2YXIgZnVuY3Rpb25QYXJhbVJpZ2h0UGFyZW5JbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGVuY2xvc2luZ05vZGUucGFyYW1zLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHJldHVybiB1dGlsLmdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXJJbmRleFdpdGhTdGFydEluZGV4KHRleHQsIG9wdGlvbnMubG9jRW5kKHV0aWwuZ2V0TGFzdChlbmNsb3NpbmdOb2RlLnBhcmFtcykpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmdW5jdGlvblBhcmFtTGVmdFBhcmVuSW5kZXggPSB1dGlsLmdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXJJbmRleFdpdGhTdGFydEluZGV4KHRleHQsIG9wdGlvbnMubG9jRW5kKGVuY2xvc2luZ05vZGUuaWQpKTtcbiAgICAgICAgcmV0dXJuIHV0aWwuZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3RlckluZGV4V2l0aFN0YXJ0SW5kZXgodGV4dCwgZnVuY3Rpb25QYXJhbUxlZnRQYXJlbkluZGV4ICsgMSk7XG4gICAgICB9KCk7XG5cbiAgICAgIGlmIChvcHRpb25zLmxvY1N0YXJ0KGNvbW1lbnQpID4gZnVuY3Rpb25QYXJhbVJpZ2h0UGFyZW5JbmRleCkge1xuICAgICAgICBhZGRCbG9ja1N0YXRlbWVudEZpcnN0Q29tbWVudChmb2xsb3dpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlSW1wb3J0U3BlY2lmaWVyQ29tbWVudHMoZW5jbG9zaW5nTm9kZSwgY29tbWVudCkge1xuICAgIGlmIChlbmNsb3NpbmdOb2RlICYmIGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJJbXBvcnRTcGVjaWZpZXJcIikge1xuICAgICAgYWRkTGVhZGluZ0NvbW1lbnQkMihlbmNsb3NpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUxhYmVsZWRTdGF0ZW1lbnRDb21tZW50cyhlbmNsb3NpbmdOb2RlLCBjb21tZW50KSB7XG4gICAgaWYgKGVuY2xvc2luZ05vZGUgJiYgZW5jbG9zaW5nTm9kZS50eXBlID09PSBcIkxhYmVsZWRTdGF0ZW1lbnRcIikge1xuICAgICAgYWRkTGVhZGluZ0NvbW1lbnQkMihlbmNsb3NpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUJyZWFrQW5kQ29udGludWVTdGF0ZW1lbnRDb21tZW50cyhlbmNsb3NpbmdOb2RlLCBjb21tZW50KSB7XG4gICAgaWYgKGVuY2xvc2luZ05vZGUgJiYgKGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJDb250aW51ZVN0YXRlbWVudFwiIHx8IGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJCcmVha1N0YXRlbWVudFwiKSAmJiAhZW5jbG9zaW5nTm9kZS5sYWJlbCkge1xuICAgICAgYWRkVHJhaWxpbmdDb21tZW50JDIoZW5jbG9zaW5nTm9kZSwgY29tbWVudCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDYWxsRXhwcmVzc2lvbkNvbW1lbnRzKHByZWNlZGluZ05vZGUsIGVuY2xvc2luZ05vZGUsIGNvbW1lbnQpIHtcbiAgICBpZiAoZW5jbG9zaW5nTm9kZSAmJiAoZW5jbG9zaW5nTm9kZS50eXBlID09PSBcIkNhbGxFeHByZXNzaW9uXCIgfHwgZW5jbG9zaW5nTm9kZS50eXBlID09PSBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIikgJiYgcHJlY2VkaW5nTm9kZSAmJiBlbmNsb3NpbmdOb2RlLmNhbGxlZSA9PT0gcHJlY2VkaW5nTm9kZSAmJiBlbmNsb3NpbmdOb2RlLmFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICBhZGRMZWFkaW5nQ29tbWVudCQyKGVuY2xvc2luZ05vZGUuYXJndW1lbnRzWzBdLCBjb21tZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVVuaW9uVHlwZUNvbW1lbnRzKHByZWNlZGluZ05vZGUsIGVuY2xvc2luZ05vZGUsIGZvbGxvd2luZ05vZGUsIGNvbW1lbnQpIHtcbiAgICBpZiAoZW5jbG9zaW5nTm9kZSAmJiAoZW5jbG9zaW5nTm9kZS50eXBlID09PSBcIlVuaW9uVHlwZUFubm90YXRpb25cIiB8fCBlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiVFNVbmlvblR5cGVcIikpIHtcbiAgICAgIGFkZFRyYWlsaW5nQ29tbWVudCQyKHByZWNlZGluZ05vZGUsIGNvbW1lbnQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDb21tZW50cyhlbmNsb3NpbmdOb2RlLCBjb21tZW50KSB7XG4gICAgaWYgKGVuY2xvc2luZ05vZGUgJiYgKGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJQcm9wZXJ0eVwiIHx8IGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJPYmplY3RQcm9wZXJ0eVwiKSkge1xuICAgICAgYWRkTGVhZGluZ0NvbW1lbnQkMihlbmNsb3NpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU9ubHlDb21tZW50cyhlbmNsb3NpbmdOb2RlLCBhc3QsIGNvbW1lbnQsIGlzTGFzdENvbW1lbnQpIHtcbiAgICAvLyBXaXRoIEZsb3cgdGhlIGVuY2xvc2luZ05vZGUgaXMgdW5kZWZpbmVkIHNvIHVzZSB0aGUgQVNUIGluc3RlYWQuXG4gICAgaWYgKGFzdCAmJiBhc3QuYm9keSAmJiBhc3QuYm9keS5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChpc0xhc3RDb21tZW50KSB7XG4gICAgICAgIGFkZERhbmdsaW5nQ29tbWVudCQyKGFzdCwgY29tbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRMZWFkaW5nQ29tbWVudCQyKGFzdCwgY29tbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZW5jbG9zaW5nTm9kZSAmJiBlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiUHJvZ3JhbVwiICYmIGVuY2xvc2luZ05vZGUuYm9keS5sZW5ndGggPT09IDAgJiYgZW5jbG9zaW5nTm9kZS5kaXJlY3RpdmVzICYmIGVuY2xvc2luZ05vZGUuZGlyZWN0aXZlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChpc0xhc3RDb21tZW50KSB7XG4gICAgICAgIGFkZERhbmdsaW5nQ29tbWVudCQyKGVuY2xvc2luZ05vZGUsIGNvbW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkTGVhZGluZ0NvbW1lbnQkMihlbmNsb3NpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlRm9yQ29tbWVudHMoZW5jbG9zaW5nTm9kZSwgcHJlY2VkaW5nTm9kZSwgY29tbWVudCkge1xuICAgIGlmIChlbmNsb3NpbmdOb2RlICYmIChlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiRm9ySW5TdGF0ZW1lbnRcIiB8fCBlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiRm9yT2ZTdGF0ZW1lbnRcIikpIHtcbiAgICAgIGFkZExlYWRpbmdDb21tZW50JDIoZW5jbG9zaW5nTm9kZSwgY29tbWVudCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVJbXBvcnREZWNsYXJhdGlvbkNvbW1lbnRzKHRleHQsIGVuY2xvc2luZ05vZGUsIHByZWNlZGluZ05vZGUsIGNvbW1lbnQsIG9wdGlvbnMpIHtcbiAgICBpZiAocHJlY2VkaW5nTm9kZSAmJiBwcmVjZWRpbmdOb2RlLnR5cGUgPT09IFwiSW1wb3J0U3BlY2lmaWVyXCIgJiYgZW5jbG9zaW5nTm9kZSAmJiBlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiSW1wb3J0RGVjbGFyYXRpb25cIiAmJiB1dGlsLmhhc05ld2xpbmUodGV4dCwgb3B0aW9ucy5sb2NFbmQoY29tbWVudCkpKSB7XG4gICAgICBhZGRUcmFpbGluZ0NvbW1lbnQkMihwcmVjZWRpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUFzc2lnbm1lbnRQYXR0ZXJuQ29tbWVudHMoZW5jbG9zaW5nTm9kZSwgY29tbWVudCkge1xuICAgIGlmIChlbmNsb3NpbmdOb2RlICYmIGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKSB7XG4gICAgICBhZGRMZWFkaW5nQ29tbWVudCQyKGVuY2xvc2luZ05vZGUsIGNvbW1lbnQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlVHlwZUFsaWFzQ29tbWVudHMoZW5jbG9zaW5nTm9kZSwgZm9sbG93aW5nTm9kZSwgY29tbWVudCkge1xuICAgIGlmIChlbmNsb3NpbmdOb2RlICYmIGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJUeXBlQWxpYXNcIikge1xuICAgICAgYWRkTGVhZGluZ0NvbW1lbnQkMihlbmNsb3NpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVZhcmlhYmxlRGVjbGFyYXRvckNvbW1lbnRzKGVuY2xvc2luZ05vZGUsIGZvbGxvd2luZ05vZGUsIGNvbW1lbnQpIHtcbiAgICBpZiAoZW5jbG9zaW5nTm9kZSAmJiAoZW5jbG9zaW5nTm9kZS50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRvclwiIHx8IGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKSAmJiBmb2xsb3dpbmdOb2RlICYmIChmb2xsb3dpbmdOb2RlLnR5cGUgPT09IFwiT2JqZWN0RXhwcmVzc2lvblwiIHx8IGZvbGxvd2luZ05vZGUudHlwZSA9PT0gXCJBcnJheUV4cHJlc3Npb25cIiB8fCBmb2xsb3dpbmdOb2RlLnR5cGUgPT09IFwiVGVtcGxhdGVMaXRlcmFsXCIgfHwgZm9sbG93aW5nTm9kZS50eXBlID09PSBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiKSkge1xuICAgICAgYWRkTGVhZGluZ0NvbW1lbnQkMihmb2xsb3dpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVRTTWFwcGVkVHlwZUNvbW1lbnRzKHRleHQsIGVuY2xvc2luZ05vZGUsIHByZWNlZGluZ05vZGUsIGZvbGxvd2luZ05vZGUsIGNvbW1lbnQpIHtcbiAgICBpZiAoIWVuY2xvc2luZ05vZGUgfHwgZW5jbG9zaW5nTm9kZS50eXBlICE9PSBcIlRTTWFwcGVkVHlwZVwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGZvbGxvd2luZ05vZGUgJiYgZm9sbG93aW5nTm9kZS50eXBlID09PSBcIlRTVHlwZVBhcmFtZXRlclwiICYmIGZvbGxvd2luZ05vZGUubmFtZSkge1xuICAgICAgYWRkTGVhZGluZ0NvbW1lbnQkMihmb2xsb3dpbmdOb2RlLm5hbWUsIGNvbW1lbnQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHByZWNlZGluZ05vZGUgJiYgcHJlY2VkaW5nTm9kZS50eXBlID09PSBcIlRTVHlwZVBhcmFtZXRlclwiICYmIHByZWNlZGluZ05vZGUuY29uc3RyYWludCkge1xuICAgICAgYWRkVHJhaWxpbmdDb21tZW50JDIocHJlY2VkaW5nTm9kZS5jb25zdHJhaW50LCBjb21tZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQmxvY2tDb21tZW50KGNvbW1lbnQpIHtcbiAgICByZXR1cm4gY29tbWVudC50eXBlID09PSBcIkJsb2NrXCIgfHwgY29tbWVudC50eXBlID09PSBcIkNvbW1lbnRCbG9ja1wiO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzTGVhZGluZ0NvbW1lbnQobm9kZSkge1xuICAgIHZhciBmbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIGlmIChub2RlLmxlYWRpbmdDb21tZW50cykge1xuICAgICAgcmV0dXJuIG5vZGUubGVhZGluZ0NvbW1lbnRzLnNvbWUoZm4pO1xuICAgIH1cblxuICAgIGlmIChub2RlLmNvbW1lbnRzKSB7XG4gICAgICByZXR1cm4gbm9kZS5jb21tZW50cy5zb21lKGZ1bmN0aW9uIChjb21tZW50KSB7XG4gICAgICAgIHJldHVybiBjb21tZW50LmxlYWRpbmcgJiYgZm4oY29tbWVudCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgY29tbWVudHMkMSA9IHtcbiAgICBoYW5kbGVPd25MaW5lQ29tbWVudDogaGFuZGxlT3duTGluZUNvbW1lbnQsXG4gICAgaGFuZGxlRW5kT2ZMaW5lQ29tbWVudDogaGFuZGxlRW5kT2ZMaW5lQ29tbWVudCxcbiAgICBoYW5kbGVSZW1haW5pbmdDb21tZW50OiBoYW5kbGVSZW1haW5pbmdDb21tZW50LFxuICAgIGhhc0xlYWRpbmdDb21tZW50OiBoYXNMZWFkaW5nQ29tbWVudCxcbiAgICBpc0Jsb2NrQ29tbWVudDogaXNCbG9ja0NvbW1lbnRcbiAgfTtcblxuICB2YXIgaXNCbG9ja0NvbW1lbnQkMSA9IGNvbW1lbnRzJDEuaXNCbG9ja0NvbW1lbnQsXG4gICAgICBoYXNMZWFkaW5nQ29tbWVudCQxID0gY29tbWVudHMkMS5oYXNMZWFkaW5nQ29tbWVudDtcbiAgdmFyIF9yZXF1aXJlJCQxJGJ1aWxkZXJzID0gZG9jLmJ1aWxkZXJzLFxuICAgICAgaW5kZW50JDYgPSBfcmVxdWlyZSQkMSRidWlsZGVycy5pbmRlbnQsXG4gICAgICBqb2luJDcgPSBfcmVxdWlyZSQkMSRidWlsZGVycy5qb2luLFxuICAgICAgaGFyZGxpbmUkOCA9IF9yZXF1aXJlJCQxJGJ1aWxkZXJzLmhhcmRsaW5lLFxuICAgICAgc29mdGxpbmUkNSA9IF9yZXF1aXJlJCQxJGJ1aWxkZXJzLnNvZnRsaW5lLFxuICAgICAgbGl0ZXJhbGxpbmUkMyA9IF9yZXF1aXJlJCQxJGJ1aWxkZXJzLmxpdGVyYWxsaW5lLFxuICAgICAgY29uY2F0JGIgPSBfcmVxdWlyZSQkMSRidWlsZGVycy5jb25jYXQsXG4gICAgICBncm91cCRhID0gX3JlcXVpcmUkJDEkYnVpbGRlcnMuZ3JvdXAsXG4gICAgICBkZWRlbnRUb1Jvb3QkMiA9IF9yZXF1aXJlJCQxJGJ1aWxkZXJzLmRlZGVudFRvUm9vdCxcbiAgICAgIF9yZXF1aXJlJCQxJHV0aWxzID0gZG9jLnV0aWxzLFxuICAgICAgbWFwRG9jJDUgPSBfcmVxdWlyZSQkMSR1dGlscy5tYXBEb2MsXG4gICAgICBzdHJpcFRyYWlsaW5nSGFyZGxpbmUkMiA9IF9yZXF1aXJlJCQxJHV0aWxzLnN0cmlwVHJhaWxpbmdIYXJkbGluZTtcblxuICBmdW5jdGlvbiBlbWJlZCQzKHBhdGgsIHByaW50LCB0ZXh0VG9Eb2MsIG9wdGlvbnMpIHtcbiAgICB2YXIgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICB2YXIgcGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG4gICAgdmFyIHBhcmVudFBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgxKTtcblxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiVGVtcGxhdGVMaXRlcmFsXCI6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgaXNDc3MgPSBbaXNTdHlsZWRKc3gsIGlzU3R5bGVkQ29tcG9uZW50cywgaXNDc3NQcm9wLCBpc0FuZ3VsYXJDb21wb25lbnRTdHlsZXNdLnNvbWUoZnVuY3Rpb24gKGlzSXQpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0l0KHBhdGgpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGlzQ3NzKSB7XG4gICAgICAgICAgICAvLyBHZXQgZnVsbCB0ZW1wbGF0ZSBsaXRlcmFsIHdpdGggZXhwcmVzc2lvbnMgcmVwbGFjZWQgYnkgcGxhY2Vob2xkZXJzXG4gICAgICAgICAgICB2YXIgcmF3UXVhc2lzID0gbm9kZS5xdWFzaXMubWFwKGZ1bmN0aW9uIChxKSB7XG4gICAgICAgICAgICAgIHJldHVybiBxLnZhbHVlLnJhdztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHBsYWNlaG9sZGVySUQgPSAwO1xuICAgICAgICAgICAgdmFyIHRleHQgPSByYXdRdWFzaXMucmVkdWNlKGZ1bmN0aW9uIChwcmV2VmFsLCBjdXJyVmFsLCBpZHgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlkeCA9PSAwID8gY3VyclZhbCA6IHByZXZWYWwgKyBcIkBwcmV0dGllci1wbGFjZWhvbGRlci1cIiArIHBsYWNlaG9sZGVySUQrKyArIFwiLWlkXCIgKyBjdXJyVmFsO1xuICAgICAgICAgICAgfSwgXCJcIik7XG4gICAgICAgICAgICB2YXIgZG9jID0gdGV4dFRvRG9jKHRleHQsIHtcbiAgICAgICAgICAgICAgcGFyc2VyOiBcImNzc1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1Dc3NEb2MoZG9jLCBwYXRoLCBwcmludCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qXG4gICAgICAgICAgICogcmVhY3QtcmVsYXkgYW5kIGdyYXBocWwtdGFnXG4gICAgICAgICAgICogZ3JhcGhxbGAuLi5gXG4gICAgICAgICAgICogZ3JhcGhxbC5leHBlcmltZW50YWxgLi4uYFxuICAgICAgICAgICAqIGdxbGAuLi5gXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBUaGlzIGludGVudGlvbmFsbHkgZXhjbHVkZXMgUmVsYXkgQ2xhc3NpYyB0YWdzLCBhcyBQcmV0dGllciBkb2VzIG5vdFxuICAgICAgICAgICAqIHN1cHBvcnQgUmVsYXkgQ2xhc3NpYyBmb3JtYXR0aW5nLlxuICAgICAgICAgICAqL1xuXG5cbiAgICAgICAgICBpZiAoaXNHcmFwaFFMKHBhdGgpKSB7XG4gICAgICAgICAgICB2YXIgZXhwcmVzc2lvbkRvY3MgPSBub2RlLmV4cHJlc3Npb25zID8gcGF0aC5tYXAocHJpbnQsIFwiZXhwcmVzc2lvbnNcIikgOiBbXTtcbiAgICAgICAgICAgIHZhciBudW1RdWFzaXMgPSBub2RlLnF1YXNpcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmIChudW1RdWFzaXMgPT09IDEgJiYgbm9kZS5xdWFzaXNbMF0udmFsdWUucmF3LnRyaW0oKSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICByZXR1cm4gXCJgYFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1RdWFzaXM7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgdGVtcGxhdGVFbGVtZW50ID0gbm9kZS5xdWFzaXNbaV07XG4gICAgICAgICAgICAgIHZhciBpc0ZpcnN0ID0gaSA9PT0gMDtcbiAgICAgICAgICAgICAgdmFyIGlzTGFzdCA9IGkgPT09IG51bVF1YXNpcyAtIDE7XG4gICAgICAgICAgICAgIHZhciBfdGV4dCA9IHRlbXBsYXRlRWxlbWVudC52YWx1ZS5jb29rZWQ7IC8vIEJhaWwgb3V0IGlmIGFueSBvZiB0aGUgcXVhc2lzIGhhdmUgYW4gaW52YWxpZCBlc2NhcGUgc2VxdWVuY2VcbiAgICAgICAgICAgICAgLy8gKHdoaWNoIHdvdWxkIG1ha2UgdGhlIGBjb29rZWRgIHZhbHVlIGJlIGBudWxsYCBvciBgdW5kZWZpbmVkYClcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIF90ZXh0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgbGluZXMgPSBfdGV4dC5zcGxpdChcIlxcblwiKTtcblxuICAgICAgICAgICAgICB2YXIgbnVtTGluZXMgPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgICAgICAgIHZhciBleHByZXNzaW9uRG9jID0gZXhwcmVzc2lvbkRvY3NbaV07XG4gICAgICAgICAgICAgIHZhciBzdGFydHNXaXRoQmxhbmtMaW5lID0gbnVtTGluZXMgPiAyICYmIGxpbmVzWzBdLnRyaW0oKSA9PT0gXCJcIiAmJiBsaW5lc1sxXS50cmltKCkgPT09IFwiXCI7XG4gICAgICAgICAgICAgIHZhciBlbmRzV2l0aEJsYW5rTGluZSA9IG51bUxpbmVzID4gMiAmJiBsaW5lc1tudW1MaW5lcyAtIDFdLnRyaW0oKSA9PT0gXCJcIiAmJiBsaW5lc1tudW1MaW5lcyAtIDJdLnRyaW0oKSA9PT0gXCJcIjtcbiAgICAgICAgICAgICAgdmFyIGNvbW1lbnRzQW5kV2hpdGVzcGFjZU9ubHkgPSBsaW5lcy5ldmVyeShmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAvXlxccyooPzojW15cXHJcXG5dKik/JC8udGVzdChsaW5lKTtcbiAgICAgICAgICAgICAgfSk7IC8vIEJhaWwgb3V0IGlmIGFuIGludGVycG9sYXRpb24gb2NjdXJzIHdpdGhpbiBhIGNvbW1lbnQuXG5cbiAgICAgICAgICAgICAgaWYgKCFpc0xhc3QgJiYgLyNbXlxcclxcbl0qJC8udGVzdChsaW5lc1tudW1MaW5lcyAtIDFdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIF9kb2MgPSBudWxsO1xuXG4gICAgICAgICAgICAgIGlmIChjb21tZW50c0FuZFdoaXRlc3BhY2VPbmx5KSB7XG4gICAgICAgICAgICAgICAgX2RvYyA9IHByaW50R3JhcGhxbENvbW1lbnRzKGxpbmVzKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfZG9jID0gc3RyaXBUcmFpbGluZ0hhcmRsaW5lJDIodGV4dFRvRG9jKF90ZXh0LCB7XG4gICAgICAgICAgICAgICAgICBwYXJzZXI6IFwiZ3JhcGhxbFwiXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKF9kb2MpIHtcbiAgICAgICAgICAgICAgICBfZG9jID0gZXNjYXBlVGVtcGxhdGVDaGFyYWN0ZXJzKF9kb2MsIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgIGlmICghaXNGaXJzdCAmJiBzdGFydHNXaXRoQmxhbmtMaW5lKSB7XG4gICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goX2RvYyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWlzTGFzdCAmJiBlbmRzV2l0aEJsYW5rTGluZSkge1xuICAgICAgICAgICAgICAgICAgcGFydHMucHVzaChcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzRmlyc3QgJiYgIWlzTGFzdCAmJiBzdGFydHNXaXRoQmxhbmtMaW5lKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChcIlwiKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChleHByZXNzaW9uRG9jKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChjb25jYXQkYihbXCIke1wiLCBleHByZXNzaW9uRG9jLCBcIn1cIl0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY29uY2F0JGIoW1wiYFwiLCBpbmRlbnQkNihjb25jYXQkYihbaGFyZGxpbmUkOCwgam9pbiQ3KGhhcmRsaW5lJDgsIHBhcnRzKV0pKSwgaGFyZGxpbmUkOCwgXCJgXCJdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaHRtbFBhcnNlciA9IGlzSHRtbChwYXRoKSA/IFwiaHRtbFwiIDogaXNBbmd1bGFyQ29tcG9uZW50VGVtcGxhdGUocGF0aCkgPyBcImFuZ3VsYXJcIiA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmIChodG1sUGFyc2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJpbnRIdG1sVGVtcGxhdGVMaXRlcmFsKHBhdGgsIHByaW50LCB0ZXh0VG9Eb2MsIGh0bWxQYXJzZXIsIG9wdGlvbnMuZW1iZWRkZWRJbkh0bWwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJUZW1wbGF0ZUVsZW1lbnRcIjpcbiAgICAgICAge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIG1kYC4uLmBcbiAgICAgICAgICAgKiBtYXJrZG93bmAuLi5gXG4gICAgICAgICAgICovXG4gICAgICAgICAgaWYgKHBhcmVudFBhcmVudCAmJiBwYXJlbnRQYXJlbnQudHlwZSA9PT0gXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIiAmJiBwYXJlbnQucXVhc2lzLmxlbmd0aCA9PT0gMSAmJiBwYXJlbnRQYXJlbnQudGFnLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIChwYXJlbnRQYXJlbnQudGFnLm5hbWUgPT09IFwibWRcIiB8fCBwYXJlbnRQYXJlbnQudGFnLm5hbWUgPT09IFwibWFya2Rvd25cIikpIHtcbiAgICAgICAgICAgIHZhciBfdGV4dDIgPSBwYXJlbnQucXVhc2lzWzBdLnZhbHVlLnJhdy5yZXBsYWNlKC8oKD86XFxcXFxcXFwpKilcXFxcYC9nLCBmdW5jdGlvbiAoXywgYmFja3NsYXNoZXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXFwiLnJlcGVhdChiYWNrc2xhc2hlcy5sZW5ndGggLyAyKSArIFwiYFwiO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBpbmRlbnRhdGlvbiA9IGdldEluZGVudGF0aW9uKF90ZXh0Mik7XG4gICAgICAgICAgICB2YXIgaGFzSW5kZW50ID0gaW5kZW50YXRpb24gIT09IFwiXCI7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0JGIoW2hhc0luZGVudCA/IGluZGVudCQ2KGNvbmNhdCRiKFtzb2Z0bGluZSQ1LCBwcmludE1hcmtkb3duKF90ZXh0Mi5yZXBsYWNlKG5ldyBSZWdFeHAoXCJeXCIuY29uY2F0KGluZGVudGF0aW9uKSwgXCJnbVwiKSwgXCJcIikpXSkpIDogY29uY2F0JGIoW2xpdGVyYWxsaW5lJDMsIGRlZGVudFRvUm9vdCQyKHByaW50TWFya2Rvd24oX3RleHQyKSldKSwgc29mdGxpbmUkNV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJpbnRNYXJrZG93bih0ZXh0KSB7XG4gICAgICB2YXIgZG9jID0gdGV4dFRvRG9jKHRleHQsIHtcbiAgICAgICAgcGFyc2VyOiBcIm1hcmtkb3duXCIsXG4gICAgICAgIF9faW5Kc1RlbXBsYXRlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzdHJpcFRyYWlsaW5nSGFyZGxpbmUkMihlc2NhcGVUZW1wbGF0ZUNoYXJhY3RlcnMoZG9jLCB0cnVlKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SW5kZW50YXRpb24oc3RyKSB7XG4gICAgdmFyIGZpcnN0TWF0Y2hlZEluZGVudCA9IHN0ci5tYXRjaCgvXihbXlxcU1xcbl0qKVxcUy9tKTtcbiAgICByZXR1cm4gZmlyc3RNYXRjaGVkSW5kZW50ID09PSBudWxsID8gXCJcIiA6IGZpcnN0TWF0Y2hlZEluZGVudFsxXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuY29vayhjb29rZWRWYWx1ZSkge1xuICAgIHJldHVybiBjb29rZWRWYWx1ZS5yZXBsYWNlKC8oW1xcXFxgXXxcXCRcXHspL2csIFwiXFxcXCQxXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXNjYXBlVGVtcGxhdGVDaGFyYWN0ZXJzKGRvYywgcmF3KSB7XG4gICAgcmV0dXJuIG1hcERvYyQ1KGRvYywgZnVuY3Rpb24gKGN1cnJlbnREb2MpIHtcbiAgICAgIGlmICghY3VycmVudERvYy5wYXJ0cykge1xuICAgICAgICByZXR1cm4gY3VycmVudERvYztcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcnRzID0gW107XG4gICAgICBjdXJyZW50RG9jLnBhcnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJ0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcGFydHMucHVzaChyYXcgPyBwYXJ0LnJlcGxhY2UoLyhcXFxcKilgL2csIFwiJDEkMVxcXFxgXCIpIDogdW5jb29rKHBhcnQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjdXJyZW50RG9jLCB7XG4gICAgICAgIHBhcnRzOiBwYXJ0c1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2Zvcm1Dc3NEb2MocXVhc2lzRG9jLCBwYXRoLCBwcmludCkge1xuICAgIHZhciBwYXJlbnROb2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIHZhciBpc0VtcHR5ID0gcGFyZW50Tm9kZS5xdWFzaXMubGVuZ3RoID09PSAxICYmICFwYXJlbnROb2RlLnF1YXNpc1swXS52YWx1ZS5yYXcudHJpbSgpO1xuXG4gICAgaWYgKGlzRW1wdHkpIHtcbiAgICAgIHJldHVybiBcImBgXCI7XG4gICAgfVxuXG4gICAgdmFyIGV4cHJlc3Npb25Eb2NzID0gcGFyZW50Tm9kZS5leHByZXNzaW9ucyA/IHBhdGgubWFwKHByaW50LCBcImV4cHJlc3Npb25zXCIpIDogW107XG4gICAgdmFyIG5ld0RvYyA9IHJlcGxhY2VQbGFjZWhvbGRlcnMocXVhc2lzRG9jLCBleHByZXNzaW9uRG9jcyk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cbiAgICBpZiAoIW5ld0RvYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgaW5zZXJ0IGFsbCB0aGUgZXhwcmVzc2lvbnNcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmNhdCRiKFtcImBcIiwgaW5kZW50JDYoY29uY2F0JGIoW2hhcmRsaW5lJDgsIHN0cmlwVHJhaWxpbmdIYXJkbGluZSQyKG5ld0RvYyldKSksIHNvZnRsaW5lJDUsIFwiYFwiXSk7XG4gIH0gLy8gU2VhcmNoIGFsbCB0aGUgcGxhY2Vob2xkZXJzIGluIHRoZSBxdWFzaXNEb2MgdHJlZVxuICAvLyBhbmQgcmVwbGFjZSB0aGVtIHdpdGggdGhlIGV4cHJlc3Npb24gZG9jcyBvbmUgYnkgb25lXG4gIC8vIHJldHVybnMgYSBuZXcgZG9jIHdpdGggYWxsIHRoZSBwbGFjZWhvbGRlcnMgcmVwbGFjZWQsXG4gIC8vIG9yIG51bGwgaWYgaXQgY291bGRuJ3QgcmVwbGFjZSBhbnkgZXhwcmVzc2lvblxuXG5cbiAgZnVuY3Rpb24gcmVwbGFjZVBsYWNlaG9sZGVycyhxdWFzaXNEb2MsIGV4cHJlc3Npb25Eb2NzKSB7XG4gICAgaWYgKCFleHByZXNzaW9uRG9jcyB8fCAhZXhwcmVzc2lvbkRvY3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcXVhc2lzRG9jO1xuICAgIH1cblxuICAgIHZhciBleHByZXNzaW9ucyA9IGV4cHJlc3Npb25Eb2NzLnNsaWNlKCk7XG4gICAgdmFyIHJlcGxhY2VDb3VudGVyID0gMDtcbiAgICB2YXIgbmV3RG9jID0gbWFwRG9jJDUocXVhc2lzRG9jLCBmdW5jdGlvbiAoZG9jKSB7XG4gICAgICBpZiAoIWRvYyB8fCAhZG9jLnBhcnRzIHx8ICFkb2MucGFydHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBkb2M7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJ0cyA9IGRvYy5wYXJ0cztcbiAgICAgIHZhciBhdEluZGV4ID0gcGFydHMuaW5kZXhPZihcIkBcIik7XG4gICAgICB2YXIgcGxhY2Vob2xkZXJJbmRleCA9IGF0SW5kZXggKyAxO1xuXG4gICAgICBpZiAoYXRJbmRleCA+IC0xICYmIHR5cGVvZiBwYXJ0c1twbGFjZWhvbGRlckluZGV4XSA9PT0gXCJzdHJpbmdcIiAmJiBwYXJ0c1twbGFjZWhvbGRlckluZGV4XS5zdGFydHNXaXRoKFwicHJldHRpZXItcGxhY2Vob2xkZXJcIikpIHtcbiAgICAgICAgLy8gSWYgcGxhY2Vob2xkZXIgaXMgc3BsaXQsIGpvaW4gaXRcbiAgICAgICAgdmFyIGF0ID0gcGFydHNbYXRJbmRleF07XG4gICAgICAgIHZhciBwbGFjZWhvbGRlciA9IHBhcnRzW3BsYWNlaG9sZGVySW5kZXhdO1xuICAgICAgICB2YXIgcmVzdCA9IHBhcnRzLnNsaWNlKHBsYWNlaG9sZGVySW5kZXggKyAxKTtcbiAgICAgICAgcGFydHMgPSBwYXJ0cy5zbGljZSgwLCBhdEluZGV4KS5jb25jYXQoW2F0ICsgcGxhY2Vob2xkZXJdKS5jb25jYXQocmVzdCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBhdFBsYWNlaG9sZGVySW5kZXggPSBwYXJ0cy5maW5kSW5kZXgoZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBwYXJ0ID09PSBcInN0cmluZ1wiICYmIHBhcnQuc3RhcnRzV2l0aChcIkBwcmV0dGllci1wbGFjZWhvbGRlclwiKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoYXRQbGFjZWhvbGRlckluZGV4ID4gLTEpIHtcbiAgICAgICAgdmFyIF9wbGFjZWhvbGRlciA9IHBhcnRzW2F0UGxhY2Vob2xkZXJJbmRleF07XG5cbiAgICAgICAgdmFyIF9yZXN0ID0gcGFydHMuc2xpY2UoYXRQbGFjZWhvbGRlckluZGV4ICsgMSk7XG5cbiAgICAgICAgdmFyIHBsYWNlaG9sZGVyTWF0Y2ggPSBfcGxhY2Vob2xkZXIubWF0Y2goL0BwcmV0dGllci1wbGFjZWhvbGRlci0oLispLWlkKFtcXHNcXFNdKikvKTtcblxuICAgICAgICB2YXIgcGxhY2Vob2xkZXJJRCA9IHBsYWNlaG9sZGVyTWF0Y2hbMV07IC8vIFdoZW4gdGhlIGV4cHJlc3Npb24gaGFzIGEgc3VmZml4IGFwcGVuZGVkLCBsaWtlOlxuICAgICAgICAvLyBhbmltYXRpb246IGxpbmVhciAke3RpbWV9cyBlYXNlLW91dDtcblxuICAgICAgICB2YXIgc3VmZml4ID0gcGxhY2Vob2xkZXJNYXRjaFsyXTtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBleHByZXNzaW9uc1twbGFjZWhvbGRlcklEXTtcbiAgICAgICAgcmVwbGFjZUNvdW50ZXIrKztcbiAgICAgICAgcGFydHMgPSBwYXJ0cy5zbGljZSgwLCBhdFBsYWNlaG9sZGVySW5kZXgpLmNvbmNhdChbXCIke1wiLCBleHByZXNzaW9uLCBcIn1cIiArIHN1ZmZpeF0pLmNvbmNhdChfcmVzdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBkb2MsIHtcbiAgICAgICAgcGFydHM6IHBhcnRzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXhwcmVzc2lvbnMubGVuZ3RoID09PSByZXBsYWNlQ291bnRlciA/IG5ld0RvYyA6IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludEdyYXBocWxDb21tZW50cyhsaW5lcykge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIHZhciBzZWVuQ29tbWVudCA9IGZhbHNlO1xuICAgIGxpbmVzLm1hcChmdW5jdGlvbiAodGV4dExpbmUpIHtcbiAgICAgIHJldHVybiB0ZXh0TGluZS50cmltKCk7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbiAodGV4dExpbmUsIGksIGFycmF5KSB7XG4gICAgICAvLyBMaW5lcyBhcmUgZWl0aGVyIHdoaXRlc3BhY2Ugb25seSwgb3IgYSBjb21tZW50ICh3aXRoIHBvdGVudGlhbCB3aGl0ZXNwYWNlXG4gICAgICAvLyBhcm91bmQgaXQpLiBEcm9wIHdoaXRlc3BhY2Utb25seSBsaW5lcy5cbiAgICAgIGlmICh0ZXh0TGluZSA9PT0gXCJcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChhcnJheVtpIC0gMV0gPT09IFwiXCIgJiYgc2VlbkNvbW1lbnQpIHtcbiAgICAgICAgLy8gSWYgYSBub24tZmlyc3QgY29tbWVudCBpcyBwcmVjZWRlZCBieSBhIGJsYW5rICh3aGl0ZXNwYWNlIG9ubHkpIGxpbmUsXG4gICAgICAgIC8vIGFkZCBpbiBhIGJsYW5rIGxpbmUuXG4gICAgICAgIHBhcnRzLnB1c2goY29uY2F0JGIoW2hhcmRsaW5lJDgsIHRleHRMaW5lXSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydHMucHVzaCh0ZXh0TGluZSk7XG4gICAgICB9XG5cbiAgICAgIHNlZW5Db21tZW50ID0gdHJ1ZTtcbiAgICB9KTsgLy8gSWYgYGxpbmVzYCB3YXMgd2hpdGVzcGFjZSBvbmx5LCByZXR1cm4gYG51bGxgLlxuXG4gICAgcmV0dXJuIHBhcnRzLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBqb2luJDcoaGFyZGxpbmUkOCwgcGFydHMpO1xuICB9XG4gIC8qKlxuICAgKiBUZW1wbGF0ZSBsaXRlcmFsIGluIHRoZXNlIGNvbnRleHRzOlxuICAgKiA8c3R5bGUganN4PntgZGl2e2NvbG9yOnJlZH1gfTwvc3R5bGU+XG4gICAqIGNzc2BgXG4gICAqIGNzcy5nbG9iYWxgYFxuICAgKiBjc3MucmVzb2x2ZWBgXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaXNTdHlsZWRKc3gocGF0aCkge1xuICAgIHZhciBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIHZhciBwYXJlbnQgPSBwYXRoLmdldFBhcmVudE5vZGUoKTtcbiAgICB2YXIgcGFyZW50UGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKDEpO1xuICAgIHJldHVybiBwYXJlbnRQYXJlbnQgJiYgbm9kZS5xdWFzaXMgJiYgcGFyZW50LnR5cGUgPT09IFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiICYmIHBhcmVudFBhcmVudC50eXBlID09PSBcIkpTWEVsZW1lbnRcIiAmJiBwYXJlbnRQYXJlbnQub3BlbmluZ0VsZW1lbnQubmFtZS5uYW1lID09PSBcInN0eWxlXCIgJiYgcGFyZW50UGFyZW50Lm9wZW5pbmdFbGVtZW50LmF0dHJpYnV0ZXMuc29tZShmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICByZXR1cm4gYXR0cmlidXRlLm5hbWUubmFtZSA9PT0gXCJqc3hcIjtcbiAgICB9KSB8fCBwYXJlbnQgJiYgcGFyZW50LnR5cGUgPT09IFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIgJiYgcGFyZW50LnRhZy50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBwYXJlbnQudGFnLm5hbWUgPT09IFwiY3NzXCIgfHwgcGFyZW50ICYmIHBhcmVudC50eXBlID09PSBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiICYmIHBhcmVudC50YWcudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgcGFyZW50LnRhZy5vYmplY3QubmFtZSA9PT0gXCJjc3NcIiAmJiAocGFyZW50LnRhZy5wcm9wZXJ0eS5uYW1lID09PSBcImdsb2JhbFwiIHx8IHBhcmVudC50YWcucHJvcGVydHkubmFtZSA9PT0gXCJyZXNvbHZlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBBbmd1bGFyIENvbXBvbmVudHMgY2FuIGhhdmU6XG4gICAqIC0gSW5saW5lIEhUTUwgdGVtcGxhdGVcbiAgICogLSBJbmxpbmUgQ1NTIHN0eWxlc1xuICAgKlxuICAgKiAuLi53aGljaCBhcmUgYm90aCB3aXRoaW4gdGVtcGxhdGUgbGl0ZXJhbHMgc29tZXdoZXJlXG4gICAqIGluc2lkZSBvZiB0aGUgQ29tcG9uZW50IGRlY29yYXRvciBmYWN0b3J5LlxuICAgKlxuICAgKiBFLmcuXG4gICAqIEBDb21wb25lbnQoe1xuICAgKiAgdGVtcGxhdGU6IGA8ZGl2Pi4uLjwvZGl2PmAsXG4gICAqICBzdHlsZXM6IFtgaDEgeyBjb2xvcjogYmx1ZTsgfWBdXG4gICAqIH0pXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaXNBbmd1bGFyQ29tcG9uZW50U3R5bGVzKHBhdGgpIHtcbiAgICByZXR1cm4gaXNQYXRoTWF0Y2gocGF0aCwgW2Z1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIlRlbXBsYXRlTGl0ZXJhbFwiO1xuICAgIH0sIGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7XG4gICAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIkFycmF5RXhwcmVzc2lvblwiICYmIG5hbWUgPT09IFwiZWxlbWVudHNcIjtcbiAgICB9LCBmdW5jdGlvbiAobm9kZSwgbmFtZSkge1xuICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJQcm9wZXJ0eVwiICYmIG5vZGUua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIG5vZGUua2V5Lm5hbWUgPT09IFwic3R5bGVzXCIgJiYgbmFtZSA9PT0gXCJ2YWx1ZVwiO1xuICAgIH1dLmNvbmNhdChnZXRBbmd1bGFyQ29tcG9uZW50T2JqZWN0RXhwcmVzc2lvblByZWRpY2F0ZXMoKSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNBbmd1bGFyQ29tcG9uZW50VGVtcGxhdGUocGF0aCkge1xuICAgIHJldHVybiBpc1BhdGhNYXRjaChwYXRoLCBbZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiVGVtcGxhdGVMaXRlcmFsXCI7XG4gICAgfSwgZnVuY3Rpb24gKG5vZGUsIG5hbWUpIHtcbiAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiUHJvcGVydHlcIiAmJiBub2RlLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBub2RlLmtleS5uYW1lID09PSBcInRlbXBsYXRlXCIgJiYgbmFtZSA9PT0gXCJ2YWx1ZVwiO1xuICAgIH1dLmNvbmNhdChnZXRBbmd1bGFyQ29tcG9uZW50T2JqZWN0RXhwcmVzc2lvblByZWRpY2F0ZXMoKSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QW5ndWxhckNvbXBvbmVudE9iamVjdEV4cHJlc3Npb25QcmVkaWNhdGVzKCkge1xuICAgIHJldHVybiBbZnVuY3Rpb24gKG5vZGUsIG5hbWUpIHtcbiAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiT2JqZWN0RXhwcmVzc2lvblwiICYmIG5hbWUgPT09IFwicHJvcGVydGllc1wiO1xuICAgIH0sIGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7XG4gICAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIkNhbGxFeHByZXNzaW9uXCIgJiYgbm9kZS5jYWxsZWUudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgbm9kZS5jYWxsZWUubmFtZSA9PT0gXCJDb21wb25lbnRcIiAmJiBuYW1lID09PSBcImFyZ3VtZW50c1wiO1xuICAgIH0sIGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7XG4gICAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIkRlY29yYXRvclwiICYmIG5hbWUgPT09IFwiZXhwcmVzc2lvblwiO1xuICAgIH1dO1xuICB9XG4gIC8qKlxuICAgKiBzdHlsZWQtY29tcG9uZW50cyB0ZW1wbGF0ZSBsaXRlcmFsc1xuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGlzU3R5bGVkQ29tcG9uZW50cyhwYXRoKSB7XG4gICAgdmFyIHBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpO1xuXG4gICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50LnR5cGUgIT09IFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdGFnID0gcGFyZW50LnRhZztcblxuICAgIHN3aXRjaCAodGFnLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiAoLy8gc3R5bGVkLmZvb2BgXG4gICAgICAgICAgaXNTdHlsZWRJZGVudGlmaWVyKHRhZy5vYmplY3QpIHx8IC8vIENvbXBvbmVudC5leHRlbmRgYFxuICAgICAgICAgIGlzU3R5bGVkRXh0ZW5kKHRhZylcbiAgICAgICAgKTtcblxuICAgICAgY2FzZSBcIkNhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiAoLy8gc3R5bGVkKENvbXBvbmVudClgYFxuICAgICAgICAgIGlzU3R5bGVkSWRlbnRpZmllcih0YWcuY2FsbGVlKSB8fCB0YWcuY2FsbGVlLnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiICYmICh0YWcuY2FsbGVlLm9iamVjdC50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiAmJiAoIC8vIHN0eWxlZC5mb28uYXR0cnMoe30pYGBcbiAgICAgICAgICBpc1N0eWxlZElkZW50aWZpZXIodGFnLmNhbGxlZS5vYmplY3Qub2JqZWN0KSB8fCAvLyBDb21wb25lbnQuZXh0ZW5kLmF0dHJzKHt9KWBgXG4gICAgICAgICAgaXNTdHlsZWRFeHRlbmQodGFnLmNhbGxlZS5vYmplY3QpKSB8fCAvLyBzdHlsZWQoQ29tcG9uZW50KS5hdHRycyh7fSlgYFxuICAgICAgICAgIHRhZy5jYWxsZWUub2JqZWN0LnR5cGUgPT09IFwiQ2FsbEV4cHJlc3Npb25cIiAmJiBpc1N0eWxlZElkZW50aWZpZXIodGFnLmNhbGxlZS5vYmplY3QuY2FsbGVlKSlcbiAgICAgICAgKTtcblxuICAgICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgICAgLy8gY3NzYGBcbiAgICAgICAgcmV0dXJuIHRhZy5uYW1lID09PSBcImNzc1wiO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBKU1ggZWxlbWVudCB3aXRoIENTUyBwcm9wXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaXNDc3NQcm9wKHBhdGgpIHtcbiAgICB2YXIgcGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG4gICAgdmFyIHBhcmVudFBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgxKTtcbiAgICByZXR1cm4gcGFyZW50UGFyZW50ICYmIHBhcmVudC50eXBlID09PSBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIiAmJiBwYXJlbnRQYXJlbnQudHlwZSA9PT0gXCJKU1hBdHRyaWJ1dGVcIiAmJiBwYXJlbnRQYXJlbnQubmFtZS50eXBlID09PSBcIkpTWElkZW50aWZpZXJcIiAmJiBwYXJlbnRQYXJlbnQubmFtZS5uYW1lID09PSBcImNzc1wiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTdHlsZWRJZGVudGlmaWVyKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBub2RlLm5hbWUgPT09IFwic3R5bGVkXCI7XG4gIH1cblxuICBmdW5jdGlvbiBpc1N0eWxlZEV4dGVuZChub2RlKSB7XG4gICAgcmV0dXJuIC9eW0EtWl0vLnRlc3Qobm9kZS5vYmplY3QubmFtZSkgJiYgbm9kZS5wcm9wZXJ0eS5uYW1lID09PSBcImV4dGVuZFwiO1xuICB9XG4gIC8qXG4gICAqIHJlYWN0LXJlbGF5IGFuZCBncmFwaHFsLXRhZ1xuICAgKiBncmFwaHFsYC4uLmBcbiAgICogZ3JhcGhxbC5leHBlcmltZW50YWxgLi4uYFxuICAgKiBncWxgLi4uYFxuICAgKiBHcmFwaFFMIGNvbW1lbnQgYmxvY2tcbiAgICpcbiAgICogVGhpcyBpbnRlbnRpb25hbGx5IGV4Y2x1ZGVzIFJlbGF5IENsYXNzaWMgdGFncywgYXMgUHJldHRpZXIgZG9lcyBub3RcbiAgICogc3VwcG9ydCBSZWxheSBDbGFzc2ljIGZvcm1hdHRpbmcuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaXNHcmFwaFFMKHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICB2YXIgcGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG4gICAgcmV0dXJuIGhhc0xhbmd1YWdlQ29tbWVudChub2RlLCBcIkdyYXBoUUxcIikgfHwgcGFyZW50ICYmIChwYXJlbnQudHlwZSA9PT0gXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIiAmJiAocGFyZW50LnRhZy50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiAmJiBwYXJlbnQudGFnLm9iamVjdC5uYW1lID09PSBcImdyYXBocWxcIiAmJiBwYXJlbnQudGFnLnByb3BlcnR5Lm5hbWUgPT09IFwiZXhwZXJpbWVudGFsXCIgfHwgcGFyZW50LnRhZy50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiAocGFyZW50LnRhZy5uYW1lID09PSBcImdxbFwiIHx8IHBhcmVudC50YWcubmFtZSA9PT0gXCJncmFwaHFsXCIpKSB8fCBwYXJlbnQudHlwZSA9PT0gXCJDYWxsRXhwcmVzc2lvblwiICYmIHBhcmVudC5jYWxsZWUudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgcGFyZW50LmNhbGxlZS5uYW1lID09PSBcImdyYXBocWxcIik7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNMYW5ndWFnZUNvbW1lbnQobm9kZSwgbGFuZ3VhZ2VOYW1lKSB7XG4gICAgLy8gVGhpcyBjaGVja3MgZm9yIGEgbGVhZGluZyBjb21tZW50IHRoYXQgaXMgZXhhY3RseSBgLyogR3JhcGhRTCAqL2BcbiAgICAvLyBJbiBvcmRlciB0byBiZSBpbiBsaW5lIHdpdGggb3RoZXIgaW1wbGVtZW50YXRpb25zIG9mIHRoaXMgY29tbWVudCB0YWdcbiAgICAvLyB3ZSB3aWxsIG5vdCB0cmltIHRoZSBjb21tZW50IHZhbHVlIGFuZCB3ZSB3aWxsIGV4cGVjdCBleGFjdGx5IG9uZSBzcGFjZSBvblxuICAgIC8vIGVpdGhlciBzaWRlIG9mIHRoZSBHcmFwaFFMIHN0cmluZ1xuICAgIC8vIEFsc28gc2VlIC4vY2xlYW4uanNcbiAgICByZXR1cm4gaGFzTGVhZGluZ0NvbW1lbnQkMShub2RlLCBmdW5jdGlvbiAoY29tbWVudCkge1xuICAgICAgcmV0dXJuIGlzQmxvY2tDb21tZW50JDEoY29tbWVudCkgJiYgY29tbWVudC52YWx1ZSA9PT0gXCIgXCIuY29uY2F0KGxhbmd1YWdlTmFtZSwgXCIgXCIpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRoTWF0Y2gocGF0aCwgcHJlZGljYXRlU3RhY2spIHtcbiAgICB2YXIgc3RhY2sgPSBwYXRoLnN0YWNrLnNsaWNlKCk7XG4gICAgdmFyIG5hbWUgPSBudWxsO1xuICAgIHZhciBub2RlID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBwcmVkaWNhdGVTdGFja1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgdmFyIHByZWRpY2F0ZSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gLy8gc2tpcCBpbmRleC9hcnJheVxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgbmFtZSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgIG5vZGUgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcHJlZGljYXRlKG5vZGUsIG5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbmFtZSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBub2RlID0gc3RhY2sucG9wKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogICAgIC0gaHRtbGAuLi5gXG4gICAqICAgICAtIEhUTUwgY29tbWVudCBibG9ja1xuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGlzSHRtbChwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSBwYXRoLmdldFZhbHVlKCk7XG4gICAgcmV0dXJuIGhhc0xhbmd1YWdlQ29tbWVudChub2RlLCBcIkhUTUxcIikgfHwgaXNQYXRoTWF0Y2gocGF0aCwgW2Z1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIlRlbXBsYXRlTGl0ZXJhbFwiO1xuICAgIH0sIGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7XG4gICAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiICYmIG5vZGUudGFnLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIG5vZGUudGFnLm5hbWUgPT09IFwiaHRtbFwiICYmIG5hbWUgPT09IFwicXVhc2lcIjtcbiAgICB9XSk7XG4gIH0gLy8gVGhlIGNvdW50ZXIgaXMgbmVlZGVkIHRvIGRpc3Rpbmd1aXNoIG5lc3RlZCBlbWJlZHMuXG5cblxuICB2YXIgaHRtbFRlbXBsYXRlTGl0ZXJhbENvdW50ZXIgPSAwO1xuXG4gIGZ1bmN0aW9uIHByaW50SHRtbFRlbXBsYXRlTGl0ZXJhbChwYXRoLCBwcmludCwgdGV4dFRvRG9jLCBwYXJzZXIsIGVzY2FwZUNsb3NpbmdTY3JpcHRUYWcpIHtcbiAgICB2YXIgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICB2YXIgY291bnRlciA9IGh0bWxUZW1wbGF0ZUxpdGVyYWxDb3VudGVyO1xuICAgIGh0bWxUZW1wbGF0ZUxpdGVyYWxDb3VudGVyID0gaHRtbFRlbXBsYXRlTGl0ZXJhbENvdW50ZXIgKyAxID4+PiAwO1xuXG4gICAgdmFyIGNvbXBvc2VQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIGNvbXBvc2VQbGFjZWhvbGRlcihpbmRleCkge1xuICAgICAgcmV0dXJuIFwiUFJFVFRJRVJfSFRNTF9QTEFDRUhPTERFUl9cIi5jb25jYXQoaW5kZXgsIFwiX1wiKS5jb25jYXQoY291bnRlciwgXCJfSU5fSlNcIik7XG4gICAgfTtcblxuICAgIHZhciB0ZXh0ID0gbm9kZS5xdWFzaXMubWFwKGZ1bmN0aW9uIChxdWFzaSwgaW5kZXgsIHF1YXNpcykge1xuICAgICAgcmV0dXJuIGluZGV4ID09PSBxdWFzaXMubGVuZ3RoIC0gMSA/IHF1YXNpLnZhbHVlLmNvb2tlZCA6IHF1YXNpLnZhbHVlLmNvb2tlZCArIGNvbXBvc2VQbGFjZWhvbGRlcihpbmRleCk7XG4gICAgfSkuam9pbihcIlwiKTtcbiAgICB2YXIgZXhwcmVzc2lvbkRvY3MgPSBwYXRoLm1hcChwcmludCwgXCJleHByZXNzaW9uc1wiKTtcblxuICAgIGlmIChleHByZXNzaW9uRG9jcy5sZW5ndGggPT09IDAgJiYgdGV4dC50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gXCJgYFwiO1xuICAgIH1cblxuICAgIHZhciBwbGFjZWhvbGRlclJlZ2V4ID0gUmVnRXhwKGNvbXBvc2VQbGFjZWhvbGRlcihcIihcXFxcZCspXCIpLCBcImdcIik7XG4gICAgdmFyIGNvbnRlbnREb2MgPSBtYXBEb2MkNShzdHJpcFRyYWlsaW5nSGFyZGxpbmUkMih0ZXh0VG9Eb2ModGV4dCwge1xuICAgICAgcGFyc2VyOiBwYXJzZXJcbiAgICB9KSksIGZ1bmN0aW9uIChkb2MpIHtcbiAgICAgIGlmICh0eXBlb2YgZG9jICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBkb2M7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgICAgdmFyIGNvbXBvbmVudHMgPSBkb2Muc3BsaXQocGxhY2Vob2xkZXJSZWdleCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcblxuICAgICAgICBpZiAoaSAlIDIgPT09IDApIHtcbiAgICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICBjb21wb25lbnQgPSB1bmNvb2soY29tcG9uZW50KTtcblxuICAgICAgICAgICAgaWYgKGVzY2FwZUNsb3NpbmdTY3JpcHRUYWcpIHtcbiAgICAgICAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50LnJlcGxhY2UoLzxcXC8oc2NyaXB0KVxcYi9naSwgXCI8XFxcXC8kMVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFydHMucHVzaChjb21wb25lbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBsYWNlaG9sZGVySW5kZXggPSArY29tcG9uZW50O1xuICAgICAgICBwYXJ0cy5wdXNoKGNvbmNhdCRiKFtcIiR7XCIsIGdyb3VwJGEoZXhwcmVzc2lvbkRvY3NbcGxhY2Vob2xkZXJJbmRleF0pLCBcIn1cIl0pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbmNhdCRiKHBhcnRzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZ3JvdXAkYShjb25jYXQkYihbXCJgXCIsIGluZGVudCQ2KGNvbmNhdCRiKFtoYXJkbGluZSQ4LCBncm91cCRhKGNvbnRlbnREb2MpXSkpLCBzb2Z0bGluZSQ1LCBcImBcIl0pKTtcbiAgfVxuXG4gIHZhciBlbWJlZF8xJDEgPSBlbWJlZCQzO1xuXG4gIGZ1bmN0aW9uIGNsZWFuJDQoYXN0LCBuZXdPYmosIHBhcmVudCkge1xuICAgIFtcInJhbmdlXCIsIFwicmF3XCIsIFwiY29tbWVudHNcIiwgXCJsZWFkaW5nQ29tbWVudHNcIiwgXCJ0cmFpbGluZ0NvbW1lbnRzXCIsIFwiZXh0cmFcIiwgXCJzdGFydFwiLCBcImVuZFwiLCBcImZsYWdzXCIsIFwiZXJyb3JzXCJdLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGRlbGV0ZSBuZXdPYmpbbmFtZV07XG4gICAgfSk7XG5cbiAgICBpZiAoYXN0LnR5cGUgPT09IFwiQmlnSW50TGl0ZXJhbFwiKSB7XG4gICAgICBuZXdPYmoudmFsdWUgPSBuZXdPYmoudmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICB9IC8vIFdlIHJlbW92ZSBleHRyYSBgO2AgYW5kIGFkZCB0aGVtIHdoZW4gbmVlZGVkXG5cblxuICAgIGlmIChhc3QudHlwZSA9PT0gXCJFbXB0eVN0YXRlbWVudFwiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIFdlIG1vdmUgdGV4dCBhcm91bmQsIGluY2x1ZGluZyB3aGl0ZXNwYWNlcyBhbmQgYWRkIHtcIiBcIn1cblxuXG4gICAgaWYgKGFzdC50eXBlID09PSBcIkpTWFRleHRcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGFzdC50eXBlID09PSBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIiAmJiBhc3QuZXhwcmVzc2lvbi50eXBlID09PSBcIkxpdGVyYWxcIiAmJiBhc3QuZXhwcmVzc2lvbi52YWx1ZSA9PT0gXCIgXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gV2UgcmVtb3ZlIHVubmVlZGVkIHBhcmVucyBhcm91bmQgc2FtZS1vcGVyYXRvciBMb2dpY2FsRXhwcmVzc2lvbnNcblxuXG4gICAgaWYgKGlzVW5iYWxhbmNlZExvZ2ljYWxUcmVlKG5ld09iaikpIHtcbiAgICAgIHJldHVybiByZWJhbGFuY2VMb2dpY2FsVHJlZShuZXdPYmopO1xuICAgIH0gLy8gKFR5cGVTY3JpcHQpIElnbm9yZSBgc3RhdGljYCBpbiBgY29uc3RydWN0b3Ioc3RhdGljIHApIHt9YFxuICAgIC8vIGFuZCBgZXhwb3J0YCBpbiBgY29uc3RydWN0b3IoZXhwb3J0IHApIHt9YFxuXG5cbiAgICBpZiAoYXN0LnR5cGUgPT09IFwiVFNQYXJhbWV0ZXJQcm9wZXJ0eVwiICYmIGFzdC5hY2Nlc3NpYmlsaXR5ID09PSBudWxsICYmICFhc3QucmVhZG9ubHkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiSWRlbnRpZmllclwiLFxuICAgICAgICBuYW1lOiBhc3QucGFyYW1ldGVyLm5hbWUsXG4gICAgICAgIHR5cGVBbm5vdGF0aW9uOiBuZXdPYmoucGFyYW1ldGVyLnR5cGVBbm5vdGF0aW9uLFxuICAgICAgICBkZWNvcmF0b3JzOiBuZXdPYmouZGVjb3JhdG9yc1xuICAgICAgfTtcbiAgICB9IC8vIChUeXBlU2NyaXB0KSBpZ25vcmUgZW1wdHkgYHNwZWNpZmllcnNgIGFycmF5XG5cblxuICAgIGlmIChhc3QudHlwZSA9PT0gXCJUU05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uXCIgJiYgYXN0LnNwZWNpZmllcnMgJiYgYXN0LnNwZWNpZmllcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBkZWxldGUgbmV3T2JqLnNwZWNpZmllcnM7XG4gICAgfSAvLyBXZSBjb252ZXJ0IDxkaXY+PC9kaXY+IHRvIDxkaXYgLz5cblxuXG4gICAgaWYgKGFzdC50eXBlID09PSBcIkpTWE9wZW5pbmdFbGVtZW50XCIpIHtcbiAgICAgIGRlbGV0ZSBuZXdPYmouc2VsZkNsb3Npbmc7XG4gICAgfVxuXG4gICAgaWYgKGFzdC50eXBlID09PSBcIkpTWEVsZW1lbnRcIikge1xuICAgICAgZGVsZXRlIG5ld09iai5jbG9zaW5nRWxlbWVudDtcbiAgICB9IC8vIFdlIGNoYW5nZSB7J2tleSc6IHZhbHVlfSBpbnRvIHtrZXk6IHZhbHVlfVxuXG5cbiAgICBpZiAoKGFzdC50eXBlID09PSBcIlByb3BlcnR5XCIgfHwgYXN0LnR5cGUgPT09IFwiT2JqZWN0UHJvcGVydHlcIiB8fCBhc3QudHlwZSA9PT0gXCJNZXRob2REZWZpbml0aW9uXCIgfHwgYXN0LnR5cGUgPT09IFwiQ2xhc3NQcm9wZXJ0eVwiIHx8IGFzdC50eXBlID09PSBcIlRTUHJvcGVydHlTaWduYXR1cmVcIiB8fCBhc3QudHlwZSA9PT0gXCJPYmplY3RUeXBlUHJvcGVydHlcIikgJiYgX3R5cGVvZihhc3Qua2V5KSA9PT0gXCJvYmplY3RcIiAmJiBhc3Qua2V5ICYmIChhc3Qua2V5LnR5cGUgPT09IFwiTGl0ZXJhbFwiIHx8IGFzdC5rZXkudHlwZSA9PT0gXCJTdHJpbmdMaXRlcmFsXCIgfHwgYXN0LmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIikpIHtcbiAgICAgIGRlbGV0ZSBuZXdPYmoua2V5O1xuICAgIH1cblxuICAgIGlmIChhc3QudHlwZSA9PT0gXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIiAmJiBhc3Qub3B0aW9uYWwgPT09IGZhbHNlKSB7XG4gICAgICBuZXdPYmoudHlwZSA9IFwiTWVtYmVyRXhwcmVzc2lvblwiO1xuICAgICAgZGVsZXRlIG5ld09iai5vcHRpb25hbDtcbiAgICB9IC8vIFJlbW92ZSByYXcgYW5kIGNvb2tlZCB2YWx1ZXMgZnJvbSBUZW1wbGF0ZUVsZW1lbnQgd2hlbiBpdCdzIENTU1xuICAgIC8vIHN0eWxlZC1qc3hcblxuXG4gICAgaWYgKGFzdC50eXBlID09PSBcIkpTWEVsZW1lbnRcIiAmJiBhc3Qub3BlbmluZ0VsZW1lbnQubmFtZS5uYW1lID09PSBcInN0eWxlXCIgJiYgYXN0Lm9wZW5pbmdFbGVtZW50LmF0dHJpYnV0ZXMuc29tZShmdW5jdGlvbiAoYXR0cikge1xuICAgICAgcmV0dXJuIGF0dHIubmFtZS5uYW1lID09PSBcImpzeFwiO1xuICAgIH0pKSB7XG4gICAgICB2YXIgdGVtcGxhdGVMaXRlcmFscyA9IG5ld09iai5jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBjaGlsZC50eXBlID09PSBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIiAmJiBjaGlsZC5leHByZXNzaW9uLnR5cGUgPT09IFwiVGVtcGxhdGVMaXRlcmFsXCI7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgICByZXR1cm4gY29udGFpbmVyLmV4cHJlc3Npb247XG4gICAgICB9KTtcbiAgICAgIHZhciBxdWFzaXMgPSB0ZW1wbGF0ZUxpdGVyYWxzLnJlZHVjZShmdW5jdGlvbiAocXVhc2lzLCB0ZW1wbGF0ZUxpdGVyYWwpIHtcbiAgICAgICAgcmV0dXJuIHF1YXNpcy5jb25jYXQodGVtcGxhdGVMaXRlcmFsLnF1YXNpcyk7XG4gICAgICB9LCBbXSk7XG4gICAgICBxdWFzaXMuZm9yRWFjaChmdW5jdGlvbiAocSkge1xuICAgICAgICByZXR1cm4gZGVsZXRlIHEudmFsdWU7XG4gICAgICB9KTtcbiAgICB9IC8vIENTUyB0ZW1wbGF0ZSBsaXRlcmFscyBpbiBjc3MgcHJvcFxuXG5cbiAgICBpZiAoYXN0LnR5cGUgPT09IFwiSlNYQXR0cmlidXRlXCIgJiYgYXN0Lm5hbWUubmFtZSA9PT0gXCJjc3NcIiAmJiBhc3QudmFsdWUudHlwZSA9PT0gXCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCIgJiYgYXN0LnZhbHVlLmV4cHJlc3Npb24udHlwZSA9PT0gXCJUZW1wbGF0ZUxpdGVyYWxcIikge1xuICAgICAgbmV3T2JqLnZhbHVlLmV4cHJlc3Npb24ucXVhc2lzLmZvckVhY2goZnVuY3Rpb24gKHEpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZSBxLnZhbHVlO1xuICAgICAgfSk7XG4gICAgfSAvLyBBbmd1bGFyIENvbXBvbmVudHM6IElubGluZSBIVE1MIHRlbXBsYXRlIGFuZCBJbmxpbmUgQ1NTIHN0eWxlc1xuXG5cbiAgICB2YXIgZXhwcmVzc2lvbiA9IGFzdC5leHByZXNzaW9uIHx8IGFzdC5jYWxsZWU7XG5cbiAgICBpZiAoYXN0LnR5cGUgPT09IFwiRGVjb3JhdG9yXCIgJiYgZXhwcmVzc2lvbi50eXBlID09PSBcIkNhbGxFeHByZXNzaW9uXCIgJiYgZXhwcmVzc2lvbi5jYWxsZWUubmFtZSA9PT0gXCJDb21wb25lbnRcIiAmJiBleHByZXNzaW9uLmFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBhc3RQcm9wcyA9IGFzdC5leHByZXNzaW9uLmFyZ3VtZW50c1swXS5wcm9wZXJ0aWVzO1xuICAgICAgbmV3T2JqLmV4cHJlc3Npb24uYXJndW1lbnRzWzBdLnByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHRlbXBsYXRlTGl0ZXJhbCA9IG51bGw7XG5cbiAgICAgICAgc3dpdGNoIChhc3RQcm9wc1tpbmRleF0ua2V5Lm5hbWUpIHtcbiAgICAgICAgICBjYXNlIFwic3R5bGVzXCI6XG4gICAgICAgICAgICBpZiAocHJvcC52YWx1ZS50eXBlID09PSBcIkFycmF5RXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgICAgIHRlbXBsYXRlTGl0ZXJhbCA9IHByb3AudmFsdWUuZWxlbWVudHNbMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcInRlbXBsYXRlXCI6XG4gICAgICAgICAgICBpZiAocHJvcC52YWx1ZS50eXBlID09PSBcIlRlbXBsYXRlTGl0ZXJhbFwiKSB7XG4gICAgICAgICAgICAgIHRlbXBsYXRlTGl0ZXJhbCA9IHByb3AudmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRlbXBsYXRlTGl0ZXJhbCkge1xuICAgICAgICAgIHRlbXBsYXRlTGl0ZXJhbC5xdWFzaXMuZm9yRWFjaChmdW5jdGlvbiAocSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZSBxLnZhbHVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IC8vIHN0eWxlZC1jb21wb25lbnRzLCBncmFwaHFsLCBtYXJrZG93blxuXG5cbiAgICBpZiAoYXN0LnR5cGUgPT09IFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIgJiYgKGFzdC50YWcudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgfHwgYXN0LnRhZy50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiAoYXN0LnRhZy5uYW1lID09PSBcImdxbFwiIHx8IGFzdC50YWcubmFtZSA9PT0gXCJncmFwaHFsXCIgfHwgYXN0LnRhZy5uYW1lID09PSBcImNzc1wiIHx8IGFzdC50YWcubmFtZSA9PT0gXCJtZFwiIHx8IGFzdC50YWcubmFtZSA9PT0gXCJtYXJrZG93blwiIHx8IGFzdC50YWcubmFtZSA9PT0gXCJodG1sXCIpIHx8IGFzdC50YWcudHlwZSA9PT0gXCJDYWxsRXhwcmVzc2lvblwiKSkge1xuICAgICAgbmV3T2JqLnF1YXNpLnF1YXNpcy5mb3JFYWNoKGZ1bmN0aW9uIChxdWFzaSkge1xuICAgICAgICByZXR1cm4gZGVsZXRlIHF1YXNpLnZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFzdC50eXBlID09PSBcIlRlbXBsYXRlTGl0ZXJhbFwiKSB7XG4gICAgICAvLyBUaGlzIGNoZWNrcyBmb3IgYSBsZWFkaW5nIGNvbW1lbnQgdGhhdCBpcyBleGFjdGx5IGAvKiBHcmFwaFFMICovYFxuICAgICAgLy8gSW4gb3JkZXIgdG8gYmUgaW4gbGluZSB3aXRoIG90aGVyIGltcGxlbWVudGF0aW9ucyBvZiB0aGlzIGNvbW1lbnQgdGFnXG4gICAgICAvLyB3ZSB3aWxsIG5vdCB0cmltIHRoZSBjb21tZW50IHZhbHVlIGFuZCB3ZSB3aWxsIGV4cGVjdCBleGFjdGx5IG9uZSBzcGFjZSBvblxuICAgICAgLy8gZWl0aGVyIHNpZGUgb2YgdGhlIEdyYXBoUUwgc3RyaW5nXG4gICAgICAvLyBBbHNvIHNlZSAuL2VtYmVkLmpzXG4gICAgICB2YXIgaGFzTGFuZ3VhZ2VDb21tZW50ID0gYXN0LmxlYWRpbmdDb21tZW50cyAmJiBhc3QubGVhZGluZ0NvbW1lbnRzLnNvbWUoZnVuY3Rpb24gKGNvbW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1lbnQudHlwZSA9PT0gXCJDb21tZW50QmxvY2tcIiAmJiBbXCJHcmFwaFFMXCIsIFwiSFRNTFwiXS5zb21lKGZ1bmN0aW9uIChsYW5ndWFnZU5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gY29tbWVudC52YWx1ZSA9PT0gXCIgXCIuY29uY2F0KGxhbmd1YWdlTmFtZSwgXCIgXCIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaGFzTGFuZ3VhZ2VDb21tZW50IHx8IHBhcmVudC50eXBlID09PSBcIkNhbGxFeHByZXNzaW9uXCIgJiYgcGFyZW50LmNhbGxlZS5uYW1lID09PSBcImdyYXBocWxcIikge1xuICAgICAgICBuZXdPYmoucXVhc2lzLmZvckVhY2goZnVuY3Rpb24gKHF1YXNpKSB7XG4gICAgICAgICAgcmV0dXJuIGRlbGV0ZSBxdWFzaS52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNVbmJhbGFuY2VkTG9naWNhbFRyZWUobmV3T2JqKSB7XG4gICAgcmV0dXJuIG5ld09iai50eXBlID09PSBcIkxvZ2ljYWxFeHByZXNzaW9uXCIgJiYgbmV3T2JqLnJpZ2h0LnR5cGUgPT09IFwiTG9naWNhbEV4cHJlc3Npb25cIiAmJiBuZXdPYmoub3BlcmF0b3IgPT09IG5ld09iai5yaWdodC5vcGVyYXRvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYmFsYW5jZUxvZ2ljYWxUcmVlKG5ld09iaikge1xuICAgIGlmIChpc1VuYmFsYW5jZWRMb2dpY2FsVHJlZShuZXdPYmopKSB7XG4gICAgICByZXR1cm4gcmViYWxhbmNlTG9naWNhbFRyZWUoe1xuICAgICAgICB0eXBlOiBcIkxvZ2ljYWxFeHByZXNzaW9uXCIsXG4gICAgICAgIG9wZXJhdG9yOiBuZXdPYmoub3BlcmF0b3IsXG4gICAgICAgIGxlZnQ6IHJlYmFsYW5jZUxvZ2ljYWxUcmVlKHtcbiAgICAgICAgICB0eXBlOiBcIkxvZ2ljYWxFeHByZXNzaW9uXCIsXG4gICAgICAgICAgb3BlcmF0b3I6IG5ld09iai5vcGVyYXRvcixcbiAgICAgICAgICBsZWZ0OiBuZXdPYmoubGVmdCxcbiAgICAgICAgICByaWdodDogbmV3T2JqLnJpZ2h0LmxlZnQsXG4gICAgICAgICAgbG9jOiB7fVxuICAgICAgICB9KSxcbiAgICAgICAgcmlnaHQ6IG5ld09iai5yaWdodC5yaWdodCxcbiAgICAgICAgbG9jOiB7fVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld09iajtcbiAgfVxuXG4gIHZhciBjbGVhbl8xJDEgPSBjbGVhbiQ0O1xuXG4gIHZhciBnZXRMYXN0JDEgPSB1dGlsLmdldExhc3QsXG4gICAgICBoYXNOZXdsaW5lJDMgPSB1dGlsLmhhc05ld2xpbmUsXG4gICAgICBoYXNOZXdsaW5lSW5SYW5nZSQxID0gdXRpbC5oYXNOZXdsaW5lSW5SYW5nZSxcbiAgICAgIGhhc0lnbm9yZUNvbW1lbnQkMyA9IHV0aWwuaGFzSWdub3JlQ29tbWVudCxcbiAgICAgIGhhc05vZGVJZ25vcmVDb21tZW50JDEgPSB1dGlsLmhhc05vZGVJZ25vcmVDb21tZW50LFxuICAgICAgc2tpcFdoaXRlc3BhY2UkMSA9IHV0aWwuc2tpcFdoaXRlc3BhY2U7XG4gIHZhciBpc0lkZW50aWZpZXJOYW1lID0gdXRpbHMkMS5rZXl3b3JkLmlzSWRlbnRpZmllck5hbWVFUzU7IC8vIFdlIG1hdGNoIGFueSB3aGl0ZXNwYWNlIGV4Y2VwdCBsaW5lIHRlcm1pbmF0b3JzIGJlY2F1c2VcbiAgLy8gRmxvdyBhbm5vdGF0aW9uIGNvbW1lbnRzIGNhbm5vdCBiZSBzcGxpdCBhY3Jvc3MgbGluZXMuIEZvciBleGFtcGxlOlxuICAvL1xuICAvLyAodGhpcyAvKlxuICAvLyA6IGFueSAqLykuZm9vID0gNTtcbiAgLy9cbiAgLy8gaXMgbm90IHBpY2tlZCB1cCBieSBGbG93IChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzcwNTApLCBzb1xuICAvLyByZW1vdmluZyB0aGUgbmV3bGluZSB3b3VsZCBjcmVhdGUgYSB0eXBlIGFubm90YXRpb24gdGhhdCB0aGUgdXNlciBkaWQgbm90IGludGVuZFxuICAvLyB0byBjcmVhdGUuXG5cbiAgdmFyIE5PTl9MSU5FX1RFUk1JTkFUSU5HX1dISVRFX1NQQUNFID0gXCIoPzooPz0uKVxcXFxzKVwiO1xuICB2YXIgRkxPV19TSE9SVEhBTkRfQU5OT1RBVElPTiA9IG5ldyBSZWdFeHAoXCJeXCIuY29uY2F0KE5PTl9MSU5FX1RFUk1JTkFUSU5HX1dISVRFX1NQQUNFLCBcIio6XCIpKTtcbiAgdmFyIEZMT1dfQU5OT1RBVElPTiA9IG5ldyBSZWdFeHAoXCJeXCIuY29uY2F0KE5PTl9MSU5FX1RFUk1JTkFUSU5HX1dISVRFX1NQQUNFLCBcIio6OlwiKSk7XG5cbiAgZnVuY3Rpb24gaGFzRmxvd1Nob3J0aGFuZEFubm90YXRpb25Db21tZW50KG5vZGUpIHtcbiAgICAvLyBodHRwczovL2Zsb3cub3JnL2VuL2RvY3MvdHlwZXMvY29tbWVudHMvXG4gICAgLy8gU3ludGF4IGV4YW1wbGU6IGNvbnN0IHIgPSBuZXcgKHdpbmRvdy5SZXF1ZXN0IC8qOiBDbGFzczxSZXF1ZXN0PiAqLykoXCJcIik7XG4gICAgcmV0dXJuIG5vZGUuZXh0cmEgJiYgbm9kZS5leHRyYS5wYXJlbnRoZXNpemVkICYmIG5vZGUudHJhaWxpbmdDb21tZW50cyAmJiBub2RlLnRyYWlsaW5nQ29tbWVudHNbMF0udmFsdWUubWF0Y2goRkxPV19TSE9SVEhBTkRfQU5OT1RBVElPTik7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNGbG93QW5ub3RhdGlvbkNvbW1lbnQoY29tbWVudHMpIHtcbiAgICByZXR1cm4gY29tbWVudHMgJiYgY29tbWVudHNbMF0udmFsdWUubWF0Y2goRkxPV19BTk5PVEFUSU9OKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc05vZGUobm9kZSwgZm4pIHtcbiAgICBpZiAoIW5vZGUgfHwgX3R5cGVvZihub2RlKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgICByZXR1cm4gbm9kZS5zb21lKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaGFzTm9kZSh2YWx1ZSwgZm4pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IGZuKG5vZGUpO1xuICAgIHJldHVybiB0eXBlb2YgcmVzdWx0ID09PSBcImJvb2xlYW5cIiA/IHJlc3VsdCA6IE9iamVjdC5rZXlzKG5vZGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGhhc05vZGUobm9kZVtrZXldLCBmbik7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNOYWtlZExlZnRTaWRlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIkJpbmFyeUV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiTG9naWNhbEV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiTkdQaXBlRXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiQ2FsbEV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJTZXF1ZW5jZUV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIkJpbmRFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIlVwZGF0ZUV4cHJlc3Npb25cIiAmJiAhbm9kZS5wcmVmaXggfHwgbm9kZS50eXBlID09PSBcIlRTQXNFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIlRTTm9uTnVsbEV4cHJlc3Npb25cIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExlZnRTaWRlKG5vZGUpIHtcbiAgICBpZiAobm9kZS5leHByZXNzaW9ucykge1xuICAgICAgcmV0dXJuIG5vZGUuZXhwcmVzc2lvbnNbMF07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGUubGVmdCB8fCBub2RlLnRlc3QgfHwgbm9kZS5jYWxsZWUgfHwgbm9kZS5vYmplY3QgfHwgbm9kZS50YWcgfHwgbm9kZS5hcmd1bWVudCB8fCBub2RlLmV4cHJlc3Npb247XG4gIH1cblxuICBmdW5jdGlvbiBnZXRMZWZ0U2lkZVBhdGhOYW1lKHBhdGgsIG5vZGUpIHtcbiAgICBpZiAobm9kZS5leHByZXNzaW9ucykge1xuICAgICAgcmV0dXJuIFtcImV4cHJlc3Npb25zXCIsIDBdO1xuICAgIH1cblxuICAgIGlmIChub2RlLmxlZnQpIHtcbiAgICAgIHJldHVybiBbXCJsZWZ0XCJdO1xuICAgIH1cblxuICAgIGlmIChub2RlLnRlc3QpIHtcbiAgICAgIHJldHVybiBbXCJ0ZXN0XCJdO1xuICAgIH1cblxuICAgIGlmIChub2RlLm9iamVjdCkge1xuICAgICAgcmV0dXJuIFtcIm9iamVjdFwiXTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5jYWxsZWUpIHtcbiAgICAgIHJldHVybiBbXCJjYWxsZWVcIl07XG4gICAgfVxuXG4gICAgaWYgKG5vZGUudGFnKSB7XG4gICAgICByZXR1cm4gW1widGFnXCJdO1xuICAgIH1cblxuICAgIGlmIChub2RlLmFyZ3VtZW50KSB7XG4gICAgICByZXR1cm4gW1wiYXJndW1lbnRcIl07XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuZXhwcmVzc2lvbikge1xuICAgICAgcmV0dXJuIFtcImV4cHJlc3Npb25cIl07XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBub2RlIGhhcyBubyBsZWZ0IHNpZGVcIiwgbm9kZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0xpdGVyYWwobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiQm9vbGVhbkxpdGVyYWxcIiB8fCBub2RlLnR5cGUgPT09IFwiRGlyZWN0aXZlTGl0ZXJhbFwiIHx8IG5vZGUudHlwZSA9PT0gXCJMaXRlcmFsXCIgfHwgbm9kZS50eXBlID09PSBcIk51bGxMaXRlcmFsXCIgfHwgbm9kZS50eXBlID09PSBcIk51bWVyaWNMaXRlcmFsXCIgfHwgbm9kZS50eXBlID09PSBcIlJlZ0V4cExpdGVyYWxcIiB8fCBub2RlLnR5cGUgPT09IFwiU3RyaW5nTGl0ZXJhbFwiIHx8IG5vZGUudHlwZSA9PT0gXCJUZW1wbGF0ZUxpdGVyYWxcIiB8fCBub2RlLnR5cGUgPT09IFwiVFNUeXBlTGl0ZXJhbFwiIHx8IG5vZGUudHlwZSA9PT0gXCJKU1hUZXh0XCI7XG4gIH1cblxuICBmdW5jdGlvbiBpc051bWVyaWNMaXRlcmFsKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIk51bWVyaWNMaXRlcmFsXCIgfHwgbm9kZS50eXBlID09PSBcIkxpdGVyYWxcIiAmJiB0eXBlb2Ygbm9kZS52YWx1ZSA9PT0gXCJudW1iZXJcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3RyaW5nTGl0ZXJhbChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJTdHJpbmdMaXRlcmFsXCIgfHwgbm9kZS50eXBlID09PSBcIkxpdGVyYWxcIiAmJiB0eXBlb2Ygbm9kZS52YWx1ZSA9PT0gXCJzdHJpbmdcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzT2JqZWN0VHlwZShuKSB7XG4gICAgcmV0dXJuIG4udHlwZSA9PT0gXCJPYmplY3RUeXBlQW5ub3RhdGlvblwiIHx8IG4udHlwZSA9PT0gXCJUU1R5cGVMaXRlcmFsXCI7XG4gIH1cblxuICBmdW5jdGlvbiBpc0Z1bmN0aW9uT3JBcnJvd0V4cHJlc3Npb24obm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCI7XG4gIH1cblxuICBmdW5jdGlvbiBpc0Z1bmN0aW9uT3JBcnJvd0V4cHJlc3Npb25XaXRoQm9keShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiBub2RlLmJvZHkudHlwZSA9PT0gXCJCbG9ja1N0YXRlbWVudFwiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNUZW1wbGF0ZUxpdGVyYWwobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiVGVtcGxhdGVMaXRlcmFsXCI7XG4gIH0gLy8gYGluamVjdGAgaXMgdXNlZCBpbiBBbmd1bGFySlMgMS54LCBgYXN5bmNgIGluIEFuZ3VsYXIgMitcbiAgLy8gZXhhbXBsZTogaHR0cHM6Ly9kb2NzLmFuZ3VsYXJqcy5vcmcvZ3VpZGUvdW5pdC10ZXN0aW5nI3VzaW5nLWJlZm9yZWFsbC1cblxuXG4gIGZ1bmN0aW9uIGlzQW5ndWxhclRlc3RXcmFwcGVyKG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUudHlwZSA9PT0gXCJDYWxsRXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCIpICYmIG5vZGUuY2FsbGVlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIChub2RlLmNhbGxlZS5uYW1lID09PSBcImFzeW5jXCIgfHwgbm9kZS5jYWxsZWUubmFtZSA9PT0gXCJpbmplY3RcIiB8fCBub2RlLmNhbGxlZS5uYW1lID09PSBcImZha2VBc3luY1wiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSlNYTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJKU1hFbGVtZW50XCIgfHwgbm9kZS50eXBlID09PSBcIkpTWEZyYWdtZW50XCI7XG4gIH1cblxuICBmdW5jdGlvbiBpc1RoZU9ubHlKU1hFbGVtZW50SW5NYXJrZG93bihvcHRpb25zLCBwYXRoKSB7XG4gICAgaWYgKG9wdGlvbnMucGFyZW50UGFyc2VyICE9PSBcIm1hcmtkb3duXCIgJiYgb3B0aW9ucy5wYXJlbnRQYXJzZXIgIT09IFwibWR4XCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IHBhdGguZ2V0Tm9kZSgpO1xuXG4gICAgaWYgKCFub2RlLmV4cHJlc3Npb24gfHwgIWlzSlNYTm9kZShub2RlLmV4cHJlc3Npb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpO1xuICAgIHJldHVybiBwYXJlbnQudHlwZSA9PT0gXCJQcm9ncmFtXCIgJiYgcGFyZW50LmJvZHkubGVuZ3RoID09IDE7XG4gIH0gLy8gRGV0ZWN0IGFuIGV4cHJlc3Npb24gbm9kZSByZXByZXNlbnRpbmcgYHtcIiBcIn1gXG5cblxuICBmdW5jdGlvbiBpc0pTWFdoaXRlc3BhY2VFeHByZXNzaW9uKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIiAmJiBpc0xpdGVyYWwobm9kZS5leHByZXNzaW9uKSAmJiBub2RlLmV4cHJlc3Npb24udmFsdWUgPT09IFwiIFwiICYmICFub2RlLmV4cHJlc3Npb24uY29tbWVudHM7XG4gIH1cblxuICBmdW5jdGlvbiBpc01lbWJlckV4cHJlc3Npb25DaGFpbihub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSAhPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgbm9kZS50eXBlICE9PSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUub2JqZWN0LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNNZW1iZXJFeHByZXNzaW9uQ2hhaW4obm9kZS5vYmplY3QpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNHZXR0ZXJPclNldHRlcihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUua2luZCA9PT0gXCJnZXRcIiB8fCBub2RlLmtpbmQgPT09IFwic2V0XCI7XG4gIH1cblxuICBmdW5jdGlvbiBzYW1lTG9jU3RhcnQobm9kZUEsIG5vZGVCLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9jU3RhcnQobm9kZUEpID09PSBvcHRpb25zLmxvY1N0YXJ0KG5vZGVCKTtcbiAgfSAvLyBUT0RPOiBUaGlzIGlzIGEgYmFkIGhhY2sgYW5kIHdlIG5lZWQgYSBiZXR0ZXIgd2F5IHRvIGRpc3Rpbmd1aXNoIGJldHdlZW5cbiAgLy8gYXJyb3cgZnVuY3Rpb25zIGFuZCBvdGhlcndpc2VcblxuXG4gIGZ1bmN0aW9uIGlzRnVuY3Rpb25Ob3RhdGlvbihub2RlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGlzR2V0dGVyT3JTZXR0ZXIobm9kZSkgfHwgc2FtZUxvY1N0YXJ0KG5vZGUsIG5vZGUudmFsdWUsIG9wdGlvbnMpO1xuICB9IC8vIEhhY2sgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHRoZSBmb2xsb3dpbmcgdHdvIHdoaWNoIGhhdmUgdGhlIHNhbWUgYXN0XG4gIC8vIHR5cGUgVCA9IHsgbWV0aG9kOiAoKSA9PiB2b2lkIH07XG4gIC8vIHR5cGUgVCA9IHsgbWV0aG9kKCk6IHZvaWQgfTtcblxuXG4gIGZ1bmN0aW9uIGlzT2JqZWN0VHlwZVByb3BlcnR5QUZ1bmN0aW9uKG5vZGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG5vZGUudHlwZSA9PT0gXCJPYmplY3RUeXBlUHJvcGVydHlcIiB8fCBub2RlLnR5cGUgPT09IFwiT2JqZWN0VHlwZUludGVybmFsU2xvdFwiKSAmJiBub2RlLnZhbHVlLnR5cGUgPT09IFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiICYmICFub2RlLnN0YXRpYyAmJiAhaXNGdW5jdGlvbk5vdGF0aW9uKG5vZGUsIG9wdGlvbnMpO1xuICB9IC8vIEhhY2sgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHRoZSBmb2xsb3dpbmcgdHdvIHdoaWNoIGhhdmUgdGhlIHNhbWUgYXN0XG4gIC8vIGRlY2xhcmUgZnVuY3Rpb24gZihhKTogdm9pZDtcbiAgLy8gdmFyIGY6IChhKSA9PiB2b2lkO1xuXG5cbiAgZnVuY3Rpb24gaXNUeXBlQW5ub3RhdGlvbkFGdW5jdGlvbihub2RlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIChub2RlLnR5cGUgPT09IFwiVHlwZUFubm90YXRpb25cIiB8fCBub2RlLnR5cGUgPT09IFwiVFNUeXBlQW5ub3RhdGlvblwiKSAmJiBub2RlLnR5cGVBbm5vdGF0aW9uLnR5cGUgPT09IFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiICYmICFub2RlLnN0YXRpYyAmJiAhc2FtZUxvY1N0YXJ0KG5vZGUsIG5vZGUudHlwZUFubm90YXRpb24sIG9wdGlvbnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNCaW5hcnlpc2gobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiQmluYXJ5RXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJMb2dpY2FsRXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJOR1BpcGVFeHByZXNzaW9uXCI7XG4gIH1cblxuICBmdW5jdGlvbiBpc01lbWJlcmlzaChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJCaW5kRXhwcmVzc2lvblwiICYmIG5vZGUub2JqZWN0O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTaW1wbGVGbG93VHlwZShub2RlKSB7XG4gICAgdmFyIGZsb3dUeXBlQW5ub3RhdGlvbnMgPSBbXCJBbnlUeXBlQW5ub3RhdGlvblwiLCBcIk51bGxMaXRlcmFsVHlwZUFubm90YXRpb25cIiwgXCJHZW5lcmljVHlwZUFubm90YXRpb25cIiwgXCJUaGlzVHlwZUFubm90YXRpb25cIiwgXCJOdW1iZXJUeXBlQW5ub3RhdGlvblwiLCBcIlZvaWRUeXBlQW5ub3RhdGlvblwiLCBcIkVtcHR5VHlwZUFubm90YXRpb25cIiwgXCJNaXhlZFR5cGVBbm5vdGF0aW9uXCIsIFwiQm9vbGVhblR5cGVBbm5vdGF0aW9uXCIsIFwiQm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvblwiLCBcIlN0cmluZ1R5cGVBbm5vdGF0aW9uXCJdO1xuICAgIHJldHVybiBub2RlICYmIGZsb3dUeXBlQW5ub3RhdGlvbnMuaW5kZXhPZihub2RlLnR5cGUpICE9PSAtMSAmJiAhKG5vZGUudHlwZSA9PT0gXCJHZW5lcmljVHlwZUFubm90YXRpb25cIiAmJiBub2RlLnR5cGVQYXJhbWV0ZXJzKTtcbiAgfVxuXG4gIHZhciB1bml0VGVzdFJlID0gL14oc2tpcHxbZnhdPyhpdHxkZXNjcmliZXx0ZXN0KSkkLztcblxuICBmdW5jdGlvbiBpc1NraXBPck9ubHlCbG9jayhub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLmNhbGxlZS50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiB8fCBub2RlLmNhbGxlZS50eXBlID09PSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiKSAmJiBub2RlLmNhbGxlZS5vYmplY3QudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgbm9kZS5jYWxsZWUucHJvcGVydHkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgdW5pdFRlc3RSZS50ZXN0KG5vZGUuY2FsbGVlLm9iamVjdC5uYW1lKSAmJiAobm9kZS5jYWxsZWUucHJvcGVydHkubmFtZSA9PT0gXCJvbmx5XCIgfHwgbm9kZS5jYWxsZWUucHJvcGVydHkubmFtZSA9PT0gXCJza2lwXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNVbml0VGVzdFNldFVwKG4pIHtcbiAgICB2YXIgdW5pdFRlc3RTZXRVcFJlID0gL14oYmVmb3JlfGFmdGVyKShFYWNofEFsbCkkLztcbiAgICByZXR1cm4gbi5jYWxsZWUudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgdW5pdFRlc3RTZXRVcFJlLnRlc3Qobi5jYWxsZWUubmFtZSkgJiYgbi5hcmd1bWVudHMubGVuZ3RoID09PSAxO1xuICB9IC8vIGVnOyBgZGVzY3JpYmUoXCJzb21lIHN0cmluZ1wiLCAoZG9uZSkgPT4ge30pYFxuXG5cbiAgZnVuY3Rpb24gaXNUZXN0Q2FsbChuLCBwYXJlbnQpIHtcbiAgICBpZiAobi50eXBlICE9PSBcIkNhbGxFeHByZXNzaW9uXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobi5hcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoaXNBbmd1bGFyVGVzdFdyYXBwZXIobikgJiYgcGFyZW50ICYmIGlzVGVzdENhbGwocGFyZW50KSkge1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbk9yQXJyb3dFeHByZXNzaW9uKG4uYXJndW1lbnRzWzBdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzVW5pdFRlc3RTZXRVcChuKSkge1xuICAgICAgICByZXR1cm4gaXNBbmd1bGFyVGVzdFdyYXBwZXIobi5hcmd1bWVudHNbMF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobi5hcmd1bWVudHMubGVuZ3RoID09PSAyIHx8IG4uYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgaWYgKChuLmNhbGxlZS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiB1bml0VGVzdFJlLnRlc3Qobi5jYWxsZWUubmFtZSkgfHwgaXNTa2lwT3JPbmx5QmxvY2sobikpICYmIChpc1RlbXBsYXRlTGl0ZXJhbChuLmFyZ3VtZW50c1swXSkgfHwgaXNTdHJpbmdMaXRlcmFsKG4uYXJndW1lbnRzWzBdKSkpIHtcbiAgICAgICAgLy8gaXQoXCJuYW1lXCIsICgpID0+IHsgLi4uIH0sIDI1MDApXG4gICAgICAgIGlmIChuLmFyZ3VtZW50c1syXSAmJiAhaXNOdW1lcmljTGl0ZXJhbChuLmFyZ3VtZW50c1syXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKG4uYXJndW1lbnRzLmxlbmd0aCA9PT0gMiA/IGlzRnVuY3Rpb25PckFycm93RXhwcmVzc2lvbihuLmFyZ3VtZW50c1sxXSkgOiBpc0Z1bmN0aW9uT3JBcnJvd0V4cHJlc3Npb25XaXRoQm9keShuLmFyZ3VtZW50c1sxXSkgJiYgbi5hcmd1bWVudHNbMV0ucGFyYW1zLmxlbmd0aCA8PSAxKSB8fCBpc0FuZ3VsYXJUZXN0V3JhcHBlcihuLmFyZ3VtZW50c1sxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzTGVhZGluZ0NvbW1lbnQkMihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuY29tbWVudHMgJiYgbm9kZS5jb21tZW50cy5zb21lKGZ1bmN0aW9uIChjb21tZW50KSB7XG4gICAgICByZXR1cm4gY29tbWVudC5sZWFkaW5nO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzVHJhaWxpbmdDb21tZW50KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5jb21tZW50cyAmJiBub2RlLmNvbW1lbnRzLnNvbWUoZnVuY3Rpb24gKGNvbW1lbnQpIHtcbiAgICAgIHJldHVybiBjb21tZW50LnRyYWlsaW5nO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNDYWxsT3JPcHRpb25hbENhbGxFeHByZXNzaW9uKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIkNhbGxFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0RhbmdsaW5nQ29tbWVudHMobm9kZSkge1xuICAgIHJldHVybiBub2RlLmNvbW1lbnRzICYmIG5vZGUuY29tbWVudHMuc29tZShmdW5jdGlvbiAoY29tbWVudCkge1xuICAgICAgcmV0dXJuICFjb21tZW50LmxlYWRpbmcgJiYgIWNvbW1lbnQudHJhaWxpbmc7XG4gICAgfSk7XG4gIH1cbiAgLyoqIGlkZW50aWZ5IGlmIGFuIGFuZ3VsYXIgZXhwcmVzc2lvbiBzZWVtcyB0byBoYXZlIHNpZGUgZWZmZWN0cyAqL1xuXG5cbiAgZnVuY3Rpb24gaGFzTmdTaWRlRWZmZWN0KHBhdGgpIHtcbiAgICByZXR1cm4gaGFzTm9kZShwYXRoLmdldFZhbHVlKCksIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgY2FzZSBcIkNhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgIGNhc2UgXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgIGNhc2UgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOZ0Zvck9mKG5vZGUsIGluZGV4LCBwYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJOR01pY3Jvc3ludGF4S2V5ZWRFeHByZXNzaW9uXCIgJiYgbm9kZS5rZXkubmFtZSA9PT0gXCJvZlwiICYmIGluZGV4ID09PSAxICYmIHBhcmVudE5vZGUuYm9keVswXS50eXBlID09PSBcIk5HTWljcm9zeW50YXhMZXRcIiAmJiBwYXJlbnROb2RlLmJvZHlbMF0udmFsdWUgPT09IG51bGw7XG4gIH1cbiAgLyoqIEBwYXJhbSBub2RlIHtpbXBvcnQoXCJlc3RyZWVcIikuVGVtcGxhdGVMaXRlcmFsfSAqL1xuXG5cbiAgZnVuY3Rpb24gaXNTaW1wbGVUZW1wbGF0ZUxpdGVyYWwobm9kZSkge1xuICAgIGlmIChub2RlLmV4cHJlc3Npb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlLmV4cHJlc3Npb25zLmV2ZXJ5KGZ1bmN0aW9uIChleHByKSB7XG4gICAgICAvLyBEaXNhbGxvdyBjb21tZW50cyBzaW5jZSBwcmludERvY1RvU3RyaW5nIGNhbid0IHByaW50IHRoZW0gaGVyZVxuICAgICAgaWYgKGV4cHIuY29tbWVudHMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBBbGxvdyBgeGAgYW5kIGB0aGlzYFxuXG5cbiAgICAgIGlmIChleHByLnR5cGUgPT09IFwiSWRlbnRpZmllclwiIHx8IGV4cHIudHlwZSA9PT0gXCJUaGlzRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBBbGxvdyBgYS5iLmNgLCBgYS5iW2NdYCwgYW5kIGB0aGlzLngueWBcblxuXG4gICAgICBpZiAoZXhwci50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiB8fCBleHByLnR5cGUgPT09IFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgdmFyIGhlYWQgPSBleHByO1xuXG4gICAgICAgIHdoaWxlIChoZWFkLnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiIHx8IGhlYWQudHlwZSA9PT0gXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIikge1xuICAgICAgICAgIGlmIChoZWFkLnByb3BlcnR5LnR5cGUgIT09IFwiSWRlbnRpZmllclwiICYmIGhlYWQucHJvcGVydHkudHlwZSAhPT0gXCJMaXRlcmFsXCIgJiYgaGVhZC5wcm9wZXJ0eS50eXBlICE9PSBcIlN0cmluZ0xpdGVyYWxcIiAmJiBoZWFkLnByb3BlcnR5LnR5cGUgIT09IFwiTnVtZXJpY0xpdGVyYWxcIikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGhlYWQgPSBoZWFkLm9iamVjdDtcblxuICAgICAgICAgIGlmIChoZWFkLmNvbW1lbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhlYWQudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgfHwgaGVhZC50eXBlID09PSBcIlRoaXNFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Rmxvd1ZhcmlhbmNlKHBhdGgpIHtcbiAgICBpZiAoIXBhdGgudmFyaWFuY2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gQmFiZWwgNy4wIGN1cnJlbnRseSB1c2VzIHZhcmlhbmNlIG5vZGUgdHlwZSwgYW5kIGZsb3cgc2hvdWxkXG4gICAgLy8gZm9sbG93IHN1aXQgc29vbjpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYmFiZWwvYmFiZWwvaXNzdWVzLzQ3MjJcblxuXG4gICAgdmFyIHZhcmlhbmNlID0gcGF0aC52YXJpYW5jZS5raW5kIHx8IHBhdGgudmFyaWFuY2U7XG5cbiAgICBzd2l0Y2ggKHZhcmlhbmNlKSB7XG4gICAgICBjYXNlIFwicGx1c1wiOlxuICAgICAgICByZXR1cm4gXCIrXCI7XG5cbiAgICAgIGNhc2UgXCJtaW51c1wiOlxuICAgICAgICByZXR1cm4gXCItXCI7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiB2YXJpYW5jZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGFzc1Byb3BNYXlDYXVzZUFTSVByb2JsZW1zKHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IHBhdGguZ2V0Tm9kZSgpO1xuXG4gICAgaWYgKG5vZGUudHlwZSAhPT0gXCJDbGFzc1Byb3BlcnR5XCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IG5vZGUua2V5ICYmIG5vZGUua2V5Lm5hbWU7IC8vIHRoaXMgaXNuJ3QgYWN0dWFsbHkgcG9zc2libGUgeWV0IHdpdGggbW9zdCBwYXJzZXJzIGF2YWlsYWJsZSB0b2RheVxuICAgIC8vIHNvIGlzbid0IHByb3Blcmx5IHRlc3RlZCB5ZXQuXG5cbiAgICBpZiAoKG5hbWUgPT09IFwic3RhdGljXCIgfHwgbmFtZSA9PT0gXCJnZXRcIiB8fCBuYW1lID09PSBcInNldFwiKSAmJiAhbm9kZS52YWx1ZSAmJiAhbm9kZS50eXBlQW5ub3RhdGlvbikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xhc3NDaGlsZE5lZWRzQVNJUHJvdGVjdGlvbihub2RlKSB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuc3RhdGljIHx8IG5vZGUuYWNjZXNzaWJpbGl0eSAvLyBUeXBlU2NyaXB0XG4gICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgIGlmICghbm9kZS5jb21wdXRlZCkge1xuICAgICAgdmFyIG5hbWUgPSBub2RlLmtleSAmJiBub2RlLmtleS5uYW1lO1xuXG4gICAgICBpZiAobmFtZSA9PT0gXCJpblwiIHx8IG5hbWUgPT09IFwiaW5zdGFuY2VvZlwiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiQ2xhc3NQcm9wZXJ0eVwiOlxuICAgICAgY2FzZSBcIlRTQWJzdHJhY3RDbGFzc1Byb3BlcnR5XCI6XG4gICAgICAgIHJldHVybiBub2RlLmNvbXB1dGVkO1xuXG4gICAgICBjYXNlIFwiTWV0aG9kRGVmaW5pdGlvblwiOiAvLyBGbG93XG5cbiAgICAgIGNhc2UgXCJUU0Fic3RyYWN0TWV0aG9kRGVmaW5pdGlvblwiOiAvLyBUeXBlU2NyaXB0XG5cbiAgICAgIGNhc2UgXCJDbGFzc01ldGhvZFwiOlxuICAgICAgY2FzZSBcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gQmFiZWxcbiAgICAgICAgICB2YXIgaXNBc3luYyA9IG5vZGUudmFsdWUgPyBub2RlLnZhbHVlLmFzeW5jIDogbm9kZS5hc3luYztcbiAgICAgICAgICB2YXIgaXNHZW5lcmF0b3IgPSBub2RlLnZhbHVlID8gbm9kZS52YWx1ZS5nZW5lcmF0b3IgOiBub2RlLmdlbmVyYXRvcjtcblxuICAgICAgICAgIGlmIChpc0FzeW5jIHx8IG5vZGUua2luZCA9PT0gXCJnZXRcIiB8fCBub2RlLmtpbmQgPT09IFwic2V0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobm9kZS5jb21wdXRlZCB8fCBpc0dlbmVyYXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJUU0luZGV4U2lnbmF0dXJlXCI6XG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VHlwZVNjcmlwdE1hcHBlZFR5cGVNb2RpZmllcih0b2tlbk5vZGUsIGtleXdvcmQpIHtcbiAgICBpZiAodG9rZW5Ob2RlID09PSBcIitcIikge1xuICAgICAgcmV0dXJuIFwiK1wiICsga2V5d29yZDtcbiAgICB9IGVsc2UgaWYgKHRva2VuTm9kZSA9PT0gXCItXCIpIHtcbiAgICAgIHJldHVybiBcIi1cIiArIGtleXdvcmQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleXdvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNOZXdsaW5lQmV0d2Vlbk9yQWZ0ZXJEZWNvcmF0b3JzKG5vZGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gaGFzTmV3bGluZUluUmFuZ2UkMShvcHRpb25zLm9yaWdpbmFsVGV4dCwgb3B0aW9ucy5sb2NTdGFydChub2RlLmRlY29yYXRvcnNbMF0pLCBvcHRpb25zLmxvY0VuZChnZXRMYXN0JDEobm9kZS5kZWNvcmF0b3JzKSkpIHx8IGhhc05ld2xpbmUkMyhvcHRpb25zLm9yaWdpbmFsVGV4dCwgb3B0aW9ucy5sb2NFbmQoZ2V0TGFzdCQxKG5vZGUuZGVjb3JhdG9ycykpKTtcbiAgfSAvLyBPbmx5IHNwYWNlLCBuZXdsaW5lLCBjYXJyaWFnZSByZXR1cm4sIGFuZCB0YWIgYXJlIHRyZWF0ZWQgYXMgd2hpdGVzcGFjZVxuICAvLyBpbnNpZGUgSlNYLlxuXG5cbiAgdmFyIGpzeFdoaXRlc3BhY2VDaGFycyA9IFwiIFxcblxcclxcdFwiO1xuICB2YXIgbWF0Y2hKc3hXaGl0ZXNwYWNlUmVnZXggPSBuZXcgUmVnRXhwKFwiKFtcIiArIGpzeFdoaXRlc3BhY2VDaGFycyArIFwiXSspXCIpO1xuICB2YXIgY29udGFpbnNOb25Kc3hXaGl0ZXNwYWNlUmVnZXggPSBuZXcgUmVnRXhwKFwiW15cIiArIGpzeFdoaXRlc3BhY2VDaGFycyArIFwiXVwiKTsgLy8gTWVhbmluZ2Z1bCBpZiBpdCBjb250YWlucyBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzLFxuICAvLyBvciBpdCBjb250YWlucyB3aGl0ZXNwYWNlIHdpdGhvdXQgYSBuZXcgbGluZS5cblxuICBmdW5jdGlvbiBpc01lYW5pbmdmdWxKU1hUZXh0KG5vZGUpIHtcbiAgICByZXR1cm4gaXNMaXRlcmFsKG5vZGUpICYmIChjb250YWluc05vbkpzeFdoaXRlc3BhY2VSZWdleC50ZXN0KHJhd1RleHQobm9kZSkpIHx8ICEvXFxuLy50ZXN0KHJhd1RleHQobm9kZSkpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0pzeElnbm9yZUNvbW1lbnQocGF0aCkge1xuICAgIHZhciBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIHZhciBwYXJlbnQgPSBwYXRoLmdldFBhcmVudE5vZGUoKTtcblxuICAgIGlmICghcGFyZW50IHx8ICFub2RlIHx8ICFpc0pTWE5vZGUobm9kZSkgfHwgIWlzSlNYTm9kZShwYXJlbnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBMb29rdXAgdGhlIHByZXZpb3VzIHNpYmxpbmcsIGlnbm9yaW5nIGFueSBlbXB0eSBKU1hUZXh0IGVsZW1lbnRzXG5cblxuICAgIHZhciBpbmRleCA9IHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKG5vZGUpO1xuICAgIHZhciBwcmV2U2libGluZyA9IG51bGw7XG5cbiAgICBmb3IgKHZhciBpID0gaW5kZXg7IGkgPiAwOyBpLS0pIHtcbiAgICAgIHZhciBjYW5kaWRhdGUgPSBwYXJlbnQuY2hpbGRyZW5baSAtIDFdO1xuXG4gICAgICBpZiAoY2FuZGlkYXRlLnR5cGUgPT09IFwiSlNYVGV4dFwiICYmICFpc01lYW5pbmdmdWxKU1hUZXh0KGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHByZXZTaWJsaW5nID0gY2FuZGlkYXRlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZXZTaWJsaW5nICYmIHByZXZTaWJsaW5nLnR5cGUgPT09IFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiICYmIHByZXZTaWJsaW5nLmV4cHJlc3Npb24udHlwZSA9PT0gXCJKU1hFbXB0eUV4cHJlc3Npb25cIiAmJiBwcmV2U2libGluZy5leHByZXNzaW9uLmNvbW1lbnRzICYmIHByZXZTaWJsaW5nLmV4cHJlc3Npb24uY29tbWVudHMuZmluZChmdW5jdGlvbiAoY29tbWVudCkge1xuICAgICAgcmV0dXJuIGNvbW1lbnQudmFsdWUudHJpbSgpID09PSBcInByZXR0aWVyLWlnbm9yZVwiO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNFbXB0eUpTWEVsZW1lbnQobm9kZSkge1xuICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gaWYgdGhlcmUgaXMgb25lIHRleHQgY2hpbGQgYW5kIGRvZXMgbm90IGNvbnRhaW4gYW55IG1lYW5pbmdmdWwgdGV4dFxuICAgIC8vIHdlIGNhbiB0cmVhdCB0aGUgZWxlbWVudCBhcyBlbXB0eS5cblxuXG4gICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlblswXTtcbiAgICByZXR1cm4gaXNMaXRlcmFsKGNoaWxkKSAmJiAhaXNNZWFuaW5nZnVsSlNYVGV4dChjaGlsZCk7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNQcmV0dGllcklnbm9yZSQyKHBhdGgpIHtcbiAgICByZXR1cm4gaGFzSWdub3JlQ29tbWVudCQzKHBhdGgpIHx8IGhhc0pzeElnbm9yZUNvbW1lbnQocGF0aCk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0xhc3RTdGF0ZW1lbnQocGF0aCkge1xuICAgIHZhciBwYXJlbnQgPSBwYXRoLmdldFBhcmVudE5vZGUoKTtcblxuICAgIGlmICghcGFyZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICB2YXIgYm9keSA9IChwYXJlbnQuYm9keSB8fCBwYXJlbnQuY29uc2VxdWVudCkuZmlsdGVyKGZ1bmN0aW9uIChzdG10KSB7XG4gICAgICByZXR1cm4gc3RtdC50eXBlICE9PSBcIkVtcHR5U3RhdGVtZW50XCI7XG4gICAgfSk7XG4gICAgcmV0dXJuIGJvZHkgJiYgYm9keVtib2R5Lmxlbmd0aCAtIDFdID09PSBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNGbG93QW5ub3RhdGlvbkNvbW1lbnQodGV4dCwgdHlwZUFubm90YXRpb24sIG9wdGlvbnMpIHtcbiAgICB2YXIgc3RhcnQgPSBvcHRpb25zLmxvY1N0YXJ0KHR5cGVBbm5vdGF0aW9uKTtcbiAgICB2YXIgZW5kID0gc2tpcFdoaXRlc3BhY2UkMSh0ZXh0LCBvcHRpb25zLmxvY0VuZCh0eXBlQW5ub3RhdGlvbikpO1xuICAgIHJldHVybiB0ZXh0LnN1YnN0cihzdGFydCwgMikgPT09IFwiLypcIiAmJiB0ZXh0LnN1YnN0cihlbmQsIDIpID09PSBcIiovXCI7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNMZWFkaW5nT3duTGluZUNvbW1lbnQodGV4dCwgbm9kZSwgb3B0aW9ucykge1xuICAgIGlmIChpc0pTWE5vZGUobm9kZSkpIHtcbiAgICAgIHJldHVybiBoYXNOb2RlSWdub3JlQ29tbWVudCQxKG5vZGUpO1xuICAgIH1cblxuICAgIHZhciByZXMgPSBub2RlLmNvbW1lbnRzICYmIG5vZGUuY29tbWVudHMuc29tZShmdW5jdGlvbiAoY29tbWVudCkge1xuICAgICAgcmV0dXJuIGNvbW1lbnQubGVhZGluZyAmJiBoYXNOZXdsaW5lJDModGV4dCwgb3B0aW9ucy5sb2NFbmQoY29tbWVudCkpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH0gLy8gVGhpcyByZWN1cnNlcyB0aGUgcmV0dXJuIGFyZ3VtZW50LCBsb29raW5nIGZvciB0aGUgZmlyc3QgdG9rZW5cbiAgLy8gKHRoZSBsZWZ0bW9zdCBsZWFmIG5vZGUpIGFuZCwgaWYgaXQgKG9yIGl0cyBwYXJlbnRzKSBoYXMgYW55XG4gIC8vIGxlYWRpbmdDb21tZW50cywgcmV0dXJucyB0cnVlIChzbyBpdCBjYW4gYmUgd3JhcHBlZCBpbiBwYXJlbnMpLlxuXG5cbiAgZnVuY3Rpb24gcmV0dXJuQXJndW1lbnRIYXNMZWFkaW5nQ29tbWVudChvcHRpb25zLCBhcmd1bWVudCkge1xuICAgIGlmIChoYXNMZWFkaW5nT3duTGluZUNvbW1lbnQob3B0aW9ucy5vcmlnaW5hbFRleHQsIGFyZ3VtZW50LCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGhhc05ha2VkTGVmdFNpZGUoYXJndW1lbnQpKSB7XG4gICAgICB2YXIgbGVmdE1vc3QgPSBhcmd1bWVudDtcbiAgICAgIHZhciBuZXdMZWZ0TW9zdDtcblxuICAgICAgd2hpbGUgKG5ld0xlZnRNb3N0ID0gZ2V0TGVmdFNpZGUobGVmdE1vc3QpKSB7XG4gICAgICAgIGxlZnRNb3N0ID0gbmV3TGVmdE1vc3Q7XG5cbiAgICAgICAgaWYgKGhhc0xlYWRpbmdPd25MaW5lQ29tbWVudChvcHRpb25zLm9yaWdpbmFsVGV4dCwgbGVmdE1vc3QsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBpc1N0cmluZ1Byb3BTYWZlVG9Db2VyY2VUb0lkZW50aWZpZXIobm9kZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBpc1N0cmluZ0xpdGVyYWwobm9kZS5rZXkpICYmIGlzSWRlbnRpZmllck5hbWUobm9kZS5rZXkudmFsdWUpICYmIG9wdGlvbnMucGFyc2VyICE9PSBcImpzb25cIiAmJiAhKG9wdGlvbnMucGFyc2VyID09PSBcInR5cGVzY3JpcHRcIiAmJiBub2RlLnR5cGUgPT09IFwiQ2xhc3NQcm9wZXJ0eVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSmVzdEVhY2hUZW1wbGF0ZUxpdGVyYWwobm9kZSwgcGFyZW50Tm9kZSkge1xuICAgIC8qKlxuICAgICAqIGRlc2NyaWJlLmVhY2hgdGFibGVgKG5hbWUsIGZuKVxuICAgICAqIGRlc2NyaWJlLm9ubHkuZWFjaGB0YWJsZWAobmFtZSwgZm4pXG4gICAgICogZGVzY3JpYmUuc2tpcC5lYWNoYHRhYmxlYChuYW1lLCBmbilcbiAgICAgKiB0ZXN0LmVhY2hgdGFibGVgKG5hbWUsIGZuKVxuICAgICAqIHRlc3Qub25seS5lYWNoYHRhYmxlYChuYW1lLCBmbilcbiAgICAgKiB0ZXN0LnNraXAuZWFjaGB0YWJsZWAobmFtZSwgZm4pXG4gICAgICpcbiAgICAgKiBSZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9qZXN0L3B1bGwvNjEwMlxuICAgICAqL1xuICAgIHZhciBqZXN0RWFjaFRyaWdnZXJSZWdleCA9IC9eW3hmXT8oZGVzY3JpYmV8aXR8dGVzdCkkLztcbiAgICByZXR1cm4gcGFyZW50Tm9kZS50eXBlID09PSBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiICYmIHBhcmVudE5vZGUucXVhc2kgPT09IG5vZGUgJiYgcGFyZW50Tm9kZS50YWcudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgcGFyZW50Tm9kZS50YWcucHJvcGVydHkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgcGFyZW50Tm9kZS50YWcucHJvcGVydHkubmFtZSA9PT0gXCJlYWNoXCIgJiYgKHBhcmVudE5vZGUudGFnLm9iamVjdC50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBqZXN0RWFjaFRyaWdnZXJSZWdleC50ZXN0KHBhcmVudE5vZGUudGFnLm9iamVjdC5uYW1lKSB8fCBwYXJlbnROb2RlLnRhZy5vYmplY3QudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgcGFyZW50Tm9kZS50YWcub2JqZWN0LnByb3BlcnR5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIChwYXJlbnROb2RlLnRhZy5vYmplY3QucHJvcGVydHkubmFtZSA9PT0gXCJvbmx5XCIgfHwgcGFyZW50Tm9kZS50YWcub2JqZWN0LnByb3BlcnR5Lm5hbWUgPT09IFwic2tpcFwiKSAmJiBwYXJlbnROb2RlLnRhZy5vYmplY3Qub2JqZWN0LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGplc3RFYWNoVHJpZ2dlclJlZ2V4LnRlc3QocGFyZW50Tm9kZS50YWcub2JqZWN0Lm9iamVjdC5uYW1lKSk7XG4gIH1cblxuICBmdW5jdGlvbiB0ZW1wbGF0ZUxpdGVyYWxIYXNOZXdMaW5lcyh0ZW1wbGF0ZSkge1xuICAgIHJldHVybiB0ZW1wbGF0ZS5xdWFzaXMuc29tZShmdW5jdGlvbiAocXVhc2kpIHtcbiAgICAgIHJldHVybiBxdWFzaS52YWx1ZS5yYXcuaW5jbHVkZXMoXCJcXG5cIik7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc1RlbXBsYXRlT25JdHNPd25MaW5lKG4sIHRleHQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG4udHlwZSA9PT0gXCJUZW1wbGF0ZUxpdGVyYWxcIiAmJiB0ZW1wbGF0ZUxpdGVyYWxIYXNOZXdMaW5lcyhuKSB8fCBuLnR5cGUgPT09IFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIgJiYgdGVtcGxhdGVMaXRlcmFsSGFzTmV3TGluZXMobi5xdWFzaSkpICYmICFoYXNOZXdsaW5lJDModGV4dCwgb3B0aW9ucy5sb2NTdGFydChuKSwge1xuICAgICAgYmFja3dhcmRzOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBuZWVkc0hhcmRsaW5lQWZ0ZXJEYW5nbGluZ0NvbW1lbnQobm9kZSkge1xuICAgIGlmICghbm9kZS5jb21tZW50cykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBsYXN0RGFuZ2xpbmdDb21tZW50ID0gZ2V0TGFzdCQxKG5vZGUuY29tbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChjb21tZW50KSB7XG4gICAgICByZXR1cm4gIWNvbW1lbnQubGVhZGluZyAmJiAhY29tbWVudC50cmFpbGluZztcbiAgICB9KSk7XG4gICAgcmV0dXJuIGxhc3REYW5nbGluZ0NvbW1lbnQgJiYgIWNvbW1lbnRzJDEuaXNCbG9ja0NvbW1lbnQobGFzdERhbmdsaW5nQ29tbWVudCk7XG4gIH0gLy8gSWYgd2UgaGF2ZSBuZXN0ZWQgY29uZGl0aW9uYWwgZXhwcmVzc2lvbnMsIHdlIHdhbnQgdG8gcHJpbnQgdGhlbSBpbiBKU1ggbW9kZVxuICAvLyBpZiB0aGVyZSdzIGF0IGxlYXN0IG9uZSBKU1hFbGVtZW50IHNvbWV3aGVyZSBpbiB0aGUgdHJlZS5cbiAgLy9cbiAgLy8gQSBjb25kaXRpb25hbCBleHByZXNzaW9uIGNoYWluIGxpa2UgdGhpcyBzaG91bGQgYmUgcHJpbnRlZCBpbiBub3JtYWwgbW9kZSxcbiAgLy8gYmVjYXVzZSB0aGVyZSBhcmVuJ3QgSlNYRWxlbWVudHMgYW55d2hlcmUgaW4gaXQ6XG4gIC8vXG4gIC8vIGlzQSA/IFwiQVwiIDogaXNCID8gXCJCXCIgOiBpc0MgPyBcIkNcIiA6IFwiVW5rbm93blwiO1xuICAvL1xuICAvLyBCdXQgYSBjb25kaXRpb25hbCBleHByZXNzaW9uIGNoYWluIGxpa2UgdGhpcyBzaG91bGQgYmUgcHJpbnRlZCBpbiBKU1ggbW9kZSxcbiAgLy8gYmVjYXVzZSB0aGVyZSBpcyBhIEpTWEVsZW1lbnQgaW4gdGhlIGxhc3QgQ29uZGl0aW9uYWxFeHByZXNzaW9uOlxuICAvL1xuICAvLyBpc0EgPyBcIkFcIiA6IGlzQiA/IFwiQlwiIDogaXNDID8gXCJDXCIgOiA8c3BhbiBjbGFzc05hbWU9XCJ3YXJuaW5nXCI+VW5rbm93bjwvc3Bhbj47XG4gIC8vXG4gIC8vIFRoaXMgdHlwZSBvZiBDb25kaXRpb25hbEV4cHJlc3Npb24gY2hhaW4gaXMgc3RydWN0dXJlZCBsaWtlIHRoaXMgaW4gdGhlIEFTVDpcbiAgLy9cbiAgLy8gQ29uZGl0aW9uYWxFeHByZXNzaW9uIHtcbiAgLy8gICB0ZXN0OiAuLi4sXG4gIC8vICAgY29uc2VxdWVudDogLi4uLFxuICAvLyAgIGFsdGVybmF0ZTogQ29uZGl0aW9uYWxFeHByZXNzaW9uIHtcbiAgLy8gICAgIHRlc3Q6IC4uLixcbiAgLy8gICAgIGNvbnNlcXVlbnQ6IC4uLixcbiAgLy8gICAgIGFsdGVybmF0ZTogQ29uZGl0aW9uYWxFeHByZXNzaW9uIHtcbiAgLy8gICAgICAgdGVzdDogLi4uLFxuICAvLyAgICAgICBjb25zZXF1ZW50OiAuLi4sXG4gIC8vICAgICAgIGFsdGVybmF0ZTogLi4uLFxuICAvLyAgICAgfVxuICAvLyAgIH1cbiAgLy8gfVxuICAvL1xuICAvLyBXZSB3YW50IHRvIHRyYXZlcnNlIG92ZXIgdGhhdCBzaGFwZSBhbmQgY29udmVydCBpdCBpbnRvIGEgZmxhdCBzdHJ1Y3R1cmUgc29cbiAgLy8gdGhhdCB3ZSBjYW4gZmluZCBpZiB0aGVyZSdzIGEgSlNYRWxlbWVudCBzb21ld2hlcmUgaW5zaWRlLlxuXG5cbiAgZnVuY3Rpb24gZ2V0Q29uZGl0aW9uYWxDaGFpbkNvbnRlbnRzKG5vZGUpIHtcbiAgICAvLyBHaXZlbiB0aGlzIGNvZGU6XG4gICAgLy9cbiAgICAvLyAvLyBVc2luZyBhIENvbmRpdGlvbmFsRXhwcmVzc2lvbiBhcyB0aGUgY29uc2VxdWVudCBpcyB1bmNvbW1vbiwgYnV0IHNob3VsZFxuICAgIC8vIC8vIGJlIGhhbmRsZWQuXG4gICAgLy8gQSA/IEIgOiBDID8gRCA6IEUgPyBGID8gRyA6IEggOiBJXG4gICAgLy9cbiAgICAvLyB3aGljaCBoYXMgdGhpcyBBU1Q6XG4gICAgLy9cbiAgICAvLyBDb25kaXRpb25hbEV4cHJlc3Npb24ge1xuICAgIC8vICAgdGVzdDogSWRlbnRpZmllcihBKSxcbiAgICAvLyAgIGNvbnNlcXVlbnQ6IElkZW50aWZpZXIoQiksXG4gICAgLy8gICBhbHRlcm5hdGU6IENvbmRpdGlvbmFsRXhwcmVzc2lvbiB7XG4gICAgLy8gICAgIHRlc3Q6IElkZW50aWZpZXIoQyksXG4gICAgLy8gICAgIGNvbnNlcXVlbnQ6IElkZW50aWZpZXIoRCksXG4gICAgLy8gICAgIGFsdGVybmF0ZTogQ29uZGl0aW9uYWxFeHByZXNzaW9uIHtcbiAgICAvLyAgICAgICB0ZXN0OiBJZGVudGlmaWVyKEUpLFxuICAgIC8vICAgICAgIGNvbnNlcXVlbnQ6IENvbmRpdGlvbmFsRXhwcmVzc2lvbiB7XG4gICAgLy8gICAgICAgICB0ZXN0OiBJZGVudGlmaWVyKEYpLFxuICAgIC8vICAgICAgICAgY29uc2VxdWVudDogSWRlbnRpZmllcihHKSxcbiAgICAvLyAgICAgICAgIGFsdGVybmF0ZTogSWRlbnRpZmllcihIKSxcbiAgICAvLyAgICAgICB9LFxuICAgIC8vICAgICAgIGFsdGVybmF0ZTogSWRlbnRpZmllcihJKSxcbiAgICAvLyAgICAgfVxuICAgIC8vICAgfVxuICAgIC8vIH1cbiAgICAvL1xuICAgIC8vIHdlIHNob3VsZCByZXR1cm4gdGhpcyBBcnJheTpcbiAgICAvL1xuICAgIC8vIFtcbiAgICAvLyAgIElkZW50aWZpZXIoQSksXG4gICAgLy8gICBJZGVudGlmaWVyKEIpLFxuICAgIC8vICAgSWRlbnRpZmllcihDKSxcbiAgICAvLyAgIElkZW50aWZpZXIoRCksXG4gICAgLy8gICBJZGVudGlmaWVyKEUpLFxuICAgIC8vICAgSWRlbnRpZmllcihGKSxcbiAgICAvLyAgIElkZW50aWZpZXIoRyksXG4gICAgLy8gICBJZGVudGlmaWVyKEgpLFxuICAgIC8vICAgSWRlbnRpZmllcihJKVxuICAgIC8vIF07XG4gICAgLy9cbiAgICAvLyBUaGlzIGxvc2VzIHRoZSBpbmZvcm1hdGlvbiBhYm91dCB3aGV0aGVyIGVhY2ggbm9kZSB3YXMgdGhlIHRlc3QsXG4gICAgLy8gY29uc2VxdWVudCwgb3IgYWx0ZXJuYXRlLCBidXQgd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGF0IGhlcmUtIHdlIGFyZSBvbmx5XG4gICAgLy8gZmxhdHRlbmluZyB0aGlzIHN0cnVjdHVyZSB0byBmaW5kIGlmIHRoZXJlJ3MgYW55IEpTWEVsZW1lbnRzIGluc2lkZS5cbiAgICB2YXIgbm9uQ29uZGl0aW9uYWxFeHByZXNzaW9ucyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gcmVjdXJzZShub2RlKSB7XG4gICAgICBpZiAobm9kZS50eXBlID09PSBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIHJlY3Vyc2Uobm9kZS50ZXN0KTtcbiAgICAgICAgcmVjdXJzZShub2RlLmNvbnNlcXVlbnQpO1xuICAgICAgICByZWN1cnNlKG5vZGUuYWx0ZXJuYXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vbkNvbmRpdGlvbmFsRXhwcmVzc2lvbnMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZWN1cnNlKG5vZGUpO1xuICAgIHJldHVybiBub25Db25kaXRpb25hbEV4cHJlc3Npb25zO1xuICB9XG5cbiAgZnVuY3Rpb24gY29uZGl0aW9uYWxFeHByZXNzaW9uQ2hhaW5Db250YWluc0pTWChub2RlKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oZ2V0Q29uZGl0aW9uYWxDaGFpbkNvbnRlbnRzKG5vZGUpLmZpbmQoaXNKU1hOb2RlKSk7XG4gIH0gLy8gTG9naWMgdG8gY2hlY2sgZm9yIGFyZ3Mgd2l0aCBtdWx0aXBsZSBhbm9ueW1vdXMgZnVuY3Rpb25zLiBGb3IgaW5zdGFuY2UsXG4gIC8vIHRoZSBmb2xsb3dpbmcgY2FsbCBzaG91bGQgYmUgc3BsaXQgb24gbXVsdGlwbGUgbGluZXMgZm9yIHJlYWRhYmlsaXR5OlxuICAvLyBzb3VyY2UucGlwZShtYXAoKHgpID0+IHggKyB4KSwgZmlsdGVyKCh4KSA9PiB4ICUgMiA9PT0gMCkpXG5cblxuICBmdW5jdGlvbiBpc0Z1bmN0aW9uQ29tcG9zaXRpb25BcmdzKGFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBhcmdzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICB2YXIgYXJnID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgaWYgKGlzRnVuY3Rpb25PckFycm93RXhwcmVzc2lvbihhcmcpKSB7XG4gICAgICAgICAgY291bnQgKz0gMTtcblxuICAgICAgICAgIGlmIChjb3VudCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc0NhbGxPck9wdGlvbmFsQ2FsbEV4cHJlc3Npb24oYXJnKSkge1xuICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuICAgICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IGFyZy5hcmd1bWVudHNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcbiAgICAgICAgICAgICAgdmFyIGNoaWxkQXJnID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uT3JBcnJvd0V4cHJlc3Npb24oY2hpbGRBcmcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBMb2dpYyB0byBkZXRlcm1pbmUgaWYgYSBjYWxsIGlzIGEg4oCcbG9uZyBjdXJyaWVkIGZ1bmN0aW9uIGNhbGzigJ0uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJldHRpZXIvcHJldHRpZXIvaXNzdWVzLzE0MjAuXG4gIC8vXG4gIC8vIGBjb25uZWN0KGEsIGIsIGMpKGQpYFxuICAvLyBJbiB0aGUgYWJvdmUgY2FsbCBleHByZXNzaW9uLCB0aGUgc2Vjb25kIGNhbGwgaXMgdGhlIHBhcmVudCBub2RlIGFuZCB0aGVcbiAgLy8gZmlyc3QgY2FsbCBpcyB0aGUgY3VycmVudCBub2RlLlxuXG5cbiAgZnVuY3Rpb24gaXNMb25nQ3VycmllZENhbGxFeHByZXNzaW9uKHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICB2YXIgcGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG4gICAgcmV0dXJuIGlzQ2FsbE9yT3B0aW9uYWxDYWxsRXhwcmVzc2lvbihub2RlKSAmJiBpc0NhbGxPck9wdGlvbmFsQ2FsbEV4cHJlc3Npb24ocGFyZW50KSAmJiBwYXJlbnQuY2FsbGVlID09PSBub2RlICYmIG5vZGUuYXJndW1lbnRzLmxlbmd0aCA+IHBhcmVudC5hcmd1bWVudHMubGVuZ3RoICYmIHBhcmVudC5hcmd1bWVudHMubGVuZ3RoID4gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJhd1RleHQobm9kZSkge1xuICAgIHJldHVybiBub2RlLmV4dHJhID8gbm9kZS5leHRyYS5yYXcgOiBub2RlLnJhdztcbiAgfVxuXG4gIGZ1bmN0aW9uIGlkZW50aXR5JDEoeCkge1xuICAgIHJldHVybiB4O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNUU1hGaWxlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5maWxlcGF0aCAmJiAvXFwudHN4JC9pLnRlc3Qob3B0aW9ucy5maWxlcGF0aCk7XG4gIH1cblxuICB2YXIgdXRpbHMkNCA9IHtcbiAgICBjbGFzc0NoaWxkTmVlZHNBU0lQcm90ZWN0aW9uOiBjbGFzc0NoaWxkTmVlZHNBU0lQcm90ZWN0aW9uLFxuICAgIGNsYXNzUHJvcE1heUNhdXNlQVNJUHJvYmxlbXM6IGNsYXNzUHJvcE1heUNhdXNlQVNJUHJvYmxlbXMsXG4gICAgY29uZGl0aW9uYWxFeHByZXNzaW9uQ2hhaW5Db250YWluc0pTWDogY29uZGl0aW9uYWxFeHByZXNzaW9uQ2hhaW5Db250YWluc0pTWCxcbiAgICBnZXRGbG93VmFyaWFuY2U6IGdldEZsb3dWYXJpYW5jZSxcbiAgICBnZXRMZWZ0U2lkZVBhdGhOYW1lOiBnZXRMZWZ0U2lkZVBhdGhOYW1lLFxuICAgIGdldFR5cGVTY3JpcHRNYXBwZWRUeXBlTW9kaWZpZXI6IGdldFR5cGVTY3JpcHRNYXBwZWRUeXBlTW9kaWZpZXIsXG4gICAgaGFzRGFuZ2xpbmdDb21tZW50czogaGFzRGFuZ2xpbmdDb21tZW50cyxcbiAgICBoYXNGbG93QW5ub3RhdGlvbkNvbW1lbnQ6IGhhc0Zsb3dBbm5vdGF0aW9uQ29tbWVudCxcbiAgICBoYXNGbG93U2hvcnRoYW5kQW5ub3RhdGlvbkNvbW1lbnQ6IGhhc0Zsb3dTaG9ydGhhbmRBbm5vdGF0aW9uQ29tbWVudCxcbiAgICBoYXNMZWFkaW5nQ29tbWVudDogaGFzTGVhZGluZ0NvbW1lbnQkMixcbiAgICBoYXNMZWFkaW5nT3duTGluZUNvbW1lbnQ6IGhhc0xlYWRpbmdPd25MaW5lQ29tbWVudCxcbiAgICBoYXNOYWtlZExlZnRTaWRlOiBoYXNOYWtlZExlZnRTaWRlLFxuICAgIGhhc05ld2xpbmVCZXR3ZWVuT3JBZnRlckRlY29yYXRvcnM6IGhhc05ld2xpbmVCZXR3ZWVuT3JBZnRlckRlY29yYXRvcnMsXG4gICAgaGFzTmdTaWRlRWZmZWN0OiBoYXNOZ1NpZGVFZmZlY3QsXG4gICAgaGFzTm9kZTogaGFzTm9kZSxcbiAgICBoYXNQcmV0dGllcklnbm9yZTogaGFzUHJldHRpZXJJZ25vcmUkMixcbiAgICBoYXNUcmFpbGluZ0NvbW1lbnQ6IGhhc1RyYWlsaW5nQ29tbWVudCxcbiAgICBpZGVudGl0eTogaWRlbnRpdHkkMSxcbiAgICBpc0JpbmFyeWlzaDogaXNCaW5hcnlpc2gsXG4gICAgaXNDYWxsT3JPcHRpb25hbENhbGxFeHByZXNzaW9uOiBpc0NhbGxPck9wdGlvbmFsQ2FsbEV4cHJlc3Npb24sXG4gICAgaXNFbXB0eUpTWEVsZW1lbnQ6IGlzRW1wdHlKU1hFbGVtZW50LFxuICAgIGlzRmxvd0Fubm90YXRpb25Db21tZW50OiBpc0Zsb3dBbm5vdGF0aW9uQ29tbWVudCxcbiAgICBpc0Z1bmN0aW9uQ29tcG9zaXRpb25BcmdzOiBpc0Z1bmN0aW9uQ29tcG9zaXRpb25BcmdzLFxuICAgIGlzRnVuY3Rpb25Ob3RhdGlvbjogaXNGdW5jdGlvbk5vdGF0aW9uLFxuICAgIGlzRnVuY3Rpb25PckFycm93RXhwcmVzc2lvbjogaXNGdW5jdGlvbk9yQXJyb3dFeHByZXNzaW9uLFxuICAgIGlzR2V0dGVyT3JTZXR0ZXI6IGlzR2V0dGVyT3JTZXR0ZXIsXG4gICAgaXNKZXN0RWFjaFRlbXBsYXRlTGl0ZXJhbDogaXNKZXN0RWFjaFRlbXBsYXRlTGl0ZXJhbCxcbiAgICBpc0pTWE5vZGU6IGlzSlNYTm9kZSxcbiAgICBpc0pTWFdoaXRlc3BhY2VFeHByZXNzaW9uOiBpc0pTWFdoaXRlc3BhY2VFeHByZXNzaW9uLFxuICAgIGlzTGFzdFN0YXRlbWVudDogaXNMYXN0U3RhdGVtZW50LFxuICAgIGlzTGl0ZXJhbDogaXNMaXRlcmFsLFxuICAgIGlzTG9uZ0N1cnJpZWRDYWxsRXhwcmVzc2lvbjogaXNMb25nQ3VycmllZENhbGxFeHByZXNzaW9uLFxuICAgIGlzTWVhbmluZ2Z1bEpTWFRleHQ6IGlzTWVhbmluZ2Z1bEpTWFRleHQsXG4gICAgaXNNZW1iZXJFeHByZXNzaW9uQ2hhaW46IGlzTWVtYmVyRXhwcmVzc2lvbkNoYWluLFxuICAgIGlzTWVtYmVyaXNoOiBpc01lbWJlcmlzaCxcbiAgICBpc05nRm9yT2Y6IGlzTmdGb3JPZixcbiAgICBpc051bWVyaWNMaXRlcmFsOiBpc051bWVyaWNMaXRlcmFsLFxuICAgIGlzT2JqZWN0VHlwZTogaXNPYmplY3RUeXBlLFxuICAgIGlzT2JqZWN0VHlwZVByb3BlcnR5QUZ1bmN0aW9uOiBpc09iamVjdFR5cGVQcm9wZXJ0eUFGdW5jdGlvbixcbiAgICBpc1NpbXBsZUZsb3dUeXBlOiBpc1NpbXBsZUZsb3dUeXBlLFxuICAgIGlzU2ltcGxlVGVtcGxhdGVMaXRlcmFsOiBpc1NpbXBsZVRlbXBsYXRlTGl0ZXJhbCxcbiAgICBpc1N0cmluZ0xpdGVyYWw6IGlzU3RyaW5nTGl0ZXJhbCxcbiAgICBpc1N0cmluZ1Byb3BTYWZlVG9Db2VyY2VUb0lkZW50aWZpZXI6IGlzU3RyaW5nUHJvcFNhZmVUb0NvZXJjZVRvSWRlbnRpZmllcixcbiAgICBpc1RlbXBsYXRlT25JdHNPd25MaW5lOiBpc1RlbXBsYXRlT25JdHNPd25MaW5lLFxuICAgIGlzVGVzdENhbGw6IGlzVGVzdENhbGwsXG4gICAgaXNUaGVPbmx5SlNYRWxlbWVudEluTWFya2Rvd246IGlzVGhlT25seUpTWEVsZW1lbnRJbk1hcmtkb3duLFxuICAgIGlzVFNYRmlsZTogaXNUU1hGaWxlLFxuICAgIGlzVHlwZUFubm90YXRpb25BRnVuY3Rpb246IGlzVHlwZUFubm90YXRpb25BRnVuY3Rpb24sXG4gICAgbWF0Y2hKc3hXaGl0ZXNwYWNlUmVnZXg6IG1hdGNoSnN4V2hpdGVzcGFjZVJlZ2V4LFxuICAgIG5lZWRzSGFyZGxpbmVBZnRlckRhbmdsaW5nQ29tbWVudDogbmVlZHNIYXJkbGluZUFmdGVyRGFuZ2xpbmdDb21tZW50LFxuICAgIHJhd1RleHQ6IHJhd1RleHQsXG4gICAgcmV0dXJuQXJndW1lbnRIYXNMZWFkaW5nQ29tbWVudDogcmV0dXJuQXJndW1lbnRIYXNMZWFkaW5nQ29tbWVudFxuICB9O1xuXG4gIHZhciBnZXRMZWZ0U2lkZVBhdGhOYW1lJDEgPSB1dGlscyQ0LmdldExlZnRTaWRlUGF0aE5hbWUsXG4gICAgICBoYXNGbG93U2hvcnRoYW5kQW5ub3RhdGlvbkNvbW1lbnQkMSA9IHV0aWxzJDQuaGFzRmxvd1Nob3J0aGFuZEFubm90YXRpb25Db21tZW50LFxuICAgICAgaGFzTmFrZWRMZWZ0U2lkZSQxID0gdXRpbHMkNC5oYXNOYWtlZExlZnRTaWRlLFxuICAgICAgaGFzTm9kZSQxID0gdXRpbHMkNC5oYXNOb2RlO1xuXG4gIGZ1bmN0aW9uIGhhc0Nsb3N1cmVDb21waWxlclR5cGVDYXN0Q29tbWVudCh0ZXh0LCBwYXRoKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWNvbXBpbGVyL3dpa2kvQW5ub3RhdGluZy1UeXBlcyN0eXBlLWNhc3RzXG4gICAgLy8gU3ludGF4IGV4YW1wbGU6IHZhciB4ID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChmcnVpdCk7XG4gICAgdmFyIG4gPSBwYXRoLmdldFZhbHVlKCk7XG4gICAgcmV0dXJuIGlzUGFyZW50aGVzaXplZChuKSAmJiAoaGFzVHlwZUNhc3RDb21tZW50KG4pIHx8IGhhc0FuY2VzdG9yVHlwZUNhc3RDb21tZW50KDApKTsgLy8gZm9yIHN1Yi1pdGVtOiAvKiogQHR5cGUge2FycmF5fSAqLyAobnVtYmVyT3JTdHJpbmcpLm1hcCh4ID0+IHgpO1xuXG4gICAgZnVuY3Rpb24gaGFzQW5jZXN0b3JUeXBlQ2FzdENvbW1lbnQoaW5kZXgpIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IHBhdGguZ2V0UGFyZW50Tm9kZShpbmRleCk7XG4gICAgICByZXR1cm4gYW5jZXN0b3IgJiYgIWlzUGFyZW50aGVzaXplZChhbmNlc3RvcikgPyBoYXNUeXBlQ2FzdENvbW1lbnQoYW5jZXN0b3IpIHx8IGhhc0FuY2VzdG9yVHlwZUNhc3RDb21tZW50KGluZGV4ICsgMSkgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNUeXBlQ2FzdENvbW1lbnQobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuY29tbWVudHMgJiYgbm9kZS5jb21tZW50cy5zb21lKGZ1bmN0aW9uIChjb21tZW50KSB7XG4gICAgICAgIHJldHVybiBjb21tZW50LmxlYWRpbmcgJiYgY29tbWVudHMkMS5pc0Jsb2NrQ29tbWVudChjb21tZW50KSAmJiBpc1R5cGVDYXN0Q29tbWVudChjb21tZW50LnZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUGFyZW50aGVzaXplZChub2RlKSB7XG4gICAgICAvLyBDbG9zdXJlIHR5cGVjYXN0IGNvbW1lbnRzIG9ubHkgcmVhbGx5IG1ha2Ugc2Vuc2Ugd2hlbiBfbm90XyB1c2luZ1xuICAgICAgLy8gdHlwZXNjcmlwdCBvciBmbG93IHBhcnNlcnMsIHNvIHdlIHRha2UgYWR2YW50YWdlIG9mIHRoZSBiYWJlbCBwYXJzZXInc1xuICAgICAgLy8gcGFyZW50aGVzaXplZCBleHByZXNzaW9ucy5cbiAgICAgIHJldHVybiBub2RlLmV4dHJhICYmIG5vZGUuZXh0cmEucGFyZW50aGVzaXplZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1R5cGVDYXN0Q29tbWVudChjb21tZW50KSB7XG4gICAgICB2YXIgY2xlYW5lZCA9IGNvbW1lbnQudHJpbSgpLnNwbGl0KFwiXFxuXCIpLm1hcChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICByZXR1cm4gbGluZS5yZXBsYWNlKC9eW1xccypdKy8sIFwiXCIpO1xuICAgICAgfSkuam9pbihcIiBcIikudHJpbSgpO1xuXG4gICAgICBpZiAoIS9eQHR5cGVcXHMqXFx7W15dK1xcfSQvLnRlc3QoY2xlYW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNDb21wbGV0ZWx5Q2xvc2VkID0gZmFsc2U7XG4gICAgICB2YXIgdW5wYWlyZWRCcmFja2V0Q291bnQgPSAwO1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGNsZWFuZWRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGNoYXIgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIGlmIChjaGFyID09PSBcIntcIikge1xuICAgICAgICAgICAgaWYgKGlzQ29tcGxldGVseUNsb3NlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVucGFpcmVkQnJhY2tldENvdW50Kys7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSBcIn1cIikge1xuICAgICAgICAgICAgaWYgKHVucGFpcmVkQnJhY2tldENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdW5wYWlyZWRCcmFja2V0Q291bnQtLTtcblxuICAgICAgICAgICAgaWYgKHVucGFpcmVkQnJhY2tldENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgIGlzQ29tcGxldGVseUNsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5wYWlyZWRCcmFja2V0Q291bnQgPT09IDA7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbmVlZHNQYXJlbnMocGF0aCwgb3B0aW9ucykge1xuICAgIHZhciBwYXJlbnQgPSBwYXRoLmdldFBhcmVudE5vZGUoKTtcblxuICAgIGlmICghcGFyZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSBwYXRoLmdldE5hbWUoKTtcbiAgICB2YXIgbm9kZSA9IHBhdGguZ2V0Tm9kZSgpOyAvLyBJZiB0aGUgdmFsdWUgb2YgdGhpcyBwYXRoIGlzIHNvbWUgY2hpbGQgb2YgYSBOb2RlIGFuZCBub3QgYSBOb2RlXG4gICAgLy8gaXRzZWxmLCB0aGVuIGl0IGRvZXNuJ3QgbmVlZCBwYXJlbnRoZXNlcy4gT25seSBOb2RlIG9iamVjdHMgKGluXG4gICAgLy8gZmFjdCwgb25seSBFeHByZXNzaW9uIG5vZGVzKSBuZWVkIHBhcmVudGhlc2VzLlxuXG4gICAgaWYgKHBhdGguZ2V0VmFsdWUoKSAhPT0gbm9kZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gdG8gYXZvaWQgdW5leHBlY3RlZCBgfX1gIGluIEhUTUwgaW50ZXJwb2xhdGlvbnNcblxuXG4gICAgaWYgKG9wdGlvbnMuX19pc0luSHRtbEludGVycG9sYXRpb24gJiYgIW9wdGlvbnMuYnJhY2tldFNwYWNpbmcgJiYgZW5kc1dpdGhSaWdodEJyYWNrZXQobm9kZSkgJiYgaXNGb2xsb3dlZEJ5UmlnaHRCcmFja2V0KHBhdGgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIE9ubHkgc3RhdGVtZW50cyBkb24ndCBuZWVkIHBhcmVudGhlc2VzLlxuXG5cbiAgICBpZiAoaXNTdGF0ZW1lbnQobm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIENsb3N1cmUgY29tcGlsZXIgcmVxdWlyZXMgdGhhdCB0eXBlIGNhc3RlZCBleHByZXNzaW9ucyB0byBiZSBzdXJyb3VuZGVkIGJ5XG4gICAgLy8gcGFyZW50aGVzZXMuXG5cblxuICAgIGlmIChoYXNDbG9zdXJlQ29tcGlsZXJUeXBlQ2FzdENvbW1lbnQob3B0aW9ucy5vcmlnaW5hbFRleHQsIHBhdGgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIC8vIFByZXNlcnZlIHBhcmVucyBpZiB3ZSBoYXZlIGEgRmxvdyBhbm5vdGF0aW9uIGNvbW1lbnQsIHVubGVzcyB3ZSdyZSB1c2luZyB0aGUgRmxvd1xuICAgIC8vIHBhcnNlci4gVGhlIEZsb3cgcGFyc2VyIHR1cm5zIEZsb3cgY29tbWVudHMgaW50byB0eXBlIGFubm90YXRpb24gbm9kZXMgaW4gaXRzXG4gICAgLy8gQVNULCB3aGljaCB3ZSBoYW5kbGUgc2VwYXJhdGVseS5cbiAgICBvcHRpb25zLnBhcnNlciAhPT0gXCJmbG93XCIgJiYgaGFzRmxvd1Nob3J0aGFuZEFubm90YXRpb25Db21tZW50JDEocGF0aC5nZXRWYWx1ZSgpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBJZGVudGlmaWVycyBuZXZlciBuZWVkIHBhcmVudGhlc2VzLlxuXG5cbiAgICBpZiAobm9kZS50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgLy8gLi4udW5sZXNzIHRob3NlIGlkZW50aWZpZXJzIGFyZSBlbWJlZCBwbGFjZWhvbGRlcnMuIFRoZXkgbWlnaHQgYmUgc3Vic3RpdHV0ZWQgYnkgY29tcGxleFxuICAgICAgLy8gZXhwcmVzc2lvbnMsIHNvIHRoZSBwYXJlbnMgYXJvdW5kIHRoZW0gc2hvdWxkIG5vdCBiZSBkcm9wcGVkLiBFeGFtcGxlIChKUy1pbi1IVE1MLWluLUpTKTpcbiAgICAgIC8vICAgICBsZXQgdHBsID0gaHRtbGA8c2NyaXB0PiBmKCgke2V4cHJ9KSAvIDIpOyA8L3NjcmlwdD5gO1xuICAgICAgLy8gSWYgdGhlIGlubmVyIEpTIGZvcm1hdHRlciByZW1vdmVzIHRoZSBwYXJlbnMsIHRoZSBleHByZXNzaW9uIG1pZ2h0IGNoYW5nZSBpdHMgbWVhbmluZzpcbiAgICAgIC8vICAgICBmKChhICsgYikgLyAyKSAgdnMgIGYoYSArIGIgLyAyKVxuICAgICAgaWYgKG5vZGUuZXh0cmEgJiYgbm9kZS5leHRyYS5wYXJlbnRoZXNpemVkICYmIC9eUFJFVFRJRVJfSFRNTF9QTEFDRUhPTERFUl9cXGQrX1xcZCtfSU5fSlMkLy50ZXN0KG5vZGUubmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAocGFyZW50LnR5cGUgPT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gQWRkIHBhcmVucyBhcm91bmQgdGhlIGV4dGVuZHMgY2xhdXNlIG9mIGEgY2xhc3MuIEl0IGlzIG5lZWRlZCBmb3IgYWxtb3N0XG4gICAgLy8gYWxsIGV4cHJlc3Npb25zLlxuXG5cbiAgICBpZiAoKHBhcmVudC50eXBlID09PSBcIkNsYXNzRGVjbGFyYXRpb25cIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJDbGFzc0V4cHJlc3Npb25cIikgJiYgcGFyZW50LnN1cGVyQ2xhc3MgPT09IG5vZGUgJiYgKG5vZGUudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJBd2FpdEV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiQmluYXJ5RXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiTG9naWNhbEV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiTmV3RXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJPYmplY3RFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIlNlcXVlbmNlRXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiVW5hcnlFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIlVwZGF0ZUV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiWWllbGRFeHByZXNzaW9uXCIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIGBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbmAgb3IgYGV4cG9ydCBkZWZhdWx0IGNsYXNzYCBjYW4ndCBiZSBmb2xsb3dlZCBieVxuICAgIC8vIGFueXRoaW5nIGFmdGVyLiBTbyBhbiBleHByZXNzaW9uIGxpa2UgYGV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbigpe30pLnRvU3RyaW5nKClgXG4gICAgLy8gbmVlZHMgdG8gYmUgZm9sbG93ZWQgYnkgYSBwYXJlbnRoZXNlc1xuXG5cbiAgICBpZiAocGFyZW50LnR5cGUgPT09IFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIpIHtcbiAgICAgIHJldHVybiBzaG91bGRXcmFwRnVuY3Rpb25Gb3JFeHBvcnREZWZhdWx0KHBhdGgsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChwYXJlbnQudHlwZSA9PT0gXCJEZWNvcmF0b3JcIiAmJiBwYXJlbnQuZXhwcmVzc2lvbiA9PT0gbm9kZSkge1xuICAgICAgdmFyIGhhc0NhbGxFeHByZXNzaW9uID0gZmFsc2U7XG4gICAgICB2YXIgaGFzTWVtYmVyRXhwcmVzc2lvbiA9IGZhbHNlO1xuICAgICAgdmFyIGN1cnJlbnQgPSBub2RlO1xuXG4gICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICBzd2l0Y2ggKGN1cnJlbnQudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICBoYXNNZW1iZXJFeHByZXNzaW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm9iamVjdDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcIkNhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvKiogQCh4KCkueSkgKi9cbiAgICAgICAgICAgIGhhc01lbWJlckV4cHJlc3Npb24gfHxcbiAgICAgICAgICAgIC8qKiBAKHgoKS55KCkpICovXG4gICAgICAgICAgICBoYXNDYWxsRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGFzQ2FsbEV4cHJlc3Npb24gPSB0cnVlO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuY2FsbGVlO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChwYXJlbnQudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiICYmIHBhcmVudC5ib2R5ID09PSBub2RlICYmIG5vZGUudHlwZSAhPT0gXCJTZXF1ZW5jZUV4cHJlc3Npb25cIiAmJiAvLyB0aGVzZSBoYXZlIHBhcmVucyBhZGRlZCBhbnl3YXlcbiAgICB1dGlsLnN0YXJ0c1dpdGhOb0xvb2thaGVhZFRva2VuKG5vZGUsXG4gICAgLyogZm9yYmlkRnVuY3Rpb25DbGFzc0FuZERvRXhwciAqL1xuICAgIGZhbHNlKSB8fCBwYXJlbnQudHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgJiYgdXRpbC5zdGFydHNXaXRoTm9Mb29rYWhlYWRUb2tlbihub2RlLFxuICAgIC8qIGZvcmJpZEZ1bmN0aW9uQ2xhc3NBbmREb0V4cHIgKi9cbiAgICB0cnVlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJTcHJlYWRFbGVtZW50XCI6XG4gICAgICBjYXNlIFwiU3ByZWFkUHJvcGVydHlcIjpcbiAgICAgICAgcmV0dXJuIHBhcmVudC50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiAmJiBuYW1lID09PSBcIm9iamVjdFwiICYmIHBhcmVudC5vYmplY3QgPT09IG5vZGU7XG5cbiAgICAgIGNhc2UgXCJVcGRhdGVFeHByZXNzaW9uXCI6XG4gICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gXCJVbmFyeUV4cHJlc3Npb25cIikge1xuICAgICAgICAgIHJldHVybiBub2RlLnByZWZpeCAmJiAobm9kZS5vcGVyYXRvciA9PT0gXCIrK1wiICYmIHBhcmVudC5vcGVyYXRvciA9PT0gXCIrXCIgfHwgbm9kZS5vcGVyYXRvciA9PT0gXCItLVwiICYmIHBhcmVudC5vcGVyYXRvciA9PT0gXCItXCIpO1xuICAgICAgICB9XG5cbiAgICAgIC8vIGVsc2UgZmFsbHRocm91Z2hcblxuICAgICAgY2FzZSBcIlVuYXJ5RXhwcmVzc2lvblwiOlxuICAgICAgICBzd2l0Y2ggKHBhcmVudC50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIlVuYXJ5RXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgcmV0dXJuIG5vZGUub3BlcmF0b3IgPT09IHBhcmVudC5vcGVyYXRvciAmJiAobm9kZS5vcGVyYXRvciA9PT0gXCIrXCIgfHwgbm9kZS5vcGVyYXRvciA9PT0gXCItXCIpO1xuXG4gICAgICAgICAgY2FzZSBcIkJpbmRFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09IFwib2JqZWN0XCI7XG5cbiAgICAgICAgICBjYXNlIFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgIGNhc2UgXCJOZXdFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIkNhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgIHJldHVybiBuYW1lID09PSBcImNhbGxlZVwiO1xuXG4gICAgICAgICAgY2FzZSBcIkJpbmFyeUV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQub3BlcmF0b3IgPT09IFwiKipcIiAmJiBuYW1lID09PSBcImxlZnRcIjtcblxuICAgICAgICAgIGNhc2UgXCJUU05vbk51bGxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIkJpbmFyeUV4cHJlc3Npb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gXCJVcGRhdGVFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpc0xlZnRPZkFGb3JTdGF0ZW1lbnQgPSBmdW5jdGlvbiBpc0xlZnRPZkFGb3JTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgICB2YXIgX3BhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZShpKyspO1xuXG4gICAgICAgICAgICAgIGlmICghX3BhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChfcGFyZW50LnR5cGUgPT09IFwiRm9yU3RhdGVtZW50XCIgJiYgX3BhcmVudC5pbml0ID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBub2RlID0gX3BhcmVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAobm9kZS5vcGVyYXRvciA9PT0gXCJpblwiICYmIGlzTGVmdE9mQUZvclN0YXRlbWVudChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAvLyBmYWxsdGhyb3VnaFxuXG4gICAgICBjYXNlIFwiVFNUeXBlQXNzZXJ0aW9uXCI6XG4gICAgICBjYXNlIFwiVFNBc0V4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJMb2dpY2FsRXhwcmVzc2lvblwiOlxuICAgICAgICBzd2l0Y2ggKHBhcmVudC50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJUU0FzRXhwcmVzc2lvblwiO1xuXG4gICAgICAgICAgY2FzZSBcIkNhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIk5ld0V4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09IFwiY2FsbGVlXCI7XG5cbiAgICAgICAgICBjYXNlIFwiQ2xhc3NFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIkNsYXNzRGVjbGFyYXRpb25cIjpcbiAgICAgICAgICAgIHJldHVybiBuYW1lID09PSBcInN1cGVyQ2xhc3NcIiAmJiBwYXJlbnQuc3VwZXJDbGFzcyA9PT0gbm9kZTtcblxuICAgICAgICAgIGNhc2UgXCJUU1R5cGVBc3NlcnRpb25cIjpcbiAgICAgICAgICBjYXNlIFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIlVuYXJ5RXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJKU1hTcHJlYWRBdHRyaWJ1dGVcIjpcbiAgICAgICAgICBjYXNlIFwiU3ByZWFkRWxlbWVudFwiOlxuICAgICAgICAgIGNhc2UgXCJTcHJlYWRQcm9wZXJ0eVwiOlxuICAgICAgICAgIGNhc2UgXCJCaW5kRXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJBd2FpdEV4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiVFNBc0V4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiVFNOb25OdWxsRXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJVcGRhdGVFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09IFwib2JqZWN0XCI7XG5cbiAgICAgICAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQubGVmdCA9PT0gbm9kZSAmJiAobm9kZS50eXBlID09PSBcIlRTVHlwZUFzc2VydGlvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJUU0FzRXhwcmVzc2lvblwiKTtcblxuICAgICAgICAgIGNhc2UgXCJMb2dpY2FsRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJMb2dpY2FsRXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJlbnQub3BlcmF0b3IgIT09IG5vZGUub3BlcmF0b3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBlbHNlIGZhbGx0aHJvdWdoXG5cbiAgICAgICAgICBjYXNlIFwiQmluYXJ5RXhwcmVzc2lvblwiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoIW5vZGUub3BlcmF0b3IgJiYgbm9kZS50eXBlICE9PSBcIlRTVHlwZUFzc2VydGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgcG8gPSBwYXJlbnQub3BlcmF0b3I7XG4gICAgICAgICAgICAgIHZhciBwcCA9IHV0aWwuZ2V0UHJlY2VkZW5jZShwbyk7XG4gICAgICAgICAgICAgIHZhciBubyA9IG5vZGUub3BlcmF0b3I7XG4gICAgICAgICAgICAgIHZhciBucCA9IHV0aWwuZ2V0UHJlY2VkZW5jZShubyk7XG5cbiAgICAgICAgICAgICAgaWYgKHBwID4gbnApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChwcCA9PT0gbnAgJiYgbmFtZSA9PT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKHBhcmVudC5yaWdodCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAocHAgPT09IG5wICYmICF1dGlsLnNob3VsZEZsYXR0ZW4ocG8sIG5vKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHBwIDwgbnAgJiYgbm8gPT09IFwiJVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvID09PSBcIitcIiB8fCBwbyA9PT0gXCItXCI7XG4gICAgICAgICAgICAgIH0gLy8gQWRkIHBhcmVudGhlc2lzIHdoZW4gd29ya2luZyB3aXRoIGJpdHdpc2Ugb3BlcmF0b3JzXG4gICAgICAgICAgICAgIC8vIEl0J3Mgbm90IHN0cmljdGx5IG5lZWRlZCBidXQgaGVscHMgd2l0aCBjb2RlIHVuZGVyc3RhbmRpbmdcblxuXG4gICAgICAgICAgICAgIGlmICh1dGlsLmlzQml0d2lzZU9wZXJhdG9yKHBvKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiU2VxdWVuY2VFeHByZXNzaW9uXCI6XG4gICAgICAgIHN3aXRjaCAocGFyZW50LnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiUmV0dXJuU3RhdGVtZW50XCI6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICBjYXNlIFwiRm9yU3RhdGVtZW50XCI6XG4gICAgICAgICAgICAvLyBBbHRob3VnaCBwYXJlbnRoZXNlcyB3b3VsZG4ndCBodXJ0IGFyb3VuZCBzZXF1ZW5jZVxuICAgICAgICAgICAgLy8gZXhwcmVzc2lvbnMgaW4gdGhlIGhlYWQgb2YgZm9yIGxvb3BzLCB0cmFkaXRpb25hbCBzdHlsZVxuICAgICAgICAgICAgLy8gZGljdGF0ZXMgdGhhdCBlLmcuIGkrKywgaisrIHNob3VsZCBub3QgYmUgd3JhcHBlZCB3aXRoXG4gICAgICAgICAgICAvLyBwYXJlbnRoZXNlcy5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgIGNhc2UgXCJFeHByZXNzaW9uU3RhdGVtZW50XCI6XG4gICAgICAgICAgICByZXR1cm4gbmFtZSAhPT0gXCJleHByZXNzaW9uXCI7XG5cbiAgICAgICAgICBjYXNlIFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgIC8vIFdlIGRvIG5lZWQgcGFyZW50aGVzZXMsIGJ1dCBTZXF1ZW5jZUV4cHJlc3Npb25zIGFyZSBoYW5kbGVkXG4gICAgICAgICAgICAvLyBzcGVjaWFsbHkgd2hlbiBwcmludGluZyBib2RpZXMgb2YgYXJyb3cgZnVuY3Rpb25zLlxuICAgICAgICAgICAgcmV0dXJuIG5hbWUgIT09IFwiYm9keVwiO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBlcnIgb24gdGhlIHNpZGUgb2Ygb3ZlcnBhcmVudGhlc2l6YXRpb24sIGFkZGluZ1xuICAgICAgICAgICAgLy8gZXhwbGljaXQgZXhjZXB0aW9ucyBhYm92ZSBpZiB0aGlzIHByb3ZlcyBvdmVyemVhbG91cy5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJZaWVsZEV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSBcIlVuYXJ5RXhwcmVzc2lvblwiIHx8IHBhcmVudC50eXBlID09PSBcIkF3YWl0RXhwcmVzc2lvblwiIHx8IHBhcmVudC50eXBlID09PSBcIlRTQXNFeHByZXNzaW9uXCIgfHwgcGFyZW50LnR5cGUgPT09IFwiVFNOb25OdWxsRXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgLy8gZWxzZSBmYWxsdGhyb3VnaFxuXG4gICAgICBjYXNlIFwiQXdhaXRFeHByZXNzaW9uXCI6XG4gICAgICAgIHN3aXRjaCAocGFyZW50LnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIlVuYXJ5RXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJCaW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIkxvZ2ljYWxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIlNwcmVhZEVsZW1lbnRcIjpcbiAgICAgICAgICBjYXNlIFwiU3ByZWFkUHJvcGVydHlcIjpcbiAgICAgICAgICBjYXNlIFwiVFNBc0V4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiVFNOb25OdWxsRXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJCaW5kRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgIHJldHVybiBuYW1lID09PSBcIm9iamVjdFwiO1xuXG4gICAgICAgICAgY2FzZSBcIk5ld0V4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiQ2FsbEV4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09IFwiY2FsbGVlXCI7XG5cbiAgICAgICAgICBjYXNlIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50LnRlc3QgPT09IG5vZGU7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJUU0NvbmRpdGlvbmFsVHlwZVwiOlxuICAgICAgICBpZiAocGFyZW50LnR5cGUgPT09IFwiVFNDb25kaXRpb25hbFR5cGVcIiAmJiBub2RlID09PSBwYXJlbnQuZXh0ZW5kc1R5cGUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAvLyBmYWxsdGhyb3VnaFxuXG4gICAgICBjYXNlIFwiVFNGdW5jdGlvblR5cGVcIjpcbiAgICAgIGNhc2UgXCJUU0NvbnN0cnVjdG9yVHlwZVwiOlxuICAgICAgICBpZiAocGFyZW50LnR5cGUgPT09IFwiVFNDb25kaXRpb25hbFR5cGVcIiAmJiBub2RlID09PSBwYXJlbnQuY2hlY2tUeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgLy8gZmFsbHRocm91Z2hcblxuICAgICAgY2FzZSBcIlRTVW5pb25UeXBlXCI6XG4gICAgICBjYXNlIFwiVFNJbnRlcnNlY3Rpb25UeXBlXCI6XG4gICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gXCJUU1VuaW9uVHlwZVwiIHx8IHBhcmVudC50eXBlID09PSBcIlRTSW50ZXJzZWN0aW9uVHlwZVwiKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgLy8gZmFsbHRocm91Z2hcblxuICAgICAgY2FzZSBcIlRTVHlwZU9wZXJhdG9yXCI6XG4gICAgICBjYXNlIFwiVFNJbmZlclR5cGVcIjpcbiAgICAgICAgcmV0dXJuIHBhcmVudC50eXBlID09PSBcIlRTQXJyYXlUeXBlXCIgfHwgcGFyZW50LnR5cGUgPT09IFwiVFNPcHRpb25hbFR5cGVcIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJUU1Jlc3RUeXBlXCIgfHwgcGFyZW50LnR5cGUgPT09IFwiVFNJbmRleGVkQWNjZXNzVHlwZVwiICYmIG5vZGUgPT09IHBhcmVudC5vYmplY3RUeXBlIHx8IHBhcmVudC50eXBlID09PSBcIlRTVHlwZU9wZXJhdG9yXCI7XG5cbiAgICAgIGNhc2UgXCJBcnJheVR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICAgIHJldHVybiBwYXJlbnQudHlwZSA9PT0gXCJOdWxsYWJsZVR5cGVBbm5vdGF0aW9uXCI7XG5cbiAgICAgIGNhc2UgXCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwiOlxuICAgICAgY2FzZSBcIlVuaW9uVHlwZUFubm90YXRpb25cIjpcbiAgICAgICAgcmV0dXJuIHBhcmVudC50eXBlID09PSBcIkFycmF5VHlwZUFubm90YXRpb25cIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJOdWxsYWJsZVR5cGVBbm5vdGF0aW9uXCIgfHwgcGFyZW50LnR5cGUgPT09IFwiSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb25cIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJVbmlvblR5cGVBbm5vdGF0aW9uXCI7XG5cbiAgICAgIGNhc2UgXCJOdWxsYWJsZVR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICAgIHJldHVybiBwYXJlbnQudHlwZSA9PT0gXCJBcnJheVR5cGVBbm5vdGF0aW9uXCI7XG5cbiAgICAgIGNhc2UgXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSBwYXJlbnQudHlwZSA9PT0gXCJOdWxsYWJsZVR5cGVBbm5vdGF0aW9uXCIgPyBwYXRoLmdldFBhcmVudE5vZGUoMSkgOiBwYXJlbnQ7XG4gICAgICAgICAgcmV0dXJuIGFuY2VzdG9yLnR5cGUgPT09IFwiVW5pb25UeXBlQW5ub3RhdGlvblwiIHx8IGFuY2VzdG9yLnR5cGUgPT09IFwiSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb25cIiB8fCBhbmNlc3Rvci50eXBlID09PSBcIkFycmF5VHlwZUFubm90YXRpb25cIiB8fCAvLyBXZSBzaG91bGQgY2hlY2sgYW5jZXN0b3IncyBwYXJlbnQgdG8ga25vdyB3aGV0aGVyIHRoZSBwYXJlbnRoZXNlc1xuICAgICAgICAgIC8vIGFyZSByZWFsbHkgbmVlZGVkLCBidXQgc2luY2UgPz9UIGRvZXNuJ3QgbWFrZSBzZW5zZSB0aGlzIGNoZWNrXG4gICAgICAgICAgLy8gd2lsbCBhbG1vc3QgbmV2ZXIgYmUgdHJ1ZS5cbiAgICAgICAgICBhbmNlc3Rvci50eXBlID09PSBcIk51bGxhYmxlVHlwZUFubm90YXRpb25cIjtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiU3RyaW5nTGl0ZXJhbFwiOlxuICAgICAgY2FzZSBcIk51bWVyaWNMaXRlcmFsXCI6XG4gICAgICBjYXNlIFwiTGl0ZXJhbFwiOlxuICAgICAgICBpZiAodHlwZW9mIG5vZGUudmFsdWUgPT09IFwic3RyaW5nXCIgJiYgcGFyZW50LnR5cGUgPT09IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiICYmICggLy8gVHlwZVNjcmlwdCB3b3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vSmFtZXNIZW5yeS90eXBlc2NyaXB0LWVzdHJlZS9pc3N1ZXMvMlxuICAgICAgICAvLyBTZWUgY29ycmVzcG9uZGluZyB3b3JrYXJvdW5kIGluIHByaW50ZXIuanMgY2FzZTogXCJMaXRlcmFsXCJcbiAgICAgICAgb3B0aW9ucy5wYXJzZXIgIT09IFwidHlwZXNjcmlwdFwiICYmICFwYXJlbnQuZGlyZWN0aXZlIHx8IG9wdGlvbnMucGFyc2VyID09PSBcInR5cGVzY3JpcHRcIiAmJiBvcHRpb25zLm9yaWdpbmFsVGV4dC5zdWJzdHIob3B0aW9ucy5sb2NTdGFydChub2RlKSAtIDEsIDEpID09PSBcIihcIikpIHtcbiAgICAgICAgICAvLyBUbyBhdm9pZCBiZWNvbWluZyBhIGRpcmVjdGl2ZVxuICAgICAgICAgIHZhciBncmFuZFBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgxKTtcbiAgICAgICAgICByZXR1cm4gZ3JhbmRQYXJlbnQudHlwZSA9PT0gXCJQcm9ncmFtXCIgfHwgZ3JhbmRQYXJlbnQudHlwZSA9PT0gXCJCbG9ja1N0YXRlbWVudFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudC50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiAmJiB0eXBlb2Ygbm9kZS52YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiBuYW1lID09PSBcIm9iamVjdFwiICYmIHBhcmVudC5vYmplY3QgPT09IG5vZGU7XG5cbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9ncmFuZFBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgxKTtcblxuICAgICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiICYmIHBhcmVudC5ib2R5ID09PSBub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcmVudC50eXBlID09PSBcIkNsYXNzUHJvcGVydHlcIiAmJiBwYXJlbnQua2V5ID09PSBub2RlICYmIHBhcmVudC5jb21wdXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50LnR5cGUgPT09IFwiVFNQcm9wZXJ0eVNpZ25hdHVyZVwiICYmIHBhcmVudC5uYW1lID09PSBub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQudHlwZSA9PT0gXCJGb3JTdGF0ZW1lbnRcIiAmJiAocGFyZW50LmluaXQgPT09IG5vZGUgfHwgcGFyZW50LnVwZGF0ZSA9PT0gbm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcmVudC50eXBlID09PSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUubGVmdC50eXBlID09PSBcIk9iamVjdFBhdHRlcm5cIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcmVudC50eXBlID09PSBcIlRTUHJvcGVydHlTaWduYXR1cmVcIiAmJiBwYXJlbnQua2V5ID09PSBub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQudHlwZSA9PT0gXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQudHlwZSA9PT0gXCJTZXF1ZW5jZUV4cHJlc3Npb25cIiAmJiBfZ3JhbmRQYXJlbnQgJiYgX2dyYW5kUGFyZW50LnR5cGUgPT09IFwiRm9yU3RhdGVtZW50XCIgJiYgKF9ncmFuZFBhcmVudC5pbml0ID09PSBwYXJlbnQgfHwgX2dyYW5kUGFyZW50LnVwZGF0ZSA9PT0gcGFyZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50LnR5cGUgPT09IFwiUHJvcGVydHlcIiAmJiBwYXJlbnQudmFsdWUgPT09IG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcmVudC50eXBlID09PSBcIk5HQ2hhaW5lZEV4cHJlc3Npb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIjpcbiAgICAgICAgc3dpdGNoIChwYXJlbnQudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiVW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIlNwcmVhZEVsZW1lbnRcIjpcbiAgICAgICAgICBjYXNlIFwiU3ByZWFkUHJvcGVydHlcIjpcbiAgICAgICAgICBjYXNlIFwiQmluYXJ5RXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJMb2dpY2FsRXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJOR1BpcGVFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiOlxuICAgICAgICAgIGNhc2UgXCJBd2FpdEV4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiSlNYU3ByZWFkQXR0cmlidXRlXCI6XG4gICAgICAgICAgY2FzZSBcIlRTVHlwZUFzc2VydGlvblwiOlxuICAgICAgICAgIGNhc2UgXCJUeXBlQ2FzdEV4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiVFNBc0V4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiVFNOb25OdWxsRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICBjYXNlIFwiTmV3RXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJDYWxsRXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gbmFtZSA9PT0gXCJjYWxsZWVcIjtcblxuICAgICAgICAgIGNhc2UgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgIHJldHVybiBuYW1lID09PSBcInRlc3RcIiAmJiBwYXJlbnQudGVzdCA9PT0gbm9kZTtcblxuICAgICAgICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09IFwib2JqZWN0XCI7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICAgICAgc3dpdGNoIChwYXJlbnQudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJOZXdFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIkNhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgIC8vIE5vdCBhbHdheXMgbmVjZXNzYXJ5LCBidXQgaXQncyBjbGVhcmVyIHRvIHRoZSByZWFkZXIgaWYgSUlGRXMgYXJlIHdyYXBwZWQgaW4gcGFyZW50aGVzZXMuXG4gICAgICAgICAgICAvLyBJcyBuZWNlc3NhcnkgaWYgaXQgaXMgYGV4cHJlc3Npb25gIG9mIGBFeHByZXNzaW9uU3RhdGVtZW50YC5cbiAgICAgICAgICAgIHJldHVybiBuYW1lID09PSBcImNhbGxlZVwiO1xuXG4gICAgICAgICAgY2FzZSBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgLy8gVGhpcyBpcyBiYXNpY2FsbHkgYSBraW5kIG9mIElJRkUuXG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiOlxuICAgICAgICBzd2l0Y2ggKHBhcmVudC50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIk5ld0V4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiQ2FsbEV4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09IFwiY2FsbGVlXCI7XG5cbiAgICAgICAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgIHJldHVybiBuYW1lID09PSBcIm9iamVjdFwiO1xuXG4gICAgICAgICAgY2FzZSBcIlRTQXNFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIkJpbmRFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJVbmFyeUV4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiTG9naWNhbEV4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiQmluYXJ5RXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJBd2FpdEV4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiVFNUeXBlQXNzZXJ0aW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgIGNhc2UgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgIHJldHVybiBuYW1lID09PSBcInRlc3RcIjtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIkNsYXNzRXhwcmVzc2lvblwiOlxuICAgICAgICBzd2l0Y2ggKHBhcmVudC50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIk5ld0V4cHJlc3Npb25cIjpcbiAgICAgICAgICAgIHJldHVybiBuYW1lID09PSBcImNhbGxlZVwiICYmIHBhcmVudC5jYWxsZWUgPT09IG5vZGU7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgIGlmICgocGFyZW50LnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiICYmIG5hbWUgPT09IFwib2JqZWN0XCIgfHwgcGFyZW50LnR5cGUgPT09IFwiQ2FsbEV4cHJlc3Npb25cIiAmJiBuYW1lID09PSBcImNhbGxlZVwiKSAmJiAvLyB3b3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvODE1OVxuICAgICAgICAhKG9wdGlvbnMucGFyc2VyID09PSBcImZsb3dcIiAmJiBwYXJlbnQucmFuZ2VbMF0gPT09IG5vZGUucmFuZ2VbMF0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgLy8gZmFsbHRocm91Z2hcblxuICAgICAgY2FzZSBcIkNhbGxFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIlRTTm9uTnVsbEV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKChwYXJlbnQudHlwZSA9PT0gXCJCaW5kRXhwcmVzc2lvblwiIHx8IHBhcmVudC50eXBlID09PSBcIk5ld0V4cHJlc3Npb25cIikgJiYgbmFtZSA9PT0gXCJjYWxsZWVcIikge1xuICAgICAgICAgIHZhciBvYmplY3QgPSBub2RlO1xuXG4gICAgICAgICAgd2hpbGUgKG9iamVjdCkge1xuICAgICAgICAgICAgc3dpdGNoIChvYmplY3QudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwiQ2FsbEV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgICAgY2FzZSBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgICBjYXNlIFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJCaW5kRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5vYmplY3Q7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIC8vIHRhZ2dlZCB0ZW1wbGF0ZXMgYXJlIGJhc2ljYWxseSBtZW1iZXIgZXhwcmVzc2lvbnMgZnJvbSBhIGdyYW1tYXIgcGVyc3BlY3RpdmVcbiAgICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jcHJvZC1NZW1iZXJFeHByZXNzaW9uXG5cbiAgICAgICAgICAgICAgY2FzZSBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC50YWc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBcIlRTTm9uTnVsbEV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgICAgICBvYmplY3QgPSBvYmplY3QuZXhwcmVzc2lvbjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGNhc2UgXCJCaW5kRXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gKHBhcmVudC50eXBlID09PSBcIkJpbmRFeHByZXNzaW9uXCIgfHwgcGFyZW50LnR5cGUgPT09IFwiTmV3RXhwcmVzc2lvblwiKSAmJiBuYW1lID09PSBcImNhbGxlZVwiIHx8IChwYXJlbnQudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgfHwgcGFyZW50LnR5cGUgPT09IFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIpICYmIG5hbWUgPT09IFwib2JqZWN0XCI7XG5cbiAgICAgIGNhc2UgXCJOR1BpcGVFeHByZXNzaW9uXCI6XG4gICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gXCJOR1Jvb3RcIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJOR01pY3Jvc3ludGF4RXhwcmVzc2lvblwiIHx8IHBhcmVudC50eXBlID09PSBcIk9iamVjdFByb3BlcnR5XCIgfHwgcGFyZW50LnR5cGUgPT09IFwiQXJyYXlFeHByZXNzaW9uXCIgfHwgKHBhcmVudC50eXBlID09PSBcIkNhbGxFeHByZXNzaW9uXCIgfHwgcGFyZW50LnR5cGUgPT09IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiKSAmJiBwYXJlbnQuYXJndW1lbnRzW25hbWVdID09PSBub2RlIHx8IHBhcmVudC50eXBlID09PSBcIk5HUGlwZUV4cHJlc3Npb25cIiAmJiBuYW1lID09PSBcInJpZ2h0XCIgfHwgcGFyZW50LnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiICYmIG5hbWUgPT09IFwicHJvcGVydHlcIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGNhc2UgXCJKU1hGcmFnbWVudFwiOlxuICAgICAgY2FzZSBcIkpTWEVsZW1lbnRcIjpcbiAgICAgICAgcmV0dXJuIG5hbWUgPT09IFwiY2FsbGVlXCIgfHwgcGFyZW50LnR5cGUgIT09IFwiQXJyYXlFeHByZXNzaW9uXCIgJiYgcGFyZW50LnR5cGUgIT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiBwYXJlbnQudHlwZSAhPT0gXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiICYmIHBhcmVudC50eXBlICE9PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIgJiYgcGFyZW50LnR5cGUgIT09IFwiQmluYXJ5RXhwcmVzc2lvblwiICYmIHBhcmVudC50eXBlICE9PSBcIkNhbGxFeHByZXNzaW9uXCIgJiYgcGFyZW50LnR5cGUgIT09IFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIgJiYgcGFyZW50LnR5cGUgIT09IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiICYmIHBhcmVudC50eXBlICE9PSBcIkpzRXhwcmVzc2lvblJvb3RcIiAmJiBwYXJlbnQudHlwZSAhPT0gXCJKU1hBdHRyaWJ1dGVcIiAmJiBwYXJlbnQudHlwZSAhPT0gXCJKU1hFbGVtZW50XCIgJiYgcGFyZW50LnR5cGUgIT09IFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiICYmIHBhcmVudC50eXBlICE9PSBcIkpTWEZyYWdtZW50XCIgJiYgcGFyZW50LnR5cGUgIT09IFwiTG9naWNhbEV4cHJlc3Npb25cIiAmJiBwYXJlbnQudHlwZSAhPT0gXCJPYmplY3RQcm9wZXJ0eVwiICYmIHBhcmVudC50eXBlICE9PSBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIiAmJiBwYXJlbnQudHlwZSAhPT0gXCJQcm9wZXJ0eVwiICYmIHBhcmVudC50eXBlICE9PSBcIlJldHVyblN0YXRlbWVudFwiICYmIHBhcmVudC50eXBlICE9PSBcIlR5cGVDYXN0RXhwcmVzc2lvblwiICYmIHBhcmVudC50eXBlICE9PSBcIlZhcmlhYmxlRGVjbGFyYXRvclwiO1xuXG4gICAgICBjYXNlIFwiVHlwZUFubm90YXRpb25cIjpcbiAgICAgICAgcmV0dXJuIG5hbWUgPT09IFwicmV0dXJuVHlwZVwiICYmIHBhcmVudC50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgJiYgaW5jbHVkZXNGdW5jdGlvblR5cGVJbk9iamVjdFR5cGUobm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTdGF0ZW1lbnQobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiQmxvY2tTdGF0ZW1lbnRcIiB8fCBub2RlLnR5cGUgPT09IFwiQnJlYWtTdGF0ZW1lbnRcIiB8fCBub2RlLnR5cGUgPT09IFwiQ2xhc3NCb2R5XCIgfHwgbm9kZS50eXBlID09PSBcIkNsYXNzRGVjbGFyYXRpb25cIiB8fCBub2RlLnR5cGUgPT09IFwiQ2xhc3NNZXRob2RcIiB8fCBub2RlLnR5cGUgPT09IFwiQ2xhc3NQcm9wZXJ0eVwiIHx8IG5vZGUudHlwZSA9PT0gXCJDbGFzc1ByaXZhdGVQcm9wZXJ0eVwiIHx8IG5vZGUudHlwZSA9PT0gXCJDb250aW51ZVN0YXRlbWVudFwiIHx8IG5vZGUudHlwZSA9PT0gXCJEZWJ1Z2dlclN0YXRlbWVudFwiIHx8IG5vZGUudHlwZSA9PT0gXCJEZWNsYXJlQ2xhc3NcIiB8fCBub2RlLnR5cGUgPT09IFwiRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uXCIgfHwgbm9kZS50eXBlID09PSBcIkRlY2xhcmVFeHBvcnREZWNsYXJhdGlvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJEZWNsYXJlRnVuY3Rpb25cIiB8fCBub2RlLnR5cGUgPT09IFwiRGVjbGFyZUludGVyZmFjZVwiIHx8IG5vZGUudHlwZSA9PT0gXCJEZWNsYXJlTW9kdWxlXCIgfHwgbm9kZS50eXBlID09PSBcIkRlY2xhcmVNb2R1bGVFeHBvcnRzXCIgfHwgbm9kZS50eXBlID09PSBcIkRlY2xhcmVWYXJpYWJsZVwiIHx8IG5vZGUudHlwZSA9PT0gXCJEb1doaWxlU3RhdGVtZW50XCIgfHwgbm9kZS50eXBlID09PSBcIkVudW1EZWNsYXJhdGlvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIiB8fCBub2RlLnR5cGUgPT09IFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgfHwgbm9kZS50eXBlID09PSBcIkZvckF3YWl0U3RhdGVtZW50XCIgfHwgbm9kZS50eXBlID09PSBcIkZvckluU3RhdGVtZW50XCIgfHwgbm9kZS50eXBlID09PSBcIkZvck9mU3RhdGVtZW50XCIgfHwgbm9kZS50eXBlID09PSBcIkZvclN0YXRlbWVudFwiIHx8IG5vZGUudHlwZSA9PT0gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgfHwgbm9kZS50eXBlID09PSBcIklmU3RhdGVtZW50XCIgfHwgbm9kZS50eXBlID09PSBcIkltcG9ydERlY2xhcmF0aW9uXCIgfHwgbm9kZS50eXBlID09PSBcIkludGVyZmFjZURlY2xhcmF0aW9uXCIgfHwgbm9kZS50eXBlID09PSBcIkxhYmVsZWRTdGF0ZW1lbnRcIiB8fCBub2RlLnR5cGUgPT09IFwiTWV0aG9kRGVmaW5pdGlvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJSZXR1cm5TdGF0ZW1lbnRcIiB8fCBub2RlLnR5cGUgPT09IFwiU3dpdGNoU3RhdGVtZW50XCIgfHwgbm9kZS50eXBlID09PSBcIlRocm93U3RhdGVtZW50XCIgfHwgbm9kZS50eXBlID09PSBcIlRyeVN0YXRlbWVudFwiIHx8IG5vZGUudHlwZSA9PT0gXCJUU0RlY2xhcmVGdW5jdGlvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJUU0VudW1EZWNsYXJhdGlvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJUU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uXCIgfHwgbm9kZS50eXBlID09PSBcIlRTSW50ZXJmYWNlRGVjbGFyYXRpb25cIiB8fCBub2RlLnR5cGUgPT09IFwiVFNNb2R1bGVEZWNsYXJhdGlvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJUU05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uXCIgfHwgbm9kZS50eXBlID09PSBcIlR5cGVBbGlhc1wiIHx8IG5vZGUudHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIgfHwgbm9kZS50eXBlID09PSBcIldoaWxlU3RhdGVtZW50XCIgfHwgbm9kZS50eXBlID09PSBcIldpdGhTdGF0ZW1lbnRcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluY2x1ZGVzRnVuY3Rpb25UeXBlSW5PYmplY3RUeXBlKG5vZGUpIHtcbiAgICByZXR1cm4gaGFzTm9kZSQxKG5vZGUsIGZ1bmN0aW9uIChuMSkge1xuICAgICAgcmV0dXJuIG4xLnR5cGUgPT09IFwiT2JqZWN0VHlwZUFubm90YXRpb25cIiAmJiBoYXNOb2RlJDEobjEsIGZ1bmN0aW9uIChuMikge1xuICAgICAgICByZXR1cm4gbjIudHlwZSA9PT0gXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIgfHwgdW5kZWZpbmVkO1xuICAgICAgfSkgfHwgdW5kZWZpbmVkO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5kc1dpdGhSaWdodEJyYWNrZXQobm9kZSkge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiT2JqZWN0RXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRm9sbG93ZWRCeVJpZ2h0QnJhY2tldChwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSBwYXRoLmdldFZhbHVlKCk7XG4gICAgdmFyIHBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpO1xuICAgIHZhciBuYW1lID0gcGF0aC5nZXROYW1lKCk7XG5cbiAgICBzd2l0Y2ggKHBhcmVudC50eXBlKSB7XG4gICAgICBjYXNlIFwiTkdQaXBlRXhwcmVzc2lvblwiOlxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwibnVtYmVyXCIgJiYgcGFyZW50LmFyZ3VtZW50c1tuYW1lXSA9PT0gbm9kZSAmJiBwYXJlbnQuYXJndW1lbnRzLmxlbmd0aCAtIDEgPT09IG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gcGF0aC5jYWxsUGFyZW50KGlzRm9sbG93ZWRCeVJpZ2h0QnJhY2tldCk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIk9iamVjdFByb3BlcnR5XCI6XG4gICAgICAgIGlmIChuYW1lID09PSBcInZhbHVlXCIpIHtcbiAgICAgICAgICB2YXIgcGFyZW50UGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKDEpO1xuICAgICAgICAgIHJldHVybiBwYXJlbnRQYXJlbnQucHJvcGVydGllc1twYXJlbnRQYXJlbnQucHJvcGVydGllcy5sZW5ndGggLSAxXSA9PT0gcGFyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJCaW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiTG9naWNhbEV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKG5hbWUgPT09IFwicmlnaHRcIikge1xuICAgICAgICAgIHJldHVybiBwYXRoLmNhbGxQYXJlbnQoaXNGb2xsb3dlZEJ5UmlnaHRCcmFja2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCI6XG4gICAgICAgIGlmIChuYW1lID09PSBcImFsdGVybmF0ZVwiKSB7XG4gICAgICAgICAgcmV0dXJuIHBhdGguY2FsbFBhcmVudChpc0ZvbGxvd2VkQnlSaWdodEJyYWNrZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJVbmFyeUV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKHBhcmVudC5wcmVmaXgpIHtcbiAgICAgICAgICByZXR1cm4gcGF0aC5jYWxsUGFyZW50KGlzRm9sbG93ZWRCeVJpZ2h0QnJhY2tldCk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRXcmFwRnVuY3Rpb25Gb3JFeHBvcnREZWZhdWx0KHBhdGgsIG9wdGlvbnMpIHtcbiAgICB2YXIgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICB2YXIgcGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG5cbiAgICBpZiAobm9kZS50eXBlID09PSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJDbGFzc0V4cHJlc3Npb25cIikge1xuICAgICAgcmV0dXJuIHBhcmVudC50eXBlID09PSBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiIHx8IC8vIGluIHNvbWUgY2FzZXMgdGhlIGZ1bmN0aW9uIGlzIGFscmVhZHkgd3JhcHBlZFxuICAgICAgLy8gKGUuZy4gYGV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbigpIHt9KSgpO2ApXG4gICAgICAvLyBpbiB0aGlzIGNhc2Ugd2UgZG9uJ3QgbmVlZCB0byBhZGQgZXh0cmEgcGFyZW5zXG4gICAgICAhbmVlZHNQYXJlbnMocGF0aCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKCFoYXNOYWtlZExlZnRTaWRlJDEobm9kZSkgfHwgcGFyZW50LnR5cGUgIT09IFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIgJiYgbmVlZHNQYXJlbnMocGF0aCwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aC5jYWxsLmFwcGx5KHBhdGgsIFtmdW5jdGlvbiAoY2hpbGRQYXRoKSB7XG4gICAgICByZXR1cm4gc2hvdWxkV3JhcEZ1bmN0aW9uRm9yRXhwb3J0RGVmYXVsdChjaGlsZFBhdGgsIG9wdGlvbnMpO1xuICAgIH1dLmNvbmNhdChnZXRMZWZ0U2lkZVBhdGhOYW1lJDEocGF0aCwgbm9kZSkpKTtcbiAgfVxuXG4gIHZhciBuZWVkc1BhcmVuc18xID0gbmVlZHNQYXJlbnM7XG5cbiAgdmFyIF9yZXF1aXJlJCQwJGJ1aWxkZXJzJDYgPSBkb2MuYnVpbGRlcnMsXG4gICAgICBjb25jYXQkYyA9IF9yZXF1aXJlJCQwJGJ1aWxkZXJzJDYuY29uY2F0LFxuICAgICAgam9pbiQ4ID0gX3JlcXVpcmUkJDAkYnVpbGRlcnMkNi5qb2luLFxuICAgICAgbGluZSQ2ID0gX3JlcXVpcmUkJDAkYnVpbGRlcnMkNi5saW5lO1xuXG4gIGZ1bmN0aW9uIHByaW50SHRtbEJpbmRpbmcocGF0aCwgb3B0aW9ucywgcHJpbnQpIHtcbiAgICB2YXIgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcblxuICAgIGlmIChvcHRpb25zLl9fb25IdG1sQmluZGluZ1Jvb3QgJiYgcGF0aC5nZXROYW1lKCkgPT09IG51bGwpIHtcbiAgICAgIG9wdGlvbnMuX19vbkh0bWxCaW5kaW5nUm9vdChub2RlKTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS50eXBlICE9PSBcIkZpbGVcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLl9faXNWdWVGb3JCaW5kaW5nTGVmdCkge1xuICAgICAgcmV0dXJuIHBhdGguY2FsbChmdW5jdGlvbiAoZnVuY3Rpb25EZWNsYXJhdGlvblBhdGgpIHtcbiAgICAgICAgdmFyIF9mdW5jdGlvbkRlY2xhcmF0aW9uUCA9IGZ1bmN0aW9uRGVjbGFyYXRpb25QYXRoLmdldFZhbHVlKCksXG4gICAgICAgICAgICBwYXJhbXMgPSBfZnVuY3Rpb25EZWNsYXJhdGlvblAucGFyYW1zO1xuXG4gICAgICAgIHJldHVybiBjb25jYXQkYyhbcGFyYW1zLmxlbmd0aCA+IDEgPyBcIihcIiA6IFwiXCIsIGpvaW4kOChjb25jYXQkYyhbXCIsXCIsIGxpbmUkNl0pLCBmdW5jdGlvbkRlY2xhcmF0aW9uUGF0aC5tYXAocHJpbnQsIFwicGFyYW1zXCIpKSwgcGFyYW1zLmxlbmd0aCA+IDEgPyBcIilcIiA6IFwiXCJdKTtcbiAgICAgIH0sIFwicHJvZ3JhbVwiLCBcImJvZHlcIiwgMCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuX19pc1Z1ZVNsb3RTY29wZSkge1xuICAgICAgcmV0dXJuIHBhdGguY2FsbChmdW5jdGlvbiAoZnVuY3Rpb25EZWNsYXJhdGlvblBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGpvaW4kOChjb25jYXQkYyhbXCIsXCIsIGxpbmUkNl0pLCBmdW5jdGlvbkRlY2xhcmF0aW9uUGF0aC5tYXAocHJpbnQsIFwicGFyYW1zXCIpKTtcbiAgICAgIH0sIFwicHJvZ3JhbVwiLCBcImJvZHlcIiwgMCk7XG4gICAgfVxuICB9IC8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmV0dGllci9wcmV0dGllci9ibG9iL21hc3Rlci9zcmMvbGFuZ3VhZ2UtaHRtbC9zeW50YXgtdnVlLmpzIGlzVnVlRXZlbnRCaW5kaW5nRXhwcmVzc2lvbigpXG5cblxuICBmdW5jdGlvbiBpc1Z1ZUV2ZW50QmluZGluZ0V4cHJlc3Npb24kMihub2RlKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICAgIHN3aXRjaCAobm9kZS5wcm9wZXJ0eS50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgICAgICBjYXNlIFwiTnVtZXJpY0xpdGVyYWxcIjpcbiAgICAgICAgICBjYXNlIFwiU3RyaW5nTGl0ZXJhbFwiOlxuICAgICAgICAgICAgcmV0dXJuIGlzVnVlRXZlbnRCaW5kaW5nRXhwcmVzc2lvbiQyKG5vZGUub2JqZWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB2YXIgaHRtbEJpbmRpbmcgPSB7XG4gICAgaXNWdWVFdmVudEJpbmRpbmdFeHByZXNzaW9uOiBpc1Z1ZUV2ZW50QmluZGluZ0V4cHJlc3Npb24kMixcbiAgICBwcmludEh0bWxCaW5kaW5nOiBwcmludEh0bWxCaW5kaW5nXG4gIH07XG5cbiAgZnVuY3Rpb24gcHJlcHJvY2VzcyQxKGFzdCwgb3B0aW9ucykge1xuICAgIHN3aXRjaCAob3B0aW9ucy5wYXJzZXIpIHtcbiAgICAgIGNhc2UgXCJqc29uXCI6XG4gICAgICBjYXNlIFwianNvbjVcIjpcbiAgICAgIGNhc2UgXCJqc29uLXN0cmluZ2lmeVwiOlxuICAgICAgY2FzZSBcIl9fanNfZXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIl9fdnVlX2V4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGFzdCwge1xuICAgICAgICAgIHR5cGU6IG9wdGlvbnMucGFyc2VyLnN0YXJ0c1dpdGgoXCJfX1wiKSA/IFwiSnNFeHByZXNzaW9uUm9vdFwiIDogXCJKc29uUm9vdFwiLFxuICAgICAgICAgIG5vZGU6IGFzdCxcbiAgICAgICAgICBjb21tZW50czogW11cbiAgICAgICAgfSk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByZXByb2Nlc3NfMSQxID0gcHJlcHJvY2VzcyQxO1xuXG4gIHZhciBnZXRQYXJlbnRFeHBvcnREZWNsYXJhdGlvbiQxID0gdXRpbC5nZXRQYXJlbnRFeHBvcnREZWNsYXJhdGlvbixcbiAgICAgIGlzRXhwb3J0RGVjbGFyYXRpb24kMSA9IHV0aWwuaXNFeHBvcnREZWNsYXJhdGlvbixcbiAgICAgIHNob3VsZEZsYXR0ZW4kMSA9IHV0aWwuc2hvdWxkRmxhdHRlbixcbiAgICAgIGdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXIkMSA9IHV0aWwuZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3RlcixcbiAgICAgIGhhc05ld2xpbmUkNCA9IHV0aWwuaGFzTmV3bGluZSxcbiAgICAgIGhhc05ld2xpbmVJblJhbmdlJDIgPSB1dGlsLmhhc05ld2xpbmVJblJhbmdlLFxuICAgICAgZ2V0TGFzdCQyID0gdXRpbC5nZXRMYXN0LFxuICAgICAgZ2V0U3RyaW5nV2lkdGgkMiA9IHV0aWwuZ2V0U3RyaW5nV2lkdGgsXG4gICAgICBwcmludFN0cmluZyQyID0gdXRpbC5wcmludFN0cmluZyxcbiAgICAgIHByaW50TnVtYmVyJDIgPSB1dGlsLnByaW50TnVtYmVyLFxuICAgICAgaGFzSWdub3JlQ29tbWVudCQ0ID0gdXRpbC5oYXNJZ25vcmVDb21tZW50LFxuICAgICAgaGFzTm9kZUlnbm9yZUNvbW1lbnQkMiA9IHV0aWwuaGFzTm9kZUlnbm9yZUNvbW1lbnQsXG4gICAgICBnZXRQZW51bHRpbWF0ZSQxID0gdXRpbC5nZXRQZW51bHRpbWF0ZSxcbiAgICAgIHN0YXJ0c1dpdGhOb0xvb2thaGVhZFRva2VuJDEgPSB1dGlsLnN0YXJ0c1dpdGhOb0xvb2thaGVhZFRva2VuLFxuICAgICAgZ2V0SW5kZW50U2l6ZSQxID0gdXRpbC5nZXRJbmRlbnRTaXplLFxuICAgICAgbWF0Y2hBbmNlc3RvclR5cGVzJDEgPSB1dGlsLm1hdGNoQW5jZXN0b3JUeXBlcyxcbiAgICAgIGdldFByZWZlcnJlZFF1b3RlJDEgPSB1dGlsLmdldFByZWZlcnJlZFF1b3RlO1xuICB2YXIgaXNOZXh0TGluZUVtcHR5JDQgPSB1dGlsU2hhcmVkLmlzTmV4dExpbmVFbXB0eSxcbiAgICAgIGlzTmV4dExpbmVFbXB0eUFmdGVySW5kZXgkMSA9IHV0aWxTaGFyZWQuaXNOZXh0TGluZUVtcHR5QWZ0ZXJJbmRleCxcbiAgICAgIGdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXJJbmRleCQyID0gdXRpbFNoYXJlZC5nZXROZXh0Tm9uU3BhY2VOb25Db21tZW50Q2hhcmFjdGVySW5kZXg7XG4gIHZhciBpbnNlcnRQcmFnbWEkNyA9IHByYWdtYS5pbnNlcnRQcmFnbWE7XG4gIHZhciBwcmludEh0bWxCaW5kaW5nJDEgPSBodG1sQmluZGluZy5wcmludEh0bWxCaW5kaW5nLFxuICAgICAgaXNWdWVFdmVudEJpbmRpbmdFeHByZXNzaW9uJDMgPSBodG1sQmluZGluZy5pc1Z1ZUV2ZW50QmluZGluZ0V4cHJlc3Npb247XG4gIHZhciBjbGFzc0NoaWxkTmVlZHNBU0lQcm90ZWN0aW9uJDEgPSB1dGlscyQ0LmNsYXNzQ2hpbGROZWVkc0FTSVByb3RlY3Rpb24sXG4gICAgICBjbGFzc1Byb3BNYXlDYXVzZUFTSVByb2JsZW1zJDEgPSB1dGlscyQ0LmNsYXNzUHJvcE1heUNhdXNlQVNJUHJvYmxlbXMsXG4gICAgICBjb25kaXRpb25hbEV4cHJlc3Npb25DaGFpbkNvbnRhaW5zSlNYJDEgPSB1dGlscyQ0LmNvbmRpdGlvbmFsRXhwcmVzc2lvbkNoYWluQ29udGFpbnNKU1gsXG4gICAgICBnZXRGbG93VmFyaWFuY2UkMSA9IHV0aWxzJDQuZ2V0Rmxvd1ZhcmlhbmNlLFxuICAgICAgZ2V0TGVmdFNpZGVQYXRoTmFtZSQyID0gdXRpbHMkNC5nZXRMZWZ0U2lkZVBhdGhOYW1lLFxuICAgICAgZ2V0VHlwZVNjcmlwdE1hcHBlZFR5cGVNb2RpZmllciQxID0gdXRpbHMkNC5nZXRUeXBlU2NyaXB0TWFwcGVkVHlwZU1vZGlmaWVyLFxuICAgICAgaGFzRGFuZ2xpbmdDb21tZW50cyQxID0gdXRpbHMkNC5oYXNEYW5nbGluZ0NvbW1lbnRzLFxuICAgICAgaGFzRmxvd0Fubm90YXRpb25Db21tZW50JDEgPSB1dGlscyQ0Lmhhc0Zsb3dBbm5vdGF0aW9uQ29tbWVudCxcbiAgICAgIGhhc0Zsb3dTaG9ydGhhbmRBbm5vdGF0aW9uQ29tbWVudCQyID0gdXRpbHMkNC5oYXNGbG93U2hvcnRoYW5kQW5ub3RhdGlvbkNvbW1lbnQsXG4gICAgICBoYXNMZWFkaW5nQ29tbWVudCQzID0gdXRpbHMkNC5oYXNMZWFkaW5nQ29tbWVudCxcbiAgICAgIGhhc0xlYWRpbmdPd25MaW5lQ29tbWVudCQxID0gdXRpbHMkNC5oYXNMZWFkaW5nT3duTGluZUNvbW1lbnQsXG4gICAgICBoYXNOYWtlZExlZnRTaWRlJDIgPSB1dGlscyQ0Lmhhc05ha2VkTGVmdFNpZGUsXG4gICAgICBoYXNOZXdsaW5lQmV0d2Vlbk9yQWZ0ZXJEZWNvcmF0b3JzJDEgPSB1dGlscyQ0Lmhhc05ld2xpbmVCZXR3ZWVuT3JBZnRlckRlY29yYXRvcnMsXG4gICAgICBoYXNOZ1NpZGVFZmZlY3QkMSA9IHV0aWxzJDQuaGFzTmdTaWRlRWZmZWN0LFxuICAgICAgaGFzUHJldHRpZXJJZ25vcmUkMyA9IHV0aWxzJDQuaGFzUHJldHRpZXJJZ25vcmUsXG4gICAgICBoYXNUcmFpbGluZ0NvbW1lbnQkMSA9IHV0aWxzJDQuaGFzVHJhaWxpbmdDb21tZW50LFxuICAgICAgaWRlbnRpdHkkMiA9IHV0aWxzJDQuaWRlbnRpdHksXG4gICAgICBpc0JpbmFyeWlzaCQxID0gdXRpbHMkNC5pc0JpbmFyeWlzaCxcbiAgICAgIGlzQ2FsbE9yT3B0aW9uYWxDYWxsRXhwcmVzc2lvbiQxID0gdXRpbHMkNC5pc0NhbGxPck9wdGlvbmFsQ2FsbEV4cHJlc3Npb24sXG4gICAgICBpc0VtcHR5SlNYRWxlbWVudCQxID0gdXRpbHMkNC5pc0VtcHR5SlNYRWxlbWVudCxcbiAgICAgIGlzRmxvd0Fubm90YXRpb25Db21tZW50JDEgPSB1dGlscyQ0LmlzRmxvd0Fubm90YXRpb25Db21tZW50LFxuICAgICAgaXNGdW5jdGlvbkNvbXBvc2l0aW9uQXJncyQxID0gdXRpbHMkNC5pc0Z1bmN0aW9uQ29tcG9zaXRpb25BcmdzLFxuICAgICAgaXNGdW5jdGlvbk5vdGF0aW9uJDEgPSB1dGlscyQ0LmlzRnVuY3Rpb25Ob3RhdGlvbixcbiAgICAgIGlzRnVuY3Rpb25PckFycm93RXhwcmVzc2lvbiQxID0gdXRpbHMkNC5pc0Z1bmN0aW9uT3JBcnJvd0V4cHJlc3Npb24sXG4gICAgICBpc0dldHRlck9yU2V0dGVyJDEgPSB1dGlscyQ0LmlzR2V0dGVyT3JTZXR0ZXIsXG4gICAgICBpc0plc3RFYWNoVGVtcGxhdGVMaXRlcmFsJDEgPSB1dGlscyQ0LmlzSmVzdEVhY2hUZW1wbGF0ZUxpdGVyYWwsXG4gICAgICBpc0pTWE5vZGUkMSA9IHV0aWxzJDQuaXNKU1hOb2RlLFxuICAgICAgaXNKU1hXaGl0ZXNwYWNlRXhwcmVzc2lvbiQxID0gdXRpbHMkNC5pc0pTWFdoaXRlc3BhY2VFeHByZXNzaW9uLFxuICAgICAgaXNMYXN0U3RhdGVtZW50JDEgPSB1dGlscyQ0LmlzTGFzdFN0YXRlbWVudCxcbiAgICAgIGlzTGl0ZXJhbCQxID0gdXRpbHMkNC5pc0xpdGVyYWwsXG4gICAgICBpc0xvbmdDdXJyaWVkQ2FsbEV4cHJlc3Npb24kMSA9IHV0aWxzJDQuaXNMb25nQ3VycmllZENhbGxFeHByZXNzaW9uLFxuICAgICAgaXNNZWFuaW5nZnVsSlNYVGV4dCQxID0gdXRpbHMkNC5pc01lYW5pbmdmdWxKU1hUZXh0LFxuICAgICAgaXNNZW1iZXJFeHByZXNzaW9uQ2hhaW4kMSA9IHV0aWxzJDQuaXNNZW1iZXJFeHByZXNzaW9uQ2hhaW4sXG4gICAgICBpc01lbWJlcmlzaCQxID0gdXRpbHMkNC5pc01lbWJlcmlzaCxcbiAgICAgIGlzTmdGb3JPZiQxID0gdXRpbHMkNC5pc05nRm9yT2YsXG4gICAgICBpc051bWVyaWNMaXRlcmFsJDEgPSB1dGlscyQ0LmlzTnVtZXJpY0xpdGVyYWwsXG4gICAgICBpc09iamVjdFR5cGUkMSA9IHV0aWxzJDQuaXNPYmplY3RUeXBlLFxuICAgICAgaXNPYmplY3RUeXBlUHJvcGVydHlBRnVuY3Rpb24kMSA9IHV0aWxzJDQuaXNPYmplY3RUeXBlUHJvcGVydHlBRnVuY3Rpb24sXG4gICAgICBpc1NpbXBsZUZsb3dUeXBlJDEgPSB1dGlscyQ0LmlzU2ltcGxlRmxvd1R5cGUsXG4gICAgICBpc1NpbXBsZVRlbXBsYXRlTGl0ZXJhbCQxID0gdXRpbHMkNC5pc1NpbXBsZVRlbXBsYXRlTGl0ZXJhbCxcbiAgICAgIGlzU3RyaW5nTGl0ZXJhbCQxID0gdXRpbHMkNC5pc1N0cmluZ0xpdGVyYWwsXG4gICAgICBpc1N0cmluZ1Byb3BTYWZlVG9Db2VyY2VUb0lkZW50aWZpZXIkMSA9IHV0aWxzJDQuaXNTdHJpbmdQcm9wU2FmZVRvQ29lcmNlVG9JZGVudGlmaWVyLFxuICAgICAgaXNUZW1wbGF0ZU9uSXRzT3duTGluZSQxID0gdXRpbHMkNC5pc1RlbXBsYXRlT25JdHNPd25MaW5lLFxuICAgICAgaXNUZXN0Q2FsbCQxID0gdXRpbHMkNC5pc1Rlc3RDYWxsLFxuICAgICAgaXNUaGVPbmx5SlNYRWxlbWVudEluTWFya2Rvd24kMSA9IHV0aWxzJDQuaXNUaGVPbmx5SlNYRWxlbWVudEluTWFya2Rvd24sXG4gICAgICBpc1RTWEZpbGUkMSA9IHV0aWxzJDQuaXNUU1hGaWxlLFxuICAgICAgaXNUeXBlQW5ub3RhdGlvbkFGdW5jdGlvbiQxID0gdXRpbHMkNC5pc1R5cGVBbm5vdGF0aW9uQUZ1bmN0aW9uLFxuICAgICAgbWF0Y2hKc3hXaGl0ZXNwYWNlUmVnZXgkMSA9IHV0aWxzJDQubWF0Y2hKc3hXaGl0ZXNwYWNlUmVnZXgsXG4gICAgICBuZWVkc0hhcmRsaW5lQWZ0ZXJEYW5nbGluZ0NvbW1lbnQkMSA9IHV0aWxzJDQubmVlZHNIYXJkbGluZUFmdGVyRGFuZ2xpbmdDb21tZW50LFxuICAgICAgcmF3VGV4dCQxID0gdXRpbHMkNC5yYXdUZXh0LFxuICAgICAgcmV0dXJuQXJndW1lbnRIYXNMZWFkaW5nQ29tbWVudCQxID0gdXRpbHMkNC5yZXR1cm5Bcmd1bWVudEhhc0xlYWRpbmdDb21tZW50O1xuICB2YXIgbmVlZHNRdW90ZVByb3BzID0gbmV3IFdlYWtNYXAoKTtcbiAgdmFyIF9yZXF1aXJlJCQ1JGJ1aWxkZXJzID0gZG9jLmJ1aWxkZXJzLFxuICAgICAgY29uY2F0JGQgPSBfcmVxdWlyZSQkNSRidWlsZGVycy5jb25jYXQsXG4gICAgICBqb2luJDkgPSBfcmVxdWlyZSQkNSRidWlsZGVycy5qb2luLFxuICAgICAgbGluZSQ3ID0gX3JlcXVpcmUkJDUkYnVpbGRlcnMubGluZSxcbiAgICAgIGhhcmRsaW5lJDkgPSBfcmVxdWlyZSQkNSRidWlsZGVycy5oYXJkbGluZSxcbiAgICAgIHNvZnRsaW5lJDYgPSBfcmVxdWlyZSQkNSRidWlsZGVycy5zb2Z0bGluZSxcbiAgICAgIGxpdGVyYWxsaW5lJDQgPSBfcmVxdWlyZSQkNSRidWlsZGVycy5saXRlcmFsbGluZSxcbiAgICAgIGdyb3VwJGIgPSBfcmVxdWlyZSQkNSRidWlsZGVycy5ncm91cCxcbiAgICAgIGluZGVudCQ3ID0gX3JlcXVpcmUkJDUkYnVpbGRlcnMuaW5kZW50LFxuICAgICAgYWxpZ24kMSA9IF9yZXF1aXJlJCQ1JGJ1aWxkZXJzLmFsaWduLFxuICAgICAgY29uZGl0aW9uYWxHcm91cCQxID0gX3JlcXVpcmUkJDUkYnVpbGRlcnMuY29uZGl0aW9uYWxHcm91cCxcbiAgICAgIGZpbGwkNCA9IF9yZXF1aXJlJCQ1JGJ1aWxkZXJzLmZpbGwsXG4gICAgICBpZkJyZWFrJDYgPSBfcmVxdWlyZSQkNSRidWlsZGVycy5pZkJyZWFrLFxuICAgICAgYnJlYWtQYXJlbnQkMyA9IF9yZXF1aXJlJCQ1JGJ1aWxkZXJzLmJyZWFrUGFyZW50LFxuICAgICAgbGluZVN1ZmZpeEJvdW5kYXJ5JDEgPSBfcmVxdWlyZSQkNSRidWlsZGVycy5saW5lU3VmZml4Qm91bmRhcnksXG4gICAgICBhZGRBbGlnbm1lbnRUb0RvYyQyID0gX3JlcXVpcmUkJDUkYnVpbGRlcnMuYWRkQWxpZ25tZW50VG9Eb2MsXG4gICAgICBkZWRlbnQkMiA9IF9yZXF1aXJlJCQ1JGJ1aWxkZXJzLmRlZGVudCxcbiAgICAgIF9yZXF1aXJlJCQ1JHV0aWxzID0gZG9jLnV0aWxzLFxuICAgICAgd2lsbEJyZWFrJDEgPSBfcmVxdWlyZSQkNSR1dGlscy53aWxsQnJlYWssXG4gICAgICBpc0xpbmVOZXh0JDEgPSBfcmVxdWlyZSQkNSR1dGlscy5pc0xpbmVOZXh0LFxuICAgICAgaXNFbXB0eSQxID0gX3JlcXVpcmUkJDUkdXRpbHMuaXNFbXB0eSxcbiAgICAgIHJlbW92ZUxpbmVzJDIgPSBfcmVxdWlyZSQkNSR1dGlscy5yZW1vdmVMaW5lcyxcbiAgICAgIHByaW50RG9jVG9TdHJpbmckMSA9IGRvYy5wcmludGVyLnByaW50RG9jVG9TdHJpbmc7XG4gIHZhciB1aWQgPSAwO1xuXG4gIGZ1bmN0aW9uIHNob3VsZFByaW50Q29tbWEkMShvcHRpb25zLCBsZXZlbCkge1xuICAgIGxldmVsID0gbGV2ZWwgfHwgXCJlczVcIjtcblxuICAgIHN3aXRjaCAob3B0aW9ucy50cmFpbGluZ0NvbW1hKSB7XG4gICAgICBjYXNlIFwiYWxsXCI6XG4gICAgICAgIGlmIChsZXZlbCA9PT0gXCJhbGxcIikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgIC8vIGZhbGx0aHJvdWdoXG5cbiAgICAgIGNhc2UgXCJlczVcIjpcbiAgICAgICAgaWYgKGxldmVsID09PSBcImVzNVwiKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgLy8gZmFsbHRocm91Z2hcblxuICAgICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmljUHJpbnQkMyhwYXRoLCBvcHRpb25zLCBwcmludFBhdGgsIGFyZ3MpIHtcbiAgICB2YXIgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICB2YXIgbmVlZHNQYXJlbnMgPSBmYWxzZTtcbiAgICB2YXIgbGluZXNXaXRob3V0UGFyZW5zID0gcHJpbnRQYXRoTm9QYXJlbnMocGF0aCwgb3B0aW9ucywgcHJpbnRQYXRoLCBhcmdzKTtcblxuICAgIGlmICghbm9kZSB8fCBpc0VtcHR5JDEobGluZXNXaXRob3V0UGFyZW5zKSkge1xuICAgICAgcmV0dXJuIGxpbmVzV2l0aG91dFBhcmVucztcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50RXhwb3J0RGVjbCA9IGdldFBhcmVudEV4cG9ydERlY2xhcmF0aW9uJDEocGF0aCk7XG4gICAgdmFyIGRlY29yYXRvcnMgPSBbXTtcblxuICAgIGlmIChub2RlLnR5cGUgPT09IFwiQ2xhc3NNZXRob2RcIiB8fCBub2RlLnR5cGUgPT09IFwiQ2xhc3NQcml2YXRlTWV0aG9kXCIgfHwgbm9kZS50eXBlID09PSBcIkNsYXNzUHJvcGVydHlcIiB8fCBub2RlLnR5cGUgPT09IFwiVFNBYnN0cmFjdENsYXNzUHJvcGVydHlcIiB8fCBub2RlLnR5cGUgPT09IFwiQ2xhc3NQcml2YXRlUHJvcGVydHlcIiB8fCBub2RlLnR5cGUgPT09IFwiTWV0aG9kRGVmaW5pdGlvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJUU0Fic3RyYWN0TWV0aG9kRGVmaW5pdGlvblwiKSA7IGVsc2UgaWYgKG5vZGUuZGVjb3JhdG9ycyAmJiBub2RlLmRlY29yYXRvcnMubGVuZ3RoID4gMCAmJiAvLyBJZiB0aGUgcGFyZW50IG5vZGUgaXMgYW4gZXhwb3J0IGRlY2xhcmF0aW9uIGFuZCB0aGUgZGVjb3JhdG9yXG4gICAgLy8gd2FzIHdyaXR0ZW4gYmVmb3JlIHRoZSBleHBvcnQsIHRoZSBleHBvcnQgd2lsbCBiZSByZXNwb25zaWJsZVxuICAgIC8vIGZvciBwcmludGluZyB0aGUgZGVjb3JhdG9ycy5cbiAgICAhKHBhcmVudEV4cG9ydERlY2wgJiYgb3B0aW9ucy5sb2NTdGFydChwYXJlbnRFeHBvcnREZWNsLCB7XG4gICAgICBpZ25vcmVEZWNvcmF0b3JzOiB0cnVlXG4gICAgfSkgPiBvcHRpb25zLmxvY1N0YXJ0KG5vZGUuZGVjb3JhdG9yc1swXSkpKSB7XG4gICAgICB2YXIgc2hvdWxkQnJlYWsgPSBub2RlLnR5cGUgPT09IFwiQ2xhc3NFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIkNsYXNzRGVjbGFyYXRpb25cIiB8fCBoYXNOZXdsaW5lQmV0d2Vlbk9yQWZ0ZXJEZWNvcmF0b3JzJDEobm9kZSwgb3B0aW9ucyk7XG4gICAgICB2YXIgc2VwYXJhdG9yID0gc2hvdWxkQnJlYWsgPyBoYXJkbGluZSQ5IDogbGluZSQ3O1xuICAgICAgcGF0aC5lYWNoKGZ1bmN0aW9uIChkZWNvcmF0b3JQYXRoKSB7XG4gICAgICAgIHZhciBkZWNvcmF0b3IgPSBkZWNvcmF0b3JQYXRoLmdldFZhbHVlKCk7XG5cbiAgICAgICAgaWYgKGRlY29yYXRvci5leHByZXNzaW9uKSB7XG4gICAgICAgICAgZGVjb3JhdG9yID0gZGVjb3JhdG9yLmV4cHJlc3Npb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVjb3JhdG9yID0gZGVjb3JhdG9yLmNhbGxlZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29yYXRvcnMucHVzaChwcmludFBhdGgoZGVjb3JhdG9yUGF0aCksIHNlcGFyYXRvcik7XG4gICAgICB9LCBcImRlY29yYXRvcnNcIik7XG5cbiAgICAgIGlmIChwYXJlbnRFeHBvcnREZWNsKSB7XG4gICAgICAgIGRlY29yYXRvcnMudW5zaGlmdChoYXJkbGluZSQ5KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzRXhwb3J0RGVjbGFyYXRpb24kMShub2RlKSAmJiBub2RlLmRlY2xhcmF0aW9uICYmIG5vZGUuZGVjbGFyYXRpb24uZGVjb3JhdG9ycyAmJiBub2RlLmRlY2xhcmF0aW9uLmRlY29yYXRvcnMubGVuZ3RoID4gMCAmJiAvLyBPbmx5IHByaW50IGRlY29yYXRvcnMgaGVyZSBpZiB0aGV5IHdlcmUgd3JpdHRlbiBiZWZvcmUgdGhlIGV4cG9ydCxcbiAgICAvLyBvdGhlcndpc2UgdGhleSBhcmUgcHJpbnRlZCBieSB0aGUgbm9kZS5kZWNsYXJhdGlvblxuICAgIG9wdGlvbnMubG9jU3RhcnQobm9kZSwge1xuICAgICAgaWdub3JlRGVjb3JhdG9yczogdHJ1ZVxuICAgIH0pID4gb3B0aW9ucy5sb2NTdGFydChub2RlLmRlY2xhcmF0aW9uLmRlY29yYXRvcnNbMF0pKSB7XG4gICAgICAvLyBFeHBvcnQgZGVjbGFyYXRpb25zIGFyZSByZXNwb25zaWJsZSBmb3IgcHJpbnRpbmcgYW55IGRlY29yYXRvcnNcbiAgICAgIC8vIHRoYXQgbG9naWNhbGx5IGFwcGx5IHRvIG5vZGUuZGVjbGFyYXRpb24uXG4gICAgICBwYXRoLmVhY2goZnVuY3Rpb24gKGRlY29yYXRvclBhdGgpIHtcbiAgICAgICAgdmFyIGRlY29yYXRvciA9IGRlY29yYXRvclBhdGguZ2V0VmFsdWUoKTtcbiAgICAgICAgdmFyIHByZWZpeCA9IGRlY29yYXRvci50eXBlID09PSBcIkRlY29yYXRvclwiID8gXCJcIiA6IFwiQFwiO1xuICAgICAgICBkZWNvcmF0b3JzLnB1c2gocHJlZml4LCBwcmludFBhdGgoZGVjb3JhdG9yUGF0aCksIGhhcmRsaW5lJDkpO1xuICAgICAgfSwgXCJkZWNsYXJhdGlvblwiLCBcImRlY29yYXRvcnNcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vZGVzIHdpdGggZGVjb3JhdG9ycyBjYW4ndCBoYXZlIHBhcmVudGhlc2VzLCBzbyB3ZSBjYW4gYXZvaWRcbiAgICAgIC8vIGNvbXB1dGluZyBwYXRoTmVlZHNQYXJlbnMoKSBleGNlcHQgaW4gdGhpcyBjYXNlLlxuICAgICAgbmVlZHNQYXJlbnMgPSBuZWVkc1BhcmVuc18xKHBhdGgsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciBwYXJ0cyA9IFtdO1xuXG4gICAgaWYgKG5lZWRzUGFyZW5zKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KFwiKFwiKTtcbiAgICB9XG5cbiAgICBwYXJ0cy5wdXNoKGxpbmVzV2l0aG91dFBhcmVucyk7XG5cbiAgICBpZiAobmVlZHNQYXJlbnMpIHtcbiAgICAgIHZhciBfbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcblxuICAgICAgaWYgKGhhc0Zsb3dTaG9ydGhhbmRBbm5vdGF0aW9uQ29tbWVudCQyKF9ub2RlKSkge1xuICAgICAgICBwYXJ0cy5wdXNoKFwiIC8qXCIpO1xuICAgICAgICBwYXJ0cy5wdXNoKF9ub2RlLnRyYWlsaW5nQ29tbWVudHNbMF0udmFsdWUudHJpbUxlZnQoKSk7XG4gICAgICAgIHBhcnRzLnB1c2goXCIqL1wiKTtcbiAgICAgICAgX25vZGUudHJhaWxpbmdDb21tZW50c1swXS5wcmludGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcGFydHMucHVzaChcIilcIik7XG4gICAgfVxuXG4gICAgaWYgKGRlY29yYXRvcnMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQoZGVjb3JhdG9ycy5jb25jYXQocGFydHMpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmNhdCRkKHBhcnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50RGVjb3JhdG9ycyhwYXRoLCBvcHRpb25zLCBwcmludCkge1xuICAgIHZhciBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIHJldHVybiBncm91cCRiKGNvbmNhdCRkKFtqb2luJDkobGluZSQ3LCBwYXRoLm1hcChwcmludCwgXCJkZWNvcmF0b3JzXCIpKSwgaGFzTmV3bGluZUJldHdlZW5PckFmdGVyRGVjb3JhdG9ycyQxKG5vZGUsIG9wdGlvbnMpID8gaGFyZGxpbmUkOSA6IGxpbmUkN10pKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGZvbGxvd2luZyBpcyB0aGUgc2hhcmVkIGxvZ2ljIGZvclxuICAgKiB0ZXJuYXJ5IG9wZXJhdG9ycywgbmFtZWx5IENvbmRpdGlvbmFsRXhwcmVzc2lvblxuICAgKiBhbmQgVFNDb25kaXRpb25hbFR5cGVcbiAgICogQHR5cGVkZWYge09iamVjdH0gT3BlcmF0b3JPcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7KCkgPT4gQXJyYXk8c3RyaW5nIHwgRG9jPn0gYmVmb3JlUGFydHMgLSBQYXJ0cyB0byBwcmludCBiZWZvcmUgdGhlIGA/YC5cbiAgICogQHByb3BlcnR5IHsoYnJlYWtDbG9zaW5nUGFyZW46IGJvb2xlYW4pID0+IEFycmF5PHN0cmluZyB8IERvYz59IGFmdGVyUGFydHMgLSBQYXJ0cyB0byBwcmludCBhZnRlciB0aGUgY29uZGl0aW9uYWwgZXhwcmVzc2lvbi5cbiAgICogQHByb3BlcnR5IHtib29sZWFufSBzaG91bGRDaGVja0pzeCAtIFdoZXRoZXIgdG8gY2hlY2sgZm9yIGFuZCBwcmludCBpbiBKU1ggbW9kZS5cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbmRpdGlvbmFsTm9kZVR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgY29uZGl0aW9uYWwgZXhwcmVzc2lvbiBub2RlLCBpZSBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiIG9yIFwiVFNDb25kaXRpb25hbFR5cGVcIi5cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbnNlcXVlbnROb2RlUHJvcGVydHlOYW1lIC0gVGhlIHByb3BlcnR5IGF0IHdoaWNoIHRoZSBjb25zZXF1ZW50IG5vZGUgY2FuIGJlIGZvdW5kIG9uIHRoZSBtYWluIG5vZGUsIGVnIFwiY29uc2VxdWVudFwiLlxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gYWx0ZXJuYXRlTm9kZVByb3BlcnR5TmFtZSAtIFRoZSBwcm9wZXJ0eSBhdCB3aGljaCB0aGUgYWx0ZXJuYXRlIG5vZGUgY2FuIGJlIGZvdW5kIG9uIHRoZSBtYWluIG5vZGUsIGVnIFwiYWx0ZXJuYXRlXCIuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0ZXN0Tm9kZVByb3BlcnR5TmFtZSAtIFRoZSBwcm9wZXJ0eSBhdCB3aGljaCB0aGUgdGVzdCBub2RlIGNhbiBiZSBmb3VuZCBvbiB0aGUgbWFpbiBub2RlLCBlZyBcInRlc3RcIi5cbiAgICogQHByb3BlcnR5IHtib29sZWFufSBicmVha05lc3RlZCAtIFdoZXRoZXIgdG8gYnJlYWsgYWxsIG5lc3RlZCB0ZXJuYXJpZXMgd2hlbiBvbmUgYnJlYWtzLlxuICAgKiBAcGFyYW0ge0Zhc3RQYXRofSBwYXRoIC0gVGhlIHBhdGggdG8gdGhlIENvbmRpdGlvbmFsRXhwcmVzc2lvbi9UU0NvbmRpdGlvbmFsVHlwZSBub2RlLlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgLSBQcmV0dGllciBvcHRpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByaW50IC0gUHJpbnQgZnVuY3Rpb24gdG8gY2FsbCByZWN1cnNpdmVseVxuICAgKiBAcGFyYW0ge09wZXJhdG9yT3B0aW9uc30gb3BlcmF0b3JPcHRpb25zXG4gICAqIEByZXR1cm5zIERvY1xuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHByaW50VGVybmFyeU9wZXJhdG9yKHBhdGgsIG9wdGlvbnMsIHByaW50LCBvcGVyYXRvck9wdGlvbnMpIHtcbiAgICB2YXIgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICB2YXIgdGVzdE5vZGUgPSBub2RlW29wZXJhdG9yT3B0aW9ucy50ZXN0Tm9kZVByb3BlcnR5TmFtZV07XG4gICAgdmFyIGNvbnNlcXVlbnROb2RlID0gbm9kZVtvcGVyYXRvck9wdGlvbnMuY29uc2VxdWVudE5vZGVQcm9wZXJ0eU5hbWVdO1xuICAgIHZhciBhbHRlcm5hdGVOb2RlID0gbm9kZVtvcGVyYXRvck9wdGlvbnMuYWx0ZXJuYXRlTm9kZVByb3BlcnR5TmFtZV07XG4gICAgdmFyIHBhcnRzID0gW107IC8vIFdlIHByaW50IGEgQ29uZGl0aW9uYWxFeHByZXNzaW9uIGluIGVpdGhlciBcIkpTWCBtb2RlXCIgb3IgXCJub3JtYWwgbW9kZVwiLlxuICAgIC8vIFNlZSB0ZXN0cy9qc3gvY29uZGl0aW9uYWwtZXhwcmVzc2lvbi5qcyBmb3IgbW9yZSBpbmZvLlxuXG4gICAgdmFyIGpzeE1vZGUgPSBmYWxzZTtcbiAgICB2YXIgcGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG4gICAgdmFyIGZvcmNlTm9JbmRlbnQgPSBwYXJlbnQudHlwZSA9PT0gb3BlcmF0b3JPcHRpb25zLmNvbmRpdGlvbmFsTm9kZVR5cGU7IC8vIEZpbmQgdGhlIG91dGVybW9zdCBub24tQ29uZGl0aW9uYWxFeHByZXNzaW9uIHBhcmVudCwgYW5kIHRoZSBvdXRlcm1vc3RcbiAgICAvLyBDb25kaXRpb25hbEV4cHJlc3Npb24gcGFyZW50LiBXZSdsbCB1c2UgdGhlc2UgdG8gZGV0ZXJtaW5lIGlmIHdlIHNob3VsZFxuICAgIC8vIHByaW50IGluIEpTWCBtb2RlLlxuXG4gICAgdmFyIGN1cnJlbnRQYXJlbnQ7XG4gICAgdmFyIHByZXZpb3VzUGFyZW50O1xuICAgIHZhciBpID0gMDtcblxuICAgIGRvIHtcbiAgICAgIHByZXZpb3VzUGFyZW50ID0gY3VycmVudFBhcmVudCB8fCBub2RlO1xuICAgICAgY3VycmVudFBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZShpKTtcbiAgICAgIGkrKztcbiAgICB9IHdoaWxlIChjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQudHlwZSA9PT0gb3BlcmF0b3JPcHRpb25zLmNvbmRpdGlvbmFsTm9kZVR5cGUpO1xuXG4gICAgdmFyIGZpcnN0Tm9uQ29uZGl0aW9uYWxQYXJlbnQgPSBjdXJyZW50UGFyZW50IHx8IHBhcmVudDtcbiAgICB2YXIgbGFzdENvbmRpdGlvbmFsUGFyZW50ID0gcHJldmlvdXNQYXJlbnQ7XG5cbiAgICBpZiAob3BlcmF0b3JPcHRpb25zLnNob3VsZENoZWNrSnN4ICYmIChpc0pTWE5vZGUkMSh0ZXN0Tm9kZSkgfHwgaXNKU1hOb2RlJDEoY29uc2VxdWVudE5vZGUpIHx8IGlzSlNYTm9kZSQxKGFsdGVybmF0ZU5vZGUpIHx8IGNvbmRpdGlvbmFsRXhwcmVzc2lvbkNoYWluQ29udGFpbnNKU1gkMShsYXN0Q29uZGl0aW9uYWxQYXJlbnQpKSkge1xuICAgICAganN4TW9kZSA9IHRydWU7XG4gICAgICBmb3JjZU5vSW5kZW50ID0gdHJ1ZTsgLy8gRXZlbiB0aG91Z2ggdGhleSBkb24ndCBuZWVkIHBhcmVucywgd2Ugd3JhcCAoYWxtb3N0KSBldmVyeXRoaW5nIGluXG4gICAgICAvLyBwYXJlbnMgd2hlbiB1c2luZyA/OiB3aXRoaW4gSlNYLCBiZWNhdXNlIHRoZSBwYXJlbnMgYXJlIGFuYWxvZ291cyB0b1xuICAgICAgLy8gY3VybHkgYnJhY2VzIGluIGFuIGlmIHN0YXRlbWVudC5cblxuICAgICAgdmFyIHdyYXAgPSBmdW5jdGlvbiB3cmFwKGRvYykge1xuICAgICAgICByZXR1cm4gY29uY2F0JGQoW2lmQnJlYWskNihcIihcIiwgXCJcIiksIGluZGVudCQ3KGNvbmNhdCRkKFtzb2Z0bGluZSQ2LCBkb2NdKSksIHNvZnRsaW5lJDYsIGlmQnJlYWskNihcIilcIiwgXCJcIildKTtcbiAgICAgIH07IC8vIFRoZSBvbmx5IHRoaW5ncyB3ZSBkb24ndCB3cmFwIGFyZTpcbiAgICAgIC8vICogTmVzdGVkIGNvbmRpdGlvbmFsIGV4cHJlc3Npb25zIGluIGFsdGVybmF0ZXNcbiAgICAgIC8vICogbnVsbFxuXG5cbiAgICAgIHZhciBpc051bGwgPSBmdW5jdGlvbiBpc051bGwobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIk51bGxMaXRlcmFsXCIgfHwgbm9kZS50eXBlID09PSBcIkxpdGVyYWxcIiAmJiBub2RlLnZhbHVlID09PSBudWxsO1xuICAgICAgfTtcblxuICAgICAgcGFydHMucHVzaChcIiA/IFwiLCBpc051bGwoY29uc2VxdWVudE5vZGUpID8gcGF0aC5jYWxsKHByaW50LCBvcGVyYXRvck9wdGlvbnMuY29uc2VxdWVudE5vZGVQcm9wZXJ0eU5hbWUpIDogd3JhcChwYXRoLmNhbGwocHJpbnQsIG9wZXJhdG9yT3B0aW9ucy5jb25zZXF1ZW50Tm9kZVByb3BlcnR5TmFtZSkpLCBcIiA6IFwiLCBhbHRlcm5hdGVOb2RlLnR5cGUgPT09IG9wZXJhdG9yT3B0aW9ucy5jb25kaXRpb25hbE5vZGVUeXBlIHx8IGlzTnVsbChhbHRlcm5hdGVOb2RlKSA/IHBhdGguY2FsbChwcmludCwgb3BlcmF0b3JPcHRpb25zLmFsdGVybmF0ZU5vZGVQcm9wZXJ0eU5hbWUpIDogd3JhcChwYXRoLmNhbGwocHJpbnQsIG9wZXJhdG9yT3B0aW9ucy5hbHRlcm5hdGVOb2RlUHJvcGVydHlOYW1lKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub3JtYWwgbW9kZVxuICAgICAgdmFyIHBhcnQgPSBjb25jYXQkZChbbGluZSQ3LCBcIj8gXCIsIGNvbnNlcXVlbnROb2RlLnR5cGUgPT09IG9wZXJhdG9yT3B0aW9ucy5jb25kaXRpb25hbE5vZGVUeXBlID8gaWZCcmVhayQ2KFwiXCIsIFwiKFwiKSA6IFwiXCIsIGFsaWduJDEoMiwgcGF0aC5jYWxsKHByaW50LCBvcGVyYXRvck9wdGlvbnMuY29uc2VxdWVudE5vZGVQcm9wZXJ0eU5hbWUpKSwgY29uc2VxdWVudE5vZGUudHlwZSA9PT0gb3BlcmF0b3JPcHRpb25zLmNvbmRpdGlvbmFsTm9kZVR5cGUgPyBpZkJyZWFrJDYoXCJcIiwgXCIpXCIpIDogXCJcIiwgbGluZSQ3LCBcIjogXCIsIGFsdGVybmF0ZU5vZGUudHlwZSA9PT0gb3BlcmF0b3JPcHRpb25zLmNvbmRpdGlvbmFsTm9kZVR5cGUgPyBwYXRoLmNhbGwocHJpbnQsIG9wZXJhdG9yT3B0aW9ucy5hbHRlcm5hdGVOb2RlUHJvcGVydHlOYW1lKSA6IGFsaWduJDEoMiwgcGF0aC5jYWxsKHByaW50LCBvcGVyYXRvck9wdGlvbnMuYWx0ZXJuYXRlTm9kZVByb3BlcnR5TmFtZSkpXSk7XG4gICAgICBwYXJ0cy5wdXNoKHBhcmVudC50eXBlICE9PSBvcGVyYXRvck9wdGlvbnMuY29uZGl0aW9uYWxOb2RlVHlwZSB8fCBwYXJlbnRbb3BlcmF0b3JPcHRpb25zLmFsdGVybmF0ZU5vZGVQcm9wZXJ0eU5hbWVdID09PSBub2RlID8gcGFydCA6IG9wdGlvbnMudXNlVGFicyA/IGRlZGVudCQyKGluZGVudCQ3KHBhcnQpKSA6IGFsaWduJDEoTWF0aC5tYXgoMCwgb3B0aW9ucy50YWJXaWR0aCAtIDIpLCBwYXJ0KSk7XG4gICAgfSAvLyBXZSB3YW50IGEgd2hvbGUgY2hhaW4gb2YgQ29uZGl0aW9uYWxFeHByZXNzaW9ucyB0byBhbGxcbiAgICAvLyBicmVhayBpZiBhbnkgb2YgdGhlbSBicmVhay4gVGhhdCBtZWFucyB3ZSBzaG91bGQgb25seSBncm91cCBhcm91bmQgdGhlXG4gICAgLy8gb3V0ZXItbW9zdCBDb25kaXRpb25hbEV4cHJlc3Npb24uXG5cblxuICAgIHZhciBtYXliZUdyb3VwID0gZnVuY3Rpb24gbWF5YmVHcm91cChkb2MpIHtcbiAgICAgIHJldHVybiBvcGVyYXRvck9wdGlvbnMuYnJlYWtOZXN0ZWQgPyBwYXJlbnQgPT09IGZpcnN0Tm9uQ29uZGl0aW9uYWxQYXJlbnQgPyBncm91cCRiKGRvYykgOiBkb2MgOiBncm91cCRiKGRvYyk7XG4gICAgfTsgLy8gQnJlYWsgdGhlIGNsb3NpbmcgcGFyZW4gdG8ga2VlcCB0aGUgY2hhaW4gcmlnaHQgYWZ0ZXIgaXQ6XG4gICAgLy8gKGFcbiAgICAvLyAgID8gYlxuICAgIC8vICAgOiBjXG4gICAgLy8gKS5jYWxsKClcblxuXG4gICAgdmFyIGJyZWFrQ2xvc2luZ1BhcmVuID0gIWpzeE1vZGUgJiYgKHBhcmVudC50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJOR1BpcGVFeHByZXNzaW9uXCIgJiYgcGFyZW50LmxlZnQgPT09IG5vZGUgJiYgb3BlcmF0b3JPcHRpb25zLmJyZWFrTmVzdGVkKSAmJiAhcGFyZW50LmNvbXB1dGVkO1xuICAgIHJldHVybiBtYXliZUdyb3VwKGNvbmNhdCRkKFtdLmNvbmNhdChmdW5jdGlvbiAodGVzdERvYykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgLyoqXG4gICAgICAgICAqICAgICBhXG4gICAgICAgICAqICAgICAgID8gYlxuICAgICAgICAgKiAgICAgICA6IG11bHRpbGluZVxuICAgICAgICAgKiAgICAgICAgIHRlc3RcbiAgICAgICAgICogICAgICAgICBub2RlXG4gICAgICAgICAqICAgICAgIF5eIGFsaWduKDIpXG4gICAgICAgICAqICAgICAgID8gZFxuICAgICAgICAgKiAgICAgICA6IGVcbiAgICAgICAgICovXG4gICAgICAgIHBhcmVudC50eXBlID09PSBvcGVyYXRvck9wdGlvbnMuY29uZGl0aW9uYWxOb2RlVHlwZSAmJiBwYXJlbnRbb3BlcmF0b3JPcHRpb25zLmFsdGVybmF0ZU5vZGVQcm9wZXJ0eU5hbWVdID09PSBub2RlID8gYWxpZ24kMSgyLCB0ZXN0RG9jKSA6IHRlc3REb2NcbiAgICAgICk7XG4gICAgfShjb25jYXQkZChvcGVyYXRvck9wdGlvbnMuYmVmb3JlUGFydHMoKSkpLCBmb3JjZU5vSW5kZW50ID8gY29uY2F0JGQocGFydHMpIDogaW5kZW50JDcoY29uY2F0JGQocGFydHMpKSwgb3BlcmF0b3JPcHRpb25zLmFmdGVyUGFydHMoYnJlYWtDbG9zaW5nUGFyZW4pKSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRQYXRoTm9QYXJlbnMocGF0aCwgb3B0aW9ucywgcHJpbnQsIGFyZ3MpIHtcbiAgICB2YXIgbiA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICB2YXIgc2VtaSA9IG9wdGlvbnMuc2VtaSA/IFwiO1wiIDogXCJcIjtcblxuICAgIGlmICghbikge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gbjtcbiAgICB9XG5cbiAgICB2YXIgaHRtbEJpbmRpbmcgPSBwcmludEh0bWxCaW5kaW5nJDEocGF0aCwgb3B0aW9ucywgcHJpbnQpO1xuXG4gICAgaWYgKGh0bWxCaW5kaW5nKSB7XG4gICAgICByZXR1cm4gaHRtbEJpbmRpbmc7XG4gICAgfVxuXG4gICAgdmFyIHBhcnRzID0gW107XG5cbiAgICBzd2l0Y2ggKG4udHlwZSkge1xuICAgICAgY2FzZSBcIkpzRXhwcmVzc2lvblJvb3RcIjpcbiAgICAgICAgcmV0dXJuIHBhdGguY2FsbChwcmludCwgXCJub2RlXCIpO1xuXG4gICAgICBjYXNlIFwiSnNvblJvb3RcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtwYXRoLmNhbGwocHJpbnQsIFwibm9kZVwiKSwgaGFyZGxpbmUkOV0pO1xuXG4gICAgICBjYXNlIFwiRmlsZVwiOlxuICAgICAgICAvLyBQcmludCBAYmFiZWwvcGFyc2VyJ3MgSW50ZXJwcmV0ZXJEaXJlY3RpdmUgaGVyZSBzbyB0aGF0XG4gICAgICAgIC8vIGxlYWRpbmcgY29tbWVudHMgb24gdGhlIGBQcm9ncmFtYCBub2RlIGdldCBwcmludGVkIGFmdGVyIHRoZSBoYXNoYmFuZy5cbiAgICAgICAgaWYgKG4ucHJvZ3JhbSAmJiBuLnByb2dyYW0uaW50ZXJwcmV0ZXIpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChmdW5jdGlvbiAocHJvZ3JhbVBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9ncmFtUGF0aC5jYWxsKHByaW50LCBcImludGVycHJldGVyXCIpO1xuICAgICAgICAgIH0sIFwicHJvZ3JhbVwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJwcm9ncmFtXCIpKTtcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKHBhcnRzKTtcblxuICAgICAgY2FzZSBcIlByb2dyYW1cIjpcbiAgICAgICAgLy8gQmFiZWwgNlxuICAgICAgICBpZiAobi5kaXJlY3RpdmVzKSB7XG4gICAgICAgICAgcGF0aC5lYWNoKGZ1bmN0aW9uIChjaGlsZFBhdGgpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2gocHJpbnQoY2hpbGRQYXRoKSwgc2VtaSwgaGFyZGxpbmUkOSk7XG5cbiAgICAgICAgICAgIGlmIChpc05leHRMaW5lRW1wdHkkNChvcHRpb25zLm9yaWdpbmFsVGV4dCwgY2hpbGRQYXRoLmdldFZhbHVlKCksIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgIHBhcnRzLnB1c2goaGFyZGxpbmUkOSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgXCJkaXJlY3RpdmVzXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwoZnVuY3Rpb24gKGJvZHlQYXRoKSB7XG4gICAgICAgICAgcmV0dXJuIHByaW50U3RhdGVtZW50U2VxdWVuY2UoYm9keVBhdGgsIG9wdGlvbnMsIHByaW50KTtcbiAgICAgICAgfSwgXCJib2R5XCIpKTtcbiAgICAgICAgcGFydHMucHVzaChjb21tZW50cy5wcmludERhbmdsaW5nQ29tbWVudHMocGF0aCwgb3B0aW9ucyxcbiAgICAgICAgLyogc2FtZUluZGVudCAqL1xuICAgICAgICB0cnVlKSk7IC8vIE9ubHkgZm9yY2UgYSB0cmFpbGluZyBuZXdsaW5lIGlmIHRoZXJlIHdlcmUgYW55IGNvbnRlbnRzLlxuXG4gICAgICAgIGlmIChuLmJvZHkubGVuZ3RoIHx8IG4uY29tbWVudHMpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKGhhcmRsaW5lJDkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKHBhcnRzKTtcbiAgICAgIC8vIEJhYmVsIGV4dGVuc2lvbi5cblxuICAgICAgY2FzZSBcIkVtcHR5U3RhdGVtZW50XCI6XG4gICAgICAgIHJldHVybiBcIlwiO1xuXG4gICAgICBjYXNlIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiOlxuICAgICAgICAvLyBEZXRlY3QgRmxvdy1wYXJzZWQgZGlyZWN0aXZlc1xuICAgICAgICBpZiAobi5kaXJlY3RpdmUpIHtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JGQoW25vZGVTdHIobi5leHByZXNzaW9uLCBvcHRpb25zLCB0cnVlKSwgc2VtaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucGFyc2VyID09PSBcIl9fdnVlX2V2ZW50X2JpbmRpbmdcIikge1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXRoLmdldFBhcmVudE5vZGUoKTtcblxuICAgICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gXCJQcm9ncmFtXCIgJiYgcGFyZW50LmJvZHkubGVuZ3RoID09PSAxICYmIHBhcmVudC5ib2R5WzBdID09PSBuKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0JGQoW3BhdGguY2FsbChwcmludCwgXCJleHByZXNzaW9uXCIpLCBpc1Z1ZUV2ZW50QmluZGluZ0V4cHJlc3Npb24kMyhuLmV4cHJlc3Npb24pID8gXCI7XCIgOiBcIlwiXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIERvIG5vdCBhcHBlbmQgc2VtaWNvbG9uIGFmdGVyIHRoZSBvbmx5IEpTWCBlbGVtZW50IGluIGEgcHJvZ3JhbVxuXG5cbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtwYXRoLmNhbGwocHJpbnQsIFwiZXhwcmVzc2lvblwiKSwgaXNUaGVPbmx5SlNYRWxlbWVudEluTWFya2Rvd24kMShvcHRpb25zLCBwYXRoKSA/IFwiXCIgOiBzZW1pXSk7XG4gICAgICAvLyBCYWJlbCBleHRlbnNpb24uXG5cbiAgICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW1wiKFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiZXhwcmVzc2lvblwiKSwgXCIpXCJdKTtcblxuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiBwcmludEFzc2lnbm1lbnQobi5sZWZ0LCBwYXRoLmNhbGwocHJpbnQsIFwibGVmdFwiKSwgY29uY2F0JGQoW1wiIFwiLCBuLm9wZXJhdG9yXSksIG4ucmlnaHQsIHBhdGguY2FsbChwcmludCwgXCJyaWdodFwiKSwgb3B0aW9ucyk7XG5cbiAgICAgIGNhc2UgXCJCaW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiTG9naWNhbEV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJOR1BpcGVFeHByZXNzaW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3BhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpO1xuXG4gICAgICAgICAgdmFyIHBhcmVudFBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgxKTtcbiAgICAgICAgICB2YXIgaXNJbnNpZGVQYXJlbnRoZXNpcyA9IG4gIT09IF9wYXJlbnQuYm9keSAmJiAoX3BhcmVudC50eXBlID09PSBcIklmU3RhdGVtZW50XCIgfHwgX3BhcmVudC50eXBlID09PSBcIldoaWxlU3RhdGVtZW50XCIgfHwgX3BhcmVudC50eXBlID09PSBcIlN3aXRjaFN0YXRlbWVudFwiIHx8IF9wYXJlbnQudHlwZSA9PT0gXCJEb1doaWxlU3RhdGVtZW50XCIpO1xuXG4gICAgICAgICAgdmFyIF9wYXJ0cyA9IHByaW50QmluYXJ5aXNoRXhwcmVzc2lvbnMocGF0aCwgcHJpbnQsIG9wdGlvbnMsXG4gICAgICAgICAgLyogaXNOZXN0ZWQgKi9cbiAgICAgICAgICBmYWxzZSwgaXNJbnNpZGVQYXJlbnRoZXNpcyk7IC8vICAgaWYgKFxuICAgICAgICAgIC8vICAgICB0aGlzLmhhc1BsdWdpbihcImR5bmFtaWNJbXBvcnRzXCIpICYmIHRoaXMubG9va2FoZWFkKCkudHlwZSA9PT0gdHQucGFyZW5MZWZ0XG4gICAgICAgICAgLy8gICApIHtcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIGxvb2tzIHN1cGVyIHdlaXJkLCB3ZSB3YW50IHRvIGJyZWFrIHRoZSBjaGlsZHJlbiBpZiB0aGUgcGFyZW50IGJyZWFrc1xuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gICBpZiAoXG4gICAgICAgICAgLy8gICAgIHRoaXMuaGFzUGx1Z2luKFwiZHluYW1pY0ltcG9ydHNcIikgJiZcbiAgICAgICAgICAvLyAgICAgdGhpcy5sb29rYWhlYWQoKS50eXBlID09PSB0dC5wYXJlbkxlZnRcbiAgICAgICAgICAvLyAgICkge1xuXG5cbiAgICAgICAgICBpZiAoaXNJbnNpZGVQYXJlbnRoZXNpcykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKF9wYXJ0cyk7XG4gICAgICAgICAgfSAvLyBCcmVhayBiZXR3ZWVuIHRoZSBwYXJlbnMgaW5cbiAgICAgICAgICAvLyB1bmFyaWVzIG9yIGluIGEgbWVtYmVyIG9yIHNwZWNpZmljIGNhbGwgZXhwcmVzc2lvbiwgaS5lLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gICAoXG4gICAgICAgICAgLy8gICAgIGEgJiZcbiAgICAgICAgICAvLyAgICAgYiAmJlxuICAgICAgICAgIC8vICAgICBjXG4gICAgICAgICAgLy8gICApLmNhbGwoKVxuXG5cbiAgICAgICAgICBpZiAoKF9wYXJlbnQudHlwZSA9PT0gXCJDYWxsRXhwcmVzc2lvblwiIHx8IF9wYXJlbnQudHlwZSA9PT0gXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCIpICYmIF9wYXJlbnQuY2FsbGVlID09PSBuIHx8IF9wYXJlbnQudHlwZSA9PT0gXCJVbmFyeUV4cHJlc3Npb25cIiB8fCAoX3BhcmVudC50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiB8fCBfcGFyZW50LnR5cGUgPT09IFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIpICYmICFfcGFyZW50LmNvbXB1dGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXAkYihjb25jYXQkZChbaW5kZW50JDcoY29uY2F0JGQoW3NvZnRsaW5lJDYsIGNvbmNhdCRkKF9wYXJ0cyldKSksIHNvZnRsaW5lJDZdKSk7XG4gICAgICAgICAgfSAvLyBBdm9pZCBpbmRlbnRpbmcgc3ViLWV4cHJlc3Npb25zIGluIHNvbWUgY2FzZXMgd2hlcmUgdGhlIGZpcnN0IHN1Yi1leHByZXNzaW9uIGlzIGFscmVhZHlcbiAgICAgICAgICAvLyBpbmRlbnRlZCBhY2NvcmRpbmdseS4gV2Ugc2hvdWxkIGluZGVudCBzdWItZXhwcmVzc2lvbnMgd2hlcmUgdGhlIGZpcnN0IGNhc2UgaXNuJ3QgaW5kZW50ZWQuXG5cblxuICAgICAgICAgIHZhciBzaG91bGROb3RJbmRlbnQgPSBfcGFyZW50LnR5cGUgPT09IFwiUmV0dXJuU3RhdGVtZW50XCIgfHwgX3BhcmVudC50eXBlID09PSBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIiAmJiBwYXJlbnRQYXJlbnQudHlwZSA9PT0gXCJKU1hBdHRyaWJ1dGVcIiB8fCBuLnR5cGUgIT09IFwiTkdQaXBlRXhwcmVzc2lvblwiICYmIChfcGFyZW50LnR5cGUgPT09IFwiTkdSb290XCIgJiYgb3B0aW9ucy5wYXJzZXIgPT09IFwiX19uZ19iaW5kaW5nXCIgfHwgX3BhcmVudC50eXBlID09PSBcIk5HTWljcm9zeW50YXhFeHByZXNzaW9uXCIgJiYgcGFyZW50UGFyZW50LnR5cGUgPT09IFwiTkdNaWNyb3N5bnRheFwiICYmIHBhcmVudFBhcmVudC5ib2R5Lmxlbmd0aCA9PT0gMSkgfHwgbiA9PT0gX3BhcmVudC5ib2R5ICYmIF9wYXJlbnQudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiIHx8IG4gIT09IF9wYXJlbnQuYm9keSAmJiBfcGFyZW50LnR5cGUgPT09IFwiRm9yU3RhdGVtZW50XCIgfHwgX3BhcmVudC50eXBlID09PSBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiICYmIHBhcmVudFBhcmVudC50eXBlICE9PSBcIlJldHVyblN0YXRlbWVudFwiICYmIHBhcmVudFBhcmVudC50eXBlICE9PSBcIkNhbGxFeHByZXNzaW9uXCIgJiYgcGFyZW50UGFyZW50LnR5cGUgIT09IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiO1xuICAgICAgICAgIHZhciBzaG91bGRJbmRlbnRJZklubGluaW5nID0gX3BhcmVudC50eXBlID09PSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIgfHwgX3BhcmVudC50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRvclwiIHx8IF9wYXJlbnQudHlwZSA9PT0gXCJDbGFzc1Byb3BlcnR5XCIgfHwgX3BhcmVudC50eXBlID09PSBcIlRTQWJzdHJhY3RDbGFzc1Byb3BlcnR5XCIgfHwgX3BhcmVudC50eXBlID09PSBcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCIgfHwgX3BhcmVudC50eXBlID09PSBcIk9iamVjdFByb3BlcnR5XCIgfHwgX3BhcmVudC50eXBlID09PSBcIlByb3BlcnR5XCI7XG4gICAgICAgICAgdmFyIHNhbWVQcmVjZWRlbmNlU3ViRXhwcmVzc2lvbiA9IGlzQmluYXJ5aXNoJDEobi5sZWZ0KSAmJiBzaG91bGRGbGF0dGVuJDEobi5vcGVyYXRvciwgbi5sZWZ0Lm9wZXJhdG9yKTtcblxuICAgICAgICAgIGlmIChzaG91bGROb3RJbmRlbnQgfHwgc2hvdWxkSW5saW5lTG9naWNhbEV4cHJlc3Npb24obikgJiYgIXNhbWVQcmVjZWRlbmNlU3ViRXhwcmVzc2lvbiB8fCAhc2hvdWxkSW5saW5lTG9naWNhbEV4cHJlc3Npb24obikgJiYgc2hvdWxkSW5kZW50SWZJbmxpbmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQoX3BhcnRzKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF9wYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgIH0gLy8gSWYgdGhlIHJpZ2h0IHBhcnQgaXMgYSBKU1ggbm9kZSwgd2UgaW5jbHVkZSBpdCBpbiBhIHNlcGFyYXRlIGdyb3VwIHRvXG4gICAgICAgICAgLy8gcHJldmVudCBpdCBicmVha2luZyB0aGUgd2hvbGUgY2hhaW4sIHNvIHdlIGNhbiBwcmludCB0aGUgZXhwcmVzc2lvbiBsaWtlOlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gICBmb28gJiYgYmFyICYmIChcbiAgICAgICAgICAvLyAgICAgPEZvbz5cbiAgICAgICAgICAvLyAgICAgICA8QmFyIC8+XG4gICAgICAgICAgLy8gICAgIDwvRm9vPlxuICAgICAgICAgIC8vICAgKVxuXG5cbiAgICAgICAgICB2YXIgaGFzSlNYID0gaXNKU1hOb2RlJDEobi5yaWdodCk7XG4gICAgICAgICAgdmFyIHJlc3QgPSBjb25jYXQkZChoYXNKU1ggPyBfcGFydHMuc2xpY2UoMSwgLTEpIDogX3BhcnRzLnNsaWNlKDEpKTtcbiAgICAgICAgICB2YXIgZ3JvdXBJZCA9IFN5bWJvbChcImxvZ2ljYWxDaGFpbi1cIiArICsrdWlkKTtcbiAgICAgICAgICB2YXIgY2hhaW4gPSBncm91cCRiKGNvbmNhdCRkKFsvLyBEb24ndCBpbmNsdWRlIHRoZSBpbml0aWFsIGV4cHJlc3Npb24gaW4gdGhlIGluZGVudGF0aW9uXG4gICAgICAgICAgLy8gbGV2ZWwuIFRoZSBmaXJzdCBpdGVtIGlzIGd1YXJhbnRlZWQgdG8gYmUgdGhlIGZpcnN0XG4gICAgICAgICAgLy8gbGVmdC1tb3N0IGV4cHJlc3Npb24uXG4gICAgICAgICAgX3BhcnRzLmxlbmd0aCA+IDAgPyBfcGFydHNbMF0gOiBcIlwiLCBpbmRlbnQkNyhyZXN0KV0pLCB7XG4gICAgICAgICAgICBpZDogZ3JvdXBJZFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKCFoYXNKU1gpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFpbjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIganN4UGFydCA9IGdldExhc3QkMihfcGFydHMpO1xuICAgICAgICAgIHJldHVybiBncm91cCRiKGNvbmNhdCRkKFtjaGFpbiwgaWZCcmVhayQ2KGluZGVudCQ3KGpzeFBhcnQpLCBqc3hQYXJ0LCB7XG4gICAgICAgICAgICBncm91cElkOiBncm91cElkXG4gICAgICAgICAgfSldKSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbcGF0aC5jYWxsKHByaW50LCBcImxlZnRcIiksIFwiID0gXCIsIHBhdGguY2FsbChwcmludCwgXCJyaWdodFwiKV0pO1xuXG4gICAgICBjYXNlIFwiVFNUeXBlQXNzZXJ0aW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgc2hvdWxkQnJlYWtBZnRlckNhc3QgPSAhKG4uZXhwcmVzc2lvbi50eXBlID09PSBcIkFycmF5RXhwcmVzc2lvblwiIHx8IG4uZXhwcmVzc2lvbi50eXBlID09PSBcIk9iamVjdEV4cHJlc3Npb25cIik7XG4gICAgICAgICAgdmFyIGNhc3RHcm91cCA9IGdyb3VwJGIoY29uY2F0JGQoW1wiPFwiLCBpbmRlbnQkNyhjb25jYXQkZChbc29mdGxpbmUkNiwgcGF0aC5jYWxsKHByaW50LCBcInR5cGVBbm5vdGF0aW9uXCIpXSkpLCBzb2Z0bGluZSQ2LCBcIj5cIl0pKTtcbiAgICAgICAgICB2YXIgZXhwckNvbnRlbnRzID0gY29uY2F0JGQoW2lmQnJlYWskNihcIihcIiksIGluZGVudCQ3KGNvbmNhdCRkKFtzb2Z0bGluZSQ2LCBwYXRoLmNhbGwocHJpbnQsIFwiZXhwcmVzc2lvblwiKV0pKSwgc29mdGxpbmUkNiwgaWZCcmVhayQ2KFwiKVwiKV0pO1xuXG4gICAgICAgICAgaWYgKHNob3VsZEJyZWFrQWZ0ZXJDYXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gY29uZGl0aW9uYWxHcm91cCQxKFtjb25jYXQkZChbY2FzdEdyb3VwLCBwYXRoLmNhbGwocHJpbnQsIFwiZXhwcmVzc2lvblwiKV0pLCBjb25jYXQkZChbY2FzdEdyb3VwLCBncm91cCRiKGV4cHJDb250ZW50cywge1xuICAgICAgICAgICAgICBzaG91bGRCcmVhazogdHJ1ZVxuICAgICAgICAgICAgfSldKSwgY29uY2F0JGQoW2Nhc3RHcm91cCwgcGF0aC5jYWxsKHByaW50LCBcImV4cHJlc3Npb25cIildKV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBncm91cCRiKGNvbmNhdCRkKFtjYXN0R3JvdXAsIHBhdGguY2FsbChwcmludCwgXCJleHByZXNzaW9uXCIpXSkpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3BhcmVudDIgPSBwYXRoLmdldFBhcmVudE5vZGUoKTtcblxuICAgICAgICAgIHZhciBmaXJzdE5vbk1lbWJlclBhcmVudDtcbiAgICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBmaXJzdE5vbk1lbWJlclBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZShpKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9IHdoaWxlIChmaXJzdE5vbk1lbWJlclBhcmVudCAmJiAoZmlyc3ROb25NZW1iZXJQYXJlbnQudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgfHwgZmlyc3ROb25NZW1iZXJQYXJlbnQudHlwZSA9PT0gXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIiB8fCBmaXJzdE5vbk1lbWJlclBhcmVudC50eXBlID09PSBcIlRTTm9uTnVsbEV4cHJlc3Npb25cIikpO1xuXG4gICAgICAgICAgdmFyIHNob3VsZElubGluZSA9IGZpcnN0Tm9uTWVtYmVyUGFyZW50ICYmIChmaXJzdE5vbk1lbWJlclBhcmVudC50eXBlID09PSBcIk5ld0V4cHJlc3Npb25cIiB8fCBmaXJzdE5vbk1lbWJlclBhcmVudC50eXBlID09PSBcIkJpbmRFeHByZXNzaW9uXCIgfHwgZmlyc3ROb25NZW1iZXJQYXJlbnQudHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0b3JcIiAmJiBmaXJzdE5vbk1lbWJlclBhcmVudC5pZC50eXBlICE9PSBcIklkZW50aWZpZXJcIiB8fCBmaXJzdE5vbk1lbWJlclBhcmVudC50eXBlID09PSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIgJiYgZmlyc3ROb25NZW1iZXJQYXJlbnQubGVmdC50eXBlICE9PSBcIklkZW50aWZpZXJcIikgfHwgbi5jb21wdXRlZCB8fCBuLm9iamVjdC50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBuLnByb3BlcnR5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIF9wYXJlbnQyLnR5cGUgIT09IFwiTWVtYmVyRXhwcmVzc2lvblwiICYmIF9wYXJlbnQyLnR5cGUgIT09IFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCI7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtwYXRoLmNhbGwocHJpbnQsIFwib2JqZWN0XCIpLCBzaG91bGRJbmxpbmUgPyBwcmludE1lbWJlckxvb2t1cChwYXRoLCBvcHRpb25zLCBwcmludCkgOiBncm91cCRiKGluZGVudCQ3KGNvbmNhdCRkKFtzb2Z0bGluZSQ2LCBwcmludE1lbWJlckxvb2t1cChwYXRoLCBvcHRpb25zLCBwcmludCldKSkpXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIk1ldGFQcm9wZXJ0eVwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW3BhdGguY2FsbChwcmludCwgXCJtZXRhXCIpLCBcIi5cIiwgcGF0aC5jYWxsKHByaW50LCBcInByb3BlcnR5XCIpXSk7XG5cbiAgICAgIGNhc2UgXCJCaW5kRXhwcmVzc2lvblwiOlxuICAgICAgICBpZiAobi5vYmplY3QpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJvYmplY3RcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFydHMucHVzaChncm91cCRiKGluZGVudCQ3KGNvbmNhdCRkKFtzb2Z0bGluZSQ2LCBwcmludEJpbmRFeHByZXNzaW9uQ2FsbGVlKHBhdGgsIG9wdGlvbnMsIHByaW50KV0pKSkpO1xuICAgICAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuXG4gICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtuLm5hbWUsIHByaW50T3B0aW9uYWxUb2tlbihwYXRoKSwgcHJpbnRUeXBlQW5ub3RhdGlvbihwYXRoLCBvcHRpb25zLCBwcmludCldKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiVjhJbnRyaW5zaWNJZGVudGlmaWVyXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbXCIlXCIsIG4ubmFtZV0pO1xuXG4gICAgICBjYXNlIFwiU3ByZWFkRWxlbWVudFwiOlxuICAgICAgY2FzZSBcIlNwcmVhZEVsZW1lbnRQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiUmVzdFByb3BlcnR5XCI6XG4gICAgICBjYXNlIFwiU3ByZWFkUHJvcGVydHlcIjpcbiAgICAgIGNhc2UgXCJTcHJlYWRQcm9wZXJ0eVBhdHRlcm5cIjpcbiAgICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgICAgY2FzZSBcIk9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eVwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW1wiLi4uXCIsIHBhdGguY2FsbChwcmludCwgXCJhcmd1bWVudFwiKSwgcHJpbnRUeXBlQW5ub3RhdGlvbihwYXRoLCBvcHRpb25zLCBwcmludCldKTtcblxuICAgICAgY2FzZSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIjpcbiAgICAgIGNhc2UgXCJGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICAgICAgcGFydHMucHVzaChwcmludEZ1bmN0aW9uRGVjbGFyYXRpb24ocGF0aCwgcHJpbnQsIG9wdGlvbnMpKTtcblxuICAgICAgICBpZiAoIW4uYm9keSkge1xuICAgICAgICAgIHBhcnRzLnB1c2goc2VtaSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuXG4gICAgICBjYXNlIFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChuLmFzeW5jKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwiYXN5bmMgXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzaG91bGRQcmludFBhcmFtc1dpdGhvdXRQYXJlbnMocGF0aCwgb3B0aW9ucykpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcInBhcmFtc1wiLCAwKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goZ3JvdXAkYihjb25jYXQkZChbcHJpbnRGdW5jdGlvblBhcmFtcyhwYXRoLCBwcmludCwgb3B0aW9ucyxcbiAgICAgICAgICAgIC8qIGV4cGFuZExhc3QgKi9cbiAgICAgICAgICAgIGFyZ3MgJiYgKGFyZ3MuZXhwYW5kTGFzdEFyZyB8fCBhcmdzLmV4cGFuZEZpcnN0QXJnKSxcbiAgICAgICAgICAgIC8qIHByaW50VHlwZVBhcmFtcyAqL1xuICAgICAgICAgICAgdHJ1ZSksIHByaW50UmV0dXJuVHlwZShwYXRoLCBwcmludCwgb3B0aW9ucyldKSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBkYW5nbGluZyA9IGNvbW1lbnRzLnByaW50RGFuZ2xpbmdDb21tZW50cyhwYXRoLCBvcHRpb25zLFxuICAgICAgICAgIC8qIHNhbWVJbmRlbnQgKi9cbiAgICAgICAgICB0cnVlLCBmdW5jdGlvbiAoY29tbWVudCkge1xuICAgICAgICAgICAgdmFyIG5leHRDaGFyYWN0ZXIgPSBnZXROZXh0Tm9uU3BhY2VOb25Db21tZW50Q2hhcmFjdGVySW5kZXgkMihvcHRpb25zLm9yaWdpbmFsVGV4dCwgY29tbWVudCwgb3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5vcmlnaW5hbFRleHQuc3Vic3RyKG5leHRDaGFyYWN0ZXIsIDIpID09PSBcIj0+XCI7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoZGFuZ2xpbmcpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCIgXCIsIGRhbmdsaW5nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJ0cy5wdXNoKFwiID0+XCIpO1xuICAgICAgICAgIHZhciBib2R5ID0gcGF0aC5jYWxsKGZ1bmN0aW9uIChib2R5UGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHByaW50KGJvZHlQYXRoLCBhcmdzKTtcbiAgICAgICAgICB9LCBcImJvZHlcIik7IC8vIFdlIHdhbnQgdG8gYWx3YXlzIGtlZXAgdGhlc2UgdHlwZXMgb2Ygbm9kZXMgb24gdGhlIHNhbWUgbGluZVxuICAgICAgICAgIC8vIGFzIHRoZSBhcnJvdy5cblxuICAgICAgICAgIGlmICghaGFzTGVhZGluZ093bkxpbmVDb21tZW50JDEob3B0aW9ucy5vcmlnaW5hbFRleHQsIG4uYm9keSwgb3B0aW9ucykgJiYgKG4uYm9keS50eXBlID09PSBcIkFycmF5RXhwcmVzc2lvblwiIHx8IG4uYm9keS50eXBlID09PSBcIk9iamVjdEV4cHJlc3Npb25cIiB8fCBuLmJvZHkudHlwZSA9PT0gXCJCbG9ja1N0YXRlbWVudFwiIHx8IGlzSlNYTm9kZSQxKG4uYm9keSkgfHwgaXNUZW1wbGF0ZU9uSXRzT3duTGluZSQxKG4uYm9keSwgb3B0aW9ucy5vcmlnaW5hbFRleHQsIG9wdGlvbnMpIHx8IG4uYm9keS50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgfHwgbi5ib2R5LnR5cGUgPT09IFwiRG9FeHByZXNzaW9uXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXAkYihjb25jYXQkZChbY29uY2F0JGQocGFydHMpLCBcIiBcIiwgYm9keV0pKTtcbiAgICAgICAgICB9IC8vIFdlIGhhbmRsZSBzZXF1ZW5jZSBleHByZXNzaW9ucyBhcyB0aGUgYm9keSBvZiBhcnJvd3Mgc3BlY2lhbGx5LFxuICAgICAgICAgIC8vIHNvIHRoYXQgdGhlIHJlcXVpcmVkIHBhcmVudGhlc2VzIGVuZCB1cCBvbiB0aGVpciBvd24gbGluZXMuXG5cblxuICAgICAgICAgIGlmIChuLmJvZHkudHlwZSA9PT0gXCJTZXF1ZW5jZUV4cHJlc3Npb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQoW2NvbmNhdCRkKHBhcnRzKSwgZ3JvdXAkYihjb25jYXQkZChbXCIgKFwiLCBpbmRlbnQkNyhjb25jYXQkZChbc29mdGxpbmUkNiwgYm9keV0pKSwgc29mdGxpbmUkNiwgXCIpXCJdKSldKSk7XG4gICAgICAgICAgfSAvLyBpZiB0aGUgYXJyb3cgZnVuY3Rpb24gaXMgZXhwYW5kZWQgYXMgbGFzdCBhcmd1bWVudCwgd2UgYXJlIGFkZGluZyBhXG4gICAgICAgICAgLy8gbGV2ZWwgb2YgaW5kZW50YXRpb24gYW5kIG5lZWQgdG8gYWRkIGEgc29mdGxpbmUgdG8gYWxpZ24gdGhlIGNsb3NpbmcgKVxuICAgICAgICAgIC8vIHdpdGggdGhlIG9wZW5pbmcgKCwgb3IgaWYgaXQncyBpbnNpZGUgYSBKU1hFeHByZXNzaW9uIChlLmcuIGFuIGF0dHJpYnV0ZSlcbiAgICAgICAgICAvLyB3ZSBzaG91bGQgYWxpZ24gdGhlIGV4cHJlc3Npb24ncyBjbG9zaW5nIH0gd2l0aCB0aGUgbGluZSB3aXRoIHRoZSBvcGVuaW5nIHsuXG5cblxuICAgICAgICAgIHZhciBzaG91bGRBZGRTb2Z0TGluZSA9IChhcmdzICYmIGFyZ3MuZXhwYW5kTGFzdEFyZyB8fCBwYXRoLmdldFBhcmVudE5vZGUoKS50eXBlID09PSBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIikgJiYgIShuLmNvbW1lbnRzICYmIG4uY29tbWVudHMubGVuZ3RoKTtcbiAgICAgICAgICB2YXIgcHJpbnRUcmFpbGluZ0NvbW1hID0gYXJncyAmJiBhcmdzLmV4cGFuZExhc3RBcmcgJiYgc2hvdWxkUHJpbnRDb21tYSQxKG9wdGlvbnMsIFwiYWxsXCIpOyAvLyBJbiBvcmRlciB0byBhdm9pZCBjb25mdXNpb24gYmV0d2VlblxuICAgICAgICAgIC8vIGEgPT4gYSA/IGEgOiBhXG4gICAgICAgICAgLy8gYSA8PSBhID8gYSA6IGFcblxuICAgICAgICAgIHZhciBzaG91bGRBZGRQYXJlbnMgPSBuLmJvZHkudHlwZSA9PT0gXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIiAmJiAhc3RhcnRzV2l0aE5vTG9va2FoZWFkVG9rZW4kMShuLmJvZHksXG4gICAgICAgICAgLyogZm9yYmlkRnVuY3Rpb25BbmRDbGFzcyAqL1xuICAgICAgICAgIGZhbHNlKTtcbiAgICAgICAgICByZXR1cm4gZ3JvdXAkYihjb25jYXQkZChbY29uY2F0JGQocGFydHMpLCBncm91cCRiKGNvbmNhdCRkKFtpbmRlbnQkNyhjb25jYXQkZChbbGluZSQ3LCBzaG91bGRBZGRQYXJlbnMgPyBpZkJyZWFrJDYoXCJcIiwgXCIoXCIpIDogXCJcIiwgYm9keSwgc2hvdWxkQWRkUGFyZW5zID8gaWZCcmVhayQ2KFwiXCIsIFwiKVwiKSA6IFwiXCJdKSksIHNob3VsZEFkZFNvZnRMaW5lID8gY29uY2F0JGQoW2lmQnJlYWskNihwcmludFRyYWlsaW5nQ29tbWEgPyBcIixcIiA6IFwiXCIpLCBzb2Z0bGluZSQ2XSkgOiBcIlwiXSkpXSkpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJZaWVsZEV4cHJlc3Npb25cIjpcbiAgICAgICAgcGFydHMucHVzaChcInlpZWxkXCIpO1xuXG4gICAgICAgIGlmIChuLmRlbGVnYXRlKSB7XG4gICAgICAgICAgcGFydHMucHVzaChcIipcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobi5hcmd1bWVudCkge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCIgXCIsIHBhdGguY2FsbChwcmludCwgXCJhcmd1bWVudFwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuXG4gICAgICBjYXNlIFwiQXdhaXRFeHByZXNzaW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKFwiYXdhaXQgXCIsIHBhdGguY2FsbChwcmludCwgXCJhcmd1bWVudFwiKSk7XG5cbiAgICAgICAgICB2YXIgX3BhcmVudDMgPSBwYXRoLmdldFBhcmVudE5vZGUoKTtcblxuICAgICAgICAgIGlmICgoX3BhcmVudDMudHlwZSA9PT0gXCJDYWxsRXhwcmVzc2lvblwiIHx8IF9wYXJlbnQzLnR5cGUgPT09IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiKSAmJiBfcGFyZW50My5jYWxsZWUgPT09IG4gfHwgKF9wYXJlbnQzLnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiIHx8IF9wYXJlbnQzLnR5cGUgPT09IFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIpICYmIF9wYXJlbnQzLm9iamVjdCA9PT0gbikge1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQoW2luZGVudCQ3KGNvbmNhdCRkKFtzb2Z0bGluZSQ2LCBjb25jYXQkZChwYXJ0cyldKSksIHNvZnRsaW5lJDZdKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKHBhcnRzKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiSW1wb3J0U3BlY2lmaWVyXCI6XG4gICAgICAgIGlmIChuLmltcG9ydEtpbmQpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJpbXBvcnRLaW5kXCIpLCBcIiBcIik7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJpbXBvcnRlZFwiKSk7XG5cbiAgICAgICAgaWYgKG4ubG9jYWwgJiYgbi5sb2NhbC5uYW1lICE9PSBuLmltcG9ydGVkLm5hbWUpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKFwiIGFzIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwibG9jYWxcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKHBhcnRzKTtcblxuICAgICAgY2FzZSBcIkV4cG9ydFNwZWNpZmllclwiOlxuICAgICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJsb2NhbFwiKSk7XG5cbiAgICAgICAgaWYgKG4uZXhwb3J0ZWQgJiYgbi5leHBvcnRlZC5uYW1lICE9PSBuLmxvY2FsLm5hbWUpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKFwiIGFzIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiZXhwb3J0ZWRcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKHBhcnRzKTtcblxuICAgICAgY2FzZSBcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiOlxuICAgICAgICBwYXJ0cy5wdXNoKFwiKiBhcyBcIik7XG4gICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcImxvY2FsXCIpKTtcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKHBhcnRzKTtcblxuICAgICAgY2FzZSBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIjpcbiAgICAgICAgcmV0dXJuIHBhdGguY2FsbChwcmludCwgXCJsb2NhbFwiKTtcblxuICAgICAgY2FzZSBcIlRTRXhwb3J0QXNzaWdubWVudFwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW1wiZXhwb3J0ID0gXCIsIHBhdGguY2FsbChwcmludCwgXCJleHByZXNzaW9uXCIpLCBzZW1pXSk7XG5cbiAgICAgIGNhc2UgXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIjpcbiAgICAgIGNhc2UgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCI6XG4gICAgICAgIHJldHVybiBwcmludEV4cG9ydERlY2xhcmF0aW9uKHBhdGgsIG9wdGlvbnMsIHByaW50KTtcblxuICAgICAgY2FzZSBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCI6XG4gICAgICAgIHBhcnRzLnB1c2goXCJleHBvcnQgXCIpO1xuXG4gICAgICAgIGlmIChuLmV4cG9ydEtpbmQgPT09IFwidHlwZVwiKSB7XG4gICAgICAgICAgcGFydHMucHVzaChcInR5cGUgXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFydHMucHVzaChcIiogZnJvbSBcIiwgcGF0aC5jYWxsKHByaW50LCBcInNvdXJjZVwiKSwgc2VtaSk7XG4gICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG5cbiAgICAgIGNhc2UgXCJFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIjpcbiAgICAgIGNhc2UgXCJFeHBvcnREZWZhdWx0U3BlY2lmaWVyXCI6XG4gICAgICAgIHJldHVybiBwYXRoLmNhbGwocHJpbnQsIFwiZXhwb3J0ZWRcIik7XG5cbiAgICAgIGNhc2UgXCJJbXBvcnREZWNsYXJhdGlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgcGFydHMucHVzaChcImltcG9ydCBcIik7XG5cbiAgICAgICAgICBpZiAobi5pbXBvcnRLaW5kICYmIG4uaW1wb3J0S2luZCAhPT0gXCJ2YWx1ZVwiKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKG4uaW1wb3J0S2luZCArIFwiIFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc3RhbmRhbG9uZXMgPSBbXTtcbiAgICAgICAgICB2YXIgZ3JvdXBlZCA9IFtdO1xuXG4gICAgICAgICAgaWYgKG4uc3BlY2lmaWVycyAmJiBuLnNwZWNpZmllcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcGF0aC5lYWNoKGZ1bmN0aW9uIChzcGVjaWZpZXJQYXRoKSB7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNwZWNpZmllclBhdGguZ2V0VmFsdWUoKTtcblxuICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIgfHwgdmFsdWUudHlwZSA9PT0gXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIikge1xuICAgICAgICAgICAgICAgIHN0YW5kYWxvbmVzLnB1c2gocHJpbnQoc3BlY2lmaWVyUGF0aCkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdyb3VwZWQucHVzaChwcmludChzcGVjaWZpZXJQYXRoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFwic3BlY2lmaWVyc1wiKTtcblxuICAgICAgICAgICAgaWYgKHN0YW5kYWxvbmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgcGFydHMucHVzaChqb2luJDkoXCIsIFwiLCBzdGFuZGFsb25lcykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RhbmRhbG9uZXMubGVuZ3RoID4gMCAmJiBncm91cGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgcGFydHMucHVzaChcIiwgXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZ3JvdXBlZC5sZW5ndGggPT09IDEgJiYgc3RhbmRhbG9uZXMubGVuZ3RoID09PSAwICYmIG4uc3BlY2lmaWVycyAmJiAhbi5zcGVjaWZpZXJzLnNvbWUoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuY29tbWVudHM7XG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGNvbmNhdCRkKFtcIntcIiwgb3B0aW9ucy5icmFja2V0U3BhY2luZyA/IFwiIFwiIDogXCJcIiwgY29uY2F0JGQoZ3JvdXBlZCksIG9wdGlvbnMuYnJhY2tldFNwYWNpbmcgPyBcIiBcIiA6IFwiXCIsIFwifVwiXSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChncm91cGVkLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgICAgICAgIHBhcnRzLnB1c2goZ3JvdXAkYihjb25jYXQkZChbXCJ7XCIsIGluZGVudCQ3KGNvbmNhdCRkKFtvcHRpb25zLmJyYWNrZXRTcGFjaW5nID8gbGluZSQ3IDogc29mdGxpbmUkNiwgam9pbiQ5KGNvbmNhdCRkKFtcIixcIiwgbGluZSQ3XSksIGdyb3VwZWQpXSkpLCBpZkJyZWFrJDYoc2hvdWxkUHJpbnRDb21tYSQxKG9wdGlvbnMpID8gXCIsXCIgOiBcIlwiKSwgb3B0aW9ucy5icmFja2V0U3BhY2luZyA/IGxpbmUkNyA6IHNvZnRsaW5lJDYsIFwifVwiXSkpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFydHMucHVzaChcIiBmcm9tIFwiKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG4uaW1wb3J0S2luZCAmJiBuLmltcG9ydEtpbmQgPT09IFwidHlwZVwiIHx8IC8vIGltcG9ydCB7fSBmcm9tICd4J1xuICAgICAgICAgIC97XFxzKn0vLnRlc3Qob3B0aW9ucy5vcmlnaW5hbFRleHQuc2xpY2Uob3B0aW9ucy5sb2NTdGFydChuKSwgb3B0aW9ucy5sb2NTdGFydChuLnNvdXJjZSkpKSkge1xuICAgICAgICAgICAgcGFydHMucHVzaChcInt9IGZyb20gXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcInNvdXJjZVwiKSwgc2VtaSk7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKHBhcnRzKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiSW1wb3J0XCI6XG4gICAgICAgIHJldHVybiBcImltcG9ydFwiO1xuXG4gICAgICBjYXNlIFwiVFNNb2R1bGVCbG9ja1wiOlxuICAgICAgY2FzZSBcIkJsb2NrU3RhdGVtZW50XCI6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbmFrZWQgPSBwYXRoLmNhbGwoZnVuY3Rpb24gKGJvZHlQYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJpbnRTdGF0ZW1lbnRTZXF1ZW5jZShib2R5UGF0aCwgb3B0aW9ucywgcHJpbnQpO1xuICAgICAgICAgIH0sIFwiYm9keVwiKTtcbiAgICAgICAgICB2YXIgaGFzQ29udGVudCA9IG4uYm9keS5maW5kKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS50eXBlICE9PSBcIkVtcHR5U3RhdGVtZW50XCI7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGhhc0RpcmVjdGl2ZXMgPSBuLmRpcmVjdGl2ZXMgJiYgbi5kaXJlY3RpdmVzLmxlbmd0aCA+IDA7XG5cbiAgICAgICAgICB2YXIgX3BhcmVudDQgPSBwYXRoLmdldFBhcmVudE5vZGUoKTtcblxuICAgICAgICAgIHZhciBfcGFyZW50UGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKDEpO1xuXG4gICAgICAgICAgaWYgKCFoYXNDb250ZW50ICYmICFoYXNEaXJlY3RpdmVzICYmICFoYXNEYW5nbGluZ0NvbW1lbnRzJDEobikgJiYgKF9wYXJlbnQ0LnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiB8fCBfcGFyZW50NC50eXBlID09PSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiIHx8IF9wYXJlbnQ0LnR5cGUgPT09IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiIHx8IF9wYXJlbnQ0LnR5cGUgPT09IFwiT2JqZWN0TWV0aG9kXCIgfHwgX3BhcmVudDQudHlwZSA9PT0gXCJDbGFzc01ldGhvZFwiIHx8IF9wYXJlbnQ0LnR5cGUgPT09IFwiQ2xhc3NQcml2YXRlTWV0aG9kXCIgfHwgX3BhcmVudDQudHlwZSA9PT0gXCJGb3JTdGF0ZW1lbnRcIiB8fCBfcGFyZW50NC50eXBlID09PSBcIldoaWxlU3RhdGVtZW50XCIgfHwgX3BhcmVudDQudHlwZSA9PT0gXCJEb1doaWxlU3RhdGVtZW50XCIgfHwgX3BhcmVudDQudHlwZSA9PT0gXCJEb0V4cHJlc3Npb25cIiB8fCBfcGFyZW50NC50eXBlID09PSBcIkNhdGNoQ2xhdXNlXCIgJiYgIV9wYXJlbnRQYXJlbnQuZmluYWxpemVyIHx8IF9wYXJlbnQ0LnR5cGUgPT09IFwiVFNNb2R1bGVEZWNsYXJhdGlvblwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwie31cIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJ0cy5wdXNoKFwie1wiKTsgLy8gQmFiZWwgNlxuXG4gICAgICAgICAgaWYgKGhhc0RpcmVjdGl2ZXMpIHtcbiAgICAgICAgICAgIHBhdGguZWFjaChmdW5jdGlvbiAoY2hpbGRQYXRoKSB7XG4gICAgICAgICAgICAgIHBhcnRzLnB1c2goaW5kZW50JDcoY29uY2F0JGQoW2hhcmRsaW5lJDksIHByaW50KGNoaWxkUGF0aCksIHNlbWldKSkpO1xuXG4gICAgICAgICAgICAgIGlmIChpc05leHRMaW5lRW1wdHkkNChvcHRpb25zLm9yaWdpbmFsVGV4dCwgY2hpbGRQYXRoLmdldFZhbHVlKCksIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChoYXJkbGluZSQ5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgXCJkaXJlY3RpdmVzXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoYXNDb250ZW50KSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGluZGVudCQ3KGNvbmNhdCRkKFtoYXJkbGluZSQ5LCBuYWtlZF0pKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFydHMucHVzaChjb21tZW50cy5wcmludERhbmdsaW5nQ29tbWVudHMocGF0aCwgb3B0aW9ucykpO1xuICAgICAgICAgIHBhcnRzLnB1c2goaGFyZGxpbmUkOSwgXCJ9XCIpO1xuICAgICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIlJldHVyblN0YXRlbWVudFwiOlxuICAgICAgICBwYXJ0cy5wdXNoKFwicmV0dXJuXCIpO1xuXG4gICAgICAgIGlmIChuLmFyZ3VtZW50KSB7XG4gICAgICAgICAgaWYgKHJldHVybkFyZ3VtZW50SGFzTGVhZGluZ0NvbW1lbnQkMShvcHRpb25zLCBuLmFyZ3VtZW50KSkge1xuICAgICAgICAgICAgcGFydHMucHVzaChjb25jYXQkZChbXCIgKFwiLCBpbmRlbnQkNyhjb25jYXQkZChbaGFyZGxpbmUkOSwgcGF0aC5jYWxsKHByaW50LCBcImFyZ3VtZW50XCIpXSkpLCBoYXJkbGluZSQ5LCBcIilcIl0pKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG4uYXJndW1lbnQudHlwZSA9PT0gXCJMb2dpY2FsRXhwcmVzc2lvblwiIHx8IG4uYXJndW1lbnQudHlwZSA9PT0gXCJCaW5hcnlFeHByZXNzaW9uXCIgfHwgbi5hcmd1bWVudC50eXBlID09PSBcIlNlcXVlbmNlRXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGdyb3VwJGIoY29uY2F0JGQoW2lmQnJlYWskNihcIiAoXCIsIFwiIFwiKSwgaW5kZW50JDcoY29uY2F0JGQoW3NvZnRsaW5lJDYsIHBhdGguY2FsbChwcmludCwgXCJhcmd1bWVudFwiKV0pKSwgc29mdGxpbmUkNiwgaWZCcmVhayQ2KFwiKVwiKV0pKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCIgXCIsIHBhdGguY2FsbChwcmludCwgXCJhcmd1bWVudFwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc0RhbmdsaW5nQ29tbWVudHMkMShuKSkge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCIgXCIsIGNvbW1lbnRzLnByaW50RGFuZ2xpbmdDb21tZW50cyhwYXRoLCBvcHRpb25zLFxuICAgICAgICAgIC8qIHNhbWVJbmRlbnQgKi9cbiAgICAgICAgICB0cnVlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJ0cy5wdXNoKHNlbWkpO1xuICAgICAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuXG4gICAgICBjYXNlIFwiTmV3RXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJDYWxsRXhwcmVzc2lvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGlzTmV3ID0gbi50eXBlID09PSBcIk5ld0V4cHJlc3Npb25cIjtcbiAgICAgICAgICB2YXIgb3B0aW9uYWwgPSBwcmludE9wdGlvbmFsVG9rZW4ocGF0aCk7XG5cbiAgICAgICAgICBpZiAoIC8vIFdlIHdhbnQgdG8ga2VlcCBDb21tb25KUy0gYW5kIEFNRC1zdHlsZSByZXF1aXJlIGNhbGxzLCBhbmQgQU1ELXN0eWxlXG4gICAgICAgICAgLy8gZGVmaW5lIGNhbGxzLCBhcyBhIHVuaXQuXG4gICAgICAgICAgLy8gZS5nLiBgZGVmaW5lKFtcInNvbWUvbGliXCIsIChsaWIpID0+IHtgXG4gICAgICAgICAgIWlzTmV3ICYmIG4uY2FsbGVlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIChuLmNhbGxlZS5uYW1lID09PSBcInJlcXVpcmVcIiB8fCBuLmNhbGxlZS5uYW1lID09PSBcImRlZmluZVwiKSB8fCAvLyBUZW1wbGF0ZSBsaXRlcmFscyBhcyBzaW5nbGUgYXJndW1lbnRzXG4gICAgICAgICAgbi5hcmd1bWVudHMubGVuZ3RoID09PSAxICYmIGlzVGVtcGxhdGVPbkl0c093bkxpbmUkMShuLmFyZ3VtZW50c1swXSwgb3B0aW9ucy5vcmlnaW5hbFRleHQsIG9wdGlvbnMpIHx8IC8vIEtlZXAgdGVzdCBkZWNsYXJhdGlvbnMgb24gYSBzaW5nbGUgbGluZVxuICAgICAgICAgIC8vIGUuZy4gYGl0KCdsb25nIG5hbWUnLCAoKSA9PiB7YFxuICAgICAgICAgICFpc05ldyAmJiBpc1Rlc3RDYWxsJDEobiwgcGF0aC5nZXRQYXJlbnROb2RlKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0JGQoW2lzTmV3ID8gXCJuZXcgXCIgOiBcIlwiLCBwYXRoLmNhbGwocHJpbnQsIFwiY2FsbGVlXCIpLCBvcHRpb25hbCwgcHJpbnRGdW5jdGlvblR5cGVQYXJhbWV0ZXJzKHBhdGgsIG9wdGlvbnMsIHByaW50KSwgY29uY2F0JGQoW1wiKFwiLCBqb2luJDkoXCIsIFwiLCBwYXRoLm1hcChwcmludCwgXCJhcmd1bWVudHNcIikpLCBcIilcIl0pXSk7XG4gICAgICAgICAgfSAvLyBJbmxpbmUgRmxvdyBhbm5vdGF0aW9uIGNvbW1lbnRzIGZvbGxvd2luZyBJZGVudGlmaWVycyBpbiBDYWxsIG5vZGVzIG5lZWQgdG9cbiAgICAgICAgICAvLyBzdGF5IHdpdGggdGhlIElkZW50aWZpZXIuIEZvciBleGFtcGxlOlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gZm9vIC8qOjogPFNvbWVHZW5lcmljPiAqLyhiYXIpO1xuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gSGVyZSwgd2UgZW5zdXJlIHRoYXQgc3VjaCBjb21tZW50cyBzdGF5IGJldHdlZW4gdGhlIElkZW50aWZpZXIgYW5kIHRoZSBDYWxsZWUuXG5cblxuICAgICAgICAgIHZhciBpc0lkZW50aWZpZXJXaXRoRmxvd0Fubm90YXRpb24gPSBuLmNhbGxlZS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBoYXNGbG93QW5ub3RhdGlvbkNvbW1lbnQkMShuLmNhbGxlZS50cmFpbGluZ0NvbW1lbnRzKTtcblxuICAgICAgICAgIGlmIChpc0lkZW50aWZpZXJXaXRoRmxvd0Fubm90YXRpb24pIHtcbiAgICAgICAgICAgIG4uY2FsbGVlLnRyYWlsaW5nQ29tbWVudHNbMF0ucHJpbnRlZCA9IHRydWU7XG4gICAgICAgICAgfSAvLyBXZSBkZXRlY3QgY2FsbHMgb24gbWVtYmVyIGxvb2t1cHMgYW5kIHBvc3NpYmx5IHByaW50IHRoZW0gaW4gYVxuICAgICAgICAgIC8vIHNwZWNpYWwgY2hhaW4gZm9ybWF0LiBTZWUgYHByaW50TWVtYmVyQ2hhaW5gIGZvciBtb3JlIGluZm8uXG5cblxuICAgICAgICAgIGlmICghaXNOZXcgJiYgaXNNZW1iZXJpc2gkMShuLmNhbGxlZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmludE1lbWJlckNoYWluKHBhdGgsIG9wdGlvbnMsIHByaW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY29udGVudHMgPSBjb25jYXQkZChbaXNOZXcgPyBcIm5ldyBcIiA6IFwiXCIsIHBhdGguY2FsbChwcmludCwgXCJjYWxsZWVcIiksIG9wdGlvbmFsLCBpc0lkZW50aWZpZXJXaXRoRmxvd0Fubm90YXRpb24gPyBcIi8qOjogXCIuY29uY2F0KG4uY2FsbGVlLnRyYWlsaW5nQ29tbWVudHNbMF0udmFsdWUuc3Vic3RyaW5nKDIpLnRyaW0oKSwgXCIgKi9cIikgOiBcIlwiLCBwcmludEZ1bmN0aW9uVHlwZVBhcmFtZXRlcnMocGF0aCwgb3B0aW9ucywgcHJpbnQpLCBwcmludEFyZ3VtZW50c0xpc3QocGF0aCwgb3B0aW9ucywgcHJpbnQpXSk7IC8vIFdlIGdyb3VwIGhlcmUgd2hlbiB0aGUgY2FsbGVlIGlzIGl0c2VsZiBhIGNhbGwgZXhwcmVzc2lvbi5cbiAgICAgICAgICAvLyBTZWUgYGlzTG9uZ0N1cnJpZWRDYWxsRXhwcmVzc2lvbmAgZm9yIG1vcmUgaW5mby5cblxuICAgICAgICAgIGlmIChpc0NhbGxPck9wdGlvbmFsQ2FsbEV4cHJlc3Npb24kMShuLmNhbGxlZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBncm91cCRiKGNvbnRlbnRzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29udGVudHM7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIlRTSW50ZXJmYWNlRGVjbGFyYXRpb25cIjpcbiAgICAgICAgaWYgKG4uZGVjbGFyZSkge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCJkZWNsYXJlIFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnRzLnB1c2gobi5hYnN0cmFjdCA/IFwiYWJzdHJhY3QgXCIgOiBcIlwiLCBwcmludFR5cGVTY3JpcHRNb2RpZmllcnMocGF0aCwgb3B0aW9ucywgcHJpbnQpLCBcImludGVyZmFjZSBcIiwgcGF0aC5jYWxsKHByaW50LCBcImlkXCIpLCBuLnR5cGVQYXJhbWV0ZXJzID8gcGF0aC5jYWxsKHByaW50LCBcInR5cGVQYXJhbWV0ZXJzXCIpIDogXCJcIiwgXCIgXCIpO1xuXG4gICAgICAgIGlmIChuLmV4dGVuZHMgJiYgbi5leHRlbmRzLmxlbmd0aCkge1xuICAgICAgICAgIHBhcnRzLnB1c2goZ3JvdXAkYihpbmRlbnQkNyhjb25jYXQkZChbc29mdGxpbmUkNiwgXCJleHRlbmRzIFwiLCAobi5leHRlbmRzLmxlbmd0aCA9PT0gMSA/IGlkZW50aXR5JDIgOiBpbmRlbnQkNykoam9pbiQ5KGNvbmNhdCRkKFtcIixcIiwgbGluZSQ3XSksIHBhdGgubWFwKHByaW50LCBcImV4dGVuZHNcIikpKSwgXCIgXCJdKSkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcImJvZHlcIikpO1xuICAgICAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuXG4gICAgICBjYXNlIFwiT2JqZWN0VHlwZUludGVybmFsU2xvdFwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW24uc3RhdGljID8gXCJzdGF0aWMgXCIgOiBcIlwiLCBcIltbXCIsIHBhdGguY2FsbChwcmludCwgXCJpZFwiKSwgXCJdXVwiLCBwcmludE9wdGlvbmFsVG9rZW4ocGF0aCksIG4ubWV0aG9kID8gXCJcIiA6IFwiOiBcIiwgcGF0aC5jYWxsKHByaW50LCBcInZhbHVlXCIpXSk7XG5cbiAgICAgIGNhc2UgXCJPYmplY3RFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgICAgY2FzZSBcIk9iamVjdFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICBjYXNlIFwiVFNJbnRlcmZhY2VCb2R5XCI6XG4gICAgICBjYXNlIFwiVFNUeXBlTGl0ZXJhbFwiOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3BlcnRpZXNGaWVsZDtcblxuICAgICAgICAgIGlmIChuLnR5cGUgPT09IFwiVFNUeXBlTGl0ZXJhbFwiKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzRmllbGQgPSBcIm1lbWJlcnNcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKG4udHlwZSA9PT0gXCJUU0ludGVyZmFjZUJvZHlcIikge1xuICAgICAgICAgICAgcHJvcGVydGllc0ZpZWxkID0gXCJib2R5XCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXNGaWVsZCA9IFwicHJvcGVydGllc1wiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpc1R5cGVBbm5vdGF0aW9uID0gbi50eXBlID09PSBcIk9iamVjdFR5cGVBbm5vdGF0aW9uXCI7XG4gICAgICAgICAgdmFyIGZpZWxkcyA9IFtdO1xuXG4gICAgICAgICAgaWYgKGlzVHlwZUFubm90YXRpb24pIHtcbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKFwiaW5kZXhlcnNcIiwgXCJjYWxsUHJvcGVydGllc1wiLCBcImludGVybmFsU2xvdHNcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmllbGRzLnB1c2gocHJvcGVydGllc0ZpZWxkKTtcbiAgICAgICAgICB2YXIgZmlyc3RQcm9wZXJ0eSA9IGZpZWxkcy5tYXAoZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gbltmaWVsZF1bMF07XG4gICAgICAgICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMubG9jU3RhcnQoYSkgLSBvcHRpb25zLmxvY1N0YXJ0KGIpO1xuICAgICAgICAgIH0pWzBdO1xuXG4gICAgICAgICAgdmFyIF9wYXJlbnQ1ID0gcGF0aC5nZXRQYXJlbnROb2RlKDApO1xuXG4gICAgICAgICAgdmFyIGlzRmxvd0ludGVyZmFjZUxpa2VCb2R5ID0gaXNUeXBlQW5ub3RhdGlvbiAmJiBfcGFyZW50NSAmJiAoX3BhcmVudDUudHlwZSA9PT0gXCJJbnRlcmZhY2VEZWNsYXJhdGlvblwiIHx8IF9wYXJlbnQ1LnR5cGUgPT09IFwiRGVjbGFyZUludGVyZmFjZVwiIHx8IF9wYXJlbnQ1LnR5cGUgPT09IFwiRGVjbGFyZUNsYXNzXCIpICYmIHBhdGguZ2V0TmFtZSgpID09PSBcImJvZHlcIjtcbiAgICAgICAgICB2YXIgc2hvdWxkQnJlYWsgPSBuLnR5cGUgPT09IFwiVFNJbnRlcmZhY2VCb2R5XCIgfHwgaXNGbG93SW50ZXJmYWNlTGlrZUJvZHkgfHwgbi50eXBlID09PSBcIk9iamVjdFBhdHRlcm5cIiAmJiBfcGFyZW50NS50eXBlICE9PSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiAmJiBfcGFyZW50NS50eXBlICE9PSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiICYmIF9wYXJlbnQ1LnR5cGUgIT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiBfcGFyZW50NS50eXBlICE9PSBcIk9iamVjdE1ldGhvZFwiICYmIF9wYXJlbnQ1LnR5cGUgIT09IFwiQ2xhc3NNZXRob2RcIiAmJiBfcGFyZW50NS50eXBlICE9PSBcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiICYmIF9wYXJlbnQ1LnR5cGUgIT09IFwiQXNzaWdubWVudFBhdHRlcm5cIiAmJiBfcGFyZW50NS50eXBlICE9PSBcIkNhdGNoQ2xhdXNlXCIgJiYgbi5wcm9wZXJ0aWVzLnNvbWUoZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcGVydHkudmFsdWUgJiYgKHByb3BlcnR5LnZhbHVlLnR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiIHx8IHByb3BlcnR5LnZhbHVlLnR5cGUgPT09IFwiQXJyYXlQYXR0ZXJuXCIpO1xuICAgICAgICAgIH0pIHx8IG4udHlwZSAhPT0gXCJPYmplY3RQYXR0ZXJuXCIgJiYgZmlyc3RQcm9wZXJ0eSAmJiBoYXNOZXdsaW5lSW5SYW5nZSQyKG9wdGlvbnMub3JpZ2luYWxUZXh0LCBvcHRpb25zLmxvY1N0YXJ0KG4pLCBvcHRpb25zLmxvY1N0YXJ0KGZpcnN0UHJvcGVydHkpKTtcbiAgICAgICAgICB2YXIgc2VwYXJhdG9yID0gaXNGbG93SW50ZXJmYWNlTGlrZUJvZHkgPyBcIjtcIiA6IG4udHlwZSA9PT0gXCJUU0ludGVyZmFjZUJvZHlcIiB8fCBuLnR5cGUgPT09IFwiVFNUeXBlTGl0ZXJhbFwiID8gaWZCcmVhayQ2KHNlbWksIFwiO1wiKSA6IFwiLFwiO1xuICAgICAgICAgIHZhciBsZWZ0QnJhY2UgPSBuLmV4YWN0ID8gXCJ7fFwiIDogXCJ7XCI7XG4gICAgICAgICAgdmFyIHJpZ2h0QnJhY2UgPSBuLmV4YWN0ID8gXCJ8fVwiIDogXCJ9XCI7IC8vIFVuZm9ydHVuYXRlbHksIHRoaW5ncyBhcmUgZ3JvdXBlZCB0b2dldGhlciBpbiB0aGUgYXN0IGNhbiBiZVxuICAgICAgICAgIC8vIGludGVybGVhdmVkIGluIHRoZSBzb3VyY2UgY29kZS4gU28gd2UgbmVlZCB0byByZW9yZGVyIHRoZW0gYmVmb3JlXG4gICAgICAgICAgLy8gcHJpbnRpbmcgdGhlbS5cblxuICAgICAgICAgIHZhciBwcm9wc0FuZExvYyA9IFtdO1xuICAgICAgICAgIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgcGF0aC5lYWNoKGZ1bmN0aW9uIChjaGlsZFBhdGgpIHtcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSBjaGlsZFBhdGguZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgcHJvcHNBbmRMb2MucHVzaCh7XG4gICAgICAgICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICAgICAgICBwcmludGVkOiBwcmludChjaGlsZFBhdGgpLFxuICAgICAgICAgICAgICAgIGxvYzogb3B0aW9ucy5sb2NTdGFydChub2RlKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZpZWxkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgc2VwYXJhdG9yUGFydHMgPSBbXTtcbiAgICAgICAgICB2YXIgcHJvcHMgPSBwcm9wc0FuZExvYy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5sb2MgLSBiLmxvYztcbiAgICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjb25jYXQkZChzZXBhcmF0b3JQYXJ0cy5jb25jYXQoZ3JvdXAkYihwcm9wLnByaW50ZWQpKSk7XG4gICAgICAgICAgICBzZXBhcmF0b3JQYXJ0cyA9IFtzZXBhcmF0b3IsIGxpbmUkN107XG5cbiAgICAgICAgICAgIGlmICgocHJvcC5ub2RlLnR5cGUgPT09IFwiVFNQcm9wZXJ0eVNpZ25hdHVyZVwiIHx8IHByb3Aubm9kZS50eXBlID09PSBcIlRTTWV0aG9kU2lnbmF0dXJlXCIgfHwgcHJvcC5ub2RlLnR5cGUgPT09IFwiVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvblwiKSAmJiBoYXNOb2RlSWdub3JlQ29tbWVudCQyKHByb3Aubm9kZSkpIHtcbiAgICAgICAgICAgICAgc2VwYXJhdG9yUGFydHMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzTmV4dExpbmVFbXB0eSQ0KG9wdGlvbnMub3JpZ2luYWxUZXh0LCBwcm9wLm5vZGUsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgIHNlcGFyYXRvclBhcnRzLnB1c2goaGFyZGxpbmUkOSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAobi5pbmV4YWN0KSB7XG4gICAgICAgICAgICBwcm9wcy5wdXNoKGNvbmNhdCRkKHNlcGFyYXRvclBhcnRzLmNvbmNhdChncm91cCRiKFwiLi4uXCIpKSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBsYXN0RWxlbSA9IGdldExhc3QkMihuW3Byb3BlcnRpZXNGaWVsZF0pO1xuICAgICAgICAgIHZhciBjYW5IYXZlVHJhaWxpbmdTZXBhcmF0b3IgPSAhKGxhc3RFbGVtICYmIChsYXN0RWxlbS50eXBlID09PSBcIlJlc3RQcm9wZXJ0eVwiIHx8IGxhc3RFbGVtLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIiB8fCBoYXNOb2RlSWdub3JlQ29tbWVudCQyKGxhc3RFbGVtKSB8fCBuLmluZXhhY3QpKTtcbiAgICAgICAgICB2YXIgY29udGVudDtcblxuICAgICAgICAgIGlmIChwcm9wcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmICghaGFzRGFuZ2xpbmdDb21tZW50cyQxKG4pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb25jYXQkZChbbGVmdEJyYWNlLCByaWdodEJyYWNlLCBwcmludFR5cGVBbm5vdGF0aW9uKHBhdGgsIG9wdGlvbnMsIHByaW50KV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250ZW50ID0gZ3JvdXAkYihjb25jYXQkZChbbGVmdEJyYWNlLCBjb21tZW50cy5wcmludERhbmdsaW5nQ29tbWVudHMocGF0aCwgb3B0aW9ucyksIHNvZnRsaW5lJDYsIHJpZ2h0QnJhY2UsIHByaW50T3B0aW9uYWxUb2tlbihwYXRoKSwgcHJpbnRUeXBlQW5ub3RhdGlvbihwYXRoLCBvcHRpb25zLCBwcmludCldKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb25jYXQkZChbbGVmdEJyYWNlLCBpbmRlbnQkNyhjb25jYXQkZChbb3B0aW9ucy5icmFja2V0U3BhY2luZyA/IGxpbmUkNyA6IHNvZnRsaW5lJDYsIGNvbmNhdCRkKHByb3BzKV0pKSwgaWZCcmVhayQ2KGNhbkhhdmVUcmFpbGluZ1NlcGFyYXRvciAmJiAoc2VwYXJhdG9yICE9PSBcIixcIiB8fCBzaG91bGRQcmludENvbW1hJDEob3B0aW9ucykpID8gc2VwYXJhdG9yIDogXCJcIiksIGNvbmNhdCRkKFtvcHRpb25zLmJyYWNrZXRTcGFjaW5nID8gbGluZSQ3IDogc29mdGxpbmUkNiwgcmlnaHRCcmFjZV0pLCBwcmludE9wdGlvbmFsVG9rZW4ocGF0aCksIHByaW50VHlwZUFubm90YXRpb24ocGF0aCwgb3B0aW9ucywgcHJpbnQpXSk7XG4gICAgICAgICAgfSAvLyBJZiB3ZSBpbmxpbmUgdGhlIG9iamVjdCBhcyBmaXJzdCBhcmd1bWVudCBvZiB0aGUgcGFyZW50LCB3ZSBkb24ndCB3YW50XG4gICAgICAgICAgLy8gdG8gY3JlYXRlIGFub3RoZXIgZ3JvdXAgc28gdGhhdCB0aGUgb2JqZWN0IGJyZWFrcyBiZWZvcmUgdGhlIHJldHVyblxuICAgICAgICAgIC8vIHR5cGVcblxuXG4gICAgICAgICAgdmFyIHBhcmVudFBhcmVudFBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgyKTtcblxuICAgICAgICAgIGlmIChuLnR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiICYmIF9wYXJlbnQ1ICYmIHNob3VsZEh1Z0FyZ3VtZW50cyhfcGFyZW50NSkgJiYgIW4uZGVjb3JhdG9ycyAmJiBfcGFyZW50NS5wYXJhbXNbMF0gPT09IG4gfHwgc2hvdWxkSHVnVHlwZShuKSAmJiBwYXJlbnRQYXJlbnRQYXJlbnQgJiYgc2hvdWxkSHVnQXJndW1lbnRzKHBhcmVudFBhcmVudFBhcmVudCkgJiYgcGFyZW50UGFyZW50UGFyZW50LnBhcmFtc1swXS50eXBlQW5ub3RhdGlvbiAmJiBwYXJlbnRQYXJlbnRQYXJlbnQucGFyYW1zWzBdLnR5cGVBbm5vdGF0aW9uLnR5cGVBbm5vdGF0aW9uID09PSBuKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZ3JvdXAkYihjb250ZW50LCB7XG4gICAgICAgICAgICBzaG91bGRCcmVhazogc2hvdWxkQnJlYWtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgLy8gQmFiZWwgNlxuXG4gICAgICBjYXNlIFwiT2JqZWN0UHJvcGVydHlcIjogLy8gTm9uLXN0YW5kYXJkIEFTVCBub2RlIHR5cGUuXG5cbiAgICAgIGNhc2UgXCJQcm9wZXJ0eVwiOlxuICAgICAgICBpZiAobi5tZXRob2QgfHwgbi5raW5kID09PSBcImdldFwiIHx8IG4ua2luZCA9PT0gXCJzZXRcIikge1xuICAgICAgICAgIHJldHVybiBwcmludE1ldGhvZChwYXRoLCBvcHRpb25zLCBwcmludCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobi5zaG9ydGhhbmQpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJ2YWx1ZVwiKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFydHMucHVzaChwcmludEFzc2lnbm1lbnQobi5rZXksIHByaW50UHJvcGVydHlLZXkocGF0aCwgb3B0aW9ucywgcHJpbnQpLCBcIjpcIiwgbi52YWx1ZSwgcGF0aC5jYWxsKHByaW50LCBcInZhbHVlXCIpLCBvcHRpb25zKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuICAgICAgLy8gQmFiZWwgNlxuXG4gICAgICBjYXNlIFwiQ2xhc3NNZXRob2RcIjpcbiAgICAgIGNhc2UgXCJDbGFzc1ByaXZhdGVNZXRob2RcIjpcbiAgICAgIGNhc2UgXCJNZXRob2REZWZpbml0aW9uXCI6XG4gICAgICBjYXNlIFwiVFNBYnN0cmFjdE1ldGhvZERlZmluaXRpb25cIjpcbiAgICAgICAgaWYgKG4uZGVjb3JhdG9ycyAmJiBuLmRlY29yYXRvcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgcGFydHMucHVzaChwcmludERlY29yYXRvcnMocGF0aCwgb3B0aW9ucywgcHJpbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuLmFjY2Vzc2liaWxpdHkpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKG4uYWNjZXNzaWJpbGl0eSArIFwiIFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuLnN0YXRpYykge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCJzdGF0aWMgXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG4udHlwZSA9PT0gXCJUU0Fic3RyYWN0TWV0aG9kRGVmaW5pdGlvblwiKSB7XG4gICAgICAgICAgcGFydHMucHVzaChcImFic3RyYWN0IFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnRzLnB1c2gocHJpbnRNZXRob2QocGF0aCwgb3B0aW9ucywgcHJpbnQpKTtcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKHBhcnRzKTtcblxuICAgICAgY2FzZSBcIk9iamVjdE1ldGhvZFwiOlxuICAgICAgICByZXR1cm4gcHJpbnRNZXRob2QocGF0aCwgb3B0aW9ucywgcHJpbnQpO1xuXG4gICAgICBjYXNlIFwiRGVjb3JhdG9yXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbXCJAXCIsIHBhdGguY2FsbChwcmludCwgXCJleHByZXNzaW9uXCIpLCBwYXRoLmNhbGwocHJpbnQsIFwiY2FsbGVlXCIpXSk7XG5cbiAgICAgIGNhc2UgXCJBcnJheUV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICAgICAgaWYgKG4uZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaWYgKCFoYXNEYW5nbGluZ0NvbW1lbnRzJDEobikpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCJbXVwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFydHMucHVzaChncm91cCRiKGNvbmNhdCRkKFtcIltcIiwgY29tbWVudHMucHJpbnREYW5nbGluZ0NvbW1lbnRzKHBhdGgsIG9wdGlvbnMpLCBzb2Z0bGluZSQ2LCBcIl1cIl0pKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfbGFzdEVsZW0gPSBnZXRMYXN0JDIobi5lbGVtZW50cyk7XG5cbiAgICAgICAgICB2YXIgY2FuSGF2ZVRyYWlsaW5nQ29tbWEgPSAhKF9sYXN0RWxlbSAmJiBfbGFzdEVsZW0udHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKTsgLy8gSmF2YVNjcmlwdCBhbGxvd3MgeW91IHRvIGhhdmUgZW1wdHkgZWxlbWVudHMgaW4gYW4gYXJyYXkgd2hpY2hcbiAgICAgICAgICAvLyBjaGFuZ2VzIGl0cyBsZW5ndGggYmFzZWQgb24gdGhlIG51bWJlciBvZiBjb21tYXMuIFRoZSBhbGdvcml0aG1cbiAgICAgICAgICAvLyBpcyB0aGF0IGlmIHRoZSBsYXN0IGFyZ3VtZW50IGlzIG51bGwsIHdlIG5lZWQgdG8gZm9yY2UgaW5zZXJ0XG4gICAgICAgICAgLy8gYSBjb21tYSB0byBlbnN1cmUgSmF2YVNjcmlwdCByZWNvZ25pemVzIGl0LlxuICAgICAgICAgIC8vICAgWyxdLmxlbmd0aCA9PT0gMVxuICAgICAgICAgIC8vICAgWzEsXS5sZW5ndGggPT09IDFcbiAgICAgICAgICAvLyAgIFsxLCxdLmxlbmd0aCA9PT0gMlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gTm90ZSB0aGF0IGdldExhc3QgcmV0dXJucyBudWxsIGlmIHRoZSBhcnJheSBpcyBlbXB0eSwgYnV0XG4gICAgICAgICAgLy8gd2UgYWxyZWFkeSBjaGVjayBmb3IgYW4gZW1wdHkgYXJyYXkganVzdCBhYm92ZSBzbyB3ZSBhcmUgc2FmZVxuXG4gICAgICAgICAgdmFyIG5lZWRzRm9yY2VkVHJhaWxpbmdDb21tYSA9IGNhbkhhdmVUcmFpbGluZ0NvbW1hICYmIF9sYXN0RWxlbSA9PT0gbnVsbDtcblxuICAgICAgICAgIHZhciBfc2hvdWxkQnJlYWsgPSBuLmVsZW1lbnRzLmxlbmd0aCA+IDEgJiYgbi5lbGVtZW50cy5ldmVyeShmdW5jdGlvbiAoZWxlbWVudCwgaSwgZWxlbWVudHMpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50VHlwZSA9IGVsZW1lbnQgJiYgZWxlbWVudC50eXBlO1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudFR5cGUgIT09IFwiQXJyYXlFeHByZXNzaW9uXCIgJiYgZWxlbWVudFR5cGUgIT09IFwiT2JqZWN0RXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG5leHRFbGVtZW50ID0gZWxlbWVudHNbaSArIDFdO1xuXG4gICAgICAgICAgICBpZiAobmV4dEVsZW1lbnQgJiYgZWxlbWVudFR5cGUgIT09IG5leHRFbGVtZW50LnR5cGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaXRlbXNLZXkgPSBlbGVtZW50VHlwZSA9PT0gXCJBcnJheUV4cHJlc3Npb25cIiA/IFwiZWxlbWVudHNcIiA6IFwicHJvcGVydGllc1wiO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRbaXRlbXNLZXldICYmIGVsZW1lbnRbaXRlbXNLZXldLmxlbmd0aCA+IDE7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBwYXJ0cy5wdXNoKGdyb3VwJGIoY29uY2F0JGQoW1wiW1wiLCBpbmRlbnQkNyhjb25jYXQkZChbc29mdGxpbmUkNiwgcHJpbnRBcnJheUl0ZW1zKHBhdGgsIG9wdGlvbnMsIFwiZWxlbWVudHNcIiwgcHJpbnQpXSkpLCBuZWVkc0ZvcmNlZFRyYWlsaW5nQ29tbWEgPyBcIixcIiA6IFwiXCIsIGlmQnJlYWskNihjYW5IYXZlVHJhaWxpbmdDb21tYSAmJiAhbmVlZHNGb3JjZWRUcmFpbGluZ0NvbW1hICYmIHNob3VsZFByaW50Q29tbWEkMShvcHRpb25zKSA/IFwiLFwiIDogXCJcIiksIGNvbW1lbnRzLnByaW50RGFuZ2xpbmdDb21tZW50cyhwYXRoLCBvcHRpb25zLFxuICAgICAgICAgIC8qIHNhbWVJbmRlbnQgKi9cbiAgICAgICAgICB0cnVlKSwgc29mdGxpbmUkNiwgXCJdXCJdKSwge1xuICAgICAgICAgICAgc2hvdWxkQnJlYWs6IF9zaG91bGRCcmVha1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnRzLnB1c2gocHJpbnRPcHRpb25hbFRva2VuKHBhdGgpLCBwcmludFR5cGVBbm5vdGF0aW9uKHBhdGgsIG9wdGlvbnMsIHByaW50KSk7XG4gICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG5cbiAgICAgIGNhc2UgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfcGFyZW50NiA9IHBhdGguZ2V0UGFyZW50Tm9kZSgwKTtcblxuICAgICAgICAgIGlmIChfcGFyZW50Ni50eXBlID09PSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiB8fCBfcGFyZW50Ni50eXBlID09PSBcIkZvclN0YXRlbWVudFwiKSB7XG4gICAgICAgICAgICAvLyBGb3IgRXhwcmVzc2lvblN0YXRlbWVudHMgYW5kIGZvci1sb29wIGhlYWRzLCB3aGljaCBhcmUgYW1vbmdcbiAgICAgICAgICAgIC8vIHRoZSBmZXcgcGxhY2VzIGEgU2VxdWVuY2VFeHByZXNzaW9uIGFwcGVhcnMgdW5wYXJlbnRoZXNpemVkLCB3ZSB3YW50XG4gICAgICAgICAgICAvLyB0byBpbmRlbnQgZXhwcmVzc2lvbnMgYWZ0ZXIgdGhlIGZpcnN0LlxuICAgICAgICAgICAgdmFyIF9wYXJ0czIgPSBbXTtcbiAgICAgICAgICAgIHBhdGguZWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICBpZiAocC5nZXROYW1lKCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBfcGFydHMyLnB1c2gocHJpbnQocCkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9wYXJ0czIucHVzaChcIixcIiwgaW5kZW50JDcoY29uY2F0JGQoW2xpbmUkNywgcHJpbnQocCldKSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBcImV4cHJlc3Npb25zXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQoX3BhcnRzMikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBncm91cCRiKGNvbmNhdCRkKFtqb2luJDkoY29uY2F0JGQoW1wiLFwiLCBsaW5lJDddKSwgcGF0aC5tYXAocHJpbnQsIFwiZXhwcmVzc2lvbnNcIikpXSkpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJUaGlzRXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gXCJ0aGlzXCI7XG5cbiAgICAgIGNhc2UgXCJTdXBlclwiOlxuICAgICAgICByZXR1cm4gXCJzdXBlclwiO1xuXG4gICAgICBjYXNlIFwiTnVsbExpdGVyYWxcIjpcbiAgICAgICAgLy8gQmFiZWwgNiBMaXRlcmFsIHNwbGl0XG4gICAgICAgIHJldHVybiBcIm51bGxcIjtcblxuICAgICAgY2FzZSBcIlJlZ0V4cExpdGVyYWxcIjpcbiAgICAgICAgLy8gQmFiZWwgNiBMaXRlcmFsIHNwbGl0XG4gICAgICAgIHJldHVybiBwcmludFJlZ2V4KG4pO1xuXG4gICAgICBjYXNlIFwiTnVtZXJpY0xpdGVyYWxcIjpcbiAgICAgICAgLy8gQmFiZWwgNiBMaXRlcmFsIHNwbGl0XG4gICAgICAgIHJldHVybiBwcmludE51bWJlciQyKG4uZXh0cmEucmF3KTtcblxuICAgICAgY2FzZSBcIkJpZ0ludExpdGVyYWxcIjpcbiAgICAgICAgLy8gYmFiZWw6IG4uZXh0cmEucmF3LCB0eXBlc2NyaXB0OiBuLnJhdywgZmxvdzogbi5iaWdpbnRcbiAgICAgICAgcmV0dXJuIChuLmJpZ2ludCB8fCAobi5leHRyYSA/IG4uZXh0cmEucmF3IDogbi5yYXcpKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBjYXNlIFwiQm9vbGVhbkxpdGVyYWxcIjogLy8gQmFiZWwgNiBMaXRlcmFsIHNwbGl0XG5cbiAgICAgIGNhc2UgXCJTdHJpbmdMaXRlcmFsXCI6IC8vIEJhYmVsIDYgTGl0ZXJhbCBzcGxpdFxuXG4gICAgICBjYXNlIFwiTGl0ZXJhbFwiOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKG4ucmVnZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmludFJlZ2V4KG4ucmVnZXgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlb2Ygbi52YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHByaW50TnVtYmVyJDIobi5yYXcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlb2Ygbi52YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyBuLnZhbHVlO1xuICAgICAgICAgIH0gLy8gVHlwZVNjcmlwdCB3b3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vSmFtZXNIZW5yeS90eXBlc2NyaXB0LWVzdHJlZS9pc3N1ZXMvMlxuICAgICAgICAgIC8vIFNlZSBjb3JyZXNwb25kaW5nIHdvcmthcm91bmQgaW4gbmVlZHMtcGFyZW5zLmpzXG5cblxuICAgICAgICAgIHZhciBncmFuZFBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgxKTtcbiAgICAgICAgICB2YXIgaXNUeXBlU2NyaXB0RGlyZWN0aXZlID0gb3B0aW9ucy5wYXJzZXIgPT09IFwidHlwZXNjcmlwdFwiICYmIHR5cGVvZiBuLnZhbHVlID09PSBcInN0cmluZ1wiICYmIGdyYW5kUGFyZW50ICYmIChncmFuZFBhcmVudC50eXBlID09PSBcIlByb2dyYW1cIiB8fCBncmFuZFBhcmVudC50eXBlID09PSBcIkJsb2NrU3RhdGVtZW50XCIpO1xuICAgICAgICAgIHJldHVybiBub2RlU3RyKG4sIG9wdGlvbnMsIGlzVHlwZVNjcmlwdERpcmVjdGl2ZSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIkRpcmVjdGl2ZVwiOlxuICAgICAgICByZXR1cm4gcGF0aC5jYWxsKHByaW50LCBcInZhbHVlXCIpO1xuICAgICAgLy8gQmFiZWwgNlxuXG4gICAgICBjYXNlIFwiRGlyZWN0aXZlTGl0ZXJhbFwiOlxuICAgICAgICByZXR1cm4gbm9kZVN0cihuLCBvcHRpb25zKTtcblxuICAgICAgY2FzZSBcIlVuYXJ5RXhwcmVzc2lvblwiOlxuICAgICAgICBwYXJ0cy5wdXNoKG4ub3BlcmF0b3IpO1xuXG4gICAgICAgIGlmICgvW2Etel0kLy50ZXN0KG4ub3BlcmF0b3IpKSB7XG4gICAgICAgICAgcGFydHMucHVzaChcIiBcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobi5hcmd1bWVudC5jb21tZW50cyAmJiBuLmFyZ3VtZW50LmNvbW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKGdyb3VwJGIoY29uY2F0JGQoW1wiKFwiLCBpbmRlbnQkNyhjb25jYXQkZChbc29mdGxpbmUkNiwgcGF0aC5jYWxsKHByaW50LCBcImFyZ3VtZW50XCIpXSkpLCBzb2Z0bGluZSQ2LCBcIilcIl0pKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwiYXJndW1lbnRcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKHBhcnRzKTtcblxuICAgICAgY2FzZSBcIlVwZGF0ZUV4cHJlc3Npb25cIjpcbiAgICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwiYXJndW1lbnRcIiksIG4ub3BlcmF0b3IpO1xuXG4gICAgICAgIGlmIChuLnByZWZpeCkge1xuICAgICAgICAgIHBhcnRzLnJldmVyc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG5cbiAgICAgIGNhc2UgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIHByaW50VGVybmFyeU9wZXJhdG9yKHBhdGgsIG9wdGlvbnMsIHByaW50LCB7XG4gICAgICAgICAgYmVmb3JlUGFydHM6IGZ1bmN0aW9uIGJlZm9yZVBhcnRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtwYXRoLmNhbGwocHJpbnQsIFwidGVzdFwiKV07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhZnRlclBhcnRzOiBmdW5jdGlvbiBhZnRlclBhcnRzKGJyZWFrQ2xvc2luZ1BhcmVuKSB7XG4gICAgICAgICAgICByZXR1cm4gW2JyZWFrQ2xvc2luZ1BhcmVuID8gc29mdGxpbmUkNiA6IFwiXCJdO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2hvdWxkQ2hlY2tKc3g6IHRydWUsXG4gICAgICAgICAgY29uZGl0aW9uYWxOb2RlVHlwZTogXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIixcbiAgICAgICAgICBjb25zZXF1ZW50Tm9kZVByb3BlcnR5TmFtZTogXCJjb25zZXF1ZW50XCIsXG4gICAgICAgICAgYWx0ZXJuYXRlTm9kZVByb3BlcnR5TmFtZTogXCJhbHRlcm5hdGVcIixcbiAgICAgICAgICB0ZXN0Tm9kZVByb3BlcnR5TmFtZTogXCJ0ZXN0XCIsXG4gICAgICAgICAgYnJlYWtOZXN0ZWQ6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcHJpbnRlZCA9IHBhdGgubWFwKGZ1bmN0aW9uIChjaGlsZFBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmludChjaGlsZFBhdGgpO1xuICAgICAgICAgIH0sIFwiZGVjbGFyYXRpb25zXCIpOyAvLyBXZSBnZW5lcmFsbHkgd2FudCB0byB0ZXJtaW5hdGUgYWxsIHZhcmlhYmxlIGRlY2xhcmF0aW9ucyB3aXRoIGFcbiAgICAgICAgICAvLyBzZW1pY29sb24sIGV4Y2VwdCB3aGVuIHRoZXkgaW4gdGhlICgpIHBhcnQgb2YgZm9yIGxvb3BzLlxuXG4gICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBwYXRoLmdldFBhcmVudE5vZGUoKTtcbiAgICAgICAgICB2YXIgaXNQYXJlbnRGb3JMb29wID0gcGFyZW50Tm9kZS50eXBlID09PSBcIkZvclN0YXRlbWVudFwiIHx8IHBhcmVudE5vZGUudHlwZSA9PT0gXCJGb3JJblN0YXRlbWVudFwiIHx8IHBhcmVudE5vZGUudHlwZSA9PT0gXCJGb3JPZlN0YXRlbWVudFwiIHx8IHBhcmVudE5vZGUudHlwZSA9PT0gXCJGb3JBd2FpdFN0YXRlbWVudFwiO1xuICAgICAgICAgIHZhciBoYXNWYWx1ZSA9IG4uZGVjbGFyYXRpb25zLnNvbWUoZnVuY3Rpb24gKGRlY2wpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNsLmluaXQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGZpcnN0VmFyaWFibGU7XG5cbiAgICAgICAgICBpZiAocHJpbnRlZC5sZW5ndGggPT09IDEgJiYgIW4uZGVjbGFyYXRpb25zWzBdLmNvbW1lbnRzKSB7XG4gICAgICAgICAgICBmaXJzdFZhcmlhYmxlID0gcHJpbnRlZFswXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByaW50ZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gSW5kZW50IGZpcnN0IHZhciB0byBjb21wbHkgd2l0aCBlc2xpbnQgb25lLXZhciBydWxlXG4gICAgICAgICAgICBmaXJzdFZhcmlhYmxlID0gaW5kZW50JDcocHJpbnRlZFswXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFydHMgPSBbbi5kZWNsYXJlID8gXCJkZWNsYXJlIFwiIDogXCJcIiwgbi5raW5kLCBmaXJzdFZhcmlhYmxlID8gY29uY2F0JGQoW1wiIFwiLCBmaXJzdFZhcmlhYmxlXSkgOiBcIlwiLCBpbmRlbnQkNyhjb25jYXQkZChwcmludGVkLnNsaWNlKDEpLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtcIixcIiwgaGFzVmFsdWUgJiYgIWlzUGFyZW50Rm9yTG9vcCA/IGhhcmRsaW5lJDkgOiBsaW5lJDcsIHBdKTtcbiAgICAgICAgICB9KSkpXTtcblxuICAgICAgICAgIGlmICghKGlzUGFyZW50Rm9yTG9vcCAmJiBwYXJlbnROb2RlLmJvZHkgIT09IG4pKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHNlbWkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBncm91cCRiKGNvbmNhdCRkKHBhcnRzKSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIlRTVHlwZUFsaWFzRGVjbGFyYXRpb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChuLmRlY2xhcmUpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCJkZWNsYXJlIFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3ByaW50ZWQgPSBwcmludEFzc2lnbm1lbnRSaWdodChuLmlkLCBuLnR5cGVBbm5vdGF0aW9uLCBuLnR5cGVBbm5vdGF0aW9uICYmIHBhdGguY2FsbChwcmludCwgXCJ0eXBlQW5ub3RhdGlvblwiKSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICBwYXJ0cy5wdXNoKFwidHlwZSBcIiwgcGF0aC5jYWxsKHByaW50LCBcImlkXCIpLCBwYXRoLmNhbGwocHJpbnQsIFwidHlwZVBhcmFtZXRlcnNcIiksIFwiID1cIiwgX3ByaW50ZWQsIHNlbWkpO1xuICAgICAgICAgIHJldHVybiBncm91cCRiKGNvbmNhdCRkKHBhcnRzKSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIlZhcmlhYmxlRGVjbGFyYXRvclwiOlxuICAgICAgICByZXR1cm4gcHJpbnRBc3NpZ25tZW50KG4uaWQsIHBhdGguY2FsbChwcmludCwgXCJpZFwiKSwgXCIgPVwiLCBuLmluaXQsIG4uaW5pdCAmJiBwYXRoLmNhbGwocHJpbnQsIFwiaW5pdFwiKSwgb3B0aW9ucyk7XG5cbiAgICAgIGNhc2UgXCJXaXRoU3RhdGVtZW50XCI6XG4gICAgICAgIHJldHVybiBncm91cCRiKGNvbmNhdCRkKFtcIndpdGggKFwiLCBwYXRoLmNhbGwocHJpbnQsIFwib2JqZWN0XCIpLCBcIilcIiwgYWRqdXN0Q2xhdXNlKG4uYm9keSwgcGF0aC5jYWxsKHByaW50LCBcImJvZHlcIikpXSkpO1xuXG4gICAgICBjYXNlIFwiSWZTdGF0ZW1lbnRcIjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBjb24gPSBhZGp1c3RDbGF1c2Uobi5jb25zZXF1ZW50LCBwYXRoLmNhbGwocHJpbnQsIFwiY29uc2VxdWVudFwiKSk7XG4gICAgICAgICAgdmFyIG9wZW5pbmcgPSBncm91cCRiKGNvbmNhdCRkKFtcImlmIChcIiwgZ3JvdXAkYihjb25jYXQkZChbaW5kZW50JDcoY29uY2F0JGQoW3NvZnRsaW5lJDYsIHBhdGguY2FsbChwcmludCwgXCJ0ZXN0XCIpXSkpLCBzb2Z0bGluZSQ2XSkpLCBcIilcIiwgY29uXSkpO1xuICAgICAgICAgIHBhcnRzLnB1c2gob3BlbmluZyk7XG5cbiAgICAgICAgICBpZiAobi5hbHRlcm5hdGUpIHtcbiAgICAgICAgICAgIHZhciBjb21tZW50T25Pd25MaW5lID0gaGFzVHJhaWxpbmdDb21tZW50JDEobi5jb25zZXF1ZW50KSAmJiBuLmNvbnNlcXVlbnQuY29tbWVudHMuc29tZShmdW5jdGlvbiAoY29tbWVudCkge1xuICAgICAgICAgICAgICByZXR1cm4gY29tbWVudC50cmFpbGluZyAmJiAhY29tbWVudHMkMS5pc0Jsb2NrQ29tbWVudChjb21tZW50KTtcbiAgICAgICAgICAgIH0pIHx8IG5lZWRzSGFyZGxpbmVBZnRlckRhbmdsaW5nQ29tbWVudCQxKG4pO1xuICAgICAgICAgICAgdmFyIGVsc2VPblNhbWVMaW5lID0gbi5jb25zZXF1ZW50LnR5cGUgPT09IFwiQmxvY2tTdGF0ZW1lbnRcIiAmJiAhY29tbWVudE9uT3duTGluZTtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goZWxzZU9uU2FtZUxpbmUgPyBcIiBcIiA6IGhhcmRsaW5lJDkpO1xuXG4gICAgICAgICAgICBpZiAoaGFzRGFuZ2xpbmdDb21tZW50cyQxKG4pKSB7XG4gICAgICAgICAgICAgIHBhcnRzLnB1c2goY29tbWVudHMucHJpbnREYW5nbGluZ0NvbW1lbnRzKHBhdGgsIG9wdGlvbnMsIHRydWUpLCBjb21tZW50T25Pd25MaW5lID8gaGFyZGxpbmUkOSA6IFwiIFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFydHMucHVzaChcImVsc2VcIiwgZ3JvdXAkYihhZGp1c3RDbGF1c2Uobi5hbHRlcm5hdGUsIHBhdGguY2FsbChwcmludCwgXCJhbHRlcm5hdGVcIiksIG4uYWx0ZXJuYXRlLnR5cGUgPT09IFwiSWZTdGF0ZW1lbnRcIikpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJGb3JTdGF0ZW1lbnRcIjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfYm9keSA9IGFkanVzdENsYXVzZShuLmJvZHksIHBhdGguY2FsbChwcmludCwgXCJib2R5XCIpKTsgLy8gV2Ugd2FudCB0byBrZWVwIGRhbmdsaW5nIGNvbW1lbnRzIGFib3ZlIHRoZSBsb29wIHRvIHN0YXkgY29uc2lzdGVudC5cbiAgICAgICAgICAvLyBBbnkgY29tbWVudCBwb3NpdGlvbmVkIGJldHdlZW4gdGhlIGZvciBzdGF0ZW1lbnQgYW5kIHRoZSBwYXJlbnRoZXNlc1xuICAgICAgICAgIC8vIGlzIGdvaW5nIHRvIGJlIHByaW50ZWQgYmVmb3JlIHRoZSBzdGF0ZW1lbnQuXG5cblxuICAgICAgICAgIHZhciBfZGFuZ2xpbmcgPSBjb21tZW50cy5wcmludERhbmdsaW5nQ29tbWVudHMocGF0aCwgb3B0aW9ucyxcbiAgICAgICAgICAvKiBzYW1lTGluZSAqL1xuICAgICAgICAgIHRydWUpO1xuXG4gICAgICAgICAgdmFyIHByaW50ZWRDb21tZW50cyA9IF9kYW5nbGluZyA/IGNvbmNhdCRkKFtfZGFuZ2xpbmcsIHNvZnRsaW5lJDZdKSA6IFwiXCI7XG5cbiAgICAgICAgICBpZiAoIW4uaW5pdCAmJiAhbi50ZXN0ICYmICFuLnVwZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtwcmludGVkQ29tbWVudHMsIGdyb3VwJGIoY29uY2F0JGQoW1wiZm9yICg7OylcIiwgX2JvZHldKSldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29uY2F0JGQoW3ByaW50ZWRDb21tZW50cywgZ3JvdXAkYihjb25jYXQkZChbXCJmb3IgKFwiLCBncm91cCRiKGNvbmNhdCRkKFtpbmRlbnQkNyhjb25jYXQkZChbc29mdGxpbmUkNiwgcGF0aC5jYWxsKHByaW50LCBcImluaXRcIiksIFwiO1wiLCBsaW5lJDcsIHBhdGguY2FsbChwcmludCwgXCJ0ZXN0XCIpLCBcIjtcIiwgbGluZSQ3LCBwYXRoLmNhbGwocHJpbnQsIFwidXBkYXRlXCIpXSkpLCBzb2Z0bGluZSQ2XSkpLCBcIilcIiwgX2JvZHldKSldKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiV2hpbGVTdGF0ZW1lbnRcIjpcbiAgICAgICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQoW1wid2hpbGUgKFwiLCBncm91cCRiKGNvbmNhdCRkKFtpbmRlbnQkNyhjb25jYXQkZChbc29mdGxpbmUkNiwgcGF0aC5jYWxsKHByaW50LCBcInRlc3RcIildKSksIHNvZnRsaW5lJDZdKSksIFwiKVwiLCBhZGp1c3RDbGF1c2Uobi5ib2R5LCBwYXRoLmNhbGwocHJpbnQsIFwiYm9keVwiKSldKSk7XG5cbiAgICAgIGNhc2UgXCJGb3JJblN0YXRlbWVudFwiOlxuICAgICAgICAvLyBOb3RlOiBlc3ByaW1hIGNhbid0IGFjdHVhbGx5IHBhcnNlIFwiZm9yIGVhY2ggKFwiLlxuICAgICAgICByZXR1cm4gZ3JvdXAkYihjb25jYXQkZChbbi5lYWNoID8gXCJmb3IgZWFjaCAoXCIgOiBcImZvciAoXCIsIHBhdGguY2FsbChwcmludCwgXCJsZWZ0XCIpLCBcIiBpbiBcIiwgcGF0aC5jYWxsKHByaW50LCBcInJpZ2h0XCIpLCBcIilcIiwgYWRqdXN0Q2xhdXNlKG4uYm9keSwgcGF0aC5jYWxsKHByaW50LCBcImJvZHlcIikpXSkpO1xuXG4gICAgICBjYXNlIFwiRm9yT2ZTdGF0ZW1lbnRcIjpcbiAgICAgIGNhc2UgXCJGb3JBd2FpdFN0YXRlbWVudFwiOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gQmFiZWwgNyByZW1vdmVkIEZvckF3YWl0U3RhdGVtZW50IGluIGZhdm9yIG9mIEZvck9mU3RhdGVtZW50XG4gICAgICAgICAgLy8gd2l0aCBgXCJhd2FpdFwiOiB0cnVlYDpcbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZXN0cmVlL2VzdHJlZS9wdWxsLzEzOFxuICAgICAgICAgIHZhciBpc0F3YWl0ID0gbi50eXBlID09PSBcIkZvckF3YWl0U3RhdGVtZW50XCIgfHwgbi5hd2FpdDtcbiAgICAgICAgICByZXR1cm4gZ3JvdXAkYihjb25jYXQkZChbXCJmb3JcIiwgaXNBd2FpdCA/IFwiIGF3YWl0XCIgOiBcIlwiLCBcIiAoXCIsIHBhdGguY2FsbChwcmludCwgXCJsZWZ0XCIpLCBcIiBvZiBcIiwgcGF0aC5jYWxsKHByaW50LCBcInJpZ2h0XCIpLCBcIilcIiwgYWRqdXN0Q2xhdXNlKG4uYm9keSwgcGF0aC5jYWxsKHByaW50LCBcImJvZHlcIikpXSkpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJEb1doaWxlU3RhdGVtZW50XCI6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY2xhdXNlID0gYWRqdXN0Q2xhdXNlKG4uYm9keSwgcGF0aC5jYWxsKHByaW50LCBcImJvZHlcIikpO1xuICAgICAgICAgIHZhciBkb0JvZHkgPSBncm91cCRiKGNvbmNhdCRkKFtcImRvXCIsIGNsYXVzZV0pKTtcbiAgICAgICAgICBwYXJ0cyA9IFtkb0JvZHldO1xuXG4gICAgICAgICAgaWYgKG4uYm9keS50eXBlID09PSBcIkJsb2NrU3RhdGVtZW50XCIpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCIgXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGhhcmRsaW5lJDkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcnRzLnB1c2goXCJ3aGlsZSAoXCIpO1xuICAgICAgICAgIHBhcnRzLnB1c2goZ3JvdXAkYihjb25jYXQkZChbaW5kZW50JDcoY29uY2F0JGQoW3NvZnRsaW5lJDYsIHBhdGguY2FsbChwcmludCwgXCJ0ZXN0XCIpXSkpLCBzb2Z0bGluZSQ2XSkpLCBcIilcIiwgc2VtaSk7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKHBhcnRzKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiRG9FeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbXCJkbyBcIiwgcGF0aC5jYWxsKHByaW50LCBcImJvZHlcIildKTtcblxuICAgICAgY2FzZSBcIkJyZWFrU3RhdGVtZW50XCI6XG4gICAgICAgIHBhcnRzLnB1c2goXCJicmVha1wiKTtcblxuICAgICAgICBpZiAobi5sYWJlbCkge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCIgXCIsIHBhdGguY2FsbChwcmludCwgXCJsYWJlbFwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJ0cy5wdXNoKHNlbWkpO1xuICAgICAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuXG4gICAgICBjYXNlIFwiQ29udGludWVTdGF0ZW1lbnRcIjpcbiAgICAgICAgcGFydHMucHVzaChcImNvbnRpbnVlXCIpO1xuXG4gICAgICAgIGlmIChuLmxhYmVsKSB7XG4gICAgICAgICAgcGFydHMucHVzaChcIiBcIiwgcGF0aC5jYWxsKHByaW50LCBcImxhYmVsXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnRzLnB1c2goc2VtaSk7XG4gICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG5cbiAgICAgIGNhc2UgXCJMYWJlbGVkU3RhdGVtZW50XCI6XG4gICAgICAgIGlmIChuLmJvZHkudHlwZSA9PT0gXCJFbXB0eVN0YXRlbWVudFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtwYXRoLmNhbGwocHJpbnQsIFwibGFiZWxcIiksIFwiOjtcIl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtwYXRoLmNhbGwocHJpbnQsIFwibGFiZWxcIiksIFwiOiBcIiwgcGF0aC5jYWxsKHByaW50LCBcImJvZHlcIildKTtcblxuICAgICAgY2FzZSBcIlRyeVN0YXRlbWVudFwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW1widHJ5IFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiYmxvY2tcIiksIG4uaGFuZGxlciA/IGNvbmNhdCRkKFtcIiBcIiwgcGF0aC5jYWxsKHByaW50LCBcImhhbmRsZXJcIildKSA6IFwiXCIsIG4uZmluYWxpemVyID8gY29uY2F0JGQoW1wiIGZpbmFsbHkgXCIsIHBhdGguY2FsbChwcmludCwgXCJmaW5hbGl6ZXJcIildKSA6IFwiXCJdKTtcblxuICAgICAgY2FzZSBcIkNhdGNoQ2xhdXNlXCI6XG4gICAgICAgIGlmIChuLnBhcmFtKSB7XG4gICAgICAgICAgdmFyIGhhc0NvbW1lbnRzID0gbi5wYXJhbS5jb21tZW50cyAmJiBuLnBhcmFtLmNvbW1lbnRzLnNvbWUoZnVuY3Rpb24gKGNvbW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiAhY29tbWVudHMkMS5pc0Jsb2NrQ29tbWVudChjb21tZW50KSB8fCBjb21tZW50LmxlYWRpbmcgJiYgaGFzTmV3bGluZSQ0KG9wdGlvbnMub3JpZ2luYWxUZXh0LCBvcHRpb25zLmxvY0VuZChjb21tZW50KSkgfHwgY29tbWVudC50cmFpbGluZyAmJiBoYXNOZXdsaW5lJDQob3B0aW9ucy5vcmlnaW5hbFRleHQsIG9wdGlvbnMubG9jU3RhcnQoY29tbWVudCksIHtcbiAgICAgICAgICAgICAgYmFja3dhcmRzOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgcGFyYW0gPSBwYXRoLmNhbGwocHJpbnQsIFwicGFyYW1cIik7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtcImNhdGNoIFwiLCBoYXNDb21tZW50cyA/IGNvbmNhdCRkKFtcIihcIiwgaW5kZW50JDcoY29uY2F0JGQoW3NvZnRsaW5lJDYsIHBhcmFtXSkpLCBzb2Z0bGluZSQ2LCBcIikgXCJdKSA6IGNvbmNhdCRkKFtcIihcIiwgcGFyYW0sIFwiKSBcIl0pLCBwYXRoLmNhbGwocHJpbnQsIFwiYm9keVwiKV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtcImNhdGNoIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiYm9keVwiKV0pO1xuXG4gICAgICBjYXNlIFwiVGhyb3dTdGF0ZW1lbnRcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtcInRocm93IFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiYXJndW1lbnRcIiksIHNlbWldKTtcbiAgICAgIC8vIE5vdGU6IGlnbm9yaW5nIG4ubGV4aWNhbCBiZWNhdXNlIGl0IGhhcyBubyBwcmludGluZyBjb25zZXF1ZW5jZXMuXG5cbiAgICAgIGNhc2UgXCJTd2l0Y2hTdGF0ZW1lbnRcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtncm91cCRiKGNvbmNhdCRkKFtcInN3aXRjaCAoXCIsIGluZGVudCQ3KGNvbmNhdCRkKFtzb2Z0bGluZSQ2LCBwYXRoLmNhbGwocHJpbnQsIFwiZGlzY3JpbWluYW50XCIpXSkpLCBzb2Z0bGluZSQ2LCBcIilcIl0pKSwgXCIge1wiLCBuLmNhc2VzLmxlbmd0aCA+IDAgPyBpbmRlbnQkNyhjb25jYXQkZChbaGFyZGxpbmUkOSwgam9pbiQ5KGhhcmRsaW5lJDksIHBhdGgubWFwKGZ1bmN0aW9uIChjYXNlUGF0aCkge1xuICAgICAgICAgIHZhciBjYXNlTm9kZSA9IGNhc2VQYXRoLmdldFZhbHVlKCk7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtjYXNlUGF0aC5jYWxsKHByaW50KSwgbi5jYXNlcy5pbmRleE9mKGNhc2VOb2RlKSAhPT0gbi5jYXNlcy5sZW5ndGggLSAxICYmIGlzTmV4dExpbmVFbXB0eSQ0KG9wdGlvbnMub3JpZ2luYWxUZXh0LCBjYXNlTm9kZSwgb3B0aW9ucykgPyBoYXJkbGluZSQ5IDogXCJcIl0pO1xuICAgICAgICB9LCBcImNhc2VzXCIpKV0pKSA6IFwiXCIsIGhhcmRsaW5lJDksIFwifVwiXSk7XG5cbiAgICAgIGNhc2UgXCJTd2l0Y2hDYXNlXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAobi50ZXN0KSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwiY2FzZSBcIiwgcGF0aC5jYWxsKHByaW50LCBcInRlc3RcIiksIFwiOlwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFydHMucHVzaChcImRlZmF1bHQ6XCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjb25zZXF1ZW50ID0gbi5jb25zZXF1ZW50LmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUudHlwZSAhPT0gXCJFbXB0eVN0YXRlbWVudFwiO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGNvbnNlcXVlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGNvbnMgPSBwYXRoLmNhbGwoZnVuY3Rpb24gKGNvbnNlcXVlbnRQYXRoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcmludFN0YXRlbWVudFNlcXVlbmNlKGNvbnNlcXVlbnRQYXRoLCBvcHRpb25zLCBwcmludCk7XG4gICAgICAgICAgICB9LCBcImNvbnNlcXVlbnRcIik7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGNvbnNlcXVlbnQubGVuZ3RoID09PSAxICYmIGNvbnNlcXVlbnRbMF0udHlwZSA9PT0gXCJCbG9ja1N0YXRlbWVudFwiID8gY29uY2F0JGQoW1wiIFwiLCBjb25zXSkgOiBpbmRlbnQkNyhjb25jYXQkZChbaGFyZGxpbmUkOSwgY29uc10pKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKHBhcnRzKTtcbiAgICAgICAgfVxuICAgICAgLy8gSlNYIGV4dGVuc2lvbnMgYmVsb3cuXG5cbiAgICAgIGNhc2UgXCJEZWJ1Z2dlclN0YXRlbWVudFwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW1wiZGVidWdnZXJcIiwgc2VtaV0pO1xuXG4gICAgICBjYXNlIFwiSlNYQXR0cmlidXRlXCI6XG4gICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcIm5hbWVcIikpO1xuXG4gICAgICAgIGlmIChuLnZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlcztcblxuICAgICAgICAgIGlmIChpc1N0cmluZ0xpdGVyYWwkMShuLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFyIHJhdyA9IHJhd1RleHQkMShuLnZhbHVlKTsgLy8gVW5lc2NhcGUgYWxsIHF1b3RlcyBzbyB3ZSBnZXQgYW4gYWNjdXJhdGUgcHJlZmVycmVkIHF1b3RlXG5cbiAgICAgICAgICAgIHZhciBmaW5hbCA9IHJhdy5yZXBsYWNlKC8mYXBvczsvZywgXCInXCIpLnJlcGxhY2UoLyZxdW90Oy9nLCAnXCInKTtcbiAgICAgICAgICAgIHZhciBxdW90ZSA9IGdldFByZWZlcnJlZFF1b3RlJDEoZmluYWwsIG9wdGlvbnMuanN4U2luZ2xlUXVvdGUgPyBcIidcIiA6ICdcIicpO1xuXG4gICAgICAgICAgICB2YXIgX2VzY2FwZSA9IHF1b3RlID09PSBcIidcIiA/IFwiJmFwb3M7XCIgOiBcIiZxdW90O1wiO1xuXG4gICAgICAgICAgICBmaW5hbCA9IGZpbmFsLnNsaWNlKDEsIC0xKS5yZXBsYWNlKG5ldyBSZWdFeHAocXVvdGUsIFwiZ1wiKSwgX2VzY2FwZSk7XG4gICAgICAgICAgICByZXMgPSBjb25jYXQkZChbcXVvdGUsIGZpbmFsLCBxdW90ZV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBwYXRoLmNhbGwocHJpbnQsIFwidmFsdWVcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFydHMucHVzaChcIj1cIiwgcmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG5cbiAgICAgIGNhc2UgXCJKU1hJZGVudGlmaWVyXCI6XG4gICAgICAgIHJldHVybiBcIlwiICsgbi5uYW1lO1xuXG4gICAgICBjYXNlIFwiSlNYTmFtZXNwYWNlZE5hbWVcIjpcbiAgICAgICAgcmV0dXJuIGpvaW4kOShcIjpcIiwgW3BhdGguY2FsbChwcmludCwgXCJuYW1lc3BhY2VcIiksIHBhdGguY2FsbChwcmludCwgXCJuYW1lXCIpXSk7XG5cbiAgICAgIGNhc2UgXCJKU1hNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiBqb2luJDkoXCIuXCIsIFtwYXRoLmNhbGwocHJpbnQsIFwib2JqZWN0XCIpLCBwYXRoLmNhbGwocHJpbnQsIFwicHJvcGVydHlcIildKTtcblxuICAgICAgY2FzZSBcIlRTUXVhbGlmaWVkTmFtZVwiOlxuICAgICAgICByZXR1cm4gam9pbiQ5KFwiLlwiLCBbcGF0aC5jYWxsKHByaW50LCBcImxlZnRcIiksIHBhdGguY2FsbChwcmludCwgXCJyaWdodFwiKV0pO1xuXG4gICAgICBjYXNlIFwiSlNYU3ByZWFkQXR0cmlidXRlXCI6XG4gICAgICBjYXNlIFwiSlNYU3ByZWFkQ2hpbGRcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBjb25jYXQkZChbXCJ7XCIsIHBhdGguY2FsbChmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgdmFyIHByaW50ZWQgPSBjb25jYXQkZChbXCIuLi5cIiwgcHJpbnQocCldKTtcbiAgICAgICAgICAgIHZhciBuID0gcC5nZXRWYWx1ZSgpO1xuXG4gICAgICAgICAgICBpZiAoIW4uY29tbWVudHMgfHwgIW4uY29tbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcmludGVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY29uY2F0JGQoW2luZGVudCQ3KGNvbmNhdCRkKFtzb2Z0bGluZSQ2LCBjb21tZW50cy5wcmludENvbW1lbnRzKHAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByaW50ZWQ7XG4gICAgICAgICAgICB9LCBvcHRpb25zKV0pKSwgc29mdGxpbmUkNl0pO1xuICAgICAgICAgIH0sIG4udHlwZSA9PT0gXCJKU1hTcHJlYWRBdHRyaWJ1dGVcIiA/IFwiYXJndW1lbnRcIiA6IFwiZXhwcmVzc2lvblwiKSwgXCJ9XCJdKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9wYXJlbnQ3ID0gcGF0aC5nZXRQYXJlbnROb2RlKDApO1xuXG4gICAgICAgICAgdmFyIHByZXZlbnRJbmxpbmUgPSBfcGFyZW50Ny50eXBlID09PSBcIkpTWEF0dHJpYnV0ZVwiICYmIG4uZXhwcmVzc2lvbi5jb21tZW50cyAmJiBuLmV4cHJlc3Npb24uY29tbWVudHMubGVuZ3RoID4gMDtcblxuICAgICAgICAgIHZhciBfc2hvdWxkSW5saW5lID0gIXByZXZlbnRJbmxpbmUgJiYgKG4uZXhwcmVzc2lvbi50eXBlID09PSBcIkFycmF5RXhwcmVzc2lvblwiIHx8IG4uZXhwcmVzc2lvbi50eXBlID09PSBcIk9iamVjdEV4cHJlc3Npb25cIiB8fCBuLmV4cHJlc3Npb24udHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiIHx8IG4uZXhwcmVzc2lvbi50eXBlID09PSBcIkNhbGxFeHByZXNzaW9uXCIgfHwgbi5leHByZXNzaW9uLnR5cGUgPT09IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiIHx8IG4uZXhwcmVzc2lvbi50eXBlID09PSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiIHx8IG4uZXhwcmVzc2lvbi50eXBlID09PSBcIkpTWEVtcHR5RXhwcmVzc2lvblwiIHx8IG4uZXhwcmVzc2lvbi50eXBlID09PSBcIlRlbXBsYXRlTGl0ZXJhbFwiIHx8IG4uZXhwcmVzc2lvbi50eXBlID09PSBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiIHx8IG4uZXhwcmVzc2lvbi50eXBlID09PSBcIkRvRXhwcmVzc2lvblwiIHx8IGlzSlNYTm9kZSQxKF9wYXJlbnQ3KSAmJiAobi5leHByZXNzaW9uLnR5cGUgPT09IFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIgfHwgaXNCaW5hcnlpc2gkMShuLmV4cHJlc3Npb24pKSk7XG5cbiAgICAgICAgICBpZiAoX3Nob3VsZElubGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQoW1wie1wiLCBwYXRoLmNhbGwocHJpbnQsIFwiZXhwcmVzc2lvblwiKSwgbGluZVN1ZmZpeEJvdW5kYXJ5JDEsIFwifVwiXSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBncm91cCRiKGNvbmNhdCRkKFtcIntcIiwgaW5kZW50JDcoY29uY2F0JGQoW3NvZnRsaW5lJDYsIHBhdGguY2FsbChwcmludCwgXCJleHByZXNzaW9uXCIpXSkpLCBzb2Z0bGluZSQ2LCBsaW5lU3VmZml4Qm91bmRhcnkkMSwgXCJ9XCJdKSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIkpTWEZyYWdtZW50XCI6XG4gICAgICBjYXNlIFwiSlNYRWxlbWVudFwiOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGVsZW0gPSBjb21tZW50cy5wcmludENvbW1lbnRzKHBhdGgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmludEpTWEVsZW1lbnQocGF0aCwgb3B0aW9ucywgcHJpbnQpO1xuICAgICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICAgIHJldHVybiBtYXliZVdyYXBKU1hFbGVtZW50SW5QYXJlbnMocGF0aCwgZWxlbSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIkpTWE9wZW5pbmdFbGVtZW50XCI6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX24gPSBwYXRoLmdldFZhbHVlKCk7XG5cbiAgICAgICAgICB2YXIgbmFtZUhhc0NvbW1lbnRzID0gX24ubmFtZSAmJiBfbi5uYW1lLmNvbW1lbnRzICYmIF9uLm5hbWUuY29tbWVudHMubGVuZ3RoID4gMCB8fCBfbi50eXBlUGFyYW1ldGVycyAmJiBfbi50eXBlUGFyYW1ldGVycy5jb21tZW50cyAmJiBfbi50eXBlUGFyYW1ldGVycy5jb21tZW50cy5sZW5ndGggPiAwOyAvLyBEb24ndCBicmVhayBzZWxmLWNsb3NpbmcgZWxlbWVudHMgd2l0aCBubyBhdHRyaWJ1dGVzIGFuZCBubyBjb21tZW50c1xuXG4gICAgICAgICAgaWYgKF9uLnNlbGZDbG9zaW5nICYmICFfbi5hdHRyaWJ1dGVzLmxlbmd0aCAmJiAhbmFtZUhhc0NvbW1lbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0JGQoW1wiPFwiLCBwYXRoLmNhbGwocHJpbnQsIFwibmFtZVwiKSwgcGF0aC5jYWxsKHByaW50LCBcInR5cGVQYXJhbWV0ZXJzXCIpLCBcIiAvPlwiXSk7XG4gICAgICAgICAgfSAvLyBkb24ndCBicmVhayB1cCBvcGVuaW5nIGVsZW1lbnRzIHdpdGggYSBzaW5nbGUgbG9uZyB0ZXh0IGF0dHJpYnV0ZVxuXG5cbiAgICAgICAgICBpZiAoX24uYXR0cmlidXRlcyAmJiBfbi5hdHRyaWJ1dGVzLmxlbmd0aCA9PT0gMSAmJiBfbi5hdHRyaWJ1dGVzWzBdLnZhbHVlICYmIGlzU3RyaW5nTGl0ZXJhbCQxKF9uLmF0dHJpYnV0ZXNbMF0udmFsdWUpICYmICFfbi5hdHRyaWJ1dGVzWzBdLnZhbHVlLnZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpICYmIC8vIFdlIHNob3VsZCBicmVhayBmb3IgdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgICAgICAgICAvLyA8ZGl2XG4gICAgICAgICAgLy8gICAvLyBjb21tZW50XG4gICAgICAgICAgLy8gICBhdHRyPVwidmFsdWVcIlxuICAgICAgICAgIC8vID5cbiAgICAgICAgICAvLyA8ZGl2XG4gICAgICAgICAgLy8gICBhdHRyPVwidmFsdWVcIlxuICAgICAgICAgIC8vICAgLy8gY29tbWVudFxuICAgICAgICAgIC8vID5cbiAgICAgICAgICAhbmFtZUhhc0NvbW1lbnRzICYmICghX24uYXR0cmlidXRlc1swXS5jb21tZW50cyB8fCAhX24uYXR0cmlidXRlc1swXS5jb21tZW50cy5sZW5ndGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXAkYihjb25jYXQkZChbXCI8XCIsIHBhdGguY2FsbChwcmludCwgXCJuYW1lXCIpLCBwYXRoLmNhbGwocHJpbnQsIFwidHlwZVBhcmFtZXRlcnNcIiksIFwiIFwiLCBjb25jYXQkZChwYXRoLm1hcChwcmludCwgXCJhdHRyaWJ1dGVzXCIpKSwgX24uc2VsZkNsb3NpbmcgPyBcIiAvPlwiIDogXCI+XCJdKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGxhc3RBdHRySGFzVHJhaWxpbmdDb21tZW50cyA9IF9uLmF0dHJpYnV0ZXMubGVuZ3RoICYmIGhhc1RyYWlsaW5nQ29tbWVudCQxKGdldExhc3QkMihfbi5hdHRyaWJ1dGVzKSk7XG4gICAgICAgICAgdmFyIGJyYWNrZXRTYW1lTGluZSA9IC8vIFNpbXBsZSB0YWdzIChubyBhdHRyaWJ1dGVzIGFuZCBubyBjb21tZW50IGluIHRhZyBuYW1lKSBzaG91bGQgYmVcbiAgICAgICAgICAvLyBrZXB0IHVuYnJva2VuIHJlZ2FyZGxlc3Mgb2YgYGpzeEJyYWNrZXRTYW1lTGluZWBcbiAgICAgICAgICAhX24uYXR0cmlidXRlcy5sZW5ndGggJiYgIW5hbWVIYXNDb21tZW50cyB8fCBvcHRpb25zLmpzeEJyYWNrZXRTYW1lTGluZSAmJiAoIC8vIFdlIHNob3VsZCBwcmludCB0aGUgYnJhY2tldCBpbiBhIG5ldyBsaW5lIGZvciB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICAgICAgICAgIC8vIDxkaXZcbiAgICAgICAgICAvLyAgIC8vIGNvbW1lbnRcbiAgICAgICAgICAvLyA+XG4gICAgICAgICAgLy8gPGRpdlxuICAgICAgICAgIC8vICAgYXR0ciAvLyBjb21tZW50XG4gICAgICAgICAgLy8gPlxuICAgICAgICAgICFuYW1lSGFzQ29tbWVudHMgfHwgX24uYXR0cmlidXRlcy5sZW5ndGgpICYmICFsYXN0QXR0ckhhc1RyYWlsaW5nQ29tbWVudHM7IC8vIFdlIHNob3VsZCBwcmludCB0aGUgb3BlbmluZyBlbGVtZW50IGV4cGFuZGVkIGlmIGFueSBwcm9wIHZhbHVlIGlzIGFcbiAgICAgICAgICAvLyBzdHJpbmcgbGl0ZXJhbCB3aXRoIG5ld2xpbmVzXG5cbiAgICAgICAgICB2YXIgX3Nob3VsZEJyZWFrMiA9IF9uLmF0dHJpYnV0ZXMgJiYgX24uYXR0cmlidXRlcy5zb21lKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICByZXR1cm4gYXR0ci52YWx1ZSAmJiBpc1N0cmluZ0xpdGVyYWwkMShhdHRyLnZhbHVlKSAmJiBhdHRyLnZhbHVlLnZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQoW1wiPFwiLCBwYXRoLmNhbGwocHJpbnQsIFwibmFtZVwiKSwgcGF0aC5jYWxsKHByaW50LCBcInR5cGVQYXJhbWV0ZXJzXCIpLCBjb25jYXQkZChbaW5kZW50JDcoY29uY2F0JGQocGF0aC5tYXAoZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQkZChbbGluZSQ3LCBwcmludChhdHRyKV0pO1xuICAgICAgICAgIH0sIFwiYXR0cmlidXRlc1wiKSkpLCBfbi5zZWxmQ2xvc2luZyA/IGxpbmUkNyA6IGJyYWNrZXRTYW1lTGluZSA/IFwiPlwiIDogc29mdGxpbmUkNl0pLCBfbi5zZWxmQ2xvc2luZyA/IFwiLz5cIiA6IGJyYWNrZXRTYW1lTGluZSA/IFwiXCIgOiBcIj5cIl0pLCB7XG4gICAgICAgICAgICBzaG91bGRCcmVhazogX3Nob3VsZEJyZWFrMlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJKU1hDbG9zaW5nRWxlbWVudFwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW1wiPC9cIiwgcGF0aC5jYWxsKHByaW50LCBcIm5hbWVcIiksIFwiPlwiXSk7XG5cbiAgICAgIGNhc2UgXCJKU1hPcGVuaW5nRnJhZ21lbnRcIjpcbiAgICAgIGNhc2UgXCJKU1hDbG9zaW5nRnJhZ21lbnRcIjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBoYXNDb21tZW50ID0gbi5jb21tZW50cyAmJiBuLmNvbW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICB2YXIgaGFzT3duTGluZUNvbW1lbnQgPSBoYXNDb21tZW50ICYmICFuLmNvbW1lbnRzLmV2ZXJ5KGNvbW1lbnRzJDEuaXNCbG9ja0NvbW1lbnQpO1xuICAgICAgICAgIHZhciBpc09wZW5pbmdGcmFnbWVudCA9IG4udHlwZSA9PT0gXCJKU1hPcGVuaW5nRnJhZ21lbnRcIjtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JGQoW2lzT3BlbmluZ0ZyYWdtZW50ID8gXCI8XCIgOiBcIjwvXCIsIGluZGVudCQ3KGNvbmNhdCRkKFtoYXNPd25MaW5lQ29tbWVudCA/IGhhcmRsaW5lJDkgOiBoYXNDb21tZW50ICYmICFpc09wZW5pbmdGcmFnbWVudCA/IFwiIFwiIDogXCJcIiwgY29tbWVudHMucHJpbnREYW5nbGluZ0NvbW1lbnRzKHBhdGgsIG9wdGlvbnMsIHRydWUpXSkpLCBoYXNPd25MaW5lQ29tbWVudCA/IGhhcmRsaW5lJDkgOiBcIlwiLCBcIj5cIl0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJKU1hUZXh0XCI6XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkpTWFRlc3Qgc2hvdWxkIGJlIGhhbmRsZWQgYnkgSlNYRWxlbWVudFwiKTtcblxuICAgICAgY2FzZSBcIkpTWEVtcHR5RXhwcmVzc2lvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHJlcXVpcmVzSGFyZGxpbmUgPSBuLmNvbW1lbnRzICYmICFuLmNvbW1lbnRzLmV2ZXJ5KGNvbW1lbnRzJDEuaXNCbG9ja0NvbW1lbnQpO1xuICAgICAgICAgIHJldHVybiBjb25jYXQkZChbY29tbWVudHMucHJpbnREYW5nbGluZ0NvbW1lbnRzKHBhdGgsIG9wdGlvbnMsXG4gICAgICAgICAgLyogc2FtZUluZGVudCAqL1xuICAgICAgICAgICFyZXF1aXJlc0hhcmRsaW5lKSwgcmVxdWlyZXNIYXJkbGluZSA/IGhhcmRsaW5lJDkgOiBcIlwiXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIkNsYXNzQm9keVwiOlxuICAgICAgICBpZiAoIW4uY29tbWVudHMgJiYgbi5ib2R5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBcInt9XCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW1wie1wiLCBuLmJvZHkubGVuZ3RoID4gMCA/IGluZGVudCQ3KGNvbmNhdCRkKFtoYXJkbGluZSQ5LCBwYXRoLmNhbGwoZnVuY3Rpb24gKGJvZHlQYXRoKSB7XG4gICAgICAgICAgcmV0dXJuIHByaW50U3RhdGVtZW50U2VxdWVuY2UoYm9keVBhdGgsIG9wdGlvbnMsIHByaW50KTtcbiAgICAgICAgfSwgXCJib2R5XCIpXSkpIDogY29tbWVudHMucHJpbnREYW5nbGluZ0NvbW1lbnRzKHBhdGgsIG9wdGlvbnMpLCBoYXJkbGluZSQ5LCBcIn1cIl0pO1xuXG4gICAgICBjYXNlIFwiQ2xhc3NQcm9wZXJ0eVwiOlxuICAgICAgY2FzZSBcIlRTQWJzdHJhY3RDbGFzc1Byb3BlcnR5XCI6XG4gICAgICBjYXNlIFwiQ2xhc3NQcml2YXRlUHJvcGVydHlcIjpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChuLmRlY29yYXRvcnMgJiYgbi5kZWNvcmF0b3JzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgcGFydHMucHVzaChwcmludERlY29yYXRvcnMocGF0aCwgb3B0aW9ucywgcHJpbnQpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobi5hY2Nlc3NpYmlsaXR5KSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKG4uYWNjZXNzaWJpbGl0eSArIFwiIFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobi5kZWNsYXJlKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwiZGVjbGFyZSBcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG4uc3RhdGljKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwic3RhdGljIFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobi50eXBlID09PSBcIlRTQWJzdHJhY3RDbGFzc1Byb3BlcnR5XCIpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCJhYnN0cmFjdCBcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG4ucmVhZG9ubHkpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCJyZWFkb25seSBcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHZhcmlhbmNlID0gZ2V0Rmxvd1ZhcmlhbmNlJDEobik7XG5cbiAgICAgICAgICBpZiAodmFyaWFuY2UpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2godmFyaWFuY2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcnRzLnB1c2gocHJpbnRQcm9wZXJ0eUtleShwYXRoLCBvcHRpb25zLCBwcmludCksIHByaW50T3B0aW9uYWxUb2tlbihwYXRoKSwgcHJpbnRUeXBlQW5ub3RhdGlvbihwYXRoLCBvcHRpb25zLCBwcmludCkpO1xuXG4gICAgICAgICAgaWYgKG4udmFsdWUpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCIgPVwiLCBwcmludEFzc2lnbm1lbnRSaWdodChuLmtleSwgbi52YWx1ZSwgcGF0aC5jYWxsKHByaW50LCBcInZhbHVlXCIpLCBvcHRpb25zKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFydHMucHVzaChzZW1pKTtcbiAgICAgICAgICByZXR1cm4gZ3JvdXAkYihjb25jYXQkZChwYXJ0cykpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJDbGFzc0RlY2xhcmF0aW9uXCI6XG4gICAgICBjYXNlIFwiQ2xhc3NFeHByZXNzaW9uXCI6XG4gICAgICAgIGlmIChuLmRlY2xhcmUpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKFwiZGVjbGFyZSBcIik7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJ0cy5wdXNoKGNvbmNhdCRkKHByaW50Q2xhc3MocGF0aCwgb3B0aW9ucywgcHJpbnQpKSk7XG4gICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG5cbiAgICAgIGNhc2UgXCJUU0ludGVyZmFjZUhlcml0YWdlXCI6XG4gICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcImV4cHJlc3Npb25cIikpO1xuXG4gICAgICAgIGlmIChuLnR5cGVQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwidHlwZVBhcmFtZXRlcnNcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKHBhcnRzKTtcblxuICAgICAgY2FzZSBcIlRlbXBsYXRlRWxlbWVudFwiOlxuICAgICAgICByZXR1cm4gam9pbiQ5KGxpdGVyYWxsaW5lJDQsIG4udmFsdWUucmF3LnNwbGl0KC9cXHI/XFxuL2cpKTtcblxuICAgICAgY2FzZSBcIlRlbXBsYXRlTGl0ZXJhbFwiOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gcGF0aC5tYXAocHJpbnQsIFwiZXhwcmVzc2lvbnNcIik7XG5cbiAgICAgICAgICB2YXIgX3BhcmVudE5vZGUgPSBwYXRoLmdldFBhcmVudE5vZGUoKTtcblxuICAgICAgICAgIGlmIChpc0plc3RFYWNoVGVtcGxhdGVMaXRlcmFsJDEobiwgX3BhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgX3ByaW50ZWQyID0gcHJpbnRKZXN0RWFjaFRlbXBsYXRlTGl0ZXJhbChuLCBleHByZXNzaW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIGlmIChfcHJpbnRlZDIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9wcmludGVkMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaXNTaW1wbGUgPSBpc1NpbXBsZVRlbXBsYXRlTGl0ZXJhbCQxKG4pO1xuXG4gICAgICAgICAgaWYgKGlzU2ltcGxlKSB7XG4gICAgICAgICAgICBleHByZXNzaW9ucyA9IGV4cHJlc3Npb25zLm1hcChmdW5jdGlvbiAoZG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcmludERvY1RvU3RyaW5nJDEoZG9jLCBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgcHJpbnRXaWR0aDogSW5maW5pdHlcbiAgICAgICAgICAgICAgfSkpLmZvcm1hdHRlZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcnRzLnB1c2gobGluZVN1ZmZpeEJvdW5kYXJ5JDEsIFwiYFwiKTtcbiAgICAgICAgICBwYXRoLmVhY2goZnVuY3Rpb24gKGNoaWxkUGF0aCkge1xuICAgICAgICAgICAgdmFyIGkgPSBjaGlsZFBhdGguZ2V0TmFtZSgpO1xuICAgICAgICAgICAgcGFydHMucHVzaChwcmludChjaGlsZFBhdGgpKTtcblxuICAgICAgICAgICAgaWYgKGkgPCBleHByZXNzaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gRm9yIGEgdGVtcGxhdGUgbGl0ZXJhbCBvZiB0aGUgZm9sbG93aW5nIGZvcm06XG4gICAgICAgICAgICAgIC8vICAgYHNvbWVRdWVyeSB7XG4gICAgICAgICAgICAgIC8vICAgICAke2NhbGwoe1xuICAgICAgICAgICAgICAvLyAgICAgICBhLFxuICAgICAgICAgICAgICAvLyAgICAgICBiLFxuICAgICAgICAgICAgICAvLyAgICAgfSl9XG4gICAgICAgICAgICAgIC8vICAgfWBcbiAgICAgICAgICAgICAgLy8gdGhlIGV4cHJlc3Npb24gaXMgb24gaXRzIG93biBsaW5lICh0aGVyZSBpcyBhIFxcbiBpbiB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgICAgLy8gcXVhc2kgbGl0ZXJhbCksIHRoZXJlZm9yZSB3ZSB3YW50IHRvIGluZGVudCB0aGUgSmF2YVNjcmlwdFxuICAgICAgICAgICAgICAvLyBleHByZXNzaW9uIGluc2lkZSBhdCB0aGUgYmVnaW5uaW5nIG9mICR7IGluc3RlYWQgb2YgdGhlIGJlZ2lubmluZ1xuICAgICAgICAgICAgICAvLyBvZiB0aGUgYC5cbiAgICAgICAgICAgICAgdmFyIHRhYldpZHRoID0gb3B0aW9ucy50YWJXaWR0aDtcbiAgICAgICAgICAgICAgdmFyIHF1YXNpID0gY2hpbGRQYXRoLmdldFZhbHVlKCk7XG4gICAgICAgICAgICAgIHZhciBpbmRlbnRTaXplID0gZ2V0SW5kZW50U2l6ZSQxKHF1YXNpLnZhbHVlLnJhdywgdGFiV2lkdGgpO1xuICAgICAgICAgICAgICB2YXIgX3ByaW50ZWQzID0gZXhwcmVzc2lvbnNbaV07XG5cbiAgICAgICAgICAgICAgaWYgKCFpc1NpbXBsZSkge1xuICAgICAgICAgICAgICAgIC8vIEJyZWFrcyBhdCB0aGUgdGVtcGxhdGUgZWxlbWVudCBib3VuZGFyaWVzICgkeyBhbmQgfSkgYXJlIHByZWZlcnJlZCB0byBicmVha2luZ1xuICAgICAgICAgICAgICAgIC8vIGluIHRoZSBtaWRkbGUgb2YgYSBNZW1iZXJFeHByZXNzaW9uXG4gICAgICAgICAgICAgICAgaWYgKG4uZXhwcmVzc2lvbnNbaV0uY29tbWVudHMgJiYgbi5leHByZXNzaW9uc1tpXS5jb21tZW50cy5sZW5ndGggfHwgbi5leHByZXNzaW9uc1tpXS50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiB8fCBuLmV4cHJlc3Npb25zW2ldLnR5cGUgPT09IFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIgfHwgbi5leHByZXNzaW9uc1tpXS50eXBlID09PSBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgICAgICAgICBfcHJpbnRlZDMgPSBjb25jYXQkZChbaW5kZW50JDcoY29uY2F0JGQoW3NvZnRsaW5lJDYsIF9wcmludGVkM10pKSwgc29mdGxpbmUkNl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBhbGlnbmVkID0gaW5kZW50U2l6ZSA9PT0gMCAmJiBxdWFzaS52YWx1ZS5yYXcuZW5kc1dpdGgoXCJcXG5cIikgPyBhbGlnbiQxKC1JbmZpbml0eSwgX3ByaW50ZWQzKSA6IGFkZEFsaWdubWVudFRvRG9jJDIoX3ByaW50ZWQzLCBpbmRlbnRTaXplLCB0YWJXaWR0aCk7XG4gICAgICAgICAgICAgIHBhcnRzLnB1c2goZ3JvdXAkYihjb25jYXQkZChbXCIke1wiLCBhbGlnbmVkLCBsaW5lU3VmZml4Qm91bmRhcnkkMSwgXCJ9XCJdKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIFwicXVhc2lzXCIpO1xuICAgICAgICAgIHBhcnRzLnB1c2goXCJgXCIpO1xuICAgICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG4gICAgICAgIH1cbiAgICAgIC8vIFRoZXNlIHR5cGVzIGFyZSB1bnByaW50YWJsZSBiZWNhdXNlIHRoZXkgc2VydmUgYXMgYWJzdHJhY3RcbiAgICAgIC8vIHN1cGVydHlwZXMgZm9yIG90aGVyIChwcmludGFibGUpIHR5cGVzLlxuXG4gICAgICBjYXNlIFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbcGF0aC5jYWxsKHByaW50LCBcInRhZ1wiKSwgcGF0aC5jYWxsKHByaW50LCBcInR5cGVQYXJhbWV0ZXJzXCIpLCBwYXRoLmNhbGwocHJpbnQsIFwicXVhc2lcIildKTtcblxuICAgICAgY2FzZSBcIk5vZGVcIjpcbiAgICAgIGNhc2UgXCJQcmludGFibGVcIjpcbiAgICAgIGNhc2UgXCJTb3VyY2VMb2NhdGlvblwiOlxuICAgICAgY2FzZSBcIlBvc2l0aW9uXCI6XG4gICAgICBjYXNlIFwiU3RhdGVtZW50XCI6XG4gICAgICBjYXNlIFwiRnVuY3Rpb25cIjpcbiAgICAgIGNhc2UgXCJQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIkRlY2xhcmF0aW9uXCI6XG4gICAgICBjYXNlIFwiU3BlY2lmaWVyXCI6XG4gICAgICBjYXNlIFwiTmFtZWRTcGVjaWZpZXJcIjpcbiAgICAgIGNhc2UgXCJDb21tZW50XCI6XG4gICAgICBjYXNlIFwiTWVtYmVyVHlwZUFubm90YXRpb25cIjogLy8gRmxvd1xuXG4gICAgICBjYXNlIFwiVHlwZVwiOlxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnByaW50YWJsZSB0eXBlOiBcIiArIEpTT04uc3RyaW5naWZ5KG4udHlwZSkpO1xuICAgICAgLy8gVHlwZSBBbm5vdGF0aW9ucyBmb3IgRmFjZWJvb2sgRmxvdywgdHlwaWNhbGx5IHN0cmlwcGVkIG91dCBvclxuICAgICAgLy8gdHJhbnNmb3JtZWQgYXdheSBiZWZvcmUgcHJpbnRpbmcuXG5cbiAgICAgIGNhc2UgXCJUeXBlQW5ub3RhdGlvblwiOlxuICAgICAgY2FzZSBcIlRTVHlwZUFubm90YXRpb25cIjpcbiAgICAgICAgaWYgKG4udHlwZUFubm90YXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gcGF0aC5jYWxsKHByaW50LCBcInR5cGVBbm5vdGF0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cblxuICAgICAgICByZXR1cm4gXCJcIjtcblxuICAgICAgY2FzZSBcIlRTVHVwbGVUeXBlXCI6XG4gICAgICBjYXNlIFwiVHVwbGVUeXBlQW5ub3RhdGlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHR5cGVzRmllbGQgPSBuLnR5cGUgPT09IFwiVFNUdXBsZVR5cGVcIiA/IFwiZWxlbWVudFR5cGVzXCIgOiBcInR5cGVzXCI7XG4gICAgICAgICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQoW1wiW1wiLCBpbmRlbnQkNyhjb25jYXQkZChbc29mdGxpbmUkNiwgcHJpbnRBcnJheUl0ZW1zKHBhdGgsIG9wdGlvbnMsIHR5cGVzRmllbGQsIHByaW50KV0pKSwgaWZCcmVhayQ2KHNob3VsZFByaW50Q29tbWEkMShvcHRpb25zLCBcImFsbFwiKSA/IFwiLFwiIDogXCJcIiksIGNvbW1lbnRzLnByaW50RGFuZ2xpbmdDb21tZW50cyhwYXRoLCBvcHRpb25zLFxuICAgICAgICAgIC8qIHNhbWVJbmRlbnQgKi9cbiAgICAgICAgICB0cnVlKSwgc29mdGxpbmUkNiwgXCJdXCJdKSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIkV4aXN0c1R5cGVBbm5vdGF0aW9uXCI6XG4gICAgICAgIHJldHVybiBcIipcIjtcblxuICAgICAgY2FzZSBcIkVtcHR5VHlwZUFubm90YXRpb25cIjpcbiAgICAgICAgcmV0dXJuIFwiZW1wdHlcIjtcblxuICAgICAgY2FzZSBcIkFueVR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICAgIHJldHVybiBcImFueVwiO1xuXG4gICAgICBjYXNlIFwiTWl4ZWRUeXBlQW5ub3RhdGlvblwiOlxuICAgICAgICByZXR1cm4gXCJtaXhlZFwiO1xuXG4gICAgICBjYXNlIFwiQXJyYXlUeXBlQW5ub3RhdGlvblwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW3BhdGguY2FsbChwcmludCwgXCJlbGVtZW50VHlwZVwiKSwgXCJbXVwiXSk7XG5cbiAgICAgIGNhc2UgXCJCb29sZWFuVHlwZUFubm90YXRpb25cIjpcbiAgICAgICAgcmV0dXJuIFwiYm9vbGVhblwiO1xuXG4gICAgICBjYXNlIFwiQm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvblwiOlxuICAgICAgICByZXR1cm4gXCJcIiArIG4udmFsdWU7XG5cbiAgICAgIGNhc2UgXCJEZWNsYXJlQ2xhc3NcIjpcbiAgICAgICAgcmV0dXJuIHByaW50Rmxvd0RlY2xhcmF0aW9uKHBhdGgsIHByaW50Q2xhc3MocGF0aCwgb3B0aW9ucywgcHJpbnQpKTtcblxuICAgICAgY2FzZSBcIlRTRGVjbGFyZUZ1bmN0aW9uXCI6XG4gICAgICAgIC8vIEZvciBUeXBlU2NyaXB0IHRoZSBUU0RlY2xhcmVGdW5jdGlvbiBub2RlIHNoYXJlcyB0aGUgQVNUXG4gICAgICAgIC8vIHN0cnVjdHVyZSB3aXRoIEZ1bmN0aW9uRGVjbGFyYXRpb25cbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtuLmRlY2xhcmUgPyBcImRlY2xhcmUgXCIgOiBcIlwiLCBwcmludEZ1bmN0aW9uRGVjbGFyYXRpb24ocGF0aCwgcHJpbnQsIG9wdGlvbnMpLCBzZW1pXSk7XG5cbiAgICAgIGNhc2UgXCJEZWNsYXJlRnVuY3Rpb25cIjpcbiAgICAgICAgcmV0dXJuIHByaW50Rmxvd0RlY2xhcmF0aW9uKHBhdGgsIFtcImZ1bmN0aW9uIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiaWRcIiksIG4ucHJlZGljYXRlID8gXCIgXCIgOiBcIlwiLCBwYXRoLmNhbGwocHJpbnQsIFwicHJlZGljYXRlXCIpLCBzZW1pXSk7XG5cbiAgICAgIGNhc2UgXCJEZWNsYXJlTW9kdWxlXCI6XG4gICAgICAgIHJldHVybiBwcmludEZsb3dEZWNsYXJhdGlvbihwYXRoLCBbXCJtb2R1bGUgXCIsIHBhdGguY2FsbChwcmludCwgXCJpZFwiKSwgXCIgXCIsIHBhdGguY2FsbChwcmludCwgXCJib2R5XCIpXSk7XG5cbiAgICAgIGNhc2UgXCJEZWNsYXJlTW9kdWxlRXhwb3J0c1wiOlxuICAgICAgICByZXR1cm4gcHJpbnRGbG93RGVjbGFyYXRpb24ocGF0aCwgW1wibW9kdWxlLmV4cG9ydHNcIiwgXCI6IFwiLCBwYXRoLmNhbGwocHJpbnQsIFwidHlwZUFubm90YXRpb25cIiksIHNlbWldKTtcblxuICAgICAgY2FzZSBcIkRlY2xhcmVWYXJpYWJsZVwiOlxuICAgICAgICByZXR1cm4gcHJpbnRGbG93RGVjbGFyYXRpb24ocGF0aCwgW1widmFyIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiaWRcIiksIHNlbWldKTtcblxuICAgICAgY2FzZSBcIkRlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvblwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW1wiZGVjbGFyZSBleHBvcnQgKiBmcm9tIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwic291cmNlXCIpXSk7XG5cbiAgICAgIGNhc2UgXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtcImRlY2xhcmUgXCIsIHByaW50RXhwb3J0RGVjbGFyYXRpb24ocGF0aCwgb3B0aW9ucywgcHJpbnQpXSk7XG5cbiAgICAgIGNhc2UgXCJEZWNsYXJlT3BhcXVlVHlwZVwiOlxuICAgICAgY2FzZSBcIk9wYXF1ZVR5cGVcIjpcbiAgICAgICAge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCJvcGFxdWUgdHlwZSBcIiwgcGF0aC5jYWxsKHByaW50LCBcImlkXCIpLCBwYXRoLmNhbGwocHJpbnQsIFwidHlwZVBhcmFtZXRlcnNcIikpO1xuXG4gICAgICAgICAgaWYgKG4uc3VwZXJ0eXBlKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwiOiBcIiwgcGF0aC5jYWxsKHByaW50LCBcInN1cGVydHlwZVwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG4uaW1wbHR5cGUpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCIgPSBcIiwgcGF0aC5jYWxsKHByaW50LCBcImltcGx0eXBlXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJ0cy5wdXNoKHNlbWkpO1xuXG4gICAgICAgICAgaWYgKG4udHlwZSA9PT0gXCJEZWNsYXJlT3BhcXVlVHlwZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJpbnRGbG93RGVjbGFyYXRpb24ocGF0aCwgcGFydHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIkVudW1EZWNsYXJhdGlvblwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW1wiZW51bSBcIiwgcGF0aC5jYWxsKHByaW50LCBcImlkXCIpLCBcIiBcIiwgcGF0aC5jYWxsKHByaW50LCBcImJvZHlcIildKTtcblxuICAgICAgY2FzZSBcIkVudW1Cb29sZWFuQm9keVwiOlxuICAgICAgY2FzZSBcIkVudW1OdW1iZXJCb2R5XCI6XG4gICAgICBjYXNlIFwiRW51bVN0cmluZ0JvZHlcIjpcbiAgICAgIGNhc2UgXCJFbnVtU3ltYm9sQm9keVwiOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKG4udHlwZSA9PT0gXCJFbnVtU3ltYm9sQm9keVwiIHx8IG4uZXhwbGljaXRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IG51bGw7XG5cbiAgICAgICAgICAgIHN3aXRjaCAobi50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJFbnVtQm9vbGVhbkJvZHlcIjpcbiAgICAgICAgICAgICAgICB0eXBlID0gXCJib29sZWFuXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBcIkVudW1OdW1iZXJCb2R5XCI6XG4gICAgICAgICAgICAgICAgdHlwZSA9IFwibnVtYmVyXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBcIkVudW1TdHJpbmdCb2R5XCI6XG4gICAgICAgICAgICAgICAgdHlwZSA9IFwic3RyaW5nXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBcIkVudW1TeW1ib2xCb2R5XCI6XG4gICAgICAgICAgICAgICAgdHlwZSA9IFwic3ltYm9sXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCJvZiBcIiwgdHlwZSwgXCIgXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuLm1lbWJlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGdyb3VwJGIoY29uY2F0JGQoW1wie1wiLCBjb21tZW50cy5wcmludERhbmdsaW5nQ29tbWVudHMocGF0aCwgb3B0aW9ucyksIHNvZnRsaW5lJDYsIFwifVwiXSkpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFydHMucHVzaChncm91cCRiKGNvbmNhdCRkKFtcIntcIiwgaW5kZW50JDcoY29uY2F0JGQoW2hhcmRsaW5lJDksIHByaW50QXJyYXlJdGVtcyhwYXRoLCBvcHRpb25zLCBcIm1lbWJlcnNcIiwgcHJpbnQpLCBzaG91bGRQcmludENvbW1hJDEob3B0aW9ucykgPyBcIixcIiA6IFwiXCJdKSksIGNvbW1lbnRzLnByaW50RGFuZ2xpbmdDb21tZW50cyhwYXRoLCBvcHRpb25zLFxuICAgICAgICAgICAgLyogc2FtZUluZGVudCAqL1xuICAgICAgICAgICAgdHJ1ZSksIGhhcmRsaW5lJDksIFwifVwiXSkpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJFbnVtQm9vbGVhbk1lbWJlclwiOlxuICAgICAgY2FzZSBcIkVudW1OdW1iZXJNZW1iZXJcIjpcbiAgICAgIGNhc2UgXCJFbnVtU3RyaW5nTWVtYmVyXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbcGF0aC5jYWxsKHByaW50LCBcImlkXCIpLCBcIiA9IFwiLCBfdHlwZW9mKG4uaW5pdCkgPT09IFwib2JqZWN0XCIgPyBwYXRoLmNhbGwocHJpbnQsIFwiaW5pdFwiKSA6IFN0cmluZyhuLmluaXQpXSk7XG5cbiAgICAgIGNhc2UgXCJFbnVtRGVmYXVsdGVkTWVtYmVyXCI6XG4gICAgICAgIHJldHVybiBwYXRoLmNhbGwocHJpbnQsIFwiaWRcIik7XG5cbiAgICAgIGNhc2UgXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICBjYXNlIFwiVFNGdW5jdGlvblR5cGVcIjpcbiAgICAgICAge1xuICAgICAgICAgIC8vIEZ1bmN0aW9uVHlwZUFubm90YXRpb24gaXMgYW1iaWd1b3VzOlxuICAgICAgICAgIC8vIGRlY2xhcmUgZnVuY3Rpb24gZm9vKGE6IEIpOiB2b2lkOyBPUlxuICAgICAgICAgIC8vIHZhciBBOiAoYTogQikgPT4gdm9pZDtcbiAgICAgICAgICB2YXIgX3BhcmVudDggPSBwYXRoLmdldFBhcmVudE5vZGUoMCk7XG5cbiAgICAgICAgICB2YXIgX3BhcmVudFBhcmVudDIgPSBwYXRoLmdldFBhcmVudE5vZGUoMSk7XG5cbiAgICAgICAgICB2YXIgX3BhcmVudFBhcmVudFBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgyKTtcblxuICAgICAgICAgIHZhciBpc0Fycm93RnVuY3Rpb25UeXBlQW5ub3RhdGlvbiA9IG4udHlwZSA9PT0gXCJUU0Z1bmN0aW9uVHlwZVwiIHx8ICEoKF9wYXJlbnQ4LnR5cGUgPT09IFwiT2JqZWN0VHlwZVByb3BlcnR5XCIgfHwgX3BhcmVudDgudHlwZSA9PT0gXCJPYmplY3RUeXBlSW50ZXJuYWxTbG90XCIpICYmICFnZXRGbG93VmFyaWFuY2UkMShfcGFyZW50OCkgJiYgIV9wYXJlbnQ4Lm9wdGlvbmFsICYmIG9wdGlvbnMubG9jU3RhcnQoX3BhcmVudDgpID09PSBvcHRpb25zLmxvY1N0YXJ0KG4pIHx8IF9wYXJlbnQ4LnR5cGUgPT09IFwiT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eVwiIHx8IF9wYXJlbnRQYXJlbnRQYXJlbnQgJiYgX3BhcmVudFBhcmVudFBhcmVudC50eXBlID09PSBcIkRlY2xhcmVGdW5jdGlvblwiKTtcbiAgICAgICAgICB2YXIgbmVlZHNDb2xvbiA9IGlzQXJyb3dGdW5jdGlvblR5cGVBbm5vdGF0aW9uICYmIChfcGFyZW50OC50eXBlID09PSBcIlR5cGVBbm5vdGF0aW9uXCIgfHwgX3BhcmVudDgudHlwZSA9PT0gXCJUU1R5cGVBbm5vdGF0aW9uXCIpOyAvLyBTYWRseSB3ZSBjYW4ndCBwdXQgaXQgaW5zaWRlIG9mIEZhc3RQYXRoOjpuZWVkc0NvbG9uIGJlY2F1c2Ugd2UgYXJlXG4gICAgICAgICAgLy8gcHJpbnRpbmcgXCI6XCIgYXMgcGFydCBvZiB0aGUgZXhwcmVzc2lvbiBhbmQgaXQgd291bGQgcHV0IHBhcmVudGhlc2lzXG4gICAgICAgICAgLy8gYXJvdW5kIDooXG5cbiAgICAgICAgICB2YXIgbmVlZHNQYXJlbnMgPSBuZWVkc0NvbG9uICYmIGlzQXJyb3dGdW5jdGlvblR5cGVBbm5vdGF0aW9uICYmIChfcGFyZW50OC50eXBlID09PSBcIlR5cGVBbm5vdGF0aW9uXCIgfHwgX3BhcmVudDgudHlwZSA9PT0gXCJUU1R5cGVBbm5vdGF0aW9uXCIpICYmIF9wYXJlbnRQYXJlbnQyLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIjtcblxuICAgICAgICAgIGlmIChpc09iamVjdFR5cGVQcm9wZXJ0eUFGdW5jdGlvbiQxKF9wYXJlbnQ4LCBvcHRpb25zKSkge1xuICAgICAgICAgICAgaXNBcnJvd0Z1bmN0aW9uVHlwZUFubm90YXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgbmVlZHNDb2xvbiA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5lZWRzUGFyZW5zKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwiKFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJ0cy5wdXNoKHByaW50RnVuY3Rpb25QYXJhbXMocGF0aCwgcHJpbnQsIG9wdGlvbnMsXG4gICAgICAgICAgLyogZXhwYW5kQXJnICovXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgLyogcHJpbnRUeXBlUGFyYW1zICovXG4gICAgICAgICAgdHJ1ZSkpOyAvLyBUaGUgcmV0dXJuVHlwZSBpcyBub3Qgd3JhcHBlZCBpbiBhIFR5cGVBbm5vdGF0aW9uLCBzbyB0aGUgY29sb25cbiAgICAgICAgICAvLyBuZWVkcyB0byBiZSBhZGRlZCBzZXBhcmF0ZWx5LlxuXG4gICAgICAgICAgaWYgKG4ucmV0dXJuVHlwZSB8fCBuLnByZWRpY2F0ZSB8fCBuLnR5cGVBbm5vdGF0aW9uKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGlzQXJyb3dGdW5jdGlvblR5cGVBbm5vdGF0aW9uID8gXCIgPT4gXCIgOiBcIjogXCIsIHBhdGguY2FsbChwcmludCwgXCJyZXR1cm5UeXBlXCIpLCBwYXRoLmNhbGwocHJpbnQsIFwicHJlZGljYXRlXCIpLCBwYXRoLmNhbGwocHJpbnQsIFwidHlwZUFubm90YXRpb25cIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZWVkc1BhcmVucykge1xuICAgICAgICAgICAgcGFydHMucHVzaChcIilcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQocGFydHMpKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiVFNSZXN0VHlwZVwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW1wiLi4uXCIsIHBhdGguY2FsbChwcmludCwgXCJ0eXBlQW5ub3RhdGlvblwiKV0pO1xuXG4gICAgICBjYXNlIFwiVFNPcHRpb25hbFR5cGVcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtwYXRoLmNhbGwocHJpbnQsIFwidHlwZUFubm90YXRpb25cIiksIFwiP1wiXSk7XG5cbiAgICAgIGNhc2UgXCJGdW5jdGlvblR5cGVQYXJhbVwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW3BhdGguY2FsbChwcmludCwgXCJuYW1lXCIpLCBwcmludE9wdGlvbmFsVG9rZW4ocGF0aCksIG4ubmFtZSA/IFwiOiBcIiA6IFwiXCIsIHBhdGguY2FsbChwcmludCwgXCJ0eXBlQW5ub3RhdGlvblwiKV0pO1xuXG4gICAgICBjYXNlIFwiR2VuZXJpY1R5cGVBbm5vdGF0aW9uXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbcGF0aC5jYWxsKHByaW50LCBcImlkXCIpLCBwYXRoLmNhbGwocHJpbnQsIFwidHlwZVBhcmFtZXRlcnNcIildKTtcblxuICAgICAgY2FzZSBcIkRlY2xhcmVJbnRlcmZhY2VcIjpcbiAgICAgIGNhc2UgXCJJbnRlcmZhY2VEZWNsYXJhdGlvblwiOlxuICAgICAgY2FzZSBcIkludGVyZmFjZVR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAobi50eXBlID09PSBcIkRlY2xhcmVJbnRlcmZhY2VcIiB8fCBuLmRlY2xhcmUpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCJkZWNsYXJlIFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJ0cy5wdXNoKFwiaW50ZXJmYWNlXCIpO1xuXG4gICAgICAgICAgaWYgKG4udHlwZSA9PT0gXCJEZWNsYXJlSW50ZXJmYWNlXCIgfHwgbi50eXBlID09PSBcIkludGVyZmFjZURlY2xhcmF0aW9uXCIpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCIgXCIsIHBhdGguY2FsbChwcmludCwgXCJpZFwiKSwgcGF0aC5jYWxsKHByaW50LCBcInR5cGVQYXJhbWV0ZXJzXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobltcImV4dGVuZHNcIl0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcGFydHMucHVzaChncm91cCRiKGluZGVudCQ3KGNvbmNhdCRkKFtsaW5lJDcsIFwiZXh0ZW5kcyBcIiwgKG4uZXh0ZW5kcy5sZW5ndGggPT09IDEgPyBpZGVudGl0eSQyIDogaW5kZW50JDcpKGpvaW4kOShjb25jYXQkZChbXCIsXCIsIGxpbmUkN10pLCBwYXRoLm1hcChwcmludCwgXCJleHRlbmRzXCIpKSldKSkpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJ0cy5wdXNoKFwiIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiYm9keVwiKSk7XG4gICAgICAgICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQocGFydHMpKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiQ2xhc3NJbXBsZW1lbnRzXCI6XG4gICAgICBjYXNlIFwiSW50ZXJmYWNlRXh0ZW5kc1wiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW3BhdGguY2FsbChwcmludCwgXCJpZFwiKSwgcGF0aC5jYWxsKHByaW50LCBcInR5cGVQYXJhbWV0ZXJzXCIpXSk7XG5cbiAgICAgIGNhc2UgXCJUU0NsYXNzSW1wbGVtZW50c1wiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW3BhdGguY2FsbChwcmludCwgXCJleHByZXNzaW9uXCIpLCBwYXRoLmNhbGwocHJpbnQsIFwidHlwZVBhcmFtZXRlcnNcIildKTtcblxuICAgICAgY2FzZSBcIlRTSW50ZXJzZWN0aW9uVHlwZVwiOlxuICAgICAgY2FzZSBcIkludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgdHlwZXMgPSBwYXRoLm1hcChwcmludCwgXCJ0eXBlc1wiKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgdmFyIHdhc0luZGVudGVkID0gZmFsc2U7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdHlwZXMubGVuZ3RoOyArK19pKSB7XG4gICAgICAgICAgICBpZiAoX2kgPT09IDApIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2godHlwZXNbX2ldKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3RUeXBlJDEobi50eXBlc1tfaSAtIDFdKSAmJiBpc09iamVjdFR5cGUkMShuLnR5cGVzW19pXSkpIHtcbiAgICAgICAgICAgICAgLy8gSWYgYm90aCBhcmUgb2JqZWN0cywgZG9uJ3QgaW5kZW50XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvbmNhdCRkKFtcIiAmIFwiLCB3YXNJbmRlbnRlZCA/IGluZGVudCQ3KHR5cGVzW19pXSkgOiB0eXBlc1tfaV1dKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpc09iamVjdFR5cGUkMShuLnR5cGVzW19pIC0gMV0pICYmICFpc09iamVjdFR5cGUkMShuLnR5cGVzW19pXSkpIHtcbiAgICAgICAgICAgICAgLy8gSWYgbm8gb2JqZWN0IGlzIGludm9sdmVkLCBnbyB0byB0aGUgbmV4dCBsaW5lIGlmIGl0IGJyZWFrc1xuICAgICAgICAgICAgICByZXN1bHQucHVzaChpbmRlbnQkNyhjb25jYXQkZChbXCIgJlwiLCBsaW5lJDcsIHR5cGVzW19pXV0pKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBJZiB5b3UgZ28gZnJvbSBvYmplY3QgdG8gbm9uLW9iamVjdCBvciB2aXMtdmVyc2EsIHRoZW4gaW5saW5lIGl0XG4gICAgICAgICAgICAgIGlmIChfaSA+IDEpIHtcbiAgICAgICAgICAgICAgICB3YXNJbmRlbnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXN1bHQucHVzaChcIiAmIFwiLCBfaSA+IDEgPyBpbmRlbnQkNyh0eXBlc1tfaV0pIDogdHlwZXNbX2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZ3JvdXAkYihjb25jYXQkZChyZXN1bHQpKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiVFNVbmlvblR5cGVcIjpcbiAgICAgIGNhc2UgXCJVbmlvblR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBzaW5nbGUtbGluZSB2YXJpYXRpb25cbiAgICAgICAgICAvLyBBIHwgQiB8IENcbiAgICAgICAgICAvLyBtdWx0aS1saW5lIHZhcmlhdGlvblxuICAgICAgICAgIC8vIHwgQVxuICAgICAgICAgIC8vIHwgQlxuICAgICAgICAgIC8vIHwgQ1xuICAgICAgICAgIHZhciBfcGFyZW50OSA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpOyAvLyBJZiB0aGVyZSdzIGEgbGVhZGluZyBjb21tZW50LCB0aGUgcGFyZW50IGlzIGRvaW5nIHRoZSBpbmRlbnRhdGlvblxuXG5cbiAgICAgICAgICB2YXIgc2hvdWxkSW5kZW50ID0gX3BhcmVudDkudHlwZSAhPT0gXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiICYmIF9wYXJlbnQ5LnR5cGUgIT09IFwiVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiICYmIF9wYXJlbnQ5LnR5cGUgIT09IFwiR2VuZXJpY1R5cGVBbm5vdGF0aW9uXCIgJiYgX3BhcmVudDkudHlwZSAhPT0gXCJUU1R5cGVSZWZlcmVuY2VcIiAmJiBfcGFyZW50OS50eXBlICE9PSBcIlRTVHlwZUFzc2VydGlvblwiICYmIF9wYXJlbnQ5LnR5cGUgIT09IFwiVHVwbGVUeXBlQW5ub3RhdGlvblwiICYmIF9wYXJlbnQ5LnR5cGUgIT09IFwiVFNUdXBsZVR5cGVcIiAmJiAhKF9wYXJlbnQ5LnR5cGUgPT09IFwiRnVuY3Rpb25UeXBlUGFyYW1cIiAmJiAhX3BhcmVudDkubmFtZSkgJiYgISgoX3BhcmVudDkudHlwZSA9PT0gXCJUeXBlQWxpYXNcIiB8fCBfcGFyZW50OS50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRvclwiIHx8IF9wYXJlbnQ5LnR5cGUgPT09IFwiVFNUeXBlQWxpYXNEZWNsYXJhdGlvblwiKSAmJiBoYXNMZWFkaW5nT3duTGluZUNvbW1lbnQkMShvcHRpb25zLm9yaWdpbmFsVGV4dCwgbiwgb3B0aW9ucykpOyAvLyB7XG4gICAgICAgICAgLy8gICBhOiBzdHJpbmdcbiAgICAgICAgICAvLyB9IHwgbnVsbCB8IHZvaWRcbiAgICAgICAgICAvLyBzaG91bGQgYmUgaW5saW5lZCBhbmQgbm90IGJlIHByaW50ZWQgaW4gdGhlIG11bHRpLWxpbmUgdmFyaWFudFxuXG4gICAgICAgICAgdmFyIHNob3VsZEh1ZyA9IHNob3VsZEh1Z1R5cGUobik7IC8vIFdlIHdhbnQgdG8gYWxpZ24gdGhlIGNoaWxkcmVuIGJ1dCB3aXRob3V0IGl0cyBjb21tZW50LCBzbyBpdCBsb29rcyBsaWtlXG4gICAgICAgICAgLy8gfCBjaGlsZDFcbiAgICAgICAgICAvLyAvLyBjb21tZW50XG4gICAgICAgICAgLy8gfCBjaGlsZDJcblxuICAgICAgICAgIHZhciBfcHJpbnRlZDQgPSBwYXRoLm1hcChmdW5jdGlvbiAodHlwZVBhdGgpIHtcbiAgICAgICAgICAgIHZhciBwcmludGVkVHlwZSA9IHR5cGVQYXRoLmNhbGwocHJpbnQpO1xuXG4gICAgICAgICAgICBpZiAoIXNob3VsZEh1Zykge1xuICAgICAgICAgICAgICBwcmludGVkVHlwZSA9IGFsaWduJDEoMiwgcHJpbnRlZFR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY29tbWVudHMucHJpbnRDb21tZW50cyh0eXBlUGF0aCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJpbnRlZFR5cGU7XG4gICAgICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgICB9LCBcInR5cGVzXCIpO1xuXG4gICAgICAgICAgaWYgKHNob3VsZEh1Zykge1xuICAgICAgICAgICAgcmV0dXJuIGpvaW4kOShcIiB8IFwiLCBfcHJpbnRlZDQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzaG91bGRBZGRTdGFydExpbmUgPSBzaG91bGRJbmRlbnQgJiYgIWhhc0xlYWRpbmdPd25MaW5lQ29tbWVudCQxKG9wdGlvbnMub3JpZ2luYWxUZXh0LCBuLCBvcHRpb25zKTtcbiAgICAgICAgICB2YXIgY29kZSA9IGNvbmNhdCRkKFtpZkJyZWFrJDYoY29uY2F0JGQoW3Nob3VsZEFkZFN0YXJ0TGluZSA/IGxpbmUkNyA6IFwiXCIsIFwifCBcIl0pKSwgam9pbiQ5KGNvbmNhdCRkKFtsaW5lJDcsIFwifCBcIl0pLCBfcHJpbnRlZDQpXSk7XG5cbiAgICAgICAgICBpZiAobmVlZHNQYXJlbnNfMShwYXRoLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQoW2luZGVudCQ3KGNvZGUpLCBzb2Z0bGluZSQ2XSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfcGFyZW50OS50eXBlID09PSBcIlR1cGxlVHlwZUFubm90YXRpb25cIiAmJiBfcGFyZW50OS50eXBlcy5sZW5ndGggPiAxIHx8IF9wYXJlbnQ5LnR5cGUgPT09IFwiVFNUdXBsZVR5cGVcIiAmJiBfcGFyZW50OS5lbGVtZW50VHlwZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQoW2luZGVudCQ3KGNvbmNhdCRkKFtpZkJyZWFrJDYoY29uY2F0JGQoW1wiKFwiLCBzb2Z0bGluZSQ2XSkpLCBjb2RlXSkpLCBzb2Z0bGluZSQ2LCBpZkJyZWFrJDYoXCIpXCIpXSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBncm91cCRiKHNob3VsZEluZGVudCA/IGluZGVudCQ3KGNvZGUpIDogY29kZSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIk51bGxhYmxlVHlwZUFubm90YXRpb25cIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtcIj9cIiwgcGF0aC5jYWxsKHByaW50LCBcInR5cGVBbm5vdGF0aW9uXCIpXSk7XG5cbiAgICAgIGNhc2UgXCJUU051bGxLZXl3b3JkXCI6XG4gICAgICBjYXNlIFwiTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvblwiOlxuICAgICAgICByZXR1cm4gXCJudWxsXCI7XG5cbiAgICAgIGNhc2UgXCJUaGlzVHlwZUFubm90YXRpb25cIjpcbiAgICAgICAgcmV0dXJuIFwidGhpc1wiO1xuXG4gICAgICBjYXNlIFwiTnVtYmVyVHlwZUFubm90YXRpb25cIjpcbiAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG5cbiAgICAgIGNhc2UgXCJPYmplY3RUeXBlQ2FsbFByb3BlcnR5XCI6XG4gICAgICAgIGlmIChuLnN0YXRpYykge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCJzdGF0aWMgXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwidmFsdWVcIikpO1xuICAgICAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuXG4gICAgICBjYXNlIFwiT2JqZWN0VHlwZUluZGV4ZXJcIjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfdmFyaWFuY2UgPSBnZXRGbG93VmFyaWFuY2UkMShuKTtcblxuICAgICAgICAgIHJldHVybiBjb25jYXQkZChbX3ZhcmlhbmNlIHx8IFwiXCIsIFwiW1wiLCBwYXRoLmNhbGwocHJpbnQsIFwiaWRcIiksIG4uaWQgPyBcIjogXCIgOiBcIlwiLCBwYXRoLmNhbGwocHJpbnQsIFwia2V5XCIpLCBcIl06IFwiLCBwYXRoLmNhbGwocHJpbnQsIFwidmFsdWVcIildKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiT2JqZWN0VHlwZVByb3BlcnR5XCI6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3ZhcmlhbmNlMiA9IGdldEZsb3dWYXJpYW5jZSQxKG4pO1xuXG4gICAgICAgICAgdmFyIG1vZGlmaWVyID0gXCJcIjtcblxuICAgICAgICAgIGlmIChuLnByb3RvKSB7XG4gICAgICAgICAgICBtb2RpZmllciA9IFwicHJvdG8gXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChuLnN0YXRpYykge1xuICAgICAgICAgICAgbW9kaWZpZXIgPSBcInN0YXRpYyBcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29uY2F0JGQoW21vZGlmaWVyLCBpc0dldHRlck9yU2V0dGVyJDEobikgPyBuLmtpbmQgKyBcIiBcIiA6IFwiXCIsIF92YXJpYW5jZTIgfHwgXCJcIiwgcHJpbnRQcm9wZXJ0eUtleShwYXRoLCBvcHRpb25zLCBwcmludCksIHByaW50T3B0aW9uYWxUb2tlbihwYXRoKSwgaXNGdW5jdGlvbk5vdGF0aW9uJDEobiwgb3B0aW9ucykgPyBcIlwiIDogXCI6IFwiLCBwYXRoLmNhbGwocHJpbnQsIFwidmFsdWVcIildKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiUXVhbGlmaWVkVHlwZUlkZW50aWZpZXJcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtwYXRoLmNhbGwocHJpbnQsIFwicXVhbGlmaWNhdGlvblwiKSwgXCIuXCIsIHBhdGguY2FsbChwcmludCwgXCJpZFwiKV0pO1xuXG4gICAgICBjYXNlIFwiU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICAgIHJldHVybiBub2RlU3RyKG4sIG9wdGlvbnMpO1xuXG4gICAgICBjYXNlIFwiTnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChfdHlwZW9mKG4udmFsdWUpLCBcIm51bWJlclwiKTtcblxuICAgICAgICBpZiAobi5leHRyYSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHByaW50TnVtYmVyJDIobi5leHRyYS5yYXcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByaW50TnVtYmVyJDIobi5yYXcpO1xuXG4gICAgICBjYXNlIFwiU3RyaW5nVHlwZUFubm90YXRpb25cIjpcbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG5cbiAgICAgIGNhc2UgXCJEZWNsYXJlVHlwZUFsaWFzXCI6XG4gICAgICBjYXNlIFwiVHlwZUFsaWFzXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAobi50eXBlID09PSBcIkRlY2xhcmVUeXBlQWxpYXNcIiB8fCBuLmRlY2xhcmUpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCJkZWNsYXJlIFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3ByaW50ZWQ1ID0gcHJpbnRBc3NpZ25tZW50UmlnaHQobi5pZCwgbi5yaWdodCwgcGF0aC5jYWxsKHByaW50LCBcInJpZ2h0XCIpLCBvcHRpb25zKTtcblxuICAgICAgICAgIHBhcnRzLnB1c2goXCJ0eXBlIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiaWRcIiksIHBhdGguY2FsbChwcmludCwgXCJ0eXBlUGFyYW1ldGVyc1wiKSwgXCIgPVwiLCBfcHJpbnRlZDUsIHNlbWkpO1xuICAgICAgICAgIHJldHVybiBncm91cCRiKGNvbmNhdCRkKHBhcnRzKSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIlR5cGVDYXN0RXhwcmVzc2lvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gcGF0aC5nZXRWYWx1ZSgpOyAvLyBGbG93IHN1cHBvcnRzIGEgY29tbWVudCBzeW50YXggZm9yIHNwZWNpZnlpbmcgdHlwZSBhbm5vdGF0aW9uczogaHR0cHM6Ly9mbG93Lm9yZy9lbi9kb2NzL3R5cGVzL2NvbW1lbnRzLy5cbiAgICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5LCBpdHMgcGFyc2VyIGRvZXNuJ3QgZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIGNvbW1lbnQgYW5ub3RhdGlvbnMgYW5kIHJlZ3VsYXJcbiAgICAgICAgICAvLyBhbm5vdGF0aW9ucyB3aGVuIHByb2R1Y2luZyBhbiBBU1QuIFNvIHRvIHByZXNlcnZlIHBhcmVudGhlc2VzIGFyb3VuZCB0eXBlIGNhc3RzIHRoYXQgdXNlXG4gICAgICAgICAgLy8gdGhlIGNvbW1lbnQgc3ludGF4LCB3ZSBuZWVkIHRvIGhhY2tpbHkgcmVhZCB0aGUgc291cmNlIGl0c2VsZiB0byBzZWUgaWYgdGhlIGNvZGUgY29udGFpbnNcbiAgICAgICAgICAvLyBhIHR5cGUgYW5ub3RhdGlvbiBjb21tZW50LlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gTm90ZSB0aGF0IHdlJ3JlIGFibGUgdG8gdXNlIHRoZSBub3JtYWwgd2hpdGVzcGFjZSByZWdleCBoZXJlIGJlY2F1c2UgdGhlIEZsb3cgcGFyc2VyIGhhc1xuICAgICAgICAgIC8vIGFscmVhZHkgZGVlbWVkIHRoaXMgQVNUIG5vZGUgdG8gYmUgYSB0eXBlIGNhc3QuIE9ubHkgdGhlIEJhYmVsIHBhcnNlciBuZWVkcyB0aGVcbiAgICAgICAgICAvLyBub24tbGluZS1icmVhayB3aGl0ZXNwYWNlIHJlZ2V4LCB3aGljaCBpcyB3aHkgaGFzRmxvd1Nob3J0aGFuZEFubm90YXRpb25Db21tZW50KCkgaXNcbiAgICAgICAgICAvLyBpbXBsZW1lbnRlZCBkaWZmZXJlbnRseS5cblxuICAgICAgICAgIHZhciBjb21tZW50U3ludGF4ID0gdmFsdWUgJiYgdmFsdWUudHlwZUFubm90YXRpb24gJiYgdmFsdWUudHlwZUFubm90YXRpb24ucmFuZ2UgJiYgb3B0aW9ucy5vcmlnaW5hbFRleHQuc3Vic3RyaW5nKHZhbHVlLnR5cGVBbm5vdGF0aW9uLnJhbmdlWzBdKS5tYXRjaCgvXlxcL1xcKlxccyo6Lyk7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtcIihcIiwgcGF0aC5jYWxsKHByaW50LCBcImV4cHJlc3Npb25cIiksIGNvbW1lbnRTeW50YXggPyBcIiAvKlwiIDogXCJcIiwgXCI6IFwiLCBwYXRoLmNhbGwocHJpbnQsIFwidHlwZUFubm90YXRpb25cIiksIGNvbW1lbnRTeW50YXggPyBcIiAqL1wiIDogXCJcIiwgXCIpXCJdKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCI6XG4gICAgICBjYXNlIFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfdmFsdWUgPSBwYXRoLmdldFZhbHVlKCk7XG5cbiAgICAgICAgICB2YXIgY29tbWVudFN0YXJ0ID0gX3ZhbHVlLnJhbmdlID8gb3B0aW9ucy5vcmlnaW5hbFRleHQuc3Vic3RyaW5nKDAsIF92YWx1ZS5yYW5nZVswXSkubGFzdEluZGV4T2YoXCIvKlwiKSA6IC0xOyAvLyBBcyBub3RlZCBpbiB0aGUgVHlwZUNhc3RFeHByZXNzaW9uIGNvbW1lbnRzIGFib3ZlLCB3ZSdyZSBhYmxlIHRvIHVzZSBhIG5vcm1hbCB3aGl0ZXNwYWNlIHJlZ2V4IGhlcmVcbiAgICAgICAgICAvLyBiZWNhdXNlIHdlIGtub3cgZm9yIHN1cmUgdGhhdCB0aGlzIGlzIGEgdHlwZSBkZWZpbml0aW9uLlxuXG4gICAgICAgICAgdmFyIF9jb21tZW50U3ludGF4ID0gY29tbWVudFN0YXJ0ID49IDAgJiYgb3B0aW9ucy5vcmlnaW5hbFRleHQuc3Vic3RyaW5nKGNvbW1lbnRTdGFydCkubWF0Y2goL15cXC9cXCpcXHMqOjovKTtcblxuICAgICAgICAgIGlmIChfY29tbWVudFN5bnRheCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtcIi8qOjogXCIsIHByaW50VHlwZVBhcmFtZXRlcnMocGF0aCwgb3B0aW9ucywgcHJpbnQsIFwicGFyYW1zXCIpLCBcIiAqL1wiXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHByaW50VHlwZVBhcmFtZXRlcnMocGF0aCwgb3B0aW9ucywgcHJpbnQsIFwicGFyYW1zXCIpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiOlxuICAgICAgY2FzZSBcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIjpcbiAgICAgICAgcmV0dXJuIHByaW50VHlwZVBhcmFtZXRlcnMocGF0aCwgb3B0aW9ucywgcHJpbnQsIFwicGFyYW1zXCIpO1xuXG4gICAgICBjYXNlIFwiVFNUeXBlUGFyYW1ldGVyXCI6XG4gICAgICBjYXNlIFwiVHlwZVBhcmFtZXRlclwiOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9wYXJlbnQxMCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpO1xuXG4gICAgICAgICAgaWYgKF9wYXJlbnQxMC50eXBlID09PSBcIlRTTWFwcGVkVHlwZVwiKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwiW1wiLCBwYXRoLmNhbGwocHJpbnQsIFwibmFtZVwiKSk7XG5cbiAgICAgICAgICAgIGlmIChuLmNvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgICAgcGFydHMucHVzaChcIiBpbiBcIiwgcGF0aC5jYWxsKHByaW50LCBcImNvbnN0cmFpbnRcIikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwiXVwiKTtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF92YXJpYW5jZTMgPSBnZXRGbG93VmFyaWFuY2UkMShuKTtcblxuICAgICAgICAgIGlmIChfdmFyaWFuY2UzKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKF92YXJpYW5jZTMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcIm5hbWVcIikpO1xuXG4gICAgICAgICAgaWYgKG4uYm91bmQpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCI6IFwiKTtcbiAgICAgICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcImJvdW5kXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobi5jb25zdHJhaW50KSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwiIGV4dGVuZHMgXCIsIHBhdGguY2FsbChwcmludCwgXCJjb25zdHJhaW50XCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobltcImRlZmF1bHRcIl0pIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCIgPSBcIiwgcGF0aC5jYWxsKHByaW50LCBcImRlZmF1bHRcIikpO1xuICAgICAgICAgIH0gLy8gS2VlcCBjb21tYSBpZiB0aGUgZmlsZSBleHRlbnNpb24gaXMgLnRzeCBhbmRcbiAgICAgICAgICAvLyBoYXMgb25lIHR5cGUgcGFyYW1ldGVyIHRoYXQgaXNuJ3QgZXh0ZW5kIHdpdGggYW55IHR5cGVzLlxuICAgICAgICAgIC8vIEJlY2F1c2UsIG90aGVyd2lzZSBmb3JtYXR0ZWQgcmVzdWx0IHdpbGwgYmUgaW52YWxpZCBhcyB0c3guXG5cblxuICAgICAgICAgIHZhciBfZ3JhbmRQYXJlbnQgPSBwYXRoLmdldE5vZGUoMik7XG5cbiAgICAgICAgICBpZiAoX3BhcmVudDEwLnBhcmFtcyAmJiBfcGFyZW50MTAucGFyYW1zLmxlbmd0aCA9PT0gMSAmJiBpc1RTWEZpbGUkMShvcHRpb25zKSAmJiAhbi5jb25zdHJhaW50ICYmIF9ncmFuZFBhcmVudC50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCIsXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIlR5cGVvZlR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbXCJ0eXBlb2YgXCIsIHBhdGguY2FsbChwcmludCwgXCJhcmd1bWVudFwiKV0pO1xuXG4gICAgICBjYXNlIFwiVm9pZFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICAgIHJldHVybiBcInZvaWRcIjtcblxuICAgICAgY2FzZSBcIkluZmVycmVkUHJlZGljYXRlXCI6XG4gICAgICAgIHJldHVybiBcIiVjaGVja3NcIjtcbiAgICAgIC8vIFVuaGFuZGxlZCB0eXBlcyBiZWxvdy4gSWYgZW5jb3VudGVyZWQsIG5vZGVzIG9mIHRoZXNlIHR5cGVzIHNob3VsZFxuICAgICAgLy8gYmUgZWl0aGVyIGxlZnQgYWxvbmUgb3IgZGVzdWdhcmVkIGludG8gQVNUIHR5cGVzIHRoYXQgYXJlIGZ1bGx5XG4gICAgICAvLyBzdXBwb3J0ZWQgYnkgdGhlIHByZXR0eS1wcmludGVyLlxuXG4gICAgICBjYXNlIFwiRGVjbGFyZWRQcmVkaWNhdGVcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtcIiVjaGVja3MoXCIsIHBhdGguY2FsbChwcmludCwgXCJ2YWx1ZVwiKSwgXCIpXCJdKTtcblxuICAgICAgY2FzZSBcIlRTQWJzdHJhY3RLZXl3b3JkXCI6XG4gICAgICAgIHJldHVybiBcImFic3RyYWN0XCI7XG5cbiAgICAgIGNhc2UgXCJUU0FueUtleXdvcmRcIjpcbiAgICAgICAgcmV0dXJuIFwiYW55XCI7XG5cbiAgICAgIGNhc2UgXCJUU0FzeW5jS2V5d29yZFwiOlxuICAgICAgICByZXR1cm4gXCJhc3luY1wiO1xuXG4gICAgICBjYXNlIFwiVFNCb29sZWFuS2V5d29yZFwiOlxuICAgICAgICByZXR1cm4gXCJib29sZWFuXCI7XG5cbiAgICAgIGNhc2UgXCJUU0JpZ0ludEtleXdvcmRcIjpcbiAgICAgICAgcmV0dXJuIFwiYmlnaW50XCI7XG5cbiAgICAgIGNhc2UgXCJUU0NvbnN0S2V5d29yZFwiOlxuICAgICAgICByZXR1cm4gXCJjb25zdFwiO1xuXG4gICAgICBjYXNlIFwiVFNEZWNsYXJlS2V5d29yZFwiOlxuICAgICAgICByZXR1cm4gXCJkZWNsYXJlXCI7XG5cbiAgICAgIGNhc2UgXCJUU0V4cG9ydEtleXdvcmRcIjpcbiAgICAgICAgcmV0dXJuIFwiZXhwb3J0XCI7XG5cbiAgICAgIGNhc2UgXCJUU05ldmVyS2V5d29yZFwiOlxuICAgICAgICByZXR1cm4gXCJuZXZlclwiO1xuXG4gICAgICBjYXNlIFwiVFNOdW1iZXJLZXl3b3JkXCI6XG4gICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuXG4gICAgICBjYXNlIFwiVFNPYmplY3RLZXl3b3JkXCI6XG4gICAgICAgIHJldHVybiBcIm9iamVjdFwiO1xuXG4gICAgICBjYXNlIFwiVFNQcm90ZWN0ZWRLZXl3b3JkXCI6XG4gICAgICAgIHJldHVybiBcInByb3RlY3RlZFwiO1xuXG4gICAgICBjYXNlIFwiVFNQcml2YXRlS2V5d29yZFwiOlxuICAgICAgICByZXR1cm4gXCJwcml2YXRlXCI7XG5cbiAgICAgIGNhc2UgXCJUU1B1YmxpY0tleXdvcmRcIjpcbiAgICAgICAgcmV0dXJuIFwicHVibGljXCI7XG5cbiAgICAgIGNhc2UgXCJUU1JlYWRvbmx5S2V5d29yZFwiOlxuICAgICAgICByZXR1cm4gXCJyZWFkb25seVwiO1xuXG4gICAgICBjYXNlIFwiVFNTeW1ib2xLZXl3b3JkXCI6XG4gICAgICAgIHJldHVybiBcInN5bWJvbFwiO1xuXG4gICAgICBjYXNlIFwiVFNTdGF0aWNLZXl3b3JkXCI6XG4gICAgICAgIHJldHVybiBcInN0YXRpY1wiO1xuXG4gICAgICBjYXNlIFwiVFNTdHJpbmdLZXl3b3JkXCI6XG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuXG4gICAgICBjYXNlIFwiVFNVbmRlZmluZWRLZXl3b3JkXCI6XG4gICAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiO1xuXG4gICAgICBjYXNlIFwiVFNVbmtub3duS2V5d29yZFwiOlxuICAgICAgICByZXR1cm4gXCJ1bmtub3duXCI7XG5cbiAgICAgIGNhc2UgXCJUU1ZvaWRLZXl3b3JkXCI6XG4gICAgICAgIHJldHVybiBcInZvaWRcIjtcblxuICAgICAgY2FzZSBcIlRTQXNFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbcGF0aC5jYWxsKHByaW50LCBcImV4cHJlc3Npb25cIiksIFwiIGFzIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwidHlwZUFubm90YXRpb25cIildKTtcblxuICAgICAgY2FzZSBcIlRTQXJyYXlUeXBlXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbcGF0aC5jYWxsKHByaW50LCBcImVsZW1lbnRUeXBlXCIpLCBcIltdXCJdKTtcblxuICAgICAgY2FzZSBcIlRTUHJvcGVydHlTaWduYXR1cmVcIjpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChuLmV4cG9ydCkge1xuICAgICAgICAgICAgcGFydHMucHVzaChcImV4cG9ydCBcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG4uYWNjZXNzaWJpbGl0eSkge1xuICAgICAgICAgICAgcGFydHMucHVzaChuLmFjY2Vzc2liaWxpdHkgKyBcIiBcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG4uc3RhdGljKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwic3RhdGljIFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobi5yZWFkb25seSkge1xuICAgICAgICAgICAgcGFydHMucHVzaChcInJlYWRvbmx5IFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJ0cy5wdXNoKHByaW50UHJvcGVydHlLZXkocGF0aCwgb3B0aW9ucywgcHJpbnQpLCBwcmludE9wdGlvbmFsVG9rZW4ocGF0aCkpO1xuXG4gICAgICAgICAgaWYgKG4udHlwZUFubm90YXRpb24pIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCI6IFwiKTtcbiAgICAgICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcInR5cGVBbm5vdGF0aW9uXCIpKTtcbiAgICAgICAgICB9IC8vIFRoaXMgaXNuJ3QgdmFsaWQgc2VtYW50aWNhbGx5LCBidXQgaXQncyBpbiB0aGUgQVNUIHNvIHdlIGNhbiBwcmludCBpdC5cblxuXG4gICAgICAgICAgaWYgKG4uaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCIgPSBcIiwgcGF0aC5jYWxsKHByaW50LCBcImluaXRpYWxpemVyXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJUU1BhcmFtZXRlclByb3BlcnR5XCI6XG4gICAgICAgIGlmIChuLmFjY2Vzc2liaWxpdHkpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKG4uYWNjZXNzaWJpbGl0eSArIFwiIFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuLmV4cG9ydCkge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCJleHBvcnQgXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG4uc3RhdGljKSB7XG4gICAgICAgICAgcGFydHMucHVzaChcInN0YXRpYyBcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobi5yZWFkb25seSkge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCJyZWFkb25seSBcIik7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJwYXJhbWV0ZXJcIikpO1xuICAgICAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuXG4gICAgICBjYXNlIFwiVFNUeXBlUmVmZXJlbmNlXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbcGF0aC5jYWxsKHByaW50LCBcInR5cGVOYW1lXCIpLCBwcmludFR5cGVQYXJhbWV0ZXJzKHBhdGgsIG9wdGlvbnMsIHByaW50LCBcInR5cGVQYXJhbWV0ZXJzXCIpXSk7XG5cbiAgICAgIGNhc2UgXCJUU1R5cGVRdWVyeVwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW1widHlwZW9mIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiZXhwck5hbWVcIildKTtcblxuICAgICAgY2FzZSBcIlRTSW5kZXhTaWduYXR1cmVcIjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfcGFyZW50MTEgPSBwYXRoLmdldFBhcmVudE5vZGUoKTtcblxuICAgICAgICAgIHJldHVybiBjb25jYXQkZChbbi5leHBvcnQgPyBcImV4cG9ydCBcIiA6IFwiXCIsIG4uYWNjZXNzaWJpbGl0eSA/IGNvbmNhdCRkKFtuLmFjY2Vzc2liaWxpdHksIFwiIFwiXSkgOiBcIlwiLCBuLnN0YXRpYyA/IFwic3RhdGljIFwiIDogXCJcIiwgbi5yZWFkb25seSA/IFwicmVhZG9ubHkgXCIgOiBcIlwiLCBcIltcIiwgbi5wYXJhbWV0ZXJzID8gY29uY2F0JGQocGF0aC5tYXAocHJpbnQsIFwicGFyYW1ldGVyc1wiKSkgOiBcIlwiLCBcIl06IFwiLCBwYXRoLmNhbGwocHJpbnQsIFwidHlwZUFubm90YXRpb25cIiksIF9wYXJlbnQxMS50eXBlID09PSBcIkNsYXNzQm9keVwiID8gc2VtaSA6IFwiXCJdKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiVFNUeXBlUHJlZGljYXRlXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbbi5hc3NlcnRzID8gXCJhc3NlcnRzIFwiIDogXCJcIiwgcGF0aC5jYWxsKHByaW50LCBcInBhcmFtZXRlck5hbWVcIiksIG4udHlwZUFubm90YXRpb24gPyBjb25jYXQkZChbXCIgaXMgXCIsIHBhdGguY2FsbChwcmludCwgXCJ0eXBlQW5ub3RhdGlvblwiKV0pIDogXCJcIl0pO1xuXG4gICAgICBjYXNlIFwiVFNOb25OdWxsRXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW3BhdGguY2FsbChwcmludCwgXCJleHByZXNzaW9uXCIpLCBcIiFcIl0pO1xuXG4gICAgICBjYXNlIFwiVFNUaGlzVHlwZVwiOlxuICAgICAgICByZXR1cm4gXCJ0aGlzXCI7XG5cbiAgICAgIGNhc2UgXCJUU0ltcG9ydFR5cGVcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFshbi5pc1R5cGVPZiA/IFwiXCIgOiBcInR5cGVvZiBcIiwgXCJpbXBvcnQoXCIsIHBhdGguY2FsbChwcmludCwgXCJwYXJhbWV0ZXJcIiksIFwiKVwiLCAhbi5xdWFsaWZpZXIgPyBcIlwiIDogY29uY2F0JGQoW1wiLlwiLCBwYXRoLmNhbGwocHJpbnQsIFwicXVhbGlmaWVyXCIpXSksIHByaW50VHlwZVBhcmFtZXRlcnMocGF0aCwgb3B0aW9ucywgcHJpbnQsIFwidHlwZVBhcmFtZXRlcnNcIildKTtcblxuICAgICAgY2FzZSBcIlRTTGl0ZXJhbFR5cGVcIjpcbiAgICAgICAgcmV0dXJuIHBhdGguY2FsbChwcmludCwgXCJsaXRlcmFsXCIpO1xuXG4gICAgICBjYXNlIFwiVFNJbmRleGVkQWNjZXNzVHlwZVwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW3BhdGguY2FsbChwcmludCwgXCJvYmplY3RUeXBlXCIpLCBcIltcIiwgcGF0aC5jYWxsKHByaW50LCBcImluZGV4VHlwZVwiKSwgXCJdXCJdKTtcblxuICAgICAgY2FzZSBcIlRTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb25cIjpcbiAgICAgIGNhc2UgXCJUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvblwiOlxuICAgICAgY2FzZSBcIlRTQ29uc3RydWN0b3JUeXBlXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAobi50eXBlICE9PSBcIlRTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uXCIpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCJuZXcgXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcnRzLnB1c2goZ3JvdXAkYihwcmludEZ1bmN0aW9uUGFyYW1zKHBhdGgsIHByaW50LCBvcHRpb25zLFxuICAgICAgICAgIC8qIGV4cGFuZEFyZyAqL1xuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIC8qIHByaW50VHlwZVBhcmFtcyAqL1xuICAgICAgICAgIHRydWUpKSk7XG5cbiAgICAgICAgICBpZiAobi5yZXR1cm5UeXBlKSB7XG4gICAgICAgICAgICB2YXIgaXNUeXBlID0gbi50eXBlID09PSBcIlRTQ29uc3RydWN0b3JUeXBlXCI7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGlzVHlwZSA/IFwiID0+IFwiIDogXCI6IFwiLCBwYXRoLmNhbGwocHJpbnQsIFwicmV0dXJuVHlwZVwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKHBhcnRzKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiVFNUeXBlT3BlcmF0b3JcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtuLm9wZXJhdG9yLCBcIiBcIiwgcGF0aC5jYWxsKHByaW50LCBcInR5cGVBbm5vdGF0aW9uXCIpXSk7XG5cbiAgICAgIGNhc2UgXCJUU01hcHBlZFR5cGVcIjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfc2hvdWxkQnJlYWszID0gaGFzTmV3bGluZUluUmFuZ2UkMihvcHRpb25zLm9yaWdpbmFsVGV4dCwgb3B0aW9ucy5sb2NTdGFydChuKSwgb3B0aW9ucy5sb2NFbmQobikpO1xuXG4gICAgICAgICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQoW1wie1wiLCBpbmRlbnQkNyhjb25jYXQkZChbb3B0aW9ucy5icmFja2V0U3BhY2luZyA/IGxpbmUkNyA6IHNvZnRsaW5lJDYsIG4ucmVhZG9ubHkgPyBjb25jYXQkZChbZ2V0VHlwZVNjcmlwdE1hcHBlZFR5cGVNb2RpZmllciQxKG4ucmVhZG9ubHksIFwicmVhZG9ubHlcIiksIFwiIFwiXSkgOiBcIlwiLCBwcmludFR5cGVTY3JpcHRNb2RpZmllcnMocGF0aCwgb3B0aW9ucywgcHJpbnQpLCBwYXRoLmNhbGwocHJpbnQsIFwidHlwZVBhcmFtZXRlclwiKSwgbi5vcHRpb25hbCA/IGdldFR5cGVTY3JpcHRNYXBwZWRUeXBlTW9kaWZpZXIkMShuLm9wdGlvbmFsLCBcIj9cIikgOiBcIlwiLCBcIjogXCIsIHBhdGguY2FsbChwcmludCwgXCJ0eXBlQW5ub3RhdGlvblwiKSwgaWZCcmVhayQ2KHNlbWksIFwiXCIpXSkpLCBjb21tZW50cy5wcmludERhbmdsaW5nQ29tbWVudHMocGF0aCwgb3B0aW9ucyxcbiAgICAgICAgICAvKiBzYW1lSW5kZW50ICovXG4gICAgICAgICAgdHJ1ZSksIG9wdGlvbnMuYnJhY2tldFNwYWNpbmcgPyBsaW5lJDcgOiBzb2Z0bGluZSQ2LCBcIn1cIl0pLCB7XG4gICAgICAgICAgICBzaG91bGRCcmVhazogX3Nob3VsZEJyZWFrM1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJUU01ldGhvZFNpZ25hdHVyZVwiOlxuICAgICAgICBwYXJ0cy5wdXNoKG4uYWNjZXNzaWJpbGl0eSA/IGNvbmNhdCRkKFtuLmFjY2Vzc2liaWxpdHksIFwiIFwiXSkgOiBcIlwiLCBuLmV4cG9ydCA/IFwiZXhwb3J0IFwiIDogXCJcIiwgbi5zdGF0aWMgPyBcInN0YXRpYyBcIiA6IFwiXCIsIG4ucmVhZG9ubHkgPyBcInJlYWRvbmx5IFwiIDogXCJcIiwgbi5jb21wdXRlZCA/IFwiW1wiIDogXCJcIiwgcGF0aC5jYWxsKHByaW50LCBcImtleVwiKSwgbi5jb21wdXRlZCA/IFwiXVwiIDogXCJcIiwgcHJpbnRPcHRpb25hbFRva2VuKHBhdGgpLCBwcmludEZ1bmN0aW9uUGFyYW1zKHBhdGgsIHByaW50LCBvcHRpb25zLFxuICAgICAgICAvKiBleHBhbmRBcmcgKi9cbiAgICAgICAgZmFsc2UsXG4gICAgICAgIC8qIHByaW50VHlwZVBhcmFtcyAqL1xuICAgICAgICB0cnVlKSk7XG5cbiAgICAgICAgaWYgKG4ucmV0dXJuVHlwZSkge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCI6IFwiLCBwYXRoLmNhbGwocHJpbnQsIFwicmV0dXJuVHlwZVwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ3JvdXAkYihjb25jYXQkZChwYXJ0cykpO1xuXG4gICAgICBjYXNlIFwiVFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvblwiOlxuICAgICAgICBwYXJ0cy5wdXNoKFwiZXhwb3J0IGFzIG5hbWVzcGFjZSBcIiwgcGF0aC5jYWxsKHByaW50LCBcImlkXCIpKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5zZW1pKSB7XG4gICAgICAgICAgcGFydHMucHVzaChcIjtcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ3JvdXAkYihjb25jYXQkZChwYXJ0cykpO1xuXG4gICAgICBjYXNlIFwiVFNFbnVtRGVjbGFyYXRpb25cIjpcbiAgICAgICAgaWYgKG4uZGVjbGFyZSkge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCJkZWNsYXJlIFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuLm1vZGlmaWVycykge1xuICAgICAgICAgIHBhcnRzLnB1c2gocHJpbnRUeXBlU2NyaXB0TW9kaWZpZXJzKHBhdGgsIG9wdGlvbnMsIHByaW50KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobi5jb25zdCkge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCJjb25zdCBcIik7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJ0cy5wdXNoKFwiZW51bSBcIiwgcGF0aC5jYWxsKHByaW50LCBcImlkXCIpLCBcIiBcIik7XG5cbiAgICAgICAgaWYgKG4ubWVtYmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKGdyb3VwJGIoY29uY2F0JGQoW1wie1wiLCBjb21tZW50cy5wcmludERhbmdsaW5nQ29tbWVudHMocGF0aCwgb3B0aW9ucyksIHNvZnRsaW5lJDYsIFwifVwiXSkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKGdyb3VwJGIoY29uY2F0JGQoW1wie1wiLCBpbmRlbnQkNyhjb25jYXQkZChbaGFyZGxpbmUkOSwgcHJpbnRBcnJheUl0ZW1zKHBhdGgsIG9wdGlvbnMsIFwibWVtYmVyc1wiLCBwcmludCksIHNob3VsZFByaW50Q29tbWEkMShvcHRpb25zLCBcImVzNVwiKSA/IFwiLFwiIDogXCJcIl0pKSwgY29tbWVudHMucHJpbnREYW5nbGluZ0NvbW1lbnRzKHBhdGgsIG9wdGlvbnMsXG4gICAgICAgICAgLyogc2FtZUluZGVudCAqL1xuICAgICAgICAgIHRydWUpLCBoYXJkbGluZSQ5LCBcIn1cIl0pKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuXG4gICAgICBjYXNlIFwiVFNFbnVtTWVtYmVyXCI6XG4gICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcImlkXCIpKTtcblxuICAgICAgICBpZiAobi5pbml0aWFsaXplcikge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCIgPSBcIiwgcGF0aC5jYWxsKHByaW50LCBcImluaXRpYWxpemVyXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG5cbiAgICAgIGNhc2UgXCJUU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uXCI6XG4gICAgICAgIGlmIChuLmlzRXhwb3J0KSB7XG4gICAgICAgICAgcGFydHMucHVzaChcImV4cG9ydCBcIik7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJ0cy5wdXNoKFwiaW1wb3J0IFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiaWRcIiksIFwiID0gXCIsIHBhdGguY2FsbChwcmludCwgXCJtb2R1bGVSZWZlcmVuY2VcIikpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnNlbWkpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKFwiO1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBncm91cCRiKGNvbmNhdCRkKHBhcnRzKSk7XG5cbiAgICAgIGNhc2UgXCJUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbXCJyZXF1aXJlKFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiZXhwcmVzc2lvblwiKSwgXCIpXCJdKTtcblxuICAgICAgY2FzZSBcIlRTTW9kdWxlRGVjbGFyYXRpb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfcGFyZW50MTIgPSBwYXRoLmdldFBhcmVudE5vZGUoKTtcblxuICAgICAgICAgIHZhciBpc0V4dGVybmFsTW9kdWxlID0gaXNMaXRlcmFsJDEobi5pZCk7XG4gICAgICAgICAgdmFyIHBhcmVudElzRGVjbGFyYXRpb24gPSBfcGFyZW50MTIudHlwZSA9PT0gXCJUU01vZHVsZURlY2xhcmF0aW9uXCI7XG4gICAgICAgICAgdmFyIGJvZHlJc0RlY2xhcmF0aW9uID0gbi5ib2R5ICYmIG4uYm9keS50eXBlID09PSBcIlRTTW9kdWxlRGVjbGFyYXRpb25cIjtcblxuICAgICAgICAgIGlmIChwYXJlbnRJc0RlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwiLlwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG4uZGVjbGFyZSkge1xuICAgICAgICAgICAgICBwYXJ0cy5wdXNoKFwiZGVjbGFyZSBcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcnRzLnB1c2gocHJpbnRUeXBlU2NyaXB0TW9kaWZpZXJzKHBhdGgsIG9wdGlvbnMsIHByaW50KSk7XG4gICAgICAgICAgICB2YXIgdGV4dEJldHdlZW5Ob2RlQW5kSXRzSWQgPSBvcHRpb25zLm9yaWdpbmFsVGV4dC5zbGljZShvcHRpb25zLmxvY1N0YXJ0KG4pLCBvcHRpb25zLmxvY1N0YXJ0KG4uaWQpKTsgLy8gR2xvYmFsIGRlY2xhcmF0aW9uIGxvb2tzIGxpa2UgdGhpczpcbiAgICAgICAgICAgIC8vIChkZWNsYXJlKT8gZ2xvYmFsIHsgLi4uIH1cblxuICAgICAgICAgICAgdmFyIGlzR2xvYmFsRGVjbGFyYXRpb24gPSBuLmlkLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIG4uaWQubmFtZSA9PT0gXCJnbG9iYWxcIiAmJiAhL25hbWVzcGFjZXxtb2R1bGUvLnRlc3QodGV4dEJldHdlZW5Ob2RlQW5kSXRzSWQpO1xuXG4gICAgICAgICAgICBpZiAoIWlzR2xvYmFsRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgcGFydHMucHVzaChpc0V4dGVybmFsTW9kdWxlIHx8IC8oXnxcXHMpbW9kdWxlKFxcc3wkKS8udGVzdCh0ZXh0QmV0d2Vlbk5vZGVBbmRJdHNJZCkgPyBcIm1vZHVsZSBcIiA6IFwibmFtZXNwYWNlIFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJpZFwiKSk7XG5cbiAgICAgICAgICBpZiAoYm9keUlzRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcImJvZHlcIikpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobi5ib2R5KSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwiIFwiLCBncm91cCRiKHBhdGguY2FsbChwcmludCwgXCJib2R5XCIpKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goc2VtaSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKHBhcnRzKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiUHJpdmF0ZU5hbWVcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtcIiNcIiwgcGF0aC5jYWxsKHByaW50LCBcImlkXCIpXSk7XG5cbiAgICAgIGNhc2UgXCJUU0NvbmRpdGlvbmFsVHlwZVwiOlxuICAgICAgICByZXR1cm4gcHJpbnRUZXJuYXJ5T3BlcmF0b3IocGF0aCwgb3B0aW9ucywgcHJpbnQsIHtcbiAgICAgICAgICBiZWZvcmVQYXJ0czogZnVuY3Rpb24gYmVmb3JlUGFydHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gW3BhdGguY2FsbChwcmludCwgXCJjaGVja1R5cGVcIiksIFwiIFwiLCBcImV4dGVuZHNcIiwgXCIgXCIsIHBhdGguY2FsbChwcmludCwgXCJleHRlbmRzVHlwZVwiKV07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhZnRlclBhcnRzOiBmdW5jdGlvbiBhZnRlclBhcnRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2hvdWxkQ2hlY2tKc3g6IGZhbHNlLFxuICAgICAgICAgIGNvbmRpdGlvbmFsTm9kZVR5cGU6IFwiVFNDb25kaXRpb25hbFR5cGVcIixcbiAgICAgICAgICBjb25zZXF1ZW50Tm9kZVByb3BlcnR5TmFtZTogXCJ0cnVlVHlwZVwiLFxuICAgICAgICAgIGFsdGVybmF0ZU5vZGVQcm9wZXJ0eU5hbWU6IFwiZmFsc2VUeXBlXCIsXG4gICAgICAgICAgdGVzdE5vZGVQcm9wZXJ0eU5hbWU6IFwiY2hlY2tUeXBlXCIsXG4gICAgICAgICAgYnJlYWtOZXN0ZWQ6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgXCJUU0luZmVyVHlwZVwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW1wiaW5mZXJcIiwgXCIgXCIsIHBhdGguY2FsbChwcmludCwgXCJ0eXBlUGFyYW1ldGVyXCIpXSk7XG5cbiAgICAgIGNhc2UgXCJJbnRlcnByZXRlckRpcmVjdGl2ZVwiOlxuICAgICAgICBwYXJ0cy5wdXNoKFwiIyFcIiwgbi52YWx1ZSwgaGFyZGxpbmUkOSk7XG5cbiAgICAgICAgaWYgKGlzTmV4dExpbmVFbXB0eSQ0KG9wdGlvbnMub3JpZ2luYWxUZXh0LCBuLCBvcHRpb25zKSkge1xuICAgICAgICAgIHBhcnRzLnB1c2goaGFyZGxpbmUkOSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuXG4gICAgICBjYXNlIFwiTkdSb290XCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbXS5jb25jYXQocGF0aC5jYWxsKHByaW50LCBcIm5vZGVcIiksICFuLm5vZGUuY29tbWVudHMgfHwgbi5ub2RlLmNvbW1lbnRzLmxlbmd0aCA9PT0gMCA/IFtdIDogY29uY2F0JGQoW1wiIC8vXCIsIG4ubm9kZS5jb21tZW50c1swXS52YWx1ZS50cmltUmlnaHQoKV0pKSk7XG5cbiAgICAgIGNhc2UgXCJOR0NoYWluZWRFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiBncm91cCRiKGpvaW4kOShjb25jYXQkZChbXCI7XCIsIGxpbmUkN10pLCBwYXRoLm1hcChmdW5jdGlvbiAoY2hpbGRQYXRoKSB7XG4gICAgICAgICAgcmV0dXJuIGhhc05nU2lkZUVmZmVjdCQxKGNoaWxkUGF0aCkgPyBwcmludChjaGlsZFBhdGgpIDogY29uY2F0JGQoW1wiKFwiLCBwcmludChjaGlsZFBhdGgpLCBcIilcIl0pO1xuICAgICAgICB9LCBcImV4cHJlc3Npb25zXCIpKSk7XG5cbiAgICAgIGNhc2UgXCJOR0VtcHR5RXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gXCJcIjtcblxuICAgICAgY2FzZSBcIk5HUXVvdGVkRXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW24ucHJlZml4LCBcIjpcIiwgbi52YWx1ZV0pO1xuXG4gICAgICBjYXNlIFwiTkdNaWNyb3N5bnRheFwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQocGF0aC5tYXAoZnVuY3Rpb24gKGNoaWxkUGF0aCwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JGQoW2luZGV4ID09PSAwID8gXCJcIiA6IGlzTmdGb3JPZiQxKGNoaWxkUGF0aC5nZXRWYWx1ZSgpLCBpbmRleCwgbikgPyBcIiBcIiA6IGNvbmNhdCRkKFtcIjtcIiwgbGluZSQ3XSksIHByaW50KGNoaWxkUGF0aCldKTtcbiAgICAgICAgfSwgXCJib2R5XCIpKTtcblxuICAgICAgY2FzZSBcIk5HTWljcm9zeW50YXhLZXlcIjpcbiAgICAgICAgcmV0dXJuIC9eW2Etel8kXVthLXowLTlfJF0qKC1bYS16XyRdW2EtejAtOV8kXSkqJC9pLnRlc3Qobi5uYW1lKSA/IG4ubmFtZSA6IEpTT04uc3RyaW5naWZ5KG4ubmFtZSk7XG5cbiAgICAgIGNhc2UgXCJOR01pY3Jvc3ludGF4RXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW3BhdGguY2FsbChwcmludCwgXCJleHByZXNzaW9uXCIpLCBuLmFsaWFzID09PSBudWxsID8gXCJcIiA6IGNvbmNhdCRkKFtcIiBhcyBcIiwgcGF0aC5jYWxsKHByaW50LCBcImFsaWFzXCIpXSldKTtcblxuICAgICAgY2FzZSBcIk5HTWljcm9zeW50YXhLZXllZEV4cHJlc3Npb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpbmRleCA9IHBhdGguZ2V0TmFtZSgpO1xuXG4gICAgICAgICAgdmFyIF9wYXJlbnROb2RlMiA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpO1xuXG4gICAgICAgICAgdmFyIHNob3VsZE5vdFByaW50Q29sb24gPSBpc05nRm9yT2YkMShuLCBpbmRleCwgX3BhcmVudE5vZGUyKSB8fCAoaW5kZXggPT09IDEgJiYgKG4ua2V5Lm5hbWUgPT09IFwidGhlblwiIHx8IG4ua2V5Lm5hbWUgPT09IFwiZWxzZVwiKSB8fCBpbmRleCA9PT0gMiAmJiBuLmtleS5uYW1lID09PSBcImVsc2VcIiAmJiBfcGFyZW50Tm9kZTIuYm9keVtpbmRleCAtIDFdLnR5cGUgPT09IFwiTkdNaWNyb3N5bnRheEtleWVkRXhwcmVzc2lvblwiICYmIF9wYXJlbnROb2RlMi5ib2R5W2luZGV4IC0gMV0ua2V5Lm5hbWUgPT09IFwidGhlblwiKSAmJiBfcGFyZW50Tm9kZTIuYm9keVswXS50eXBlID09PSBcIk5HTWljcm9zeW50YXhFeHByZXNzaW9uXCI7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtwYXRoLmNhbGwocHJpbnQsIFwia2V5XCIpLCBzaG91bGROb3RQcmludENvbG9uID8gXCIgXCIgOiBcIjogXCIsIHBhdGguY2FsbChwcmludCwgXCJleHByZXNzaW9uXCIpXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIk5HTWljcm9zeW50YXhMZXRcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtcImxldCBcIiwgcGF0aC5jYWxsKHByaW50LCBcImtleVwiKSwgbi52YWx1ZSA9PT0gbnVsbCA/IFwiXCIgOiBjb25jYXQkZChbXCIgPSBcIiwgcGF0aC5jYWxsKHByaW50LCBcInZhbHVlXCIpXSldKTtcblxuICAgICAgY2FzZSBcIk5HTWljcm9zeW50YXhBc1wiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW3BhdGguY2FsbChwcmludCwgXCJrZXlcIiksIFwiIGFzIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiYWxpYXNcIildKTtcblxuICAgICAgY2FzZSBcIkFyZ3VtZW50UGxhY2Vob2xkZXJcIjpcbiAgICAgICAgcmV0dXJuIFwiP1wiO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgSlNPTi5zdHJpbmdpZnkobi50eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRTdGF0ZW1lbnRTZXF1ZW5jZShwYXRoLCBvcHRpb25zLCBwcmludCkge1xuICAgIHZhciBwcmludGVkID0gW107XG4gICAgdmFyIGJvZHlOb2RlID0gcGF0aC5nZXROb2RlKCk7XG4gICAgdmFyIGlzQ2xhc3MgPSBib2R5Tm9kZS50eXBlID09PSBcIkNsYXNzQm9keVwiO1xuICAgIHBhdGgubWFwKGZ1bmN0aW9uIChzdG10UGF0aCwgaSkge1xuICAgICAgdmFyIHN0bXQgPSBzdG10UGF0aC5nZXRWYWx1ZSgpOyAvLyBKdXN0IGluIGNhc2UgdGhlIEFTVCBoYXMgYmVlbiBtb2RpZmllZCB0byBjb250YWluIGZhbHN5XG4gICAgICAvLyBcInN0YXRlbWVudHMsXCIgaXQncyBzYWZlciBzaW1wbHkgdG8gc2tpcCB0aGVtLlxuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblxuICAgICAgaWYgKCFzdG10KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gU2tpcCBwcmludGluZyBFbXB0eVN0YXRlbWVudCBub2RlcyB0byBhdm9pZCBsZWF2aW5nIHN0cmF5XG4gICAgICAvLyBzZW1pY29sb25zIGx5aW5nIGFyb3VuZC5cblxuXG4gICAgICBpZiAoc3RtdC50eXBlID09PSBcIkVtcHR5U3RhdGVtZW50XCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RtdFByaW50ZWQgPSBwcmludChzdG10UGF0aCk7XG4gICAgICB2YXIgdGV4dCA9IG9wdGlvbnMub3JpZ2luYWxUZXh0O1xuICAgICAgdmFyIHBhcnRzID0gW107IC8vIGluIG5vLXNlbWkgbW9kZSwgcHJlcGVuZCBzdGF0ZW1lbnQgd2l0aCBzZW1pY29sb24gaWYgaXQgbWlnaHQgYnJlYWsgQVNJXG4gICAgICAvLyBkb24ndCBwcmVwZW5kIHRoZSBvbmx5IEpTWCBlbGVtZW50IGluIGEgcHJvZ3JhbSB3aXRoIHNlbWljb2xvblxuXG4gICAgICBpZiAoIW9wdGlvbnMuc2VtaSAmJiAhaXNDbGFzcyAmJiAhaXNUaGVPbmx5SlNYRWxlbWVudEluTWFya2Rvd24kMShvcHRpb25zLCBzdG10UGF0aCkgJiYgc3RtdE5lZWRzQVNJUHJvdGVjdGlvbihzdG10UGF0aCwgb3B0aW9ucykpIHtcbiAgICAgICAgaWYgKHN0bXQuY29tbWVudHMgJiYgc3RtdC5jb21tZW50cy5zb21lKGZ1bmN0aW9uIChjb21tZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGNvbW1lbnQubGVhZGluZztcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHByaW50KHN0bXRQYXRoLCB7XG4gICAgICAgICAgICBuZWVkc1NlbWk6IHRydWVcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFydHMucHVzaChcIjtcIiwgc3RtdFByaW50ZWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0cy5wdXNoKHN0bXRQcmludGVkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFvcHRpb25zLnNlbWkgJiYgaXNDbGFzcykge1xuICAgICAgICBpZiAoY2xhc3NQcm9wTWF5Q2F1c2VBU0lQcm9ibGVtcyQxKHN0bXRQYXRoKSkge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCI7XCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0bXQudHlwZSA9PT0gXCJDbGFzc1Byb3BlcnR5XCIpIHtcbiAgICAgICAgICB2YXIgbmV4dENoaWxkID0gYm9keU5vZGUuYm9keVtpICsgMV07XG5cbiAgICAgICAgICBpZiAoY2xhc3NDaGlsZE5lZWRzQVNJUHJvdGVjdGlvbiQxKG5leHRDaGlsZCkpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCI7XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNOZXh0TGluZUVtcHR5JDQodGV4dCwgc3RtdCwgb3B0aW9ucykgJiYgIWlzTGFzdFN0YXRlbWVudCQxKHN0bXRQYXRoKSkge1xuICAgICAgICBwYXJ0cy5wdXNoKGhhcmRsaW5lJDkpO1xuICAgICAgfVxuXG4gICAgICBwcmludGVkLnB1c2goY29uY2F0JGQocGFydHMpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gam9pbiQ5KGhhcmRsaW5lJDksIHByaW50ZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRQcm9wZXJ0eUtleShwYXRoLCBvcHRpb25zLCBwcmludCkge1xuICAgIHZhciBub2RlID0gcGF0aC5nZXROb2RlKCk7XG5cbiAgICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgICAgcmV0dXJuIGNvbmNhdCRkKFtcIltcIiwgcGF0aC5jYWxsKHByaW50LCBcImtleVwiKSwgXCJdXCJdKTtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG4gICAgdmFyIGtleSA9IG5vZGUua2V5O1xuXG4gICAgaWYgKG9wdGlvbnMucXVvdGVQcm9wcyA9PT0gXCJjb25zaXN0ZW50XCIgJiYgIW5lZWRzUXVvdGVQcm9wcy5oYXMocGFyZW50KSkge1xuICAgICAgdmFyIG9iamVjdEhhc1N0cmluZ1Byb3AgPSAocGFyZW50LnByb3BlcnRpZXMgfHwgcGFyZW50LmJvZHkgfHwgcGFyZW50Lm1lbWJlcnMpLnNvbWUoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgcmV0dXJuICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5ICYmIGlzU3RyaW5nTGl0ZXJhbCQxKHByb3Aua2V5KSAmJiAhaXNTdHJpbmdQcm9wU2FmZVRvQ29lcmNlVG9JZGVudGlmaWVyJDEocHJvcCwgb3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICAgIG5lZWRzUXVvdGVQcm9wcy5zZXQocGFyZW50LCBvYmplY3RIYXNTdHJpbmdQcm9wKTtcbiAgICB9XG5cbiAgICBpZiAoa2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIChvcHRpb25zLnBhcnNlciA9PT0gXCJqc29uXCIgfHwgb3B0aW9ucy5xdW90ZVByb3BzID09PSBcImNvbnNpc3RlbnRcIiAmJiBuZWVkc1F1b3RlUHJvcHMuZ2V0KHBhcmVudCkpKSB7XG4gICAgICAvLyBhIC0+IFwiYVwiXG4gICAgICB2YXIgcHJvcCA9IHByaW50U3RyaW5nJDIoSlNPTi5zdHJpbmdpZnkoa2V5Lm5hbWUpLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBwYXRoLmNhbGwoZnVuY3Rpb24gKGtleVBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1lbnRzLnByaW50Q29tbWVudHMoa2V5UGF0aCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wO1xuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgIH0sIFwia2V5XCIpO1xuICAgIH1cblxuICAgIGlmIChpc1N0cmluZ1Byb3BTYWZlVG9Db2VyY2VUb0lkZW50aWZpZXIkMShub2RlLCBvcHRpb25zKSAmJiAob3B0aW9ucy5xdW90ZVByb3BzID09PSBcImFzLW5lZWRlZFwiIHx8IG9wdGlvbnMucXVvdGVQcm9wcyA9PT0gXCJjb25zaXN0ZW50XCIgJiYgIW5lZWRzUXVvdGVQcm9wcy5nZXQocGFyZW50KSkpIHtcbiAgICAgIC8vICdhJyAtPiBhXG4gICAgICByZXR1cm4gcGF0aC5jYWxsKGZ1bmN0aW9uIChrZXlQYXRoKSB7XG4gICAgICAgIHJldHVybiBjb21tZW50cy5wcmludENvbW1lbnRzKGtleVBhdGgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4ga2V5LnZhbHVlO1xuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgIH0sIFwia2V5XCIpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoLmNhbGwocHJpbnQsIFwia2V5XCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRNZXRob2QocGF0aCwgb3B0aW9ucywgcHJpbnQpIHtcbiAgICB2YXIgbm9kZSA9IHBhdGguZ2V0Tm9kZSgpO1xuICAgIHZhciBraW5kID0gbm9kZS5raW5kO1xuICAgIHZhciB2YWx1ZSA9IG5vZGUudmFsdWUgfHwgbm9kZTtcbiAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgIGlmICgha2luZCB8fCBraW5kID09PSBcImluaXRcIiB8fCBraW5kID09PSBcIm1ldGhvZFwiIHx8IGtpbmQgPT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgaWYgKHZhbHVlLmFzeW5jKSB7XG4gICAgICAgIHBhcnRzLnB1c2goXCJhc3luYyBcIik7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZS5nZW5lcmF0b3IpIHtcbiAgICAgICAgcGFydHMucHVzaChcIipcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydC5vayhraW5kID09PSBcImdldFwiIHx8IGtpbmQgPT09IFwic2V0XCIpO1xuICAgICAgcGFydHMucHVzaChraW5kLCBcIiBcIik7XG4gICAgfVxuXG4gICAgcGFydHMucHVzaChwcmludFByb3BlcnR5S2V5KHBhdGgsIG9wdGlvbnMsIHByaW50KSwgbm9kZS5vcHRpb25hbCB8fCBub2RlLmtleS5vcHRpb25hbCA/IFwiP1wiIDogXCJcIiwgbm9kZSA9PT0gdmFsdWUgPyBwcmludE1ldGhvZEludGVybmFsKHBhdGgsIG9wdGlvbnMsIHByaW50KSA6IHBhdGguY2FsbChmdW5jdGlvbiAocGF0aCkge1xuICAgICAgcmV0dXJuIHByaW50TWV0aG9kSW50ZXJuYWwocGF0aCwgb3B0aW9ucywgcHJpbnQpO1xuICAgIH0sIFwidmFsdWVcIikpO1xuICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludE1ldGhvZEludGVybmFsKHBhdGgsIG9wdGlvbnMsIHByaW50KSB7XG4gICAgdmFyIHBhcnRzID0gW3ByaW50RnVuY3Rpb25UeXBlUGFyYW1ldGVycyhwYXRoLCBvcHRpb25zLCBwcmludCksIGdyb3VwJGIoY29uY2F0JGQoW3ByaW50RnVuY3Rpb25QYXJhbXMocGF0aCwgcHJpbnQsIG9wdGlvbnMpLCBwcmludFJldHVyblR5cGUocGF0aCwgcHJpbnQsIG9wdGlvbnMpXSkpXTtcblxuICAgIGlmIChwYXRoLmdldE5vZGUoKS5ib2R5KSB7XG4gICAgICBwYXJ0cy5wdXNoKFwiIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiYm9keVwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnRzLnB1c2gob3B0aW9ucy5zZW1pID8gXCI7XCIgOiBcIlwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gY291bGRHcm91cEFyZyhhcmcpIHtcbiAgICByZXR1cm4gYXJnLnR5cGUgPT09IFwiT2JqZWN0RXhwcmVzc2lvblwiICYmIChhcmcucHJvcGVydGllcy5sZW5ndGggPiAwIHx8IGFyZy5jb21tZW50cykgfHwgYXJnLnR5cGUgPT09IFwiQXJyYXlFeHByZXNzaW9uXCIgJiYgKGFyZy5lbGVtZW50cy5sZW5ndGggPiAwIHx8IGFyZy5jb21tZW50cykgfHwgYXJnLnR5cGUgPT09IFwiVFNUeXBlQXNzZXJ0aW9uXCIgJiYgY291bGRHcm91cEFyZyhhcmcuZXhwcmVzc2lvbikgfHwgYXJnLnR5cGUgPT09IFwiVFNBc0V4cHJlc3Npb25cIiAmJiBjb3VsZEdyb3VwQXJnKGFyZy5leHByZXNzaW9uKSB8fCBhcmcudHlwZSA9PT0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIiB8fCBhcmcudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiICYmICggLy8gd2Ugd2FudCB0byBhdm9pZCBicmVha2luZyBpbnNpZGUgY29tcG9zaXRlIHJldHVybiB0eXBlcyBidXQgbm90IHNpbXBsZSBrZXl3b3Jkc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmV0dGllci9wcmV0dGllci9pc3N1ZXMvNDA3MFxuICAgIC8vIGV4cG9ydCBjbGFzcyBUaGluZyBpbXBsZW1lbnRzIE90aGVyVGhpbmcge1xuICAgIC8vICAgZG86ICh0eXBlOiBUeXBlKSA9PiBQcm92aWRlcjxQcm9wPiA9IG1lbW9pemUoXG4gICAgLy8gICAgICh0eXBlOiBPYmplY3RUeXBlKTogUHJvdmlkZXI8T3B0cz4gPT4ge31cbiAgICAvLyAgICk7XG4gICAgLy8gfVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmV0dGllci9wcmV0dGllci9pc3N1ZXMvNjA5OVxuICAgIC8vIGFwcC5nZXQoXCIvXCIsIChyZXEsIHJlcyk6IHZvaWQgPT4ge1xuICAgIC8vICAgcmVzLnNlbmQoXCJIZWxsbyBXb3JsZCFcIik7XG4gICAgLy8gfSk7XG4gICAgIWFyZy5yZXR1cm5UeXBlIHx8ICFhcmcucmV0dXJuVHlwZS50eXBlQW5ub3RhdGlvbiB8fCBhcmcucmV0dXJuVHlwZS50eXBlQW5ub3RhdGlvbi50eXBlICE9PSBcIlRTVHlwZVJlZmVyZW5jZVwiKSAmJiAoYXJnLmJvZHkudHlwZSA9PT0gXCJCbG9ja1N0YXRlbWVudFwiIHx8IGFyZy5ib2R5LnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiB8fCBhcmcuYm9keS50eXBlID09PSBcIk9iamVjdEV4cHJlc3Npb25cIiB8fCBhcmcuYm9keS50eXBlID09PSBcIkFycmF5RXhwcmVzc2lvblwiIHx8IGFyZy5ib2R5LnR5cGUgPT09IFwiQ2FsbEV4cHJlc3Npb25cIiB8fCBhcmcuYm9keS50eXBlID09PSBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIiB8fCBhcmcuYm9keS50eXBlID09PSBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiIHx8IGlzSlNYTm9kZSQxKGFyZy5ib2R5KSk7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRHcm91cExhc3RBcmcoYXJncykge1xuICAgIHZhciBsYXN0QXJnID0gZ2V0TGFzdCQyKGFyZ3MpO1xuICAgIHZhciBwZW51bHRpbWF0ZUFyZyA9IGdldFBlbnVsdGltYXRlJDEoYXJncyk7XG4gICAgcmV0dXJuICFoYXNMZWFkaW5nQ29tbWVudCQzKGxhc3RBcmcpICYmICFoYXNUcmFpbGluZ0NvbW1lbnQkMShsYXN0QXJnKSAmJiBjb3VsZEdyb3VwQXJnKGxhc3RBcmcpICYmICggLy8gSWYgdGhlIGxhc3QgdHdvIGFyZ3VtZW50cyBhcmUgb2YgdGhlIHNhbWUgdHlwZSxcbiAgICAvLyBkaXNhYmxlIGxhc3QgZWxlbWVudCBleHBhbnNpb24uXG4gICAgIXBlbnVsdGltYXRlQXJnIHx8IHBlbnVsdGltYXRlQXJnLnR5cGUgIT09IGxhc3RBcmcudHlwZSk7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRHcm91cEZpcnN0QXJnKGFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZmlyc3RBcmcgPSBhcmdzWzBdO1xuICAgIHZhciBzZWNvbmRBcmcgPSBhcmdzWzFdO1xuICAgIHJldHVybiAoIWZpcnN0QXJnLmNvbW1lbnRzIHx8ICFmaXJzdEFyZy5jb21tZW50cy5sZW5ndGgpICYmIChmaXJzdEFyZy50eXBlID09PSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiIHx8IGZpcnN0QXJnLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiBmaXJzdEFyZy5ib2R5LnR5cGUgPT09IFwiQmxvY2tTdGF0ZW1lbnRcIikgJiYgc2Vjb25kQXJnLnR5cGUgIT09IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIgJiYgc2Vjb25kQXJnLnR5cGUgIT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiBzZWNvbmRBcmcudHlwZSAhPT0gXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIiAmJiAhY291bGRHcm91cEFyZyhzZWNvbmRBcmcpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRKZXN0RWFjaFRlbXBsYXRlTGl0ZXJhbChub2RlLCBleHByZXNzaW9ucywgb3B0aW9ucykge1xuICAgIC8qKlxuICAgICAqIGEgICAgfCBiICAgIHwgZXhwZWN0ZWRcbiAgICAgKiAkezF9IHwgJHsxfSB8ICR7Mn1cbiAgICAgKiAkezF9IHwgJHsyfSB8ICR7M31cbiAgICAgKiAkezJ9IHwgJHsxfSB8ICR7M31cbiAgICAgKi9cbiAgICB2YXIgaGVhZGVyTmFtZXMgPSBub2RlLnF1YXNpc1swXS52YWx1ZS5yYXcudHJpbSgpLnNwbGl0KC9cXHMqXFx8XFxzKi8pO1xuXG4gICAgaWYgKGhlYWRlck5hbWVzLmxlbmd0aCA+IDEgfHwgaGVhZGVyTmFtZXMuc29tZShmdW5jdGlvbiAoaGVhZGVyTmFtZSkge1xuICAgICAgcmV0dXJuIGhlYWRlck5hbWUubGVuZ3RoICE9PSAwO1xuICAgIH0pKSB7XG4gICAgICB2YXIgcGFydHMgPSBbXTtcbiAgICAgIHZhciBzdHJpbmdpZmllZEV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnMubWFwKGZ1bmN0aW9uIChkb2MpIHtcbiAgICAgICAgcmV0dXJuIFwiJHtcIiArIHByaW50RG9jVG9TdHJpbmckMShkb2MsIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICBwcmludFdpZHRoOiBJbmZpbml0eSxcbiAgICAgICAgICBlbmRPZkxpbmU6IFwibGZcIlxuICAgICAgICB9KSkuZm9ybWF0dGVkICsgXCJ9XCI7XG4gICAgICB9KTtcbiAgICAgIHZhciB0YWJsZUJvZHkgPSBbe1xuICAgICAgICBoYXNMaW5lQnJlYWs6IGZhbHNlLFxuICAgICAgICBjZWxsczogW11cbiAgICAgIH1dO1xuXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG5vZGUucXVhc2lzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByb3cgPSB0YWJsZUJvZHlbdGFibGVCb2R5Lmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgY29ycmVzcG9uZGluZ0V4cHJlc3Npb24gPSBzdHJpbmdpZmllZEV4cHJlc3Npb25zW2kgLSAxXTtcbiAgICAgICAgcm93LmNlbGxzLnB1c2goY29ycmVzcG9uZGluZ0V4cHJlc3Npb24pO1xuXG4gICAgICAgIGlmIChjb3JyZXNwb25kaW5nRXhwcmVzc2lvbi5pbmRleE9mKFwiXFxuXCIpICE9PSAtMSkge1xuICAgICAgICAgIHJvdy5oYXNMaW5lQnJlYWsgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUucXVhc2lzW2ldLnZhbHVlLnJhdy5pbmRleE9mKFwiXFxuXCIpICE9PSAtMSkge1xuICAgICAgICAgIHRhYmxlQm9keS5wdXNoKHtcbiAgICAgICAgICAgIGhhc0xpbmVCcmVhazogZmFsc2UsXG4gICAgICAgICAgICBjZWxsczogW11cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbWF4Q29sdW1uQ291bnQgPSB0YWJsZUJvZHkucmVkdWNlKGZ1bmN0aW9uIChtYXhDb2x1bW5Db3VudCwgcm93KSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChtYXhDb2x1bW5Db3VudCwgcm93LmNlbGxzLmxlbmd0aCk7XG4gICAgICB9LCBoZWFkZXJOYW1lcy5sZW5ndGgpO1xuICAgICAgdmFyIG1heENvbHVtbldpZHRocyA9IEFycmF5LmZyb20obmV3IEFycmF5KG1heENvbHVtbkNvdW50KSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0pO1xuICAgICAgdmFyIHRhYmxlID0gW3tcbiAgICAgICAgY2VsbHM6IGhlYWRlck5hbWVzXG4gICAgICB9XS5jb25jYXQodGFibGVCb2R5LmZpbHRlcihmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHJldHVybiByb3cuY2VsbHMubGVuZ3RoICE9PSAwO1xuICAgICAgfSkpO1xuICAgICAgdGFibGUuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgcmV0dXJuICFyb3cuaGFzTGluZUJyZWFrO1xuICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHJvdy5jZWxscy5mb3JFYWNoKGZ1bmN0aW9uIChjZWxsLCBpbmRleCkge1xuICAgICAgICAgIG1heENvbHVtbldpZHRoc1tpbmRleF0gPSBNYXRoLm1heChtYXhDb2x1bW5XaWR0aHNbaW5kZXhdLCBnZXRTdHJpbmdXaWR0aCQyKGNlbGwpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHBhcnRzLnB1c2gobGluZVN1ZmZpeEJvdW5kYXJ5JDEsIFwiYFwiLCBpbmRlbnQkNyhjb25jYXQkZChbaGFyZGxpbmUkOSwgam9pbiQ5KGhhcmRsaW5lJDksIHRhYmxlLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHJldHVybiBqb2luJDkoXCIgfCBcIiwgcm93LmNlbGxzLm1hcChmdW5jdGlvbiAoY2VsbCwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gcm93Lmhhc0xpbmVCcmVhayA/IGNlbGwgOiBjZWxsICsgXCIgXCIucmVwZWF0KG1heENvbHVtbldpZHRoc1tpbmRleF0gLSBnZXRTdHJpbmdXaWR0aCQyKGNlbGwpKTtcbiAgICAgICAgfSkpO1xuICAgICAgfSkpXSkpLCBoYXJkbGluZSQ5LCBcImBcIik7XG4gICAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50QXJndW1lbnRzTGlzdChwYXRoLCBvcHRpb25zLCBwcmludCkge1xuICAgIHZhciBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIHZhciBhcmdzID0gbm9kZS5hcmd1bWVudHM7XG5cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjb25jYXQkZChbXCIoXCIsIGNvbW1lbnRzLnByaW50RGFuZ2xpbmdDb21tZW50cyhwYXRoLCBvcHRpb25zLFxuICAgICAgLyogc2FtZUluZGVudCAqL1xuICAgICAgdHJ1ZSksIFwiKVwiXSk7XG4gICAgfSAvLyB1c2VFZmZlY3QoKCkgPT4geyAuLi4gfSwgW2ZvbywgYmFyLCBiYXpdKVxuXG5cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDIgJiYgYXJnc1swXS50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgJiYgYXJnc1swXS5wYXJhbXMubGVuZ3RoID09PSAwICYmIGFyZ3NbMF0uYm9keS50eXBlID09PSBcIkJsb2NrU3RhdGVtZW50XCIgJiYgYXJnc1sxXS50eXBlID09PSBcIkFycmF5RXhwcmVzc2lvblwiICYmICFhcmdzLmZpbmQoZnVuY3Rpb24gKGFyZykge1xuICAgICAgcmV0dXJuIGFyZy5jb21tZW50cztcbiAgICB9KSkge1xuICAgICAgcmV0dXJuIGNvbmNhdCRkKFtcIihcIiwgcGF0aC5jYWxsKHByaW50LCBcImFyZ3VtZW50c1wiLCAwKSwgXCIsIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiYXJndW1lbnRzXCIsIDEpLCBcIilcIl0pO1xuICAgIH0gLy8gZnVuYyhcbiAgICAvLyAgICh7XG4gICAgLy8gICAgIGEsXG4gICAgLy8gICAgIGJcbiAgICAvLyAgIH0pID0+IHt9XG4gICAgLy8gKTtcblxuXG4gICAgZnVuY3Rpb24gc2hvdWxkQnJlYWtGb3JBcnJvd0Z1bmN0aW9uSW5Bcmd1bWVudHMoYXJnLCBhcmdQYXRoKSB7XG4gICAgICBpZiAoIWFyZyB8fCBhcmcudHlwZSAhPT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiIHx8ICFhcmcuYm9keSB8fCBhcmcuYm9keS50eXBlICE9PSBcIkJsb2NrU3RhdGVtZW50XCIgfHwgIWFyZy5wYXJhbXMgfHwgYXJnLnBhcmFtcy5sZW5ndGggPCAxKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNob3VsZEJyZWFrID0gZmFsc2U7XG4gICAgICBhcmdQYXRoLmVhY2goZnVuY3Rpb24gKHBhcmFtUGF0aCkge1xuICAgICAgICB2YXIgcHJpbnRlZCA9IGNvbmNhdCRkKFtwcmludChwYXJhbVBhdGgpXSk7XG4gICAgICAgIHNob3VsZEJyZWFrID0gc2hvdWxkQnJlYWsgfHwgd2lsbEJyZWFrJDEocHJpbnRlZCk7XG4gICAgICB9LCBcInBhcmFtc1wiKTtcbiAgICAgIHJldHVybiBzaG91bGRCcmVhaztcbiAgICB9XG5cbiAgICB2YXIgYW55QXJnRW1wdHlMaW5lID0gZmFsc2U7XG4gICAgdmFyIHNob3VsZEJyZWFrRm9yQXJyb3dGdW5jdGlvbiA9IGZhbHNlO1xuICAgIHZhciBoYXNFbXB0eUxpbmVGb2xsb3dpbmdGaXJzdEFyZyA9IGZhbHNlO1xuICAgIHZhciBsYXN0QXJnSW5kZXggPSBhcmdzLmxlbmd0aCAtIDE7XG4gICAgdmFyIHByaW50ZWRBcmd1bWVudHMgPSBwYXRoLm1hcChmdW5jdGlvbiAoYXJnUGF0aCwgaW5kZXgpIHtcbiAgICAgIHZhciBhcmcgPSBhcmdQYXRoLmdldE5vZGUoKTtcbiAgICAgIHZhciBwYXJ0cyA9IFtwcmludChhcmdQYXRoKV07XG5cbiAgICAgIGlmIChpbmRleCA9PT0gbGFzdEFyZ0luZGV4KSA7IGVsc2UgaWYgKGlzTmV4dExpbmVFbXB0eSQ0KG9wdGlvbnMub3JpZ2luYWxUZXh0LCBhcmcsIG9wdGlvbnMpKSB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgIGhhc0VtcHR5TGluZUZvbGxvd2luZ0ZpcnN0QXJnID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFueUFyZ0VtcHR5TGluZSA9IHRydWU7XG4gICAgICAgIHBhcnRzLnB1c2goXCIsXCIsIGhhcmRsaW5lJDksIGhhcmRsaW5lJDkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydHMucHVzaChcIixcIiwgbGluZSQ3KTtcbiAgICAgIH1cblxuICAgICAgc2hvdWxkQnJlYWtGb3JBcnJvd0Z1bmN0aW9uID0gc2hvdWxkQnJlYWtGb3JBcnJvd0Z1bmN0aW9uSW5Bcmd1bWVudHMoYXJnLCBhcmdQYXRoKTtcbiAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG4gICAgfSwgXCJhcmd1bWVudHNcIik7XG4gICAgdmFyIG1heWJlVHJhaWxpbmdDb21tYSA9IC8vIER5bmFtaWMgaW1wb3J0cyBjYW5ub3QgaGF2ZSB0cmFpbGluZyBjb21tYXNcbiAgICAhKG5vZGUuY2FsbGVlICYmIG5vZGUuY2FsbGVlLnR5cGUgPT09IFwiSW1wb3J0XCIpICYmIHNob3VsZFByaW50Q29tbWEkMShvcHRpb25zLCBcImFsbFwiKSA/IFwiLFwiIDogXCJcIjtcblxuICAgIGZ1bmN0aW9uIGFsbEFyZ3NCcm9rZW5PdXQoKSB7XG4gICAgICByZXR1cm4gZ3JvdXAkYihjb25jYXQkZChbXCIoXCIsIGluZGVudCQ3KGNvbmNhdCRkKFtsaW5lJDcsIGNvbmNhdCRkKHByaW50ZWRBcmd1bWVudHMpXSkpLCBtYXliZVRyYWlsaW5nQ29tbWEsIGxpbmUkNywgXCIpXCJdKSwge1xuICAgICAgICBzaG91bGRCcmVhazogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGlzRnVuY3Rpb25Db21wb3NpdGlvbkFyZ3MkMShhcmdzKSkge1xuICAgICAgcmV0dXJuIGFsbEFyZ3NCcm9rZW5PdXQoKTtcbiAgICB9XG5cbiAgICB2YXIgc2hvdWxkR3JvdXBGaXJzdCA9IHNob3VsZEdyb3VwRmlyc3RBcmcoYXJncyk7XG4gICAgdmFyIHNob3VsZEdyb3VwTGFzdCA9IHNob3VsZEdyb3VwTGFzdEFyZyhhcmdzKTtcblxuICAgIGlmIChzaG91bGRHcm91cEZpcnN0IHx8IHNob3VsZEdyb3VwTGFzdCkge1xuICAgICAgdmFyIHNob3VsZEJyZWFrID0gKHNob3VsZEdyb3VwRmlyc3QgPyBwcmludGVkQXJndW1lbnRzLnNsaWNlKDEpLnNvbWUod2lsbEJyZWFrJDEpIDogcHJpbnRlZEFyZ3VtZW50cy5zbGljZSgwLCAtMSkuc29tZSh3aWxsQnJlYWskMSkpIHx8IGFueUFyZ0VtcHR5TGluZSB8fCBzaG91bGRCcmVha0ZvckFycm93RnVuY3Rpb247IC8vIFdlIHdhbnQgdG8gcHJpbnQgdGhlIGxhc3QgYXJndW1lbnQgd2l0aCBhIHNwZWNpYWwgZmxhZ1xuXG4gICAgICB2YXIgcHJpbnRlZEV4cGFuZGVkO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgcGF0aC5lYWNoKGZ1bmN0aW9uIChhcmdQYXRoKSB7XG4gICAgICAgIGlmIChzaG91bGRHcm91cEZpcnN0ICYmIGkgPT09IDApIHtcbiAgICAgICAgICBwcmludGVkRXhwYW5kZWQgPSBbY29uY2F0JGQoW2FyZ1BhdGguY2FsbChmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgcmV0dXJuIHByaW50KHAsIHtcbiAgICAgICAgICAgICAgZXhwYW5kRmlyc3RBcmc6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pLCBwcmludGVkQXJndW1lbnRzLmxlbmd0aCA+IDEgPyBcIixcIiA6IFwiXCIsIGhhc0VtcHR5TGluZUZvbGxvd2luZ0ZpcnN0QXJnID8gaGFyZGxpbmUkOSA6IGxpbmUkNywgaGFzRW1wdHlMaW5lRm9sbG93aW5nRmlyc3RBcmcgPyBoYXJkbGluZSQ5IDogXCJcIl0pXS5jb25jYXQocHJpbnRlZEFyZ3VtZW50cy5zbGljZSgxKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvdWxkR3JvdXBMYXN0ICYmIGkgPT09IGFyZ3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHByaW50ZWRFeHBhbmRlZCA9IHByaW50ZWRBcmd1bWVudHMuc2xpY2UoMCwgLTEpLmNvbmNhdChhcmdQYXRoLmNhbGwoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIHJldHVybiBwcmludChwLCB7XG4gICAgICAgICAgICAgIGV4cGFuZExhc3RBcmc6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkrKztcbiAgICAgIH0sIFwiYXJndW1lbnRzXCIpO1xuICAgICAgdmFyIHNvbWVQcmludGVkQXJndW1lbnRzV2lsbEJyZWFrID0gcHJpbnRlZEFyZ3VtZW50cy5zb21lKHdpbGxCcmVhayQxKTtcbiAgICAgIHZhciBzaW1wbGVDb25jYXQgPSBjb25jYXQkZChbXCIoXCIsIGNvbmNhdCRkKHByaW50ZWRFeHBhbmRlZCksIFwiKVwiXSk7XG4gICAgICByZXR1cm4gY29uY2F0JGQoW3NvbWVQcmludGVkQXJndW1lbnRzV2lsbEJyZWFrID8gYnJlYWtQYXJlbnQkMyA6IFwiXCIsIGNvbmRpdGlvbmFsR3JvdXAkMShbIXNvbWVQcmludGVkQXJndW1lbnRzV2lsbEJyZWFrICYmICFub2RlLnR5cGVBcmd1bWVudHMgJiYgIW5vZGUudHlwZVBhcmFtZXRlcnMgPyBzaW1wbGVDb25jYXQgOiBpZkJyZWFrJDYoYWxsQXJnc0Jyb2tlbk91dCgpLCBzaW1wbGVDb25jYXQpLCBzaG91bGRHcm91cEZpcnN0ID8gY29uY2F0JGQoW1wiKFwiLCBncm91cCRiKHByaW50ZWRFeHBhbmRlZFswXSwge1xuICAgICAgICBzaG91bGRCcmVhazogdHJ1ZVxuICAgICAgfSksIGNvbmNhdCRkKHByaW50ZWRFeHBhbmRlZC5zbGljZSgxKSksIFwiKVwiXSkgOiBjb25jYXQkZChbXCIoXCIsIGNvbmNhdCRkKHByaW50ZWRBcmd1bWVudHMuc2xpY2UoMCwgLTEpKSwgZ3JvdXAkYihnZXRMYXN0JDIocHJpbnRlZEV4cGFuZGVkKSwge1xuICAgICAgICBzaG91bGRCcmVhazogdHJ1ZVxuICAgICAgfSksIFwiKVwiXSksIGFsbEFyZ3NCcm9rZW5PdXQoKV0sIHtcbiAgICAgICAgc2hvdWxkQnJlYWs6IHNob3VsZEJyZWFrXG4gICAgICB9KV0pO1xuICAgIH1cblxuICAgIHZhciBjb250ZW50cyA9IGNvbmNhdCRkKFtcIihcIiwgaW5kZW50JDcoY29uY2F0JGQoW3NvZnRsaW5lJDYsIGNvbmNhdCRkKHByaW50ZWRBcmd1bWVudHMpXSkpLCBpZkJyZWFrJDYobWF5YmVUcmFpbGluZ0NvbW1hKSwgc29mdGxpbmUkNiwgXCIpXCJdKTtcblxuICAgIGlmIChpc0xvbmdDdXJyaWVkQ2FsbEV4cHJlc3Npb24kMShwYXRoKSkge1xuICAgICAgLy8gQnkgbm90IHdyYXBwaW5nIHRoZSBhcmd1bWVudHMgaW4gYSBncm91cCwgdGhlIHByaW50ZXIgcHJpb3JpdGl6ZXNcbiAgICAgIC8vIGJyZWFraW5nIHVwIHRoZXNlIGFyZ3VtZW50cyByYXRoZXIgdGhhbiB0aGUgYXJncyBvZiB0aGUgcGFyZW50IGNhbGwuXG4gICAgICByZXR1cm4gY29udGVudHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyb3VwJGIoY29udGVudHMsIHtcbiAgICAgIHNob3VsZEJyZWFrOiBwcmludGVkQXJndW1lbnRzLnNvbWUod2lsbEJyZWFrJDEpIHx8IGFueUFyZ0VtcHR5TGluZVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRUeXBlQW5ub3RhdGlvbihwYXRoLCBvcHRpb25zLCBwcmludCkge1xuICAgIHZhciBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuXG4gICAgaWYgKCFub2RlLnR5cGVBbm5vdGF0aW9uKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50Tm9kZSA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpO1xuICAgIHZhciBpc0RlZmluaXRlID0gbm9kZS5kZWZpbml0ZSB8fCBwYXJlbnROb2RlICYmIHBhcmVudE5vZGUudHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0b3JcIiAmJiBwYXJlbnROb2RlLmRlZmluaXRlO1xuICAgIHZhciBpc0Z1bmN0aW9uRGVjbGFyYXRpb25JZGVudGlmaWVyID0gcGFyZW50Tm9kZS50eXBlID09PSBcIkRlY2xhcmVGdW5jdGlvblwiICYmIHBhcmVudE5vZGUuaWQgPT09IG5vZGU7XG5cbiAgICBpZiAoaXNGbG93QW5ub3RhdGlvbkNvbW1lbnQkMShvcHRpb25zLm9yaWdpbmFsVGV4dCwgbm9kZS50eXBlQW5ub3RhdGlvbiwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBjb25jYXQkZChbXCIgLyo6IFwiLCBwYXRoLmNhbGwocHJpbnQsIFwidHlwZUFubm90YXRpb25cIiksIFwiICovXCJdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uY2F0JGQoW2lzRnVuY3Rpb25EZWNsYXJhdGlvbklkZW50aWZpZXIgPyBcIlwiIDogaXNEZWZpbml0ZSA/IFwiITogXCIgOiBcIjogXCIsIHBhdGguY2FsbChwcmludCwgXCJ0eXBlQW5ub3RhdGlvblwiKV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRGdW5jdGlvblR5cGVQYXJhbWV0ZXJzKHBhdGgsIG9wdGlvbnMsIHByaW50KSB7XG4gICAgdmFyIGZ1biA9IHBhdGguZ2V0VmFsdWUoKTtcblxuICAgIGlmIChmdW4udHlwZUFyZ3VtZW50cykge1xuICAgICAgcmV0dXJuIHBhdGguY2FsbChwcmludCwgXCJ0eXBlQXJndW1lbnRzXCIpO1xuICAgIH1cblxuICAgIGlmIChmdW4udHlwZVBhcmFtZXRlcnMpIHtcbiAgICAgIHJldHVybiBwYXRoLmNhbGwocHJpbnQsIFwidHlwZVBhcmFtZXRlcnNcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludEZ1bmN0aW9uUGFyYW1zKHBhdGgsIHByaW50LCBvcHRpb25zLCBleHBhbmRBcmcsIHByaW50VHlwZVBhcmFtcykge1xuICAgIHZhciBmdW4gPSBwYXRoLmdldFZhbHVlKCk7XG4gICAgdmFyIHBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpO1xuICAgIHZhciBwYXJhbXNGaWVsZCA9IGZ1bi5wYXJhbWV0ZXJzID8gXCJwYXJhbWV0ZXJzXCIgOiBcInBhcmFtc1wiO1xuICAgIHZhciBpc1BhcmFtZXRlcnNJblRlc3RDYWxsID0gaXNUZXN0Q2FsbCQxKHBhcmVudCk7XG4gICAgdmFyIHNob3VsZEh1Z1BhcmFtZXRlcnMgPSBzaG91bGRIdWdBcmd1bWVudHMoZnVuKTtcbiAgICB2YXIgc2hvdWxkRXhwYW5kUGFyYW1ldGVycyA9IGV4cGFuZEFyZyAmJiAhKGZ1bltwYXJhbXNGaWVsZF0gJiYgZnVuW3BhcmFtc0ZpZWxkXS5zb21lKGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gbi5jb21tZW50cztcbiAgICB9KSk7XG4gICAgdmFyIHR5cGVQYXJhbXMgPSBwcmludFR5cGVQYXJhbXMgPyBwcmludEZ1bmN0aW9uVHlwZVBhcmFtZXRlcnMocGF0aCwgb3B0aW9ucywgcHJpbnQpIDogXCJcIjtcbiAgICB2YXIgcHJpbnRlZCA9IFtdO1xuXG4gICAgaWYgKGZ1bltwYXJhbXNGaWVsZF0pIHtcbiAgICAgIHZhciBsYXN0QXJnSW5kZXggPSBmdW5bcGFyYW1zRmllbGRdLmxlbmd0aCAtIDE7XG4gICAgICBwcmludGVkID0gcGF0aC5tYXAoZnVuY3Rpb24gKGNoaWxkUGF0aCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gW107XG4gICAgICAgIHZhciBwYXJhbSA9IGNoaWxkUGF0aC5nZXRWYWx1ZSgpO1xuICAgICAgICBwYXJ0cy5wdXNoKHByaW50KGNoaWxkUGF0aCkpO1xuXG4gICAgICAgIGlmIChpbmRleCA9PT0gbGFzdEFyZ0luZGV4KSB7XG4gICAgICAgICAgaWYgKGZ1bi5yZXN0KSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwiLFwiLCBsaW5lJDcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtZXRlcnNJblRlc3RDYWxsIHx8IHNob3VsZEh1Z1BhcmFtZXRlcnMgfHwgc2hvdWxkRXhwYW5kUGFyYW1ldGVycykge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCIsIFwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc05leHRMaW5lRW1wdHkkNChvcHRpb25zLm9yaWdpbmFsVGV4dCwgcGFyYW0sIG9wdGlvbnMpKSB7XG4gICAgICAgICAgcGFydHMucHVzaChcIixcIiwgaGFyZGxpbmUkOSwgaGFyZGxpbmUkOSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFydHMucHVzaChcIixcIiwgbGluZSQ3KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG4gICAgICB9LCBwYXJhbXNGaWVsZCk7XG4gICAgfVxuXG4gICAgaWYgKGZ1bi5yZXN0KSB7XG4gICAgICBwcmludGVkLnB1c2goY29uY2F0JGQoW1wiLi4uXCIsIHBhdGguY2FsbChwcmludCwgXCJyZXN0XCIpXSkpO1xuICAgIH1cblxuICAgIGlmIChwcmludGVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNvbmNhdCRkKFt0eXBlUGFyYW1zLCBcIihcIiwgY29tbWVudHMucHJpbnREYW5nbGluZ0NvbW1lbnRzKHBhdGgsIG9wdGlvbnMsXG4gICAgICAvKiBzYW1lSW5kZW50ICovXG4gICAgICB0cnVlLCBmdW5jdGlvbiAoY29tbWVudCkge1xuICAgICAgICByZXR1cm4gZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3RlciQxKG9wdGlvbnMub3JpZ2luYWxUZXh0LCBjb21tZW50LCBvcHRpb25zLmxvY0VuZCkgPT09IFwiKVwiO1xuICAgICAgfSksIFwiKVwiXSk7XG4gICAgfVxuXG4gICAgdmFyIGxhc3RQYXJhbSA9IGdldExhc3QkMihmdW5bcGFyYW1zRmllbGRdKTsgLy8gSWYgdGhlIHBhcmVudCBpcyBhIGNhbGwgd2l0aCB0aGUgZmlyc3QvbGFzdCBhcmd1bWVudCBleHBhbnNpb24gYW5kIHRoaXMgaXMgdGhlXG4gICAgLy8gcGFyYW1zIG9mIHRoZSBmaXJzdC9sYXN0IGFyZ3VtZW50LCB3ZSBkb24ndCB3YW50IHRoZSBhcmd1bWVudHMgdG8gYnJlYWsgYW5kIGluc3RlYWRcbiAgICAvLyB3YW50IHRoZSB3aG9sZSBleHByZXNzaW9uIHRvIGJlIG9uIGEgbmV3IGxpbmUuXG4gICAgLy9cbiAgICAvLyBHb29kOiAgICAgICAgICAgICAgICAgQmFkOlxuICAgIC8vICAgdmVyeWxvbmdjYWxsKCAgICAgICAgIHZlcnlsb25nY2FsbCgoXG4gICAgLy8gICAgIChhLCBiKSA9PiB7ICAgICAgICAgICBhLFxuICAgIC8vICAgICB9ICAgICAgICAgICAgICAgICAgICAgYixcbiAgICAvLyAgIH0pICAgICAgICAgICAgICAgICAgICApID0+IHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuXG4gICAgaWYgKHNob3VsZEV4cGFuZFBhcmFtZXRlcnMpIHtcbiAgICAgIHJldHVybiBncm91cCRiKGNvbmNhdCRkKFtyZW1vdmVMaW5lcyQyKHR5cGVQYXJhbXMpLCBcIihcIiwgY29uY2F0JGQocHJpbnRlZC5tYXAocmVtb3ZlTGluZXMkMikpLCBcIilcIl0pKTtcbiAgICB9IC8vIFNpbmdsZSBvYmplY3QgZGVzdHJ1Y3R1cmluZyBzaG91bGQgaHVnXG4gICAgLy9cbiAgICAvLyBmdW5jdGlvbih7XG4gICAgLy8gICBhLFxuICAgIC8vICAgYixcbiAgICAvLyAgIGNcbiAgICAvLyB9KSB7fVxuXG5cbiAgICB2YXIgaGFzTm90UGFyYW1ldGVyRGVjb3JhdG9yID0gZnVuW3BhcmFtc0ZpZWxkXS5ldmVyeShmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgIHJldHVybiAhcGFyYW0uZGVjb3JhdG9ycztcbiAgICB9KTtcblxuICAgIGlmIChzaG91bGRIdWdQYXJhbWV0ZXJzICYmIGhhc05vdFBhcmFtZXRlckRlY29yYXRvcikge1xuICAgICAgcmV0dXJuIGNvbmNhdCRkKFt0eXBlUGFyYW1zLCBcIihcIiwgY29uY2F0JGQocHJpbnRlZCksIFwiKVwiXSk7XG4gICAgfSAvLyBkb24ndCBicmVhayBpbiBzcGVjcywgZWc7IGBpdChcInNob3VsZCBtYWludGFpbiBwYXJlbnMgYXJvdW5kIGRvbmUgZXZlbiB3aGVuIGxvbmdcIiwgKGRvbmUpID0+IHt9KWBcblxuXG4gICAgaWYgKGlzUGFyYW1ldGVyc0luVGVzdENhbGwpIHtcbiAgICAgIHJldHVybiBjb25jYXQkZChbdHlwZVBhcmFtcywgXCIoXCIsIGNvbmNhdCRkKHByaW50ZWQpLCBcIilcIl0pO1xuICAgIH1cblxuICAgIHZhciBpc0Zsb3dTaG9ydGhhbmRXaXRoT25lQXJnID0gKGlzT2JqZWN0VHlwZVByb3BlcnR5QUZ1bmN0aW9uJDEocGFyZW50LCBvcHRpb25zKSB8fCBpc1R5cGVBbm5vdGF0aW9uQUZ1bmN0aW9uJDEocGFyZW50LCBvcHRpb25zKSB8fCBwYXJlbnQudHlwZSA9PT0gXCJUeXBlQWxpYXNcIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJVbmlvblR5cGVBbm5vdGF0aW9uXCIgfHwgcGFyZW50LnR5cGUgPT09IFwiVFNVbmlvblR5cGVcIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwiIHx8IHBhcmVudC50eXBlID09PSBcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIiAmJiBwYXJlbnQucmV0dXJuVHlwZSA9PT0gZnVuKSAmJiBmdW5bcGFyYW1zRmllbGRdLmxlbmd0aCA9PT0gMSAmJiBmdW5bcGFyYW1zRmllbGRdWzBdLm5hbWUgPT09IG51bGwgJiYgZnVuW3BhcmFtc0ZpZWxkXVswXS50eXBlQW5ub3RhdGlvbiAmJiBmdW4udHlwZVBhcmFtZXRlcnMgPT09IG51bGwgJiYgaXNTaW1wbGVGbG93VHlwZSQxKGZ1bltwYXJhbXNGaWVsZF1bMF0udHlwZUFubm90YXRpb24pICYmICFmdW4ucmVzdDtcblxuICAgIGlmIChpc0Zsb3dTaG9ydGhhbmRXaXRoT25lQXJnKSB7XG4gICAgICBpZiAob3B0aW9ucy5hcnJvd1BhcmVucyA9PT0gXCJhbHdheXNcIikge1xuICAgICAgICByZXR1cm4gY29uY2F0JGQoW1wiKFwiLCBjb25jYXQkZChwcmludGVkKSwgXCIpXCJdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbmNhdCRkKHByaW50ZWQpO1xuICAgIH1cblxuICAgIHZhciBjYW5IYXZlVHJhaWxpbmdDb21tYSA9ICEobGFzdFBhcmFtICYmIGxhc3RQYXJhbS50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpICYmICFmdW4ucmVzdDtcbiAgICByZXR1cm4gY29uY2F0JGQoW3R5cGVQYXJhbXMsIFwiKFwiLCBpbmRlbnQkNyhjb25jYXQkZChbc29mdGxpbmUkNiwgY29uY2F0JGQocHJpbnRlZCldKSksIGlmQnJlYWskNihjYW5IYXZlVHJhaWxpbmdDb21tYSAmJiBzaG91bGRQcmludENvbW1hJDEob3B0aW9ucywgXCJhbGxcIikgPyBcIixcIiA6IFwiXCIpLCBzb2Z0bGluZSQ2LCBcIilcIl0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkUHJpbnRQYXJhbXNXaXRob3V0UGFyZW5zKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5hcnJvd1BhcmVucyA9PT0gXCJhbHdheXNcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmFycm93UGFyZW5zID09PSBcImF2b2lkXCIpIHtcbiAgICAgIHZhciBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgICAgcmV0dXJuIGNhblByaW50UGFyYW1zV2l0aG91dFBhcmVucyhub2RlKTtcbiAgICB9IC8vIEZhbGxiYWNrIGRlZmF1bHQ7IHNob3VsZCBiZSB1bnJlYWNoYWJsZVxuXG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5QcmludFBhcmFtc1dpdGhvdXRQYXJlbnMobm9kZSkge1xuICAgIHJldHVybiBub2RlLnBhcmFtcy5sZW5ndGggPT09IDEgJiYgIW5vZGUucmVzdCAmJiAhbm9kZS50eXBlUGFyYW1ldGVycyAmJiAhaGFzRGFuZ2xpbmdDb21tZW50cyQxKG5vZGUpICYmIG5vZGUucGFyYW1zWzBdLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmICFub2RlLnBhcmFtc1swXS50eXBlQW5ub3RhdGlvbiAmJiAhbm9kZS5wYXJhbXNbMF0uY29tbWVudHMgJiYgIW5vZGUucGFyYW1zWzBdLm9wdGlvbmFsICYmICFub2RlLnByZWRpY2F0ZSAmJiAhbm9kZS5yZXR1cm5UeXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRGdW5jdGlvbkRlY2xhcmF0aW9uKHBhdGgsIHByaW50LCBvcHRpb25zKSB7XG4gICAgdmFyIG4gPSBwYXRoLmdldFZhbHVlKCk7XG4gICAgdmFyIHBhcnRzID0gW107XG5cbiAgICBpZiAobi5hc3luYykge1xuICAgICAgcGFydHMucHVzaChcImFzeW5jIFwiKTtcbiAgICB9XG5cbiAgICBwYXJ0cy5wdXNoKFwiZnVuY3Rpb25cIik7XG5cbiAgICBpZiAobi5nZW5lcmF0b3IpIHtcbiAgICAgIHBhcnRzLnB1c2goXCIqXCIpO1xuICAgIH1cblxuICAgIGlmIChuLmlkKSB7XG4gICAgICBwYXJ0cy5wdXNoKFwiIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiaWRcIikpO1xuICAgIH1cblxuICAgIHBhcnRzLnB1c2gocHJpbnRGdW5jdGlvblR5cGVQYXJhbWV0ZXJzKHBhdGgsIG9wdGlvbnMsIHByaW50KSwgZ3JvdXAkYihjb25jYXQkZChbcHJpbnRGdW5jdGlvblBhcmFtcyhwYXRoLCBwcmludCwgb3B0aW9ucyksIHByaW50UmV0dXJuVHlwZShwYXRoLCBwcmludCwgb3B0aW9ucyldKSksIG4uYm9keSA/IFwiIFwiIDogXCJcIiwgcGF0aC5jYWxsKHByaW50LCBcImJvZHlcIikpO1xuICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludFJldHVyblR5cGUocGF0aCwgcHJpbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgbiA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICB2YXIgcmV0dXJuVHlwZSA9IHBhdGguY2FsbChwcmludCwgXCJyZXR1cm5UeXBlXCIpO1xuXG4gICAgaWYgKG4ucmV0dXJuVHlwZSAmJiBpc0Zsb3dBbm5vdGF0aW9uQ29tbWVudCQxKG9wdGlvbnMub3JpZ2luYWxUZXh0LCBuLnJldHVyblR5cGUsIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gY29uY2F0JGQoW1wiIC8qOiBcIiwgcmV0dXJuVHlwZSwgXCIgKi9cIl0pO1xuICAgIH1cblxuICAgIHZhciBwYXJ0cyA9IFtyZXR1cm5UeXBlXTsgLy8gcHJlcGVuZCBjb2xvbiB0byBUeXBlU2NyaXB0IHR5cGUgYW5ub3RhdGlvblxuXG4gICAgaWYgKG4ucmV0dXJuVHlwZSAmJiBuLnJldHVyblR5cGUudHlwZUFubm90YXRpb24pIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoXCI6IFwiKTtcbiAgICB9XG5cbiAgICBpZiAobi5wcmVkaWNhdGUpIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gdHlwZSB3aWxsIGFscmVhZHkgYWRkIHRoZSBjb2xvbiwgYnV0IG90aGVyd2lzZSB3ZVxuICAgICAgLy8gbmVlZCB0byBkbyBpdCBvdXJzZWx2ZXNcbiAgICAgIHBhcnRzLnB1c2gobi5yZXR1cm5UeXBlID8gXCIgXCIgOiBcIjogXCIsIHBhdGguY2FsbChwcmludCwgXCJwcmVkaWNhdGVcIikpO1xuICAgIH1cblxuICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludEV4cG9ydERlY2xhcmF0aW9uKHBhdGgsIG9wdGlvbnMsIHByaW50KSB7XG4gICAgdmFyIGRlY2wgPSBwYXRoLmdldFZhbHVlKCk7XG4gICAgdmFyIHNlbWkgPSBvcHRpb25zLnNlbWkgPyBcIjtcIiA6IFwiXCI7XG4gICAgdmFyIHBhcnRzID0gW1wiZXhwb3J0IFwiXTtcbiAgICB2YXIgaXNEZWZhdWx0ID0gZGVjbFtcImRlZmF1bHRcIl0gfHwgZGVjbC50eXBlID09PSBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiO1xuXG4gICAgaWYgKGlzRGVmYXVsdCkge1xuICAgICAgcGFydHMucHVzaChcImRlZmF1bHQgXCIpO1xuICAgIH1cblxuICAgIHBhcnRzLnB1c2goY29tbWVudHMucHJpbnREYW5nbGluZ0NvbW1lbnRzKHBhdGgsIG9wdGlvbnMsXG4gICAgLyogc2FtZUluZGVudCAqL1xuICAgIHRydWUpKTtcblxuICAgIGlmIChuZWVkc0hhcmRsaW5lQWZ0ZXJEYW5nbGluZ0NvbW1lbnQkMShkZWNsKSkge1xuICAgICAgcGFydHMucHVzaChoYXJkbGluZSQ5KTtcbiAgICB9XG5cbiAgICBpZiAoZGVjbC5kZWNsYXJhdGlvbikge1xuICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwiZGVjbGFyYXRpb25cIikpO1xuXG4gICAgICBpZiAoaXNEZWZhdWx0ICYmIGRlY2wuZGVjbGFyYXRpb24udHlwZSAhPT0gXCJDbGFzc0RlY2xhcmF0aW9uXCIgJiYgZGVjbC5kZWNsYXJhdGlvbi50eXBlICE9PSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiAmJiBkZWNsLmRlY2xhcmF0aW9uLnR5cGUgIT09IFwiVFNJbnRlcmZhY2VEZWNsYXJhdGlvblwiICYmIGRlY2wuZGVjbGFyYXRpb24udHlwZSAhPT0gXCJEZWNsYXJlQ2xhc3NcIiAmJiBkZWNsLmRlY2xhcmF0aW9uLnR5cGUgIT09IFwiRGVjbGFyZUZ1bmN0aW9uXCIgJiYgZGVjbC5kZWNsYXJhdGlvbi50eXBlICE9PSBcIlRTRGVjbGFyZUZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcGFydHMucHVzaChzZW1pKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRlY2wuc3BlY2lmaWVycyAmJiBkZWNsLnNwZWNpZmllcnMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgc3BlY2lmaWVycyA9IFtdO1xuICAgICAgICB2YXIgZGVmYXVsdFNwZWNpZmllcnMgPSBbXTtcbiAgICAgICAgdmFyIG5hbWVzcGFjZVNwZWNpZmllcnMgPSBbXTtcbiAgICAgICAgcGF0aC5lYWNoKGZ1bmN0aW9uIChzcGVjaWZpZXJQYXRoKSB7XG4gICAgICAgICAgdmFyIHNwZWNpZmllclR5cGUgPSBwYXRoLmdldFZhbHVlKCkudHlwZTtcblxuICAgICAgICAgIGlmIChzcGVjaWZpZXJUeXBlID09PSBcIkV4cG9ydFNwZWNpZmllclwiKSB7XG4gICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2gocHJpbnQoc3BlY2lmaWVyUGF0aCkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3BlY2lmaWVyVHlwZSA9PT0gXCJFeHBvcnREZWZhdWx0U3BlY2lmaWVyXCIpIHtcbiAgICAgICAgICAgIGRlZmF1bHRTcGVjaWZpZXJzLnB1c2gocHJpbnQoc3BlY2lmaWVyUGF0aCkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3BlY2lmaWVyVHlwZSA9PT0gXCJFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIikge1xuICAgICAgICAgICAgbmFtZXNwYWNlU3BlY2lmaWVycy5wdXNoKGNvbmNhdCRkKFtcIiogYXMgXCIsIHByaW50KHNwZWNpZmllclBhdGgpXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgXCJzcGVjaWZpZXJzXCIpO1xuICAgICAgICB2YXIgaXNOYW1lc3BhY2VGb2xsb3dlZCA9IG5hbWVzcGFjZVNwZWNpZmllcnMubGVuZ3RoICE9PSAwICYmIHNwZWNpZmllcnMubGVuZ3RoICE9PSAwO1xuICAgICAgICB2YXIgaXNEZWZhdWx0Rm9sbG93ZWQgPSBkZWZhdWx0U3BlY2lmaWVycy5sZW5ndGggIT09IDAgJiYgKG5hbWVzcGFjZVNwZWNpZmllcnMubGVuZ3RoICE9PSAwIHx8IHNwZWNpZmllcnMubGVuZ3RoICE9PSAwKTtcbiAgICAgICAgdmFyIGNhbkJyZWFrID0gc3BlY2lmaWVycy5sZW5ndGggPiAxIHx8IGRlZmF1bHRTcGVjaWZpZXJzLmxlbmd0aCA+IDAgfHwgZGVjbC5zcGVjaWZpZXJzICYmIGRlY2wuc3BlY2lmaWVycy5zb21lKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUuY29tbWVudHM7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcHJpbnRlZCA9IFwiXCI7XG5cbiAgICAgICAgaWYgKHNwZWNpZmllcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgaWYgKGNhbkJyZWFrKSB7XG4gICAgICAgICAgICBwcmludGVkID0gZ3JvdXAkYihjb25jYXQkZChbXCJ7XCIsIGluZGVudCQ3KGNvbmNhdCRkKFtvcHRpb25zLmJyYWNrZXRTcGFjaW5nID8gbGluZSQ3IDogc29mdGxpbmUkNiwgam9pbiQ5KGNvbmNhdCRkKFtcIixcIiwgbGluZSQ3XSksIHNwZWNpZmllcnMpXSkpLCBpZkJyZWFrJDYoc2hvdWxkUHJpbnRDb21tYSQxKG9wdGlvbnMpID8gXCIsXCIgOiBcIlwiKSwgb3B0aW9ucy5icmFja2V0U3BhY2luZyA/IGxpbmUkNyA6IHNvZnRsaW5lJDYsIFwifVwiXSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmludGVkID0gY29uY2F0JGQoW1wie1wiLCBvcHRpb25zLmJyYWNrZXRTcGFjaW5nID8gXCIgXCIgOiBcIlwiLCBjb25jYXQkZChzcGVjaWZpZXJzKSwgb3B0aW9ucy5icmFja2V0U3BhY2luZyA/IFwiIFwiIDogXCJcIiwgXCJ9XCJdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwYXJ0cy5wdXNoKGRlY2wuZXhwb3J0S2luZCA9PT0gXCJ0eXBlXCIgPyBcInR5cGUgXCIgOiBcIlwiLCBjb25jYXQkZChkZWZhdWx0U3BlY2lmaWVycyksIGNvbmNhdCRkKFtpc0RlZmF1bHRGb2xsb3dlZCA/IFwiLCBcIiA6IFwiXCJdKSwgY29uY2F0JGQobmFtZXNwYWNlU3BlY2lmaWVycyksIGNvbmNhdCRkKFtpc05hbWVzcGFjZUZvbGxvd2VkID8gXCIsIFwiIDogXCJcIl0pLCBwcmludGVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRzLnB1c2goXCJ7fVwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlY2wuc291cmNlKSB7XG4gICAgICAgIHBhcnRzLnB1c2goXCIgZnJvbSBcIiwgcGF0aC5jYWxsKHByaW50LCBcInNvdXJjZVwiKSk7XG4gICAgICB9XG5cbiAgICAgIHBhcnRzLnB1c2goc2VtaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmNhdCRkKHBhcnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50Rmxvd0RlY2xhcmF0aW9uKHBhdGgsIHBhcnRzKSB7XG4gICAgdmFyIHBhcmVudEV4cG9ydERlY2wgPSBnZXRQYXJlbnRFeHBvcnREZWNsYXJhdGlvbiQxKHBhdGgpO1xuXG4gICAgaWYgKHBhcmVudEV4cG9ydERlY2wpIHtcbiAgICAgIGFzc2VydC5zdHJpY3RFcXVhbChwYXJlbnRFeHBvcnREZWNsLnR5cGUsIFwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGUgcGFyZW50IG5vZGUgaGFzIHR5cGUgRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uLCB0aGVuIGl0XG4gICAgICAvLyB3aWxsIGJlIHJlc3BvbnNpYmxlIGZvciBwcmludGluZyB0aGUgXCJkZWNsYXJlXCIgdG9rZW4uIE90aGVyd2lzZVxuICAgICAgLy8gaXQgbmVlZHMgdG8gYmUgcHJpbnRlZCB3aXRoIHRoaXMgbm9uLWV4cG9ydGVkIGRlY2xhcmF0aW9uIG5vZGUuXG4gICAgICBwYXJ0cy51bnNoaWZ0KFwiZGVjbGFyZSBcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmNhdCRkKHBhcnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50VHlwZVNjcmlwdE1vZGlmaWVycyhwYXRoLCBvcHRpb25zLCBwcmludCkge1xuICAgIHZhciBuID0gcGF0aC5nZXRWYWx1ZSgpO1xuXG4gICAgaWYgKCFuLm1vZGlmaWVycyB8fCAhbi5tb2RpZmllcnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uY2F0JGQoW2pvaW4kOShcIiBcIiwgcGF0aC5tYXAocHJpbnQsIFwibW9kaWZpZXJzXCIpKSwgXCIgXCJdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50VHlwZVBhcmFtZXRlcnMocGF0aCwgb3B0aW9ucywgcHJpbnQsIHBhcmFtc0tleSkge1xuICAgIHZhciBuID0gcGF0aC5nZXRWYWx1ZSgpO1xuXG4gICAgaWYgKCFuW3BhcmFtc0tleV0pIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH0gLy8gZm9yIFR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbiB0eXBlUGFyYW1ldGVycyBpcyBhIHNpbmdsZSBub2RlXG5cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShuW3BhcmFtc0tleV0pKSB7XG4gICAgICByZXR1cm4gcGF0aC5jYWxsKHByaW50LCBwYXJhbXNLZXkpO1xuICAgIH1cblxuICAgIHZhciBncmFuZHBhcmVudCA9IHBhdGguZ2V0Tm9kZSgyKTtcbiAgICB2YXIgZ3JlYXRHcmVhdEdyYW5kUGFyZW50ID0gcGF0aC5nZXROb2RlKDQpO1xuICAgIHZhciBpc1BhcmFtZXRlckluVGVzdENhbGwgPSBncmFuZHBhcmVudCAhPSBudWxsICYmIGlzVGVzdENhbGwkMShncmFuZHBhcmVudCk7XG4gICAgdmFyIHNob3VsZElubGluZSA9IGlzUGFyYW1ldGVySW5UZXN0Q2FsbCB8fCBuW3BhcmFtc0tleV0ubGVuZ3RoID09PSAwIHx8IG5bcGFyYW1zS2V5XS5sZW5ndGggPT09IDEgJiYgKHNob3VsZEh1Z1R5cGUobltwYXJhbXNLZXldWzBdKSB8fCBuW3BhcmFtc0tleV1bMF0udHlwZSA9PT0gXCJHZW5lcmljVHlwZUFubm90YXRpb25cIiAmJiBzaG91bGRIdWdUeXBlKG5bcGFyYW1zS2V5XVswXS5pZCkgfHwgbltwYXJhbXNLZXldWzBdLnR5cGUgPT09IFwiVFNUeXBlUmVmZXJlbmNlXCIgJiYgc2hvdWxkSHVnVHlwZShuW3BhcmFtc0tleV1bMF0udHlwZU5hbWUpIHx8IG5bcGFyYW1zS2V5XVswXS50eXBlID09PSBcIk51bGxhYmxlVHlwZUFubm90YXRpb25cIiB8fCAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ByZXR0aWVyL3ByZXR0aWVyL3B1bGwvNjQ2NyBmb3IgdGhlIGNvbnRleHQuXG4gICAgZ3JlYXRHcmVhdEdyYW5kUGFyZW50ICYmIGdyZWF0R3JlYXRHcmFuZFBhcmVudC50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRvclwiICYmIGdyYW5kcGFyZW50ICYmIGdyYW5kcGFyZW50LnR5cGUgPT09IFwiVFNUeXBlQW5ub3RhdGlvblwiICYmIG5bcGFyYW1zS2V5XVswXS50eXBlICE9PSBcIlRTVW5pb25UeXBlXCIgJiYgbltwYXJhbXNLZXldWzBdLnR5cGUgIT09IFwiVW5pb25UeXBlQW5ub3RhdGlvblwiICYmIG5bcGFyYW1zS2V5XVswXS50eXBlICE9PSBcIlRTQ29uZGl0aW9uYWxUeXBlXCIgJiYgbltwYXJhbXNLZXldWzBdLnR5cGUgIT09IFwiVFNNYXBwZWRUeXBlXCIpO1xuXG4gICAgaWYgKHNob3VsZElubGluZSkge1xuICAgICAgcmV0dXJuIGNvbmNhdCRkKFtcIjxcIiwgam9pbiQ5KFwiLCBcIiwgcGF0aC5tYXAocHJpbnQsIHBhcmFtc0tleSkpLCBcIj5cIl0pO1xuICAgIH1cblxuICAgIHJldHVybiBncm91cCRiKGNvbmNhdCRkKFtcIjxcIiwgaW5kZW50JDcoY29uY2F0JGQoW3NvZnRsaW5lJDYsIGpvaW4kOShjb25jYXQkZChbXCIsXCIsIGxpbmUkN10pLCBwYXRoLm1hcChwcmludCwgcGFyYW1zS2V5KSldKSksIGlmQnJlYWskNihvcHRpb25zLnBhcnNlciAhPT0gXCJ0eXBlc2NyaXB0XCIgJiYgc2hvdWxkUHJpbnRDb21tYSQxKG9wdGlvbnMsIFwiYWxsXCIpID8gXCIsXCIgOiBcIlwiKSwgc29mdGxpbmUkNiwgXCI+XCJdKSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludENsYXNzKHBhdGgsIG9wdGlvbnMsIHByaW50KSB7XG4gICAgdmFyIG4gPSBwYXRoLmdldFZhbHVlKCk7XG4gICAgdmFyIHBhcnRzID0gW107XG5cbiAgICBpZiAobi5hYnN0cmFjdCkge1xuICAgICAgcGFydHMucHVzaChcImFic3RyYWN0IFwiKTtcbiAgICB9XG5cbiAgICBwYXJ0cy5wdXNoKFwiY2xhc3NcIik7XG5cbiAgICBpZiAobi5pZCkge1xuICAgICAgcGFydHMucHVzaChcIiBcIiwgcGF0aC5jYWxsKHByaW50LCBcImlkXCIpKTtcbiAgICB9XG5cbiAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJ0eXBlUGFyYW1ldGVyc1wiKSk7XG4gICAgdmFyIHBhcnRzR3JvdXAgPSBbXTtcblxuICAgIGlmIChuLnN1cGVyQ2xhc3MpIHtcbiAgICAgIHZhciBwcmludGVkID0gY29uY2F0JGQoW1wiZXh0ZW5kcyBcIiwgcGF0aC5jYWxsKHByaW50LCBcInN1cGVyQ2xhc3NcIiksIHBhdGguY2FsbChwcmludCwgXCJzdXBlclR5cGVQYXJhbWV0ZXJzXCIpXSk7IC8vIEtlZXAgb2xkIGJlaGF2aW91ciBvZiBleHRlbmRzIGluIHNhbWUgbGluZVxuICAgICAgLy8gSWYgdGhlcmUgaXMgb25seSBvbiBleHRlbmRzIGFuZCB0aGVyZSBhcmUgbm90IGNvbW1lbnRzXG5cbiAgICAgIGlmICgoIW4uaW1wbGVtZW50cyB8fCBuLmltcGxlbWVudHMubGVuZ3RoID09PSAwKSAmJiAoIW4uc3VwZXJDbGFzcy5jb21tZW50cyB8fCBuLnN1cGVyQ2xhc3MuY29tbWVudHMubGVuZ3RoID09PSAwKSkge1xuICAgICAgICBwYXJ0cy5wdXNoKGNvbmNhdCRkKFtcIiBcIiwgcGF0aC5jYWxsKGZ1bmN0aW9uIChzdXBlckNsYXNzKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbW1lbnRzLnByaW50Q29tbWVudHMoc3VwZXJDbGFzcywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByaW50ZWQ7XG4gICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIH0sIFwic3VwZXJDbGFzc1wiKV0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRzR3JvdXAucHVzaChncm91cCRiKGNvbmNhdCRkKFtsaW5lJDcsIHBhdGguY2FsbChmdW5jdGlvbiAoc3VwZXJDbGFzcykge1xuICAgICAgICAgIHJldHVybiBjb21tZW50cy5wcmludENvbW1lbnRzKHN1cGVyQ2xhc3MsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmludGVkO1xuICAgICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICB9LCBcInN1cGVyQ2xhc3NcIildKSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobi5leHRlbmRzICYmIG4uZXh0ZW5kcy5sZW5ndGggPiAwKSB7XG4gICAgICBwYXJ0cy5wdXNoKFwiIGV4dGVuZHMgXCIsIGpvaW4kOShcIiwgXCIsIHBhdGgubWFwKHByaW50LCBcImV4dGVuZHNcIikpKTtcbiAgICB9XG5cbiAgICBpZiAobltcIm1peGluc1wiXSAmJiBuW1wibWl4aW5zXCJdLmxlbmd0aCA+IDApIHtcbiAgICAgIHBhcnRzR3JvdXAucHVzaChsaW5lJDcsIFwibWl4aW5zIFwiLCBncm91cCRiKGluZGVudCQ3KGpvaW4kOShjb25jYXQkZChbXCIsXCIsIGxpbmUkN10pLCBwYXRoLm1hcChwcmludCwgXCJtaXhpbnNcIikpKSkpO1xuICAgIH1cblxuICAgIGlmIChuW1wiaW1wbGVtZW50c1wiXSAmJiBuW1wiaW1wbGVtZW50c1wiXS5sZW5ndGggPiAwKSB7XG4gICAgICBwYXJ0c0dyb3VwLnB1c2gobGluZSQ3LCBcImltcGxlbWVudHNcIiwgZ3JvdXAkYihpbmRlbnQkNyhjb25jYXQkZChbbGluZSQ3LCBqb2luJDkoY29uY2F0JGQoW1wiLFwiLCBsaW5lJDddKSwgcGF0aC5tYXAocHJpbnQsIFwiaW1wbGVtZW50c1wiKSldKSkpKTtcbiAgICB9XG5cbiAgICBpZiAocGFydHNHcm91cC5sZW5ndGggPiAwKSB7XG4gICAgICBwYXJ0cy5wdXNoKGdyb3VwJGIoaW5kZW50JDcoY29uY2F0JGQocGFydHNHcm91cCkpKSk7XG4gICAgfVxuXG4gICAgaWYgKG4uYm9keSAmJiBuLmJvZHkuY29tbWVudHMgJiYgaGFzTGVhZGluZ093bkxpbmVDb21tZW50JDEob3B0aW9ucy5vcmlnaW5hbFRleHQsIG4uYm9keSwgb3B0aW9ucykpIHtcbiAgICAgIHBhcnRzLnB1c2goaGFyZGxpbmUkOSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnRzLnB1c2goXCIgXCIpO1xuICAgIH1cblxuICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcImJvZHlcIikpO1xuICAgIHJldHVybiBwYXJ0cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50T3B0aW9uYWxUb2tlbihwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSBwYXRoLmdldFZhbHVlKCk7XG5cbiAgICBpZiAoIW5vZGUub3B0aW9uYWwgfHwgLy8gSXQncyBhbiBvcHRpb25hbCBjb21wdXRlZCBtZXRob2QgcGFyc2VkIGJ5IHR5cGVzY3JpcHQtZXN0cmVlLlxuICAgIC8vIFwiP1wiIGlzIHByaW50ZWQgaW4gYHByaW50TWV0aG9kYC5cbiAgICBub2RlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIG5vZGUgPT09IHBhdGguZ2V0UGFyZW50Tm9kZSgpLmtleSkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiICYmIG5vZGUuY29tcHV0ZWQpIHtcbiAgICAgIHJldHVybiBcIj8uXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiP1wiO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRNZW1iZXJMb29rdXAocGF0aCwgb3B0aW9ucywgcHJpbnQpIHtcbiAgICB2YXIgcHJvcGVydHkgPSBwYXRoLmNhbGwocHJpbnQsIFwicHJvcGVydHlcIik7XG4gICAgdmFyIG4gPSBwYXRoLmdldFZhbHVlKCk7XG4gICAgdmFyIG9wdGlvbmFsID0gcHJpbnRPcHRpb25hbFRva2VuKHBhdGgpO1xuXG4gICAgaWYgKCFuLmNvbXB1dGVkKSB7XG4gICAgICByZXR1cm4gY29uY2F0JGQoW29wdGlvbmFsLCBcIi5cIiwgcHJvcGVydHldKTtcbiAgICB9XG5cbiAgICBpZiAoIW4ucHJvcGVydHkgfHwgaXNOdW1lcmljTGl0ZXJhbCQxKG4ucHJvcGVydHkpKSB7XG4gICAgICByZXR1cm4gY29uY2F0JGQoW29wdGlvbmFsLCBcIltcIiwgcHJvcGVydHksIFwiXVwiXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQoW29wdGlvbmFsLCBcIltcIiwgaW5kZW50JDcoY29uY2F0JGQoW3NvZnRsaW5lJDYsIHByb3BlcnR5XSkpLCBzb2Z0bGluZSQ2LCBcIl1cIl0pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50QmluZEV4cHJlc3Npb25DYWxsZWUocGF0aCwgb3B0aW9ucywgcHJpbnQpIHtcbiAgICByZXR1cm4gY29uY2F0JGQoW1wiOjpcIiwgcGF0aC5jYWxsKHByaW50LCBcImNhbGxlZVwiKV0pO1xuICB9IC8vIFdlIGRldGVjdCBjYWxscyBvbiBtZW1iZXIgZXhwcmVzc2lvbnMgc3BlY2lhbGx5IHRvIGZvcm1hdCBhXG4gIC8vIGNvbW1vbiBwYXR0ZXJuIGJldHRlci4gVGhlIHBhdHRlcm4gd2UgYXJlIGxvb2tpbmcgZm9yIGlzIHRoaXM6XG4gIC8vXG4gIC8vIGFyclxuICAvLyAgIC5tYXAoeCA9PiB4ICsgMSlcbiAgLy8gICAuZmlsdGVyKHggPT4geCA+IDEwKVxuICAvLyAgIC5zb21lKHggPT4geCAlIDIpXG4gIC8vXG4gIC8vIFRoZSB3YXkgaXQgaXMgc3RydWN0dXJlZCBpbiB0aGUgQVNUIGlzIHZpYSBhIG5lc3RlZCBzZXF1ZW5jZSBvZlxuICAvLyBNZW1iZXJFeHByZXNzaW9uIGFuZCBDYWxsRXhwcmVzc2lvbi4gV2UgbmVlZCB0byB0cmF2ZXJzZSB0aGUgQVNUXG4gIC8vIGFuZCBtYWtlIGdyb3VwcyBvdXQgb2YgaXQgdG8gcHJpbnQgaXQgaW4gdGhlIGRlc2lyZWQgd2F5LlxuXG5cbiAgZnVuY3Rpb24gcHJpbnRNZW1iZXJDaGFpbihwYXRoLCBvcHRpb25zLCBwcmludCkge1xuICAgIC8vIFRoZSBmaXJzdCBwaGFzZSBpcyB0byBsaW5lYXJpemUgdGhlIEFTVCBieSB0cmF2ZXJzaW5nIGl0IGRvd24uXG4gICAgLy9cbiAgICAvLyAgIGEoKS5iKClcbiAgICAvLyBoYXMgdGhlIGZvbGxvd2luZyBBU1Qgc3RydWN0dXJlOlxuICAgIC8vICAgQ2FsbEV4cHJlc3Npb24oTWVtYmVyRXhwcmVzc2lvbihDYWxsRXhwcmVzc2lvbihJZGVudGlmaWVyKSkpXG4gICAgLy8gYW5kIHdlIHRyYW5zZm9ybSBpdCBpbnRvXG4gICAgLy8gICBbSWRlbnRpZmllciwgQ2FsbEV4cHJlc3Npb24sIE1lbWJlckV4cHJlc3Npb24sIENhbGxFeHByZXNzaW9uXVxuICAgIHZhciBwcmludGVkTm9kZXMgPSBbXTsgLy8gSGVyZSB3ZSB0cnkgdG8gcmV0YWluIG9uZSB0eXBlZCBlbXB0eSBsaW5lIGFmdGVyIGVhY2ggY2FsbCBleHByZXNzaW9uIG9yXG4gICAgLy8gdGhlIGZpcnN0IGdyb3VwIHdoZXRoZXIgaXQgaXMgaW4gcGFyZW50aGVzZXMgb3Igbm90XG5cbiAgICBmdW5jdGlvbiBzaG91bGRJbnNlcnRFbXB0eUxpbmVBZnRlcihub2RlKSB7XG4gICAgICB2YXIgb3JpZ2luYWxUZXh0ID0gb3B0aW9ucy5vcmlnaW5hbFRleHQ7XG4gICAgICB2YXIgbmV4dENoYXJJbmRleCA9IGdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXJJbmRleCQyKG9yaWdpbmFsVGV4dCwgbm9kZSwgb3B0aW9ucyk7XG4gICAgICB2YXIgbmV4dENoYXIgPSBvcmlnaW5hbFRleHQuY2hhckF0KG5leHRDaGFySW5kZXgpOyAvLyBpZiBpdCBpcyBjdXQgb2ZmIGJ5IGEgcGFyZW50aGVzaXMsIHdlIG9ubHkgYWNjb3VudCBmb3Igb25lIHR5cGVkIGVtcHR5XG4gICAgICAvLyBsaW5lIGFmdGVyIHRoYXQgcGFyZW50aGVzaXNcblxuICAgICAgaWYgKG5leHRDaGFyID09IFwiKVwiKSB7XG4gICAgICAgIHJldHVybiBpc05leHRMaW5lRW1wdHlBZnRlckluZGV4JDEob3JpZ2luYWxUZXh0LCBuZXh0Q2hhckluZGV4ICsgMSwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpc05leHRMaW5lRW1wdHkkNChvcmlnaW5hbFRleHQsIG5vZGUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYyhwYXRoKSB7XG4gICAgICB2YXIgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcblxuICAgICAgaWYgKChub2RlLnR5cGUgPT09IFwiQ2FsbEV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiKSAmJiAoaXNNZW1iZXJpc2gkMShub2RlLmNhbGxlZSkgfHwgbm9kZS5jYWxsZWUudHlwZSA9PT0gXCJDYWxsRXhwcmVzc2lvblwiIHx8IG5vZGUuY2FsbGVlLnR5cGUgPT09IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiKSkge1xuICAgICAgICBwcmludGVkTm9kZXMudW5zaGlmdCh7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBwcmludGVkOiBjb25jYXQkZChbY29tbWVudHMucHJpbnRDb21tZW50cyhwYXRoLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0JGQoW3ByaW50T3B0aW9uYWxUb2tlbihwYXRoKSwgcHJpbnRGdW5jdGlvblR5cGVQYXJhbWV0ZXJzKHBhdGgsIG9wdGlvbnMsIHByaW50KSwgcHJpbnRBcmd1bWVudHNMaXN0KHBhdGgsIG9wdGlvbnMsIHByaW50KV0pO1xuICAgICAgICAgIH0sIG9wdGlvbnMpLCBzaG91bGRJbnNlcnRFbXB0eUxpbmVBZnRlcihub2RlKSA/IGhhcmRsaW5lJDkgOiBcIlwiXSlcbiAgICAgICAgfSk7XG4gICAgICAgIHBhdGguY2FsbChmdW5jdGlvbiAoY2FsbGVlKSB7XG4gICAgICAgICAgcmV0dXJuIHJlYyhjYWxsZWUpO1xuICAgICAgICB9LCBcImNhbGxlZVwiKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNNZW1iZXJpc2gkMShub2RlKSkge1xuICAgICAgICBwcmludGVkTm9kZXMudW5zaGlmdCh7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBuZWVkc1BhcmVuczogbmVlZHNQYXJlbnNfMShwYXRoLCBvcHRpb25zKSxcbiAgICAgICAgICBwcmludGVkOiBjb21tZW50cy5wcmludENvbW1lbnRzKHBhdGgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiA/IHByaW50TWVtYmVyTG9va3VwKHBhdGgsIG9wdGlvbnMsIHByaW50KSA6IHByaW50QmluZEV4cHJlc3Npb25DYWxsZWUocGF0aCwgb3B0aW9ucywgcHJpbnQpO1xuICAgICAgICAgIH0sIG9wdGlvbnMpXG4gICAgICAgIH0pO1xuICAgICAgICBwYXRoLmNhbGwoZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiByZWMob2JqZWN0KTtcbiAgICAgICAgfSwgXCJvYmplY3RcIik7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJUU05vbk51bGxFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgcHJpbnRlZE5vZGVzLnVuc2hpZnQoe1xuICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgcHJpbnRlZDogY29tbWVudHMucHJpbnRDb21tZW50cyhwYXRoLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIhXCI7XG4gICAgICAgICAgfSwgb3B0aW9ucylcbiAgICAgICAgfSk7XG4gICAgICAgIHBhdGguY2FsbChmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgIHJldHVybiByZWMoZXhwcmVzc2lvbik7XG4gICAgICAgIH0sIFwiZXhwcmVzc2lvblwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByaW50ZWROb2Rlcy51bnNoaWZ0KHtcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIHByaW50ZWQ6IHBhdGguY2FsbChwcmludClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSAvLyBOb3RlOiB0aGUgY29tbWVudHMgb2YgdGhlIHJvb3Qgbm9kZSBoYXZlIGFscmVhZHkgYmVlbiBwcmludGVkLCBzbyB3ZVxuICAgIC8vIG5lZWQgdG8gZXh0cmFjdCB0aGlzIGZpcnN0IGNhbGwgd2l0aG91dCBwcmludGluZyB0aGVtIGFzIHRoZXkgd291bGRcbiAgICAvLyBpZiBoYW5kbGVkIGluc2lkZSBvZiB0aGUgcmVjdXJzaXZlIGNhbGwuXG5cblxuICAgIHZhciBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIHByaW50ZWROb2Rlcy51bnNoaWZ0KHtcbiAgICAgIG5vZGU6IG5vZGUsXG4gICAgICBwcmludGVkOiBjb25jYXQkZChbcHJpbnRPcHRpb25hbFRva2VuKHBhdGgpLCBwcmludEZ1bmN0aW9uVHlwZVBhcmFtZXRlcnMocGF0aCwgb3B0aW9ucywgcHJpbnQpLCBwcmludEFyZ3VtZW50c0xpc3QocGF0aCwgb3B0aW9ucywgcHJpbnQpXSlcbiAgICB9KTtcbiAgICBwYXRoLmNhbGwoZnVuY3Rpb24gKGNhbGxlZSkge1xuICAgICAgcmV0dXJuIHJlYyhjYWxsZWUpO1xuICAgIH0sIFwiY2FsbGVlXCIpOyAvLyBPbmNlIHdlIGhhdmUgYSBsaW5lYXIgbGlzdCBvZiBwcmludGVkIG5vZGVzLCB3ZSB3YW50IHRvIGNyZWF0ZSBncm91cHMgb3V0XG4gICAgLy8gb2YgaXQuXG4gICAgLy9cbiAgICAvLyAgIGEoKS5iLmMoKS5kKCkuZVxuICAgIC8vIHdpbGwgYmUgZ3JvdXBlZCBhc1xuICAgIC8vICAgW1xuICAgIC8vICAgICBbSWRlbnRpZmllciwgQ2FsbEV4cHJlc3Npb25dLFxuICAgIC8vICAgICBbTWVtYmVyRXhwcmVzc2lvbiwgTWVtYmVyRXhwcmVzc2lvbiwgQ2FsbEV4cHJlc3Npb25dLFxuICAgIC8vICAgICBbTWVtYmVyRXhwcmVzc2lvbiwgQ2FsbEV4cHJlc3Npb25dLFxuICAgIC8vICAgICBbTWVtYmVyRXhwcmVzc2lvbl0sXG4gICAgLy8gICBdXG4gICAgLy8gc28gdGhhdCB3ZSBjYW4gcHJpbnQgaXQgYXNcbiAgICAvLyAgIGEoKVxuICAgIC8vICAgICAuYi5jKClcbiAgICAvLyAgICAgLmQoKVxuICAgIC8vICAgICAuZVxuICAgIC8vIFRoZSBmaXJzdCBncm91cCBpcyB0aGUgZmlyc3Qgbm9kZSBmb2xsb3dlZCBieVxuICAgIC8vICAgLSBhcyBtYW55IENhbGxFeHByZXNzaW9uIGFzIHBvc3NpYmxlXG4gICAgLy8gICAgICAgPCBmbigpKCkoKSA+LnNvbWV0aGluZygpXG4gICAgLy8gICAtIGFzIG1hbnkgYXJyYXkgYWNjZXNzb3JzIGFzIHBvc3NpYmxlXG4gICAgLy8gICAgICAgPCBmbigpWzBdWzFdWzJdID4uc29tZXRoaW5nKClcbiAgICAvLyAgIC0gdGhlbiwgYXMgbWFueSBNZW1iZXJFeHByZXNzaW9uIGFzIHBvc3NpYmxlIGJ1dCB0aGUgbGFzdCBvbmVcbiAgICAvLyAgICAgICA8IHRoaXMuaXRlbXMgPi5zb21ldGhpbmcoKVxuXG4gICAgdmFyIGdyb3VwcyA9IFtdO1xuICAgIHZhciBjdXJyZW50R3JvdXAgPSBbcHJpbnRlZE5vZGVzWzBdXTtcbiAgICB2YXIgaSA9IDE7XG5cbiAgICBmb3IgKDsgaSA8IHByaW50ZWROb2Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHByaW50ZWROb2Rlc1tpXS5ub2RlLnR5cGUgPT09IFwiVFNOb25OdWxsRXhwcmVzc2lvblwiIHx8IHByaW50ZWROb2Rlc1tpXS5ub2RlLnR5cGUgPT09IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiIHx8IHByaW50ZWROb2Rlc1tpXS5ub2RlLnR5cGUgPT09IFwiQ2FsbEV4cHJlc3Npb25cIiB8fCAocHJpbnRlZE5vZGVzW2ldLm5vZGUudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgfHwgcHJpbnRlZE5vZGVzW2ldLm5vZGUudHlwZSA9PT0gXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIikgJiYgcHJpbnRlZE5vZGVzW2ldLm5vZGUuY29tcHV0ZWQgJiYgaXNOdW1lcmljTGl0ZXJhbCQxKHByaW50ZWROb2Rlc1tpXS5ub2RlLnByb3BlcnR5KSkge1xuICAgICAgICBjdXJyZW50R3JvdXAucHVzaChwcmludGVkTm9kZXNbaV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByaW50ZWROb2Rlc1swXS5ub2RlLnR5cGUgIT09IFwiQ2FsbEV4cHJlc3Npb25cIiAmJiBwcmludGVkTm9kZXNbMF0ubm9kZS50eXBlICE9PSBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIikge1xuICAgICAgZm9yICg7IGkgKyAxIDwgcHJpbnRlZE5vZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChpc01lbWJlcmlzaCQxKHByaW50ZWROb2Rlc1tpXS5ub2RlKSAmJiBpc01lbWJlcmlzaCQxKHByaW50ZWROb2Rlc1tpICsgMV0ubm9kZSkpIHtcbiAgICAgICAgICBjdXJyZW50R3JvdXAucHVzaChwcmludGVkTm9kZXNbaV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ3JvdXBzLnB1c2goY3VycmVudEdyb3VwKTtcbiAgICBjdXJyZW50R3JvdXAgPSBbXTsgLy8gVGhlbiwgZWFjaCBmb2xsb3dpbmcgZ3JvdXAgaXMgYSBzZXF1ZW5jZSBvZiBNZW1iZXJFeHByZXNzaW9uIGZvbGxvd2VkIGJ5XG4gICAgLy8gYSBzZXF1ZW5jZSBvZiBDYWxsRXhwcmVzc2lvbi4gVG8gY29tcHV0ZSBpdCwgd2Uga2VlcCBhZGRpbmcgdGhpbmdzIHRvIHRoZVxuICAgIC8vIGdyb3VwIHVudGlsIHdlIGhhcyBzZWVuIGEgQ2FsbEV4cHJlc3Npb24gaW4gdGhlIHBhc3QgYW5kIHJlYWNoIGFcbiAgICAvLyBNZW1iZXJFeHByZXNzaW9uXG5cbiAgICB2YXIgaGFzU2VlbkNhbGxFeHByZXNzaW9uID0gZmFsc2U7XG5cbiAgICBmb3IgKDsgaSA8IHByaW50ZWROb2Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGhhc1NlZW5DYWxsRXhwcmVzc2lvbiAmJiBpc01lbWJlcmlzaCQxKHByaW50ZWROb2Rlc1tpXS5ub2RlKSkge1xuICAgICAgICAvLyBbMF0gc2hvdWxkIGJlIGFwcGVuZGVkIGF0IHRoZSBlbmQgb2YgdGhlIGdyb3VwIGluc3RlYWQgb2YgdGhlXG4gICAgICAgIC8vIGJlZ2lubmluZyBvZiB0aGUgbmV4dCBvbmVcbiAgICAgICAgaWYgKHByaW50ZWROb2Rlc1tpXS5ub2RlLmNvbXB1dGVkICYmIGlzTnVtZXJpY0xpdGVyYWwkMShwcmludGVkTm9kZXNbaV0ubm9kZS5wcm9wZXJ0eSkpIHtcbiAgICAgICAgICBjdXJyZW50R3JvdXAucHVzaChwcmludGVkTm9kZXNbaV0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JvdXBzLnB1c2goY3VycmVudEdyb3VwKTtcbiAgICAgICAgY3VycmVudEdyb3VwID0gW107XG4gICAgICAgIGhhc1NlZW5DYWxsRXhwcmVzc2lvbiA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJpbnRlZE5vZGVzW2ldLm5vZGUudHlwZSA9PT0gXCJDYWxsRXhwcmVzc2lvblwiIHx8IHByaW50ZWROb2Rlc1tpXS5ub2RlLnR5cGUgPT09IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIGhhc1NlZW5DYWxsRXhwcmVzc2lvbiA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRHcm91cC5wdXNoKHByaW50ZWROb2Rlc1tpXSk7XG5cbiAgICAgIGlmIChwcmludGVkTm9kZXNbaV0ubm9kZS5jb21tZW50cyAmJiBwcmludGVkTm9kZXNbaV0ubm9kZS5jb21tZW50cy5zb21lKGZ1bmN0aW9uIChjb21tZW50KSB7XG4gICAgICAgIHJldHVybiBjb21tZW50LnRyYWlsaW5nO1xuICAgICAgfSkpIHtcbiAgICAgICAgZ3JvdXBzLnB1c2goY3VycmVudEdyb3VwKTtcbiAgICAgICAgY3VycmVudEdyb3VwID0gW107XG4gICAgICAgIGhhc1NlZW5DYWxsRXhwcmVzc2lvbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjdXJyZW50R3JvdXAubGVuZ3RoID4gMCkge1xuICAgICAgZ3JvdXBzLnB1c2goY3VycmVudEdyb3VwKTtcbiAgICB9IC8vIFRoZXJlIGFyZSBjYXNlcyBsaWtlIE9iamVjdC5rZXlzKCksIE9ic2VydmFibGUub2YoKSwgXy52YWx1ZXMoKSB3aGVyZVxuICAgIC8vIHRoZXkgYXJlIHRoZSBzdWJqZWN0IG9mIGFsbCB0aGUgY2hhaW5lZCBjYWxscyBhbmQgdGhlcmVmb3JlIHNob3VsZFxuICAgIC8vIGJlIGtlcHQgb24gdGhlIHNhbWUgbGluZTpcbiAgICAvL1xuICAgIC8vICAgT2JqZWN0LmtleXMoaXRlbXMpXG4gICAgLy8gICAgIC5maWx0ZXIoeCA9PiB4KVxuICAgIC8vICAgICAubWFwKHggPT4geClcbiAgICAvL1xuICAgIC8vIEluIG9yZGVyIHRvIGRldGVjdCB0aG9zZSBjYXNlcywgd2UgdXNlIGFuIGhldXJpc3RpYzogaWYgdGhlIGZpcnN0XG4gICAgLy8gbm9kZSBpcyBhbiBpZGVudGlmaWVyIHdpdGggdGhlIG5hbWUgc3RhcnRpbmcgd2l0aCBhIGNhcGl0YWxcbiAgICAvLyBsZXR0ZXIgb3IganVzdCBhIHNlcXVlbmNlIG9mIF8kLiBUaGUgcmF0aW9uYWxlIGlzIHRoYXQgdGhleSBhcmVcbiAgICAvLyBsaWtlbHkgdG8gYmUgZmFjdG9yaWVzLlxuXG5cbiAgICBmdW5jdGlvbiBpc0ZhY3RvcnkobmFtZSkge1xuICAgICAgcmV0dXJuIC9eW0EtWl18XltfJF0rJC8udGVzdChuYW1lKTtcbiAgICB9IC8vIEluIGNhc2UgdGhlIElkZW50aWZpZXIgaXMgc2hvcnRlciB0aGFuIHRhYiB3aWR0aCwgd2UgY2FuIGtlZXAgdGhlXG4gICAgLy8gZmlyc3QgY2FsbCBpbiBhIHNpbmdsZSBsaW5lLCBpZiBpdCdzIGFuIEV4cHJlc3Npb25TdGF0ZW1lbnQuXG4gICAgLy9cbiAgICAvLyAgIGQzLnNjYWxlTGluZWFyKClcbiAgICAvLyAgICAgLmRvbWFpbihbMCwgMTAwXSlcbiAgICAvLyAgICAgLnJhbmdlKFswLCB3aWR0aF0pO1xuICAgIC8vXG5cblxuICAgIGZ1bmN0aW9uIGlzU2hvcnQobmFtZSkge1xuICAgICAgcmV0dXJuIG5hbWUubGVuZ3RoIDw9IG9wdGlvbnMudGFiV2lkdGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hvdWxkTm90V3JhcChncm91cHMpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBwYXRoLmdldFBhcmVudE5vZGUoKTtcbiAgICAgIHZhciBpc0V4cHJlc3Npb24gPSBwYXJlbnQgJiYgcGFyZW50LnR5cGUgPT09IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiO1xuICAgICAgdmFyIGhhc0NvbXB1dGVkID0gZ3JvdXBzWzFdLmxlbmd0aCAmJiBncm91cHNbMV1bMF0ubm9kZS5jb21wdXRlZDtcblxuICAgICAgaWYgKGdyb3Vwc1swXS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdmFyIGZpcnN0Tm9kZSA9IGdyb3Vwc1swXVswXS5ub2RlO1xuICAgICAgICByZXR1cm4gZmlyc3ROb2RlLnR5cGUgPT09IFwiVGhpc0V4cHJlc3Npb25cIiB8fCBmaXJzdE5vZGUudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgKGlzRmFjdG9yeShmaXJzdE5vZGUubmFtZSkgfHwgaXNFeHByZXNzaW9uICYmIGlzU2hvcnQoZmlyc3ROb2RlLm5hbWUpIHx8IGhhc0NvbXB1dGVkKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxhc3ROb2RlID0gZ2V0TGFzdCQyKGdyb3Vwc1swXSkubm9kZTtcbiAgICAgIHJldHVybiAobGFzdE5vZGUudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgfHwgbGFzdE5vZGUudHlwZSA9PT0gXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIikgJiYgbGFzdE5vZGUucHJvcGVydHkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgKGlzRmFjdG9yeShsYXN0Tm9kZS5wcm9wZXJ0eS5uYW1lKSB8fCBoYXNDb21wdXRlZCk7XG4gICAgfVxuXG4gICAgdmFyIHNob3VsZE1lcmdlID0gZ3JvdXBzLmxlbmd0aCA+PSAyICYmICFncm91cHNbMV1bMF0ubm9kZS5jb21tZW50cyAmJiBzaG91bGROb3RXcmFwKGdyb3Vwcyk7XG5cbiAgICBmdW5jdGlvbiBwcmludEdyb3VwKHByaW50ZWRHcm91cCkge1xuICAgICAgdmFyIHByaW50ZWQgPSBwcmludGVkR3JvdXAubWFwKGZ1bmN0aW9uICh0dXBsZSkge1xuICAgICAgICByZXR1cm4gdHVwbGUucHJpbnRlZDtcbiAgICAgIH0pOyAvLyBDaGVja3MgaWYgdGhlIGxhc3Qgbm9kZSAoaS5lLiB0aGUgcGFyZW50IG5vZGUpIG5lZWRzIHBhcmVucyBhbmQgcHJpbnRcbiAgICAgIC8vIGFjY29yZGluZ2x5XG5cbiAgICAgIGlmIChwcmludGVkR3JvdXAubGVuZ3RoID4gMCAmJiBwcmludGVkR3JvdXBbcHJpbnRlZEdyb3VwLmxlbmd0aCAtIDFdLm5lZWRzUGFyZW5zKSB7XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbXCIoXCJdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocHJpbnRlZCksIFtcIilcIl0pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbmNhdCRkKHByaW50ZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByaW50SW5kZW50ZWRHcm91cChncm91cHMpIHtcbiAgICAgIGlmIChncm91cHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5kZW50JDcoZ3JvdXAkYihjb25jYXQkZChbaGFyZGxpbmUkOSwgam9pbiQ5KGhhcmRsaW5lJDksIGdyb3Vwcy5tYXAocHJpbnRHcm91cCkpXSkpKTtcbiAgICB9XG5cbiAgICB2YXIgcHJpbnRlZEdyb3VwcyA9IGdyb3Vwcy5tYXAocHJpbnRHcm91cCk7XG4gICAgdmFyIG9uZUxpbmUgPSBjb25jYXQkZChwcmludGVkR3JvdXBzKTtcbiAgICB2YXIgY3V0b2ZmID0gc2hvdWxkTWVyZ2UgPyAzIDogMjtcbiAgICB2YXIgZmxhdEdyb3VwcyA9IGdyb3Vwcy5zbGljZSgwLCBjdXRvZmYpLnJlZHVjZShmdW5jdGlvbiAocmVzLCBncm91cCkge1xuICAgICAgcmV0dXJuIHJlcy5jb25jYXQoZ3JvdXApO1xuICAgIH0sIFtdKTtcbiAgICB2YXIgaGFzQ29tbWVudCA9IGZsYXRHcm91cHMuc2xpY2UoMSwgLTEpLnNvbWUoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBoYXNMZWFkaW5nQ29tbWVudCQzKG5vZGUubm9kZSk7XG4gICAgfSkgfHwgZmxhdEdyb3Vwcy5zbGljZSgwLCAtMSkuc29tZShmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIGhhc1RyYWlsaW5nQ29tbWVudCQxKG5vZGUubm9kZSk7XG4gICAgfSkgfHwgZ3JvdXBzW2N1dG9mZl0gJiYgaGFzTGVhZGluZ0NvbW1lbnQkMyhncm91cHNbY3V0b2ZmXVswXS5ub2RlKTsgLy8gSWYgd2Ugb25seSBoYXZlIGEgc2luZ2xlIGAuYCwgd2Ugc2hvdWxkbid0IGRvIGFueXRoaW5nIGZhbmN5IGFuZCBqdXN0XG4gICAgLy8gcmVuZGVyIGV2ZXJ5dGhpbmcgY29uY2F0ZW5hdGVkIHRvZ2V0aGVyLlxuXG4gICAgaWYgKGdyb3Vwcy5sZW5ndGggPD0gY3V0b2ZmICYmICFoYXNDb21tZW50KSB7XG4gICAgICBpZiAoaXNMb25nQ3VycmllZENhbGxFeHByZXNzaW9uJDEocGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIG9uZUxpbmU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBncm91cCRiKG9uZUxpbmUpO1xuICAgIH0gLy8gRmluZCBvdXQgdGhlIGxhc3Qgbm9kZSBpbiB0aGUgZmlyc3QgZ3JvdXAgYW5kIGNoZWNrIGlmIGl0IGhhcyBhblxuICAgIC8vIGVtcHR5IGxpbmUgYWZ0ZXJcblxuXG4gICAgdmFyIGxhc3ROb2RlQmVmb3JlSW5kZW50ID0gZ2V0TGFzdCQyKHNob3VsZE1lcmdlID8gZ3JvdXBzLnNsaWNlKDEsIDIpWzBdIDogZ3JvdXBzWzBdKS5ub2RlO1xuICAgIHZhciBzaG91bGRIYXZlRW1wdHlMaW5lQmVmb3JlSW5kZW50ID0gbGFzdE5vZGVCZWZvcmVJbmRlbnQudHlwZSAhPT0gXCJDYWxsRXhwcmVzc2lvblwiICYmIGxhc3ROb2RlQmVmb3JlSW5kZW50LnR5cGUgIT09IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiICYmIHNob3VsZEluc2VydEVtcHR5TGluZUFmdGVyKGxhc3ROb2RlQmVmb3JlSW5kZW50KTtcbiAgICB2YXIgZXhwYW5kZWQgPSBjb25jYXQkZChbcHJpbnRHcm91cChncm91cHNbMF0pLCBzaG91bGRNZXJnZSA/IGNvbmNhdCRkKGdyb3Vwcy5zbGljZSgxLCAyKS5tYXAocHJpbnRHcm91cCkpIDogXCJcIiwgc2hvdWxkSGF2ZUVtcHR5TGluZUJlZm9yZUluZGVudCA/IGhhcmRsaW5lJDkgOiBcIlwiLCBwcmludEluZGVudGVkR3JvdXAoZ3JvdXBzLnNsaWNlKHNob3VsZE1lcmdlID8gMiA6IDEpKV0pO1xuICAgIHZhciBjYWxsRXhwcmVzc2lvbnMgPSBwcmludGVkTm9kZXMubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgbm9kZSA9IF9yZWYubm9kZTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0pLmZpbHRlcihpc0NhbGxPck9wdGlvbmFsQ2FsbEV4cHJlc3Npb24kMSk7IC8vIFdlIGRvbid0IHdhbnQgdG8gcHJpbnQgaW4gb25lIGxpbmUgaWYgdGhlcmUnczpcbiAgICAvLyAgKiBBIGNvbW1lbnQuXG4gICAgLy8gICogMyBvciBtb3JlIGNoYWluZWQgY2FsbHMuXG4gICAgLy8gICogQW55IGdyb3VwIGJ1dCB0aGUgbGFzdCBvbmUgaGFzIGEgaGFyZCBsaW5lLlxuICAgIC8vIElmIHRoZSBsYXN0IGdyb3VwIGlzIGEgZnVuY3Rpb24gaXQncyBva2F5IHRvIGlubGluZSBpZiBpdCBmaXRzLlxuXG4gICAgaWYgKGhhc0NvbW1lbnQgfHwgY2FsbEV4cHJlc3Npb25zLmxlbmd0aCA+PSAzIHx8IHByaW50ZWRHcm91cHMuc2xpY2UoMCwgLTEpLnNvbWUod2lsbEJyZWFrJDEpIHx8XG4gICAgLyoqXG4gICAgICogICAgIHNjb3Blcy5maWx0ZXIoc2NvcGUgPT4gc2NvcGUudmFsdWUgIT09ICcnKS5tYXAoKHNjb3BlLCBpKSA9PiB7XG4gICAgICogICAgICAgLy8gbXVsdGkgbGluZSBjb250ZW50XG4gICAgICogICAgIH0pXG4gICAgICovXG4gICAgZnVuY3Rpb24gKGxhc3RHcm91cERvYywgbGFzdEdyb3VwTm9kZSkge1xuICAgICAgcmV0dXJuIGlzQ2FsbE9yT3B0aW9uYWxDYWxsRXhwcmVzc2lvbiQxKGxhc3RHcm91cE5vZGUpICYmIHdpbGxCcmVhayQxKGxhc3RHcm91cERvYyk7XG4gICAgfShnZXRMYXN0JDIocHJpbnRlZEdyb3VwcyksIGdldExhc3QkMihnZXRMYXN0JDIoZ3JvdXBzKSkubm9kZSkgJiYgY2FsbEV4cHJlc3Npb25zLnNsaWNlKDAsIC0xKS5zb21lKGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gbi5hcmd1bWVudHMuc29tZShpc0Z1bmN0aW9uT3JBcnJvd0V4cHJlc3Npb24kMSk7XG4gICAgfSkpIHtcbiAgICAgIHJldHVybiBncm91cCRiKGV4cGFuZGVkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uY2F0JGQoWy8vIFdlIG9ubHkgbmVlZCB0byBjaGVjayBgb25lTGluZWAgYmVjYXVzZSBpZiBgZXhwYW5kZWRgIGlzIGNob3NlblxuICAgIC8vIHRoYXQgbWVhbnMgdGhhdCB0aGUgcGFyZW50IGdyb3VwIGhhcyBhbHJlYWR5IGJlZW4gYnJva2VuXG4gICAgLy8gbmF0dXJhbGx5XG4gICAgd2lsbEJyZWFrJDEob25lTGluZSkgfHwgc2hvdWxkSGF2ZUVtcHR5TGluZUJlZm9yZUluZGVudCA/IGJyZWFrUGFyZW50JDMgOiBcIlwiLCBjb25kaXRpb25hbEdyb3VwJDEoW29uZUxpbmUsIGV4cGFuZGVkXSldKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlcGFyYXRvck5vV2hpdGVzcGFjZShpc0ZhY2Vib29rVHJhbnNsYXRpb25UYWcsIGNoaWxkLCBjaGlsZE5vZGUsIG5leHROb2RlKSB7XG4gICAgaWYgKGlzRmFjZWJvb2tUcmFuc2xhdGlvblRhZykge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkTm9kZS50eXBlID09PSBcIkpTWEVsZW1lbnRcIiAmJiAhY2hpbGROb2RlLmNsb3NpbmdFbGVtZW50IHx8IG5leHROb2RlICYmIG5leHROb2RlLnR5cGUgPT09IFwiSlNYRWxlbWVudFwiICYmICFuZXh0Tm9kZS5jbG9zaW5nRWxlbWVudCkge1xuICAgICAgcmV0dXJuIGNoaWxkLmxlbmd0aCA9PT0gMSA/IHNvZnRsaW5lJDYgOiBoYXJkbGluZSQ5O1xuICAgIH1cblxuICAgIHJldHVybiBzb2Z0bGluZSQ2O1xuICB9XG5cbiAgZnVuY3Rpb24gc2VwYXJhdG9yV2l0aFdoaXRlc3BhY2UoaXNGYWNlYm9va1RyYW5zbGF0aW9uVGFnLCBjaGlsZCwgY2hpbGROb2RlLCBuZXh0Tm9kZSkge1xuICAgIGlmIChpc0ZhY2Vib29rVHJhbnNsYXRpb25UYWcpIHtcbiAgICAgIHJldHVybiBoYXJkbGluZSQ5O1xuICAgIH1cblxuICAgIGlmIChjaGlsZC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBjaGlsZE5vZGUudHlwZSA9PT0gXCJKU1hFbGVtZW50XCIgJiYgIWNoaWxkTm9kZS5jbG9zaW5nRWxlbWVudCB8fCBuZXh0Tm9kZSAmJiBuZXh0Tm9kZS50eXBlID09PSBcIkpTWEVsZW1lbnRcIiAmJiAhbmV4dE5vZGUuY2xvc2luZ0VsZW1lbnQgPyBoYXJkbGluZSQ5IDogc29mdGxpbmUkNjtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFyZGxpbmUkOTtcbiAgfSAvLyBKU1ggQ2hpbGRyZW4gYXJlIHN0cmFuZ2UsIG1vc3RseSBmb3IgdHdvIHJlYXNvbnM6XG4gIC8vIDEuIEpTWCByZWFkcyBuZXdsaW5lcyBpbnRvIHN0cmluZyB2YWx1ZXMsIGluc3RlYWQgb2Ygc2tpcHBpbmcgdGhlbSBsaWtlIEpTXG4gIC8vIDIuIHVwIHRvIG9uZSB3aGl0ZXNwYWNlIGJldHdlZW4gZWxlbWVudHMgd2l0aGluIGEgbGluZSBpcyBzaWduaWZpY2FudCxcbiAgLy8gICAgYnV0IG5vdCBiZXR3ZWVuIGxpbmVzLlxuICAvL1xuICAvLyBMZWFkaW5nLCB0cmFpbGluZywgYW5kIGxvbmUgd2hpdGVzcGFjZSBhbGwgbmVlZCB0b1xuICAvLyB0dXJuIHRoZW1zZWx2ZXMgaW50byB0aGUgcmF0aGVyIHVnbHkgYHsnICd9YCB3aGVuIGJyZWFraW5nLlxuICAvL1xuICAvLyBXZSBwcmludCBKU1ggdXNpbmcgdGhlIGBmaWxsYCBkb2MgcHJpbWl0aXZlLlxuICAvLyBUaGlzIHJlcXVpcmVzIHRoYXQgd2UgZ2l2ZSBpdCBhbiBhcnJheSBvZiBhbHRlcm5hdGluZ1xuICAvLyBjb250ZW50IGFuZCB3aGl0ZXNwYWNlIGVsZW1lbnRzLlxuICAvLyBUbyBlbnN1cmUgdGhpcyB3ZSBhZGQgZHVtbXkgYFwiXCJgIGNvbnRlbnQgZWxlbWVudHMgYXMgbmVlZGVkLlxuXG5cbiAgZnVuY3Rpb24gcHJpbnRKU1hDaGlsZHJlbihwYXRoLCBvcHRpb25zLCBwcmludCwganN4V2hpdGVzcGFjZSwgaXNGYWNlYm9va1RyYW5zbGF0aW9uVGFnKSB7XG4gICAgdmFyIG4gPSBwYXRoLmdldFZhbHVlKCk7XG4gICAgdmFyIGNoaWxkcmVuID0gW107IC8vIHVzaW5nIGBtYXBgIGluc3RlYWQgb2YgYGVhY2hgIGJlY2F1c2UgaXQgcHJvdmlkZXMgYGlgXG5cbiAgICBwYXRoLm1hcChmdW5jdGlvbiAoY2hpbGRQYXRoLCBpKSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZFBhdGguZ2V0VmFsdWUoKTtcblxuICAgICAgaWYgKGlzTGl0ZXJhbCQxKGNoaWxkKSkge1xuICAgICAgICB2YXIgdGV4dCA9IHJhd1RleHQkMShjaGlsZCk7IC8vIENvbnRhaW5zIGEgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyXG5cbiAgICAgICAgaWYgKGlzTWVhbmluZ2Z1bEpTWFRleHQkMShjaGlsZCkpIHtcbiAgICAgICAgICB2YXIgd29yZHMgPSB0ZXh0LnNwbGl0KG1hdGNoSnN4V2hpdGVzcGFjZVJlZ2V4JDEpOyAvLyBTdGFydHMgd2l0aCB3aGl0ZXNwYWNlXG5cbiAgICAgICAgICBpZiAod29yZHNbMF0gPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goXCJcIik7XG4gICAgICAgICAgICB3b3Jkcy5zaGlmdCgpO1xuXG4gICAgICAgICAgICBpZiAoL1xcbi8udGVzdCh3b3Jkc1swXSkpIHtcbiAgICAgICAgICAgICAgdmFyIG5leHQgPSBuLmNoaWxkcmVuW2kgKyAxXTtcbiAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChzZXBhcmF0b3JXaXRoV2hpdGVzcGFjZShpc0ZhY2Vib29rVHJhbnNsYXRpb25UYWcsIHdvcmRzWzFdLCBjaGlsZCwgbmV4dCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChqc3hXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd29yZHMuc2hpZnQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZW5kV2hpdGVzcGFjZTsgLy8gRW5kcyB3aXRoIHdoaXRlc3BhY2VcblxuICAgICAgICAgIGlmIChnZXRMYXN0JDIod29yZHMpID09PSBcIlwiKSB7XG4gICAgICAgICAgICB3b3Jkcy5wb3AoKTtcbiAgICAgICAgICAgIGVuZFdoaXRlc3BhY2UgPSB3b3Jkcy5wb3AoKTtcbiAgICAgICAgICB9IC8vIFRoaXMgd2FzIHdoaXRlc3BhY2Ugb25seSB3aXRob3V0IGEgbmV3IGxpbmUuXG5cblxuICAgICAgICAgIGlmICh3b3Jkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3b3Jkcy5mb3JFYWNoKGZ1bmN0aW9uICh3b3JkLCBpKSB7XG4gICAgICAgICAgICBpZiAoaSAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChsaW5lJDcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh3b3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChlbmRXaGl0ZXNwYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICgvXFxuLy50ZXN0KGVuZFdoaXRlc3BhY2UpKSB7XG4gICAgICAgICAgICAgIHZhciBfbmV4dCA9IG4uY2hpbGRyZW5baSArIDFdO1xuICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHNlcGFyYXRvcldpdGhXaGl0ZXNwYWNlKGlzRmFjZWJvb2tUcmFuc2xhdGlvblRhZywgZ2V0TGFzdCQyKGNoaWxkcmVuKSwgY2hpbGQsIF9uZXh0KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGpzeFdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgX25leHQyID0gbi5jaGlsZHJlbltpICsgMV07XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHNlcGFyYXRvck5vV2hpdGVzcGFjZShpc0ZhY2Vib29rVHJhbnNsYXRpb25UYWcsIGdldExhc3QkMihjaGlsZHJlbiksIGNoaWxkLCBfbmV4dDIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoL1xcbi8udGVzdCh0ZXh0KSkge1xuICAgICAgICAgIC8vIEtlZXAgKHVwIHRvIG9uZSkgYmxhbmsgbGluZSBiZXR3ZWVuIHRhZ3MvZXhwcmVzc2lvbnMvdGV4dC5cbiAgICAgICAgICAvLyBOb3RlOiBXZSBkb24ndCBrZWVwIGJsYW5rIGxpbmVzIGJldHdlZW4gdGV4dCBlbGVtZW50cy5cbiAgICAgICAgICBpZiAodGV4dC5tYXRjaCgvXFxuL2cpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goXCJcIik7XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGhhcmRsaW5lJDkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKFwiXCIpO1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goanN4V2hpdGVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwcmludGVkQ2hpbGQgPSBwcmludChjaGlsZFBhdGgpO1xuICAgICAgICBjaGlsZHJlbi5wdXNoKHByaW50ZWRDaGlsZCk7XG4gICAgICAgIHZhciBfbmV4dDMgPSBuLmNoaWxkcmVuW2kgKyAxXTtcblxuICAgICAgICB2YXIgZGlyZWN0bHlGb2xsb3dlZEJ5TWVhbmluZ2Z1bFRleHQgPSBfbmV4dDMgJiYgaXNNZWFuaW5nZnVsSlNYVGV4dCQxKF9uZXh0Myk7XG5cbiAgICAgICAgaWYgKGRpcmVjdGx5Rm9sbG93ZWRCeU1lYW5pbmdmdWxUZXh0KSB7XG4gICAgICAgICAgdmFyIGZpcnN0V29yZCA9IHJhd1RleHQkMShfbmV4dDMpLnRyaW0oKS5zcGxpdChtYXRjaEpzeFdoaXRlc3BhY2VSZWdleCQxKVswXTtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHNlcGFyYXRvck5vV2hpdGVzcGFjZShpc0ZhY2Vib29rVHJhbnNsYXRpb25UYWcsIGZpcnN0V29yZCwgY2hpbGQsIF9uZXh0MykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goaGFyZGxpbmUkOSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBcImNoaWxkcmVuXCIpO1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfSAvLyBKU1ggZXhwYW5kcyBjaGlsZHJlbiBmcm9tIHRoZSBpbnNpZGUtb3V0LCBpbnN0ZWFkIG9mIHRoZSBvdXRzaWRlLWluLlxuICAvLyBUaGlzIGlzIGJvdGggdG8gYnJlYWsgY2hpbGRyZW4gYmVmb3JlIGF0dHJpYnV0ZXMsXG4gIC8vIGFuZCB0byBlbnN1cmUgdGhhdCB3aGVuIGNoaWxkcmVuIGJyZWFrLCB0aGVpciBwYXJlbnRzIGRvIGFzIHdlbGwuXG4gIC8vXG4gIC8vIEFueSBlbGVtZW50IHRoYXQgaXMgd3JpdHRlbiB3aXRob3V0IGFueSBuZXdsaW5lcyBhbmQgZml0cyBvbiBhIHNpbmdsZSBsaW5lXG4gIC8vIGlzIGxlZnQgdGhhdCB3YXkuXG4gIC8vIE5vdCBvbmx5IHRoYXQsIGFueSB1c2VyLXdyaXR0ZW4tbGluZSBjb250YWluaW5nIG11bHRpcGxlIEpTWCBzaWJsaW5nc1xuICAvLyBzaG91bGQgYWxzbyBiZSBrZXB0IG9uIG9uZSBsaW5lIGlmIHBvc3NpYmxlLFxuICAvLyBzbyBlYWNoIHVzZXItd3JpdHRlbi1saW5lIGlzIHdyYXBwZWQgaW4gaXRzIG93biBncm91cC5cbiAgLy9cbiAgLy8gRWxlbWVudHMgdGhhdCBjb250YWluIG5ld2xpbmVzIG9yIGRvbid0IGZpdCBvbiBhIHNpbmdsZSBsaW5lIChyZWN1cnNpdmVseSlcbiAgLy8gYXJlIGZ1bGx5LXNwbGl0LCB1c2luZyBoYXJkbGluZSBhbmQgc2hvdWxkQnJlYWs6IHRydWUuXG4gIC8vXG4gIC8vIFRvIHN1cHBvcnQgdGhhdCBjYXNlIHByb3Blcmx5LCBhbGwgbGVhZGluZyBhbmQgdHJhaWxpbmcgc3BhY2VzXG4gIC8vIGFyZSBzdHJpcHBlZCBmcm9tIHRoZSBsaXN0IG9mIGNoaWxkcmVuLCBhbmQgcmVwbGFjZWQgd2l0aCBhIHNpbmdsZSBoYXJkbGluZS5cblxuXG4gIGZ1bmN0aW9uIHByaW50SlNYRWxlbWVudChwYXRoLCBvcHRpb25zLCBwcmludCkge1xuICAgIHZhciBuID0gcGF0aC5nZXRWYWx1ZSgpO1xuXG4gICAgaWYgKG4udHlwZSA9PT0gXCJKU1hFbGVtZW50XCIgJiYgaXNFbXB0eUpTWEVsZW1lbnQkMShuKSkge1xuICAgICAgcmV0dXJuIGNvbmNhdCRkKFtwYXRoLmNhbGwocHJpbnQsIFwib3BlbmluZ0VsZW1lbnRcIiksIHBhdGguY2FsbChwcmludCwgXCJjbG9zaW5nRWxlbWVudFwiKV0pO1xuICAgIH1cblxuICAgIHZhciBvcGVuaW5nTGluZXMgPSBuLnR5cGUgPT09IFwiSlNYRWxlbWVudFwiID8gcGF0aC5jYWxsKHByaW50LCBcIm9wZW5pbmdFbGVtZW50XCIpIDogcGF0aC5jYWxsKHByaW50LCBcIm9wZW5pbmdGcmFnbWVudFwiKTtcbiAgICB2YXIgY2xvc2luZ0xpbmVzID0gbi50eXBlID09PSBcIkpTWEVsZW1lbnRcIiA/IHBhdGguY2FsbChwcmludCwgXCJjbG9zaW5nRWxlbWVudFwiKSA6IHBhdGguY2FsbChwcmludCwgXCJjbG9zaW5nRnJhZ21lbnRcIik7XG5cbiAgICBpZiAobi5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgbi5jaGlsZHJlblswXS50eXBlID09PSBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIiAmJiAobi5jaGlsZHJlblswXS5leHByZXNzaW9uLnR5cGUgPT09IFwiVGVtcGxhdGVMaXRlcmFsXCIgfHwgbi5jaGlsZHJlblswXS5leHByZXNzaW9uLnR5cGUgPT09IFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIpKSB7XG4gICAgICByZXR1cm4gY29uY2F0JGQoW29wZW5pbmdMaW5lcywgY29uY2F0JGQocGF0aC5tYXAocHJpbnQsIFwiY2hpbGRyZW5cIikpLCBjbG9zaW5nTGluZXNdKTtcbiAgICB9IC8vIENvbnZlcnQgYHtcIiBcIn1gIHRvIHRleHQgbm9kZXMgY29udGFpbmluZyBhIHNwYWNlLlxuICAgIC8vIFRoaXMgbWFrZXMgaXQgZWFzeSB0byB0dXJuIHRoZW0gaW50byBganN4V2hpdGVzcGFjZWAgd2hpY2hcbiAgICAvLyBjYW4gdGhlbiBwcmludCBhcyBlaXRoZXIgYSBzcGFjZSBvciBge1wiIFwifWAgd2hlbiBicmVha2luZy5cblxuXG4gICAgbi5jaGlsZHJlbiA9IG4uY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgaWYgKGlzSlNYV2hpdGVzcGFjZUV4cHJlc3Npb24kMShjaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcIkpTWFRleHRcIixcbiAgICAgICAgICB2YWx1ZTogXCIgXCIsXG4gICAgICAgICAgcmF3OiBcIiBcIlxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSk7XG4gICAgdmFyIGNvbnRhaW5zVGFnID0gbi5jaGlsZHJlbi5maWx0ZXIoaXNKU1hOb2RlJDEpLmxlbmd0aCA+IDA7XG4gICAgdmFyIGNvbnRhaW5zTXVsdGlwbGVFeHByZXNzaW9ucyA9IG4uY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkLnR5cGUgPT09IFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiO1xuICAgIH0pLmxlbmd0aCA+IDE7XG4gICAgdmFyIGNvbnRhaW5zTXVsdGlwbGVBdHRyaWJ1dGVzID0gbi50eXBlID09PSBcIkpTWEVsZW1lbnRcIiAmJiBuLm9wZW5pbmdFbGVtZW50LmF0dHJpYnV0ZXMubGVuZ3RoID4gMTsgLy8gUmVjb3JkIGFueSBicmVha3MuIFNob3VsZCBuZXZlciBnbyBmcm9tIHRydWUgdG8gZmFsc2UsIG9ubHkgZmFsc2UgdG8gdHJ1ZS5cblxuICAgIHZhciBmb3JjZWRCcmVhayA9IHdpbGxCcmVhayQxKG9wZW5pbmdMaW5lcykgfHwgY29udGFpbnNUYWcgfHwgY29udGFpbnNNdWx0aXBsZUF0dHJpYnV0ZXMgfHwgY29udGFpbnNNdWx0aXBsZUV4cHJlc3Npb25zO1xuICAgIHZhciByYXdKc3hXaGl0ZXNwYWNlID0gb3B0aW9ucy5zaW5nbGVRdW90ZSA/IFwieycgJ31cIiA6ICd7XCIgXCJ9JztcbiAgICB2YXIganN4V2hpdGVzcGFjZSA9IGlmQnJlYWskNihjb25jYXQkZChbcmF3SnN4V2hpdGVzcGFjZSwgc29mdGxpbmUkNl0pLCBcIiBcIik7XG4gICAgdmFyIGlzRmFjZWJvb2tUcmFuc2xhdGlvblRhZyA9IG4ub3BlbmluZ0VsZW1lbnQgJiYgbi5vcGVuaW5nRWxlbWVudC5uYW1lICYmIG4ub3BlbmluZ0VsZW1lbnQubmFtZS5uYW1lID09PSBcImZidFwiO1xuICAgIHZhciBjaGlsZHJlbiA9IHByaW50SlNYQ2hpbGRyZW4ocGF0aCwgb3B0aW9ucywgcHJpbnQsIGpzeFdoaXRlc3BhY2UsIGlzRmFjZWJvb2tUcmFuc2xhdGlvblRhZyk7XG4gICAgdmFyIGNvbnRhaW5zVGV4dCA9IG4uY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgcmV0dXJuIGlzTWVhbmluZ2Z1bEpTWFRleHQkMShjaGlsZCk7XG4gICAgfSkubGVuZ3RoID4gMDsgLy8gV2UgY2FuIGVuZCB1cCB3ZSBtdWx0aXBsZSB3aGl0ZXNwYWNlIGVsZW1lbnRzIHdpdGggZW1wdHkgc3RyaW5nXG4gICAgLy8gY29udGVudCBiZXR3ZWVuIHRoZW0uXG4gICAgLy8gV2UgbmVlZCB0byByZW1vdmUgZW1wdHkgd2hpdGVzcGFjZSBhbmQgc29mdGxpbmVzIGJlZm9yZSBKU1ggd2hpdGVzcGFjZVxuICAgIC8vIHRvIGdldCB0aGUgY29ycmVjdCBvdXRwdXQuXG5cbiAgICBmb3IgKHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBpc1BhaXJPZkVtcHR5U3RyaW5ncyA9IGNoaWxkcmVuW2ldID09PSBcIlwiICYmIGNoaWxkcmVuW2kgKyAxXSA9PT0gXCJcIjtcbiAgICAgIHZhciBpc1BhaXJPZkhhcmRsaW5lcyA9IGNoaWxkcmVuW2ldID09PSBoYXJkbGluZSQ5ICYmIGNoaWxkcmVuW2kgKyAxXSA9PT0gXCJcIiAmJiBjaGlsZHJlbltpICsgMl0gPT09IGhhcmRsaW5lJDk7XG4gICAgICB2YXIgaXNMaW5lRm9sbG93ZWRCeUpTWFdoaXRlc3BhY2UgPSAoY2hpbGRyZW5baV0gPT09IHNvZnRsaW5lJDYgfHwgY2hpbGRyZW5baV0gPT09IGhhcmRsaW5lJDkpICYmIGNoaWxkcmVuW2kgKyAxXSA9PT0gXCJcIiAmJiBjaGlsZHJlbltpICsgMl0gPT09IGpzeFdoaXRlc3BhY2U7XG4gICAgICB2YXIgaXNKU1hXaGl0ZXNwYWNlRm9sbG93ZWRCeUxpbmUgPSBjaGlsZHJlbltpXSA9PT0ganN4V2hpdGVzcGFjZSAmJiBjaGlsZHJlbltpICsgMV0gPT09IFwiXCIgJiYgKGNoaWxkcmVuW2kgKyAyXSA9PT0gc29mdGxpbmUkNiB8fCBjaGlsZHJlbltpICsgMl0gPT09IGhhcmRsaW5lJDkpO1xuICAgICAgdmFyIGlzRG91YmxlSlNYV2hpdGVzcGFjZSA9IGNoaWxkcmVuW2ldID09PSBqc3hXaGl0ZXNwYWNlICYmIGNoaWxkcmVuW2kgKyAxXSA9PT0gXCJcIiAmJiBjaGlsZHJlbltpICsgMl0gPT09IGpzeFdoaXRlc3BhY2U7XG4gICAgICB2YXIgaXNQYWlyT2ZIYXJkT3JTb2Z0TGluZXMgPSBjaGlsZHJlbltpXSA9PT0gc29mdGxpbmUkNiAmJiBjaGlsZHJlbltpICsgMV0gPT09IFwiXCIgJiYgY2hpbGRyZW5baSArIDJdID09PSBoYXJkbGluZSQ5IHx8IGNoaWxkcmVuW2ldID09PSBoYXJkbGluZSQ5ICYmIGNoaWxkcmVuW2kgKyAxXSA9PT0gXCJcIiAmJiBjaGlsZHJlbltpICsgMl0gPT09IHNvZnRsaW5lJDY7XG5cbiAgICAgIGlmIChpc1BhaXJPZkhhcmRsaW5lcyAmJiBjb250YWluc1RleHQgfHwgaXNQYWlyT2ZFbXB0eVN0cmluZ3MgfHwgaXNMaW5lRm9sbG93ZWRCeUpTWFdoaXRlc3BhY2UgfHwgaXNEb3VibGVKU1hXaGl0ZXNwYWNlIHx8IGlzUGFpck9mSGFyZE9yU29mdExpbmVzKSB7XG4gICAgICAgIGNoaWxkcmVuLnNwbGljZShpLCAyKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNKU1hXaGl0ZXNwYWNlRm9sbG93ZWRCeUxpbmUpIHtcbiAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGkgKyAxLCAyKTtcbiAgICAgIH1cbiAgICB9IC8vIFRyaW0gdHJhaWxpbmcgbGluZXMgKG9yIGVtcHR5IHN0cmluZ3MpXG5cblxuICAgIHdoaWxlIChjaGlsZHJlbi5sZW5ndGggJiYgKGlzTGluZU5leHQkMShnZXRMYXN0JDIoY2hpbGRyZW4pKSB8fCBpc0VtcHR5JDEoZ2V0TGFzdCQyKGNoaWxkcmVuKSkpKSB7XG4gICAgICBjaGlsZHJlbi5wb3AoKTtcbiAgICB9IC8vIFRyaW0gbGVhZGluZyBsaW5lcyAob3IgZW1wdHkgc3RyaW5ncylcblxuXG4gICAgd2hpbGUgKGNoaWxkcmVuLmxlbmd0aCAmJiAoaXNMaW5lTmV4dCQxKGNoaWxkcmVuWzBdKSB8fCBpc0VtcHR5JDEoY2hpbGRyZW5bMF0pKSAmJiAoaXNMaW5lTmV4dCQxKGNoaWxkcmVuWzFdKSB8fCBpc0VtcHR5JDEoY2hpbGRyZW5bMV0pKSkge1xuICAgICAgY2hpbGRyZW4uc2hpZnQoKTtcbiAgICAgIGNoaWxkcmVuLnNoaWZ0KCk7XG4gICAgfSAvLyBUd2VhayBob3cgd2UgZm9ybWF0IGNoaWxkcmVuIGlmIG91dHB1dHRpbmcgdGhpcyBlbGVtZW50IG92ZXIgbXVsdGlwbGUgbGluZXMuXG4gICAgLy8gQWxzbyBkZXRlY3Qgd2hldGhlciB3ZSB3aWxsIGZvcmNlIHRoaXMgZWxlbWVudCB0byBvdXRwdXQgb3ZlciBtdWx0aXBsZSBsaW5lcy5cblxuXG4gICAgdmFyIG11bHRpbGluZUNoaWxkcmVuID0gW107XG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQsIGkpIHtcbiAgICAgIC8vIFRoZXJlIGFyZSBhIG51bWJlciBvZiBzaXR1YXRpb25zIHdoZXJlIHdlIG5lZWQgdG8gZW5zdXJlIHdlIGRpc3BsYXlcbiAgICAgIC8vIHdoaXRlc3BhY2UgYXMgYHtcIiBcIn1gIHdoZW4gb3V0cHV0dGluZyB0aGlzIGVsZW1lbnQgb3ZlciBtdWx0aXBsZSBsaW5lcy5cbiAgICAgIGlmIChjaGlsZCA9PT0ganN4V2hpdGVzcGFjZSkge1xuICAgICAgICBpZiAoaSA9PT0gMSAmJiBjaGlsZHJlbltpIC0gMV0gPT09IFwiXCIpIHtcbiAgICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAvLyBTb2xpdGFyeSB3aGl0ZXNwYWNlXG4gICAgICAgICAgICBtdWx0aWxpbmVDaGlsZHJlbi5wdXNoKHJhd0pzeFdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gLy8gTGVhZGluZyB3aGl0ZXNwYWNlXG5cblxuICAgICAgICAgIG11bHRpbGluZUNoaWxkcmVuLnB1c2goY29uY2F0JGQoW3Jhd0pzeFdoaXRlc3BhY2UsIGhhcmRsaW5lJDldKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKGkgPT09IGNoaWxkcmVuLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAvLyBUcmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgICAgICAgbXVsdGlsaW5lQ2hpbGRyZW4ucHVzaChyYXdKc3hXaGl0ZXNwYWNlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5baSAtIDFdID09PSBcIlwiICYmIGNoaWxkcmVuW2kgLSAyXSA9PT0gaGFyZGxpbmUkOSkge1xuICAgICAgICAgIC8vIFdoaXRlc3BhY2UgYWZ0ZXIgbGluZSBicmVha1xuICAgICAgICAgIG11bHRpbGluZUNoaWxkcmVuLnB1c2gocmF3SnN4V2hpdGVzcGFjZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG11bHRpbGluZUNoaWxkcmVuLnB1c2goY2hpbGQpO1xuXG4gICAgICBpZiAod2lsbEJyZWFrJDEoY2hpbGQpKSB7XG4gICAgICAgIGZvcmNlZEJyZWFrID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTsgLy8gSWYgdGhlcmUgaXMgdGV4dCB3ZSB1c2UgYGZpbGxgIHRvIGZpdCBhcyBtdWNoIG9udG8gZWFjaCBsaW5lIGFzIHBvc3NpYmxlLlxuICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gdGV4dCAoanVzdCB0YWdzIGFuZCBleHByZXNzaW9ucykgd2UgdXNlIGBncm91cGBcbiAgICAvLyB0byBvdXRwdXQgZWFjaCBvbiBhIHNlcGFyYXRlIGxpbmUuXG5cbiAgICB2YXIgY29udGVudCA9IGNvbnRhaW5zVGV4dCA/IGZpbGwkNChtdWx0aWxpbmVDaGlsZHJlbikgOiBncm91cCRiKGNvbmNhdCRkKG11bHRpbGluZUNoaWxkcmVuKSwge1xuICAgICAgc2hvdWxkQnJlYWs6IHRydWVcbiAgICB9KTtcbiAgICB2YXIgbXVsdGlMaW5lRWxlbSA9IGdyb3VwJGIoY29uY2F0JGQoW29wZW5pbmdMaW5lcywgaW5kZW50JDcoY29uY2F0JGQoW2hhcmRsaW5lJDksIGNvbnRlbnRdKSksIGhhcmRsaW5lJDksIGNsb3NpbmdMaW5lc10pKTtcblxuICAgIGlmIChmb3JjZWRCcmVhaykge1xuICAgICAgcmV0dXJuIG11bHRpTGluZUVsZW07XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmRpdGlvbmFsR3JvdXAkMShbZ3JvdXAkYihjb25jYXQkZChbb3BlbmluZ0xpbmVzLCBjb25jYXQkZChjaGlsZHJlbiksIGNsb3NpbmdMaW5lc10pKSwgbXVsdGlMaW5lRWxlbV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF5YmVXcmFwSlNYRWxlbWVudEluUGFyZW5zKHBhdGgsIGVsZW0sIG9wdGlvbnMpIHtcbiAgICB2YXIgcGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG5cbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgcmV0dXJuIGVsZW07XG4gICAgfVxuXG4gICAgdmFyIE5PX1dSQVBfUEFSRU5UUyA9IHtcbiAgICAgIEFycmF5RXhwcmVzc2lvbjogdHJ1ZSxcbiAgICAgIEpTWEF0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgIEpTWEVsZW1lbnQ6IHRydWUsXG4gICAgICBKU1hFeHByZXNzaW9uQ29udGFpbmVyOiB0cnVlLFxuICAgICAgSlNYRnJhZ21lbnQ6IHRydWUsXG4gICAgICBFeHByZXNzaW9uU3RhdGVtZW50OiB0cnVlLFxuICAgICAgQ2FsbEV4cHJlc3Npb246IHRydWUsXG4gICAgICBPcHRpb25hbENhbGxFeHByZXNzaW9uOiB0cnVlLFxuICAgICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiB0cnVlLFxuICAgICAgSnNFeHByZXNzaW9uUm9vdDogdHJ1ZVxuICAgIH07XG5cbiAgICBpZiAoTk9fV1JBUF9QQVJFTlRTW3BhcmVudC50eXBlXSkge1xuICAgICAgcmV0dXJuIGVsZW07XG4gICAgfVxuXG4gICAgdmFyIHNob3VsZEJyZWFrID0gbWF0Y2hBbmNlc3RvclR5cGVzJDEocGF0aCwgW1wiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiwgXCJDYWxsRXhwcmVzc2lvblwiLCBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIl0pIHx8IG1hdGNoQW5jZXN0b3JUeXBlcyQxKHBhdGgsIFtcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIsIFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiLCBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIl0pO1xuICAgIHZhciBuZWVkc1BhcmVucyA9IG5lZWRzUGFyZW5zXzEocGF0aCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQoW25lZWRzUGFyZW5zID8gXCJcIiA6IGlmQnJlYWskNihcIihcIiksIGluZGVudCQ3KGNvbmNhdCRkKFtzb2Z0bGluZSQ2LCBlbGVtXSkpLCBzb2Z0bGluZSQ2LCBuZWVkc1BhcmVucyA/IFwiXCIgOiBpZkJyZWFrJDYoXCIpXCIpXSksIHtcbiAgICAgIHNob3VsZEJyZWFrOiBzaG91bGRCcmVha1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkSW5saW5lTG9naWNhbEV4cHJlc3Npb24obm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgIT09IFwiTG9naWNhbEV4cHJlc3Npb25cIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChub2RlLnJpZ2h0LnR5cGUgPT09IFwiT2JqZWN0RXhwcmVzc2lvblwiICYmIG5vZGUucmlnaHQucHJvcGVydGllcy5sZW5ndGggIT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlLnJpZ2h0LnR5cGUgPT09IFwiQXJyYXlFeHByZXNzaW9uXCIgJiYgbm9kZS5yaWdodC5lbGVtZW50cy5sZW5ndGggIT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpc0pTWE5vZGUkMShub2RlLnJpZ2h0KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIEZvciBiaW5hcnkgZXhwcmVzc2lvbnMgdG8gYmUgY29uc2lzdGVudCwgd2UgbmVlZCB0byBncm91cFxuICAvLyBzdWJzZXF1ZW50IG9wZXJhdG9ycyB3aXRoIHRoZSBzYW1lIHByZWNlZGVuY2UgbGV2ZWwgdW5kZXIgYSBzaW5nbGVcbiAgLy8gZ3JvdXAuIE90aGVyd2lzZSB0aGV5IHdpbGwgYmUgbmVzdGVkIHN1Y2ggdGhhdCBzb21lIG9mIHRoZW0gYnJlYWtcbiAgLy8gb250byBuZXcgbGluZXMgYnV0IG5vdCBhbGwuIE9wZXJhdG9ycyB3aXRoIHRoZSBzYW1lIHByZWNlZGVuY2VcbiAgLy8gbGV2ZWwgc2hvdWxkIGVpdGhlciBhbGwgYnJlYWsgb3Igbm90LiBCZWNhdXNlIHdlIGdyb3VwIHRoZW0gYnlcbiAgLy8gcHJlY2VkZW5jZSBsZXZlbCBhbmQgdGhlIEFTVCBpcyBzdHJ1Y3R1cmVkIGJhc2VkIG9uIHByZWNlZGVuY2VcbiAgLy8gbGV2ZWwsIHRoaW5ncyBhcmUgbmF0dXJhbGx5IGJyb2tlbiB1cCBjb3JyZWN0bHksIGkuZS4gYCYmYCBpc1xuICAvLyBicm9rZW4gYmVmb3JlIGArYC5cblxuXG4gIGZ1bmN0aW9uIHByaW50QmluYXJ5aXNoRXhwcmVzc2lvbnMocGF0aCwgcHJpbnQsIG9wdGlvbnMsIGlzTmVzdGVkLCBpc0luc2lkZVBhcmVudGhlc2lzKSB7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgdmFyIG5vZGUgPSBwYXRoLmdldFZhbHVlKCk7IC8vIFdlIHRyZWF0IEJpbmFyeUV4cHJlc3Npb24gYW5kIExvZ2ljYWxFeHByZXNzaW9uIG5vZGVzIHRoZSBzYW1lLlxuXG4gICAgaWYgKGlzQmluYXJ5aXNoJDEobm9kZSkpIHtcbiAgICAgIC8vIFB1dCBhbGwgb3BlcmF0b3JzIHdpdGggdGhlIHNhbWUgcHJlY2VkZW5jZSBsZXZlbCBpbiB0aGUgc2FtZVxuICAgICAgLy8gZ3JvdXAuIFRoZSByZWFzb24gd2Ugb25seSBuZWVkIHRvIGRvIHRoaXMgd2l0aCB0aGUgYGxlZnRgXG4gICAgICAvLyBleHByZXNzaW9uIGlzIGJlY2F1c2UgZ2l2ZW4gYW4gZXhwcmVzc2lvbiBsaWtlIGAxICsgMiAtIDNgLCBpdFxuICAgICAgLy8gaXMgYWx3YXlzIHBhcnNlZCBsaWtlIGAoKDEgKyAyKSAtIDMpYCwgbWVhbmluZyB0aGUgYGxlZnRgIHNpZGVcbiAgICAgIC8vIGlzIHdoZXJlIHRoZSByZXN0IG9mIHRoZSBleHByZXNzaW9uIHdpbGwgZXhpc3QuIEJpbmFyeVxuICAgICAgLy8gZXhwcmVzc2lvbnMgb24gdGhlIHJpZ2h0IHNpZGUgbWVhbiB0aGV5IGhhdmUgYSBkaWZmZXJlbmNlXG4gICAgICAvLyBwcmVjZWRlbmNlIGxldmVsIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIHNlcGFyYXRlIGdyb3VwLCBzb1xuICAgICAgLy8gcHJpbnQgdGhlbSBub3JtYWxseS4gKFRoaXMgZG9lc24ndCBob2xkIGZvciB0aGUgYCoqYCBvcGVyYXRvcixcbiAgICAgIC8vIHdoaWNoIGlzIHVuaXF1ZSBpbiB0aGF0IGl0IGlzIHJpZ2h0LWFzc29jaWF0aXZlLilcbiAgICAgIGlmIChzaG91bGRGbGF0dGVuJDEobm9kZS5vcGVyYXRvciwgbm9kZS5sZWZ0Lm9wZXJhdG9yKSkge1xuICAgICAgICAvLyBGbGF0dGVuIHRoZW0gb3V0IGJ5IHJlY3Vyc2l2ZWx5IGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICAgICAgcGFydHMgPSBwYXJ0cy5jb25jYXQocGF0aC5jYWxsKGZ1bmN0aW9uIChsZWZ0KSB7XG4gICAgICAgICAgcmV0dXJuIHByaW50QmluYXJ5aXNoRXhwcmVzc2lvbnMobGVmdCwgcHJpbnQsIG9wdGlvbnMsXG4gICAgICAgICAgLyogaXNOZXN0ZWQgKi9cbiAgICAgICAgICB0cnVlLCBpc0luc2lkZVBhcmVudGhlc2lzKTtcbiAgICAgICAgfSwgXCJsZWZ0XCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcImxlZnRcIikpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2hvdWxkSW5saW5lID0gc2hvdWxkSW5saW5lTG9naWNhbEV4cHJlc3Npb24obm9kZSk7XG4gICAgICB2YXIgbGluZUJlZm9yZU9wZXJhdG9yID0gKG5vZGUub3BlcmF0b3IgPT09IFwifD5cIiB8fCBub2RlLnR5cGUgPT09IFwiTkdQaXBlRXhwcmVzc2lvblwiIHx8IG5vZGUub3BlcmF0b3IgPT09IFwifFwiICYmIG9wdGlvbnMucGFyc2VyID09PSBcIl9fdnVlX2V4cHJlc3Npb25cIikgJiYgIWhhc0xlYWRpbmdPd25MaW5lQ29tbWVudCQxKG9wdGlvbnMub3JpZ2luYWxUZXh0LCBub2RlLnJpZ2h0LCBvcHRpb25zKTtcbiAgICAgIHZhciBvcGVyYXRvciA9IG5vZGUudHlwZSA9PT0gXCJOR1BpcGVFeHByZXNzaW9uXCIgPyBcInxcIiA6IG5vZGUub3BlcmF0b3I7XG4gICAgICB2YXIgcmlnaHRTdWZmaXggPSBub2RlLnR5cGUgPT09IFwiTkdQaXBlRXhwcmVzc2lvblwiICYmIG5vZGUuYXJndW1lbnRzLmxlbmd0aCAhPT0gMCA/IGdyb3VwJGIoaW5kZW50JDcoY29uY2F0JGQoW3NvZnRsaW5lJDYsIFwiOiBcIiwgam9pbiQ5KGNvbmNhdCRkKFtzb2Z0bGluZSQ2LCBcIjpcIiwgaWZCcmVhayQ2KFwiIFwiKV0pLCBwYXRoLm1hcChwcmludCwgXCJhcmd1bWVudHNcIikubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgcmV0dXJuIGFsaWduJDEoMiwgZ3JvdXAkYihhcmcpKTtcbiAgICAgIH0pKV0pKSkgOiBcIlwiO1xuICAgICAgdmFyIHJpZ2h0ID0gc2hvdWxkSW5saW5lID8gY29uY2F0JGQoW29wZXJhdG9yLCBcIiBcIiwgcGF0aC5jYWxsKHByaW50LCBcInJpZ2h0XCIpLCByaWdodFN1ZmZpeF0pIDogY29uY2F0JGQoW2xpbmVCZWZvcmVPcGVyYXRvciA/IHNvZnRsaW5lJDYgOiBcIlwiLCBvcGVyYXRvciwgbGluZUJlZm9yZU9wZXJhdG9yID8gXCIgXCIgOiBsaW5lJDcsIHBhdGguY2FsbChwcmludCwgXCJyaWdodFwiKSwgcmlnaHRTdWZmaXhdKTsgLy8gSWYgdGhlcmUncyBvbmx5IGEgc2luZ2xlIGJpbmFyeSBleHByZXNzaW9uLCB3ZSB3YW50IHRvIGNyZWF0ZSBhIGdyb3VwXG4gICAgICAvLyBpbiBvcmRlciB0byBhdm9pZCBoYXZpbmcgYSBzbWFsbCByaWdodCBwYXJ0IGxpa2UgLTEgYmUgb24gaXRzIG93biBsaW5lLlxuXG4gICAgICB2YXIgcGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG4gICAgICB2YXIgc2hvdWxkR3JvdXAgPSAhKGlzSW5zaWRlUGFyZW50aGVzaXMgJiYgbm9kZS50eXBlID09PSBcIkxvZ2ljYWxFeHByZXNzaW9uXCIpICYmIHBhcmVudC50eXBlICE9PSBub2RlLnR5cGUgJiYgbm9kZS5sZWZ0LnR5cGUgIT09IG5vZGUudHlwZSAmJiBub2RlLnJpZ2h0LnR5cGUgIT09IG5vZGUudHlwZTtcbiAgICAgIHBhcnRzLnB1c2goXCIgXCIsIHNob3VsZEdyb3VwID8gZ3JvdXAkYihyaWdodCkgOiByaWdodCk7IC8vIFRoZSByb290IGNvbW1lbnRzIGFyZSBhbHJlYWR5IHByaW50ZWQsIGJ1dCB3ZSBuZWVkIHRvIG1hbnVhbGx5IHByaW50XG4gICAgICAvLyB0aGUgb3RoZXIgb25lcyBzaW5jZSB3ZSBkb24ndCBjYWxsIHRoZSBub3JtYWwgcHJpbnQgb24gQmluYXJ5RXhwcmVzc2lvbixcbiAgICAgIC8vIG9ubHkgZm9yIHRoZSBsZWZ0IGFuZCByaWdodCBwYXJ0c1xuXG4gICAgICBpZiAoaXNOZXN0ZWQgJiYgbm9kZS5jb21tZW50cykge1xuICAgICAgICBwYXJ0cyA9IGNvbW1lbnRzLnByaW50Q29tbWVudHMocGF0aCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdXIgc3RvcHBpbmcgY2FzZS4gU2ltcGx5IHByaW50IHRoZSBub2RlIG5vcm1hbGx5LlxuICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFydHM7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludEFzc2lnbm1lbnRSaWdodChsZWZ0Tm9kZSwgcmlnaHROb2RlLCBwcmludGVkUmlnaHQsIG9wdGlvbnMpIHtcbiAgICBpZiAoaGFzTGVhZGluZ093bkxpbmVDb21tZW50JDEob3B0aW9ucy5vcmlnaW5hbFRleHQsIHJpZ2h0Tm9kZSwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBpbmRlbnQkNyhjb25jYXQkZChbaGFyZGxpbmUkOSwgcHJpbnRlZFJpZ2h0XSkpO1xuICAgIH1cblxuICAgIHZhciBjYW5CcmVhayA9IGlzQmluYXJ5aXNoJDEocmlnaHROb2RlKSAmJiAhc2hvdWxkSW5saW5lTG9naWNhbEV4cHJlc3Npb24ocmlnaHROb2RlKSB8fCByaWdodE5vZGUudHlwZSA9PT0gXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIiAmJiBpc0JpbmFyeWlzaCQxKHJpZ2h0Tm9kZS50ZXN0KSAmJiAhc2hvdWxkSW5saW5lTG9naWNhbEV4cHJlc3Npb24ocmlnaHROb2RlLnRlc3QpIHx8IHJpZ2h0Tm9kZS50eXBlID09PSBcIlN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvblwiIHx8IHJpZ2h0Tm9kZS50eXBlID09PSBcIkNsYXNzRXhwcmVzc2lvblwiICYmIHJpZ2h0Tm9kZS5kZWNvcmF0b3JzICYmIHJpZ2h0Tm9kZS5kZWNvcmF0b3JzLmxlbmd0aCB8fCAobGVmdE5vZGUudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgfHwgaXNTdHJpbmdMaXRlcmFsJDEobGVmdE5vZGUpIHx8IGxlZnROb2RlLnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSAmJiAoaXNTdHJpbmdMaXRlcmFsJDEocmlnaHROb2RlKSB8fCBpc01lbWJlckV4cHJlc3Npb25DaGFpbiQxKHJpZ2h0Tm9kZSkpICYmIC8vIGRvIG5vdCBwdXQgdmFsdWVzIG9uIGEgc2VwYXJhdGUgbGluZSBmcm9tIHRoZSBrZXkgaW4ganNvblxuICAgIG9wdGlvbnMucGFyc2VyICE9PSBcImpzb25cIiAmJiBvcHRpb25zLnBhcnNlciAhPT0gXCJqc29uNVwiIHx8IHJpZ2h0Tm9kZS50eXBlID09PSBcIlNlcXVlbmNlRXhwcmVzc2lvblwiO1xuXG4gICAgaWYgKGNhbkJyZWFrKSB7XG4gICAgICByZXR1cm4gZ3JvdXAkYihpbmRlbnQkNyhjb25jYXQkZChbbGluZSQ3LCBwcmludGVkUmlnaHRdKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBjb25jYXQkZChbXCIgXCIsIHByaW50ZWRSaWdodF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRBc3NpZ25tZW50KGxlZnROb2RlLCBwcmludGVkTGVmdCwgb3BlcmF0b3IsIHJpZ2h0Tm9kZSwgcHJpbnRlZFJpZ2h0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFyaWdodE5vZGUpIHtcbiAgICAgIHJldHVybiBwcmludGVkTGVmdDtcbiAgICB9XG5cbiAgICB2YXIgcHJpbnRlZCA9IHByaW50QXNzaWdubWVudFJpZ2h0KGxlZnROb2RlLCByaWdodE5vZGUsIHByaW50ZWRSaWdodCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQoW3ByaW50ZWRMZWZ0LCBvcGVyYXRvciwgcHJpbnRlZF0pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkanVzdENsYXVzZShub2RlLCBjbGF1c2UsIGZvcmNlU3BhY2UpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIkVtcHR5U3RhdGVtZW50XCIpIHtcbiAgICAgIHJldHVybiBcIjtcIjtcbiAgICB9XG5cbiAgICBpZiAobm9kZS50eXBlID09PSBcIkJsb2NrU3RhdGVtZW50XCIgfHwgZm9yY2VTcGFjZSkge1xuICAgICAgcmV0dXJuIGNvbmNhdCRkKFtcIiBcIiwgY2xhdXNlXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGVudCQ3KGNvbmNhdCRkKFtsaW5lJDcsIGNsYXVzZV0pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vZGVTdHIobm9kZSwgb3B0aW9ucywgaXNGbG93T3JUeXBlU2NyaXB0RGlyZWN0aXZlTGl0ZXJhbCkge1xuICAgIHZhciByYXcgPSByYXdUZXh0JDEobm9kZSk7XG4gICAgdmFyIGlzRGlyZWN0aXZlTGl0ZXJhbCA9IGlzRmxvd09yVHlwZVNjcmlwdERpcmVjdGl2ZUxpdGVyYWwgfHwgbm9kZS50eXBlID09PSBcIkRpcmVjdGl2ZUxpdGVyYWxcIjtcbiAgICByZXR1cm4gcHJpbnRTdHJpbmckMihyYXcsIG9wdGlvbnMsIGlzRGlyZWN0aXZlTGl0ZXJhbCk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludFJlZ2V4KG5vZGUpIHtcbiAgICB2YXIgZmxhZ3MgPSBub2RlLmZsYWdzLnNwbGl0KFwiXCIpLnNvcnQoKS5qb2luKFwiXCIpO1xuICAgIHJldHVybiBcIi9cIi5jb25jYXQobm9kZS5wYXR0ZXJuLCBcIi9cIikuY29uY2F0KGZsYWdzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4cHJOZWVkc0FTSVByb3RlY3Rpb24ocGF0aCwgb3B0aW9ucykge1xuICAgIHZhciBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIHZhciBtYXliZUFTSVByb2JsZW0gPSBuZWVkc1BhcmVuc18xKHBhdGgsIG9wdGlvbnMpIHx8IG5vZGUudHlwZSA9PT0gXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJUeXBlQ2FzdEV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiAhc2hvdWxkUHJpbnRQYXJhbXNXaXRob3V0UGFyZW5zKHBhdGgsIG9wdGlvbnMpIHx8IG5vZGUudHlwZSA9PT0gXCJBcnJheUV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiQXJyYXlQYXR0ZXJuXCIgfHwgbm9kZS50eXBlID09PSBcIlVuYXJ5RXhwcmVzc2lvblwiICYmIG5vZGUucHJlZml4ICYmIChub2RlLm9wZXJhdG9yID09PSBcIitcIiB8fCBub2RlLm9wZXJhdG9yID09PSBcIi1cIikgfHwgbm9kZS50eXBlID09PSBcIlRlbXBsYXRlTGl0ZXJhbFwiIHx8IG5vZGUudHlwZSA9PT0gXCJUZW1wbGF0ZUVsZW1lbnRcIiB8fCBpc0pTWE5vZGUkMShub2RlKSB8fCBub2RlLnR5cGUgPT09IFwiQmluZEV4cHJlc3Npb25cIiAmJiAhbm9kZS5vYmplY3QgfHwgbm9kZS50eXBlID09PSBcIlJlZ0V4cExpdGVyYWxcIiB8fCBub2RlLnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmIG5vZGUucGF0dGVybiB8fCBub2RlLnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmIG5vZGUucmVnZXg7XG5cbiAgICBpZiAobWF5YmVBU0lQcm9ibGVtKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIWhhc05ha2VkTGVmdFNpZGUkMihub2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoLmNhbGwuYXBwbHkocGF0aCwgW2Z1bmN0aW9uIChjaGlsZFBhdGgpIHtcbiAgICAgIHJldHVybiBleHByTmVlZHNBU0lQcm90ZWN0aW9uKGNoaWxkUGF0aCwgb3B0aW9ucyk7XG4gICAgfV0uY29uY2F0KGdldExlZnRTaWRlUGF0aE5hbWUkMihwYXRoLCBub2RlKSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RtdE5lZWRzQVNJUHJvdGVjdGlvbihwYXRoLCBvcHRpb25zKSB7XG4gICAgdmFyIG5vZGUgPSBwYXRoLmdldE5vZGUoKTtcblxuICAgIGlmIChub2RlLnR5cGUgIT09IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGguY2FsbChmdW5jdGlvbiAoY2hpbGRQYXRoKSB7XG4gICAgICByZXR1cm4gZXhwck5lZWRzQVNJUHJvdGVjdGlvbihjaGlsZFBhdGgsIG9wdGlvbnMpO1xuICAgIH0sIFwiZXhwcmVzc2lvblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEh1Z1R5cGUobm9kZSkge1xuICAgIGlmIChpc1NpbXBsZUZsb3dUeXBlJDEobm9kZSkgfHwgaXNPYmplY3RUeXBlJDEobm9kZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlLnR5cGUgPT09IFwiVW5pb25UeXBlQW5ub3RhdGlvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJUU1VuaW9uVHlwZVwiKSB7XG4gICAgICB2YXIgdm9pZENvdW50ID0gbm9kZS50eXBlcy5maWx0ZXIoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIG4udHlwZSA9PT0gXCJWb2lkVHlwZUFubm90YXRpb25cIiB8fCBuLnR5cGUgPT09IFwiVFNWb2lkS2V5d29yZFwiIHx8IG4udHlwZSA9PT0gXCJOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIgfHwgbi50eXBlID09PSBcIlRTTnVsbEtleXdvcmRcIjtcbiAgICAgIH0pLmxlbmd0aDtcbiAgICAgIHZhciBvYmplY3RDb3VudCA9IG5vZGUudHlwZXMuZmlsdGVyKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBuLnR5cGUgPT09IFwiT2JqZWN0VHlwZUFubm90YXRpb25cIiB8fCBuLnR5cGUgPT09IFwiVFNUeXBlTGl0ZXJhbFwiIHx8IC8vIFRoaXMgaXMgYSBiaXQgYWdncmVzc2l2ZSBidXQgY2FwdHVyZXMgQXJyYXk8e3h9PlxuICAgICAgICBuLnR5cGUgPT09IFwiR2VuZXJpY1R5cGVBbm5vdGF0aW9uXCIgfHwgbi50eXBlID09PSBcIlRTVHlwZVJlZmVyZW5jZVwiO1xuICAgICAgfSkubGVuZ3RoO1xuXG4gICAgICBpZiAobm9kZS50eXBlcy5sZW5ndGggLSAxID09PSB2b2lkQ291bnQgJiYgb2JqZWN0Q291bnQgPiAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEh1Z0FyZ3VtZW50cyhmdW4pIHtcbiAgICByZXR1cm4gZnVuICYmIGZ1bi5wYXJhbXMgJiYgZnVuLnBhcmFtcy5sZW5ndGggPT09IDEgJiYgIWZ1bi5wYXJhbXNbMF0uY29tbWVudHMgJiYgKGZ1bi5wYXJhbXNbMF0udHlwZSA9PT0gXCJPYmplY3RQYXR0ZXJuXCIgfHwgZnVuLnBhcmFtc1swXS50eXBlID09PSBcIkFycmF5UGF0dGVyblwiIHx8IGZ1bi5wYXJhbXNbMF0udHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgZnVuLnBhcmFtc1swXS50eXBlQW5ub3RhdGlvbiAmJiAoZnVuLnBhcmFtc1swXS50eXBlQW5ub3RhdGlvbi50eXBlID09PSBcIlR5cGVBbm5vdGF0aW9uXCIgfHwgZnVuLnBhcmFtc1swXS50eXBlQW5ub3RhdGlvbi50eXBlID09PSBcIlRTVHlwZUFubm90YXRpb25cIikgJiYgaXNPYmplY3RUeXBlJDEoZnVuLnBhcmFtc1swXS50eXBlQW5ub3RhdGlvbi50eXBlQW5ub3RhdGlvbikgfHwgZnVuLnBhcmFtc1swXS50eXBlID09PSBcIkZ1bmN0aW9uVHlwZVBhcmFtXCIgJiYgaXNPYmplY3RUeXBlJDEoZnVuLnBhcmFtc1swXS50eXBlQW5ub3RhdGlvbikgfHwgZnVuLnBhcmFtc1swXS50eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIgJiYgKGZ1bi5wYXJhbXNbMF0ubGVmdC50eXBlID09PSBcIk9iamVjdFBhdHRlcm5cIiB8fCBmdW4ucGFyYW1zWzBdLmxlZnQudHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIikgJiYgKGZ1bi5wYXJhbXNbMF0ucmlnaHQudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgfHwgZnVuLnBhcmFtc1swXS5yaWdodC50eXBlID09PSBcIk9iamVjdEV4cHJlc3Npb25cIiAmJiBmdW4ucGFyYW1zWzBdLnJpZ2h0LnByb3BlcnRpZXMubGVuZ3RoID09PSAwIHx8IGZ1bi5wYXJhbXNbMF0ucmlnaHQudHlwZSA9PT0gXCJBcnJheUV4cHJlc3Npb25cIiAmJiBmdW4ucGFyYW1zWzBdLnJpZ2h0LmVsZW1lbnRzLmxlbmd0aCA9PT0gMCkpICYmICFmdW4ucmVzdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50QXJyYXlJdGVtcyhwYXRoLCBvcHRpb25zLCBwcmludFBhdGgsIHByaW50KSB7XG4gICAgdmFyIHByaW50ZWRFbGVtZW50cyA9IFtdO1xuICAgIHZhciBzZXBhcmF0b3JQYXJ0cyA9IFtdO1xuICAgIHBhdGguZWFjaChmdW5jdGlvbiAoY2hpbGRQYXRoKSB7XG4gICAgICBwcmludGVkRWxlbWVudHMucHVzaChjb25jYXQkZChzZXBhcmF0b3JQYXJ0cykpO1xuICAgICAgcHJpbnRlZEVsZW1lbnRzLnB1c2goZ3JvdXAkYihwcmludChjaGlsZFBhdGgpKSk7XG4gICAgICBzZXBhcmF0b3JQYXJ0cyA9IFtcIixcIiwgbGluZSQ3XTtcblxuICAgICAgaWYgKGNoaWxkUGF0aC5nZXRWYWx1ZSgpICYmIGlzTmV4dExpbmVFbXB0eSQ0KG9wdGlvbnMub3JpZ2luYWxUZXh0LCBjaGlsZFBhdGguZ2V0VmFsdWUoKSwgb3B0aW9ucykpIHtcbiAgICAgICAgc2VwYXJhdG9yUGFydHMucHVzaChzb2Z0bGluZSQ2KTtcbiAgICAgIH1cbiAgICB9LCBwcmludFBhdGgpO1xuICAgIHJldHVybiBjb25jYXQkZChwcmludGVkRWxlbWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gd2lsbFByaW50T3duQ29tbWVudHMocGF0aFxuICAvKiwgb3B0aW9ucyAqL1xuICApIHtcbiAgICB2YXIgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICB2YXIgcGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG4gICAgcmV0dXJuIChub2RlICYmIChpc0pTWE5vZGUkMShub2RlKSB8fCBoYXNGbG93U2hvcnRoYW5kQW5ub3RhdGlvbkNvbW1lbnQkMihub2RlKSB8fCBwYXJlbnQgJiYgKHBhcmVudC50eXBlID09PSBcIkNhbGxFeHByZXNzaW9uXCIgfHwgcGFyZW50LnR5cGUgPT09IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiKSAmJiAoaGFzRmxvd0Fubm90YXRpb25Db21tZW50JDEobm9kZS5sZWFkaW5nQ29tbWVudHMpIHx8IGhhc0Zsb3dBbm5vdGF0aW9uQ29tbWVudCQxKG5vZGUudHJhaWxpbmdDb21tZW50cykpKSB8fCBwYXJlbnQgJiYgKHBhcmVudC50eXBlID09PSBcIkpTWFNwcmVhZEF0dHJpYnV0ZVwiIHx8IHBhcmVudC50eXBlID09PSBcIkpTWFNwcmVhZENoaWxkXCIgfHwgcGFyZW50LnR5cGUgPT09IFwiVW5pb25UeXBlQW5ub3RhdGlvblwiIHx8IHBhcmVudC50eXBlID09PSBcIlRTVW5pb25UeXBlXCIgfHwgKHBhcmVudC50eXBlID09PSBcIkNsYXNzRGVjbGFyYXRpb25cIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJDbGFzc0V4cHJlc3Npb25cIikgJiYgcGFyZW50LnN1cGVyQ2xhc3MgPT09IG5vZGUpKSAmJiAhaGFzSWdub3JlQ29tbWVudCQ0KHBhdGgpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuQXR0YWNoQ29tbWVudCQxKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlICYmIG5vZGUudHlwZSAhPT0gXCJDb21tZW50QmxvY2tcIiAmJiBub2RlLnR5cGUgIT09IFwiQ29tbWVudExpbmVcIiAmJiBub2RlLnR5cGUgIT09IFwiTGluZVwiICYmIG5vZGUudHlwZSAhPT0gXCJCbG9ja1wiICYmIG5vZGUudHlwZSAhPT0gXCJFbXB0eVN0YXRlbWVudFwiICYmIG5vZGUudHlwZSAhPT0gXCJUZW1wbGF0ZUVsZW1lbnRcIiAmJiBub2RlLnR5cGUgIT09IFwiSW1wb3J0XCI7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludENvbW1lbnQkMihjb21tZW50UGF0aCwgb3B0aW9ucykge1xuICAgIHZhciBjb21tZW50ID0gY29tbWVudFBhdGguZ2V0VmFsdWUoKTtcblxuICAgIHN3aXRjaCAoY29tbWVudC50eXBlKSB7XG4gICAgICBjYXNlIFwiQ29tbWVudEJsb2NrXCI6XG4gICAgICBjYXNlIFwiQmxvY2tcIjpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChpc0luZGVudGFibGVCbG9ja0NvbW1lbnQoY29tbWVudCkpIHtcbiAgICAgICAgICAgIHZhciBwcmludGVkID0gcHJpbnRJbmRlbnRhYmxlQmxvY2tDb21tZW50KGNvbW1lbnQpOyAvLyBXZSBuZWVkIHRvIHByZXZlbnQgYW4gZWRnZSBjYXNlIG9mIGEgcHJldmlvdXMgdHJhaWxpbmcgY29tbWVudFxuICAgICAgICAgICAgLy8gcHJpbnRlZCBhcyBhIGBsaW5lU3VmZml4YCB3aGljaCBjYXVzZXMgdGhlIGNvbW1lbnRzIHRvIGJlXG4gICAgICAgICAgICAvLyBpbnRlcmxlYXZlZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmV0dGllci9wcmV0dGllci9pc3N1ZXMvNDQxMlxuXG4gICAgICAgICAgICBpZiAoY29tbWVudC50cmFpbGluZyAmJiAhaGFzTmV3bGluZSQ0KG9wdGlvbnMub3JpZ2luYWxUZXh0LCBvcHRpb25zLmxvY1N0YXJ0KGNvbW1lbnQpLCB7XG4gICAgICAgICAgICAgIGJhY2t3YXJkczogdHJ1ZVxuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtoYXJkbGluZSQ5LCBwcmludGVkXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwcmludGVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpc0luc2lkZUZsb3dDb21tZW50ID0gb3B0aW9ucy5vcmlnaW5hbFRleHQuc3Vic3RyKG9wdGlvbnMubG9jRW5kKGNvbW1lbnQpIC0gMywgMykgPT09IFwiKi0vXCI7XG4gICAgICAgICAgcmV0dXJuIFwiLypcIiArIGNvbW1lbnQudmFsdWUgKyAoaXNJbnNpZGVGbG93Q29tbWVudCA/IFwiKi0vXCIgOiBcIiovXCIpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJDb21tZW50TGluZVwiOlxuICAgICAgY2FzZSBcIkxpbmVcIjpcbiAgICAgICAgLy8gUHJpbnQgc2hlYmFuZ3Mgd2l0aCB0aGUgcHJvcGVyIGNvbW1lbnQgY2hhcmFjdGVyc1xuICAgICAgICBpZiAob3B0aW9ucy5vcmlnaW5hbFRleHQuc2xpY2Uob3B0aW9ucy5sb2NTdGFydChjb21tZW50KSkuc3RhcnRzV2l0aChcIiMhXCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFwiIyFcIiArIGNvbW1lbnQudmFsdWUudHJpbVJpZ2h0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gXCIvL1wiICsgY29tbWVudC52YWx1ZS50cmltUmlnaHQoKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGEgY29tbWVudDogXCIgKyBKU09OLnN0cmluZ2lmeShjb21tZW50KSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNJbmRlbnRhYmxlQmxvY2tDb21tZW50KGNvbW1lbnQpIHtcbiAgICAvLyBJZiB0aGUgY29tbWVudCBoYXMgbXVsdGlwbGUgbGluZXMgYW5kIGV2ZXJ5IGxpbmUgc3RhcnRzIHdpdGggYSBzdGFyXG4gICAgLy8gd2UgY2FuIGZpeCB0aGUgaW5kZW50YXRpb24gb2YgZWFjaCBsaW5lLiBUaGUgc3RhcnMgaW4gdGhlIGAvKmAgYW5kXG4gICAgLy8gYCovYCBkZWxpbWl0ZXJzIGFyZSBub3QgaW5jbHVkZWQgaW4gdGhlIGNvbW1lbnQgdmFsdWUsIHNvIGFkZCB0aGVtXG4gICAgLy8gYmFjayBmaXJzdC5cbiAgICB2YXIgbGluZXMgPSBcIipcIi5jb25jYXQoY29tbWVudC52YWx1ZSwgXCIqXCIpLnNwbGl0KFwiXFxuXCIpO1xuICAgIHJldHVybiBsaW5lcy5sZW5ndGggPiAxICYmIGxpbmVzLmV2ZXJ5KGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICByZXR1cm4gbGluZS50cmltKClbMF0gPT09IFwiKlwiO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRJbmRlbnRhYmxlQmxvY2tDb21tZW50KGNvbW1lbnQpIHtcbiAgICB2YXIgbGluZXMgPSBjb21tZW50LnZhbHVlLnNwbGl0KFwiXFxuXCIpO1xuICAgIHJldHVybiBjb25jYXQkZChbXCIvKlwiLCBqb2luJDkoaGFyZGxpbmUkOSwgbGluZXMubWFwKGZ1bmN0aW9uIChsaW5lLCBpbmRleCkge1xuICAgICAgcmV0dXJuIGluZGV4ID09PSAwID8gbGluZS50cmltUmlnaHQoKSA6IFwiIFwiICsgKGluZGV4IDwgbGluZXMubGVuZ3RoIC0gMSA/IGxpbmUudHJpbSgpIDogbGluZS50cmltTGVmdCgpKTtcbiAgICB9KSksIFwiKi9cIl0pO1xuICB9XG5cbiAgdmFyIHByaW50ZXJFc3RyZWUgPSB7XG4gICAgcHJlcHJvY2VzczogcHJlcHJvY2Vzc18xJDEsXG4gICAgcHJpbnQ6IGdlbmVyaWNQcmludCQzLFxuICAgIGVtYmVkOiBlbWJlZF8xJDEsXG4gICAgaW5zZXJ0UHJhZ21hOiBpbnNlcnRQcmFnbWEkNyxcbiAgICBtYXNzYWdlQXN0Tm9kZTogY2xlYW5fMSQxLFxuICAgIGhhc1ByZXR0aWVySWdub3JlOiBoYXNQcmV0dGllcklnbm9yZSQzLFxuICAgIHdpbGxQcmludE93bkNvbW1lbnRzOiB3aWxsUHJpbnRPd25Db21tZW50cyxcbiAgICBjYW5BdHRhY2hDb21tZW50OiBjYW5BdHRhY2hDb21tZW50JDEsXG4gICAgcHJpbnRDb21tZW50OiBwcmludENvbW1lbnQkMixcbiAgICBpc0Jsb2NrQ29tbWVudDogY29tbWVudHMkMS5pc0Jsb2NrQ29tbWVudCxcbiAgICBoYW5kbGVDb21tZW50czoge1xuICAgICAgb3duTGluZTogY29tbWVudHMkMS5oYW5kbGVPd25MaW5lQ29tbWVudCxcbiAgICAgIGVuZE9mTGluZTogY29tbWVudHMkMS5oYW5kbGVFbmRPZkxpbmVDb21tZW50LFxuICAgICAgcmVtYWluaW5nOiBjb21tZW50cyQxLmhhbmRsZVJlbWFpbmluZ0NvbW1lbnRcbiAgICB9XG4gIH07XG5cbiAgdmFyIF9yZXF1aXJlJCQwJGJ1aWxkZXJzJDcgPSBkb2MuYnVpbGRlcnMsXG4gICAgICBjb25jYXQkZSA9IF9yZXF1aXJlJCQwJGJ1aWxkZXJzJDcuY29uY2F0LFxuICAgICAgaGFyZGxpbmUkYSA9IF9yZXF1aXJlJCQwJGJ1aWxkZXJzJDcuaGFyZGxpbmUsXG4gICAgICBpbmRlbnQkOCA9IF9yZXF1aXJlJCQwJGJ1aWxkZXJzJDcuaW5kZW50LFxuICAgICAgam9pbiRhID0gX3JlcXVpcmUkJDAkYnVpbGRlcnMkNy5qb2luO1xuXG4gIGZ1bmN0aW9uIGdlbmVyaWNQcmludCQ0KHBhdGgsIG9wdGlvbnMsIHByaW50KSB7XG4gICAgdmFyIG5vZGUgPSBwYXRoLmdldFZhbHVlKCk7XG5cbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcIkpzb25Sb290XCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZShbcGF0aC5jYWxsKHByaW50LCBcIm5vZGVcIiksIGhhcmRsaW5lJGFdKTtcblxuICAgICAgY2FzZSBcIkFycmF5RXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gbm9kZS5lbGVtZW50cy5sZW5ndGggPT09IDAgPyBcIltdXCIgOiBjb25jYXQkZShbXCJbXCIsIGluZGVudCQ4KGNvbmNhdCRlKFtoYXJkbGluZSRhLCBqb2luJGEoY29uY2F0JGUoW1wiLFwiLCBoYXJkbGluZSRhXSksIHBhdGgubWFwKHByaW50LCBcImVsZW1lbnRzXCIpKV0pKSwgaGFyZGxpbmUkYSwgXCJdXCJdKTtcblxuICAgICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIG5vZGUucHJvcGVydGllcy5sZW5ndGggPT09IDAgPyBcInt9XCIgOiBjb25jYXQkZShbXCJ7XCIsIGluZGVudCQ4KGNvbmNhdCRlKFtoYXJkbGluZSRhLCBqb2luJGEoY29uY2F0JGUoW1wiLFwiLCBoYXJkbGluZSRhXSksIHBhdGgubWFwKHByaW50LCBcInByb3BlcnRpZXNcIikpXSkpLCBoYXJkbGluZSRhLCBcIn1cIl0pO1xuXG4gICAgICBjYXNlIFwiT2JqZWN0UHJvcGVydHlcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRlKFtwYXRoLmNhbGwocHJpbnQsIFwia2V5XCIpLCBcIjogXCIsIHBhdGguY2FsbChwcmludCwgXCJ2YWx1ZVwiKV0pO1xuXG4gICAgICBjYXNlIFwiVW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZShbbm9kZS5vcGVyYXRvciA9PT0gXCIrXCIgPyBcIlwiIDogbm9kZS5vcGVyYXRvciwgcGF0aC5jYWxsKHByaW50LCBcImFyZ3VtZW50XCIpXSk7XG5cbiAgICAgIGNhc2UgXCJOdWxsTGl0ZXJhbFwiOlxuICAgICAgICByZXR1cm4gXCJudWxsXCI7XG5cbiAgICAgIGNhc2UgXCJCb29sZWFuTGl0ZXJhbFwiOlxuICAgICAgICByZXR1cm4gbm9kZS52YWx1ZSA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiO1xuXG4gICAgICBjYXNlIFwiU3RyaW5nTGl0ZXJhbFwiOlxuICAgICAgY2FzZSBcIk51bWVyaWNMaXRlcmFsXCI6XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShub2RlLnZhbHVlKTtcblxuICAgICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG5vZGUubmFtZSk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyBKU09OLnN0cmluZ2lmeShub2RlLnR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbiQ1KG5vZGUsIG5ld05vZGVcbiAgLyosIHBhcmVudCovXG4gICkge1xuICAgIGRlbGV0ZSBuZXdOb2RlLnN0YXJ0O1xuICAgIGRlbGV0ZSBuZXdOb2RlLmVuZDtcbiAgICBkZWxldGUgbmV3Tm9kZS5leHRyYTtcbiAgICBkZWxldGUgbmV3Tm9kZS5sb2M7XG4gICAgZGVsZXRlIG5ld05vZGUuY29tbWVudHM7XG4gICAgZGVsZXRlIG5ld05vZGUuZXJyb3JzO1xuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiU3RyaW5nTGl0ZXJhbFwiLFxuICAgICAgICB2YWx1ZTogbm9kZS5uYW1lXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChub2RlLnR5cGUgPT09IFwiVW5hcnlFeHByZXNzaW9uXCIgJiYgbm9kZS5vcGVyYXRvciA9PT0gXCIrXCIpIHtcbiAgICAgIHJldHVybiBuZXdOb2RlLmFyZ3VtZW50O1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcmludGVyRXN0cmVlSnNvbiA9IHtcbiAgICBwcmVwcm9jZXNzOiBwcmVwcm9jZXNzXzEkMSxcbiAgICBwcmludDogZ2VuZXJpY1ByaW50JDQsXG4gICAgbWFzc2FnZUFzdE5vZGU6IGNsZWFuJDVcbiAgfTtcblxuICB2YXIgQ0FURUdPUllfSkFWQVNDUklQVCA9IFwiSmF2YVNjcmlwdFwiOyAvLyBmb3JtYXQgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL3ByZXR0aWVyL3ByZXR0aWVyL2Jsb2IvbWFzdGVyL3NyYy9tYWluL2NvcmUtb3B0aW9ucy5qc1xuXG4gIHZhciBvcHRpb25zJDUgPSB7XG4gICAgYXJyb3dQYXJlbnM6IHtcbiAgICAgIHNpbmNlOiBcIjEuOS4wXCIsXG4gICAgICBjYXRlZ29yeTogQ0FURUdPUllfSkFWQVNDUklQVCxcbiAgICAgIHR5cGU6IFwiY2hvaWNlXCIsXG4gICAgICBkZWZhdWx0OiBcImF2b2lkXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJJbmNsdWRlIHBhcmVudGhlc2VzIGFyb3VuZCBhIHNvbGUgYXJyb3cgZnVuY3Rpb24gcGFyYW1ldGVyLlwiLFxuICAgICAgY2hvaWNlczogW3tcbiAgICAgICAgdmFsdWU6IFwiYXZvaWRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiT21pdCBwYXJlbnMgd2hlbiBwb3NzaWJsZS4gRXhhbXBsZTogYHggPT4geGBcIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJhbHdheXNcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiQWx3YXlzIGluY2x1ZGUgcGFyZW5zLiBFeGFtcGxlOiBgKHgpID0+IHhgXCJcbiAgICAgIH1dXG4gICAgfSxcbiAgICBicmFja2V0U3BhY2luZzogY29tbW9uT3B0aW9ucy5icmFja2V0U3BhY2luZyxcbiAgICBqc3hCcmFja2V0U2FtZUxpbmU6IHtcbiAgICAgIHNpbmNlOiBcIjAuMTcuMFwiLFxuICAgICAgY2F0ZWdvcnk6IENBVEVHT1JZX0pBVkFTQ1JJUFQsXG4gICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgZGVzY3JpcHRpb246IFwiUHV0ID4gb24gdGhlIGxhc3QgbGluZSBpbnN0ZWFkIG9mIGF0IGEgbmV3IGxpbmUuXCJcbiAgICB9LFxuICAgIHNlbWk6IHtcbiAgICAgIHNpbmNlOiBcIjEuMC4wXCIsXG4gICAgICBjYXRlZ29yeTogQ0FURUdPUllfSkFWQVNDUklQVCxcbiAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlByaW50IHNlbWljb2xvbnMuXCIsXG4gICAgICBvcHBvc2l0ZURlc2NyaXB0aW9uOiBcIkRvIG5vdCBwcmludCBzZW1pY29sb25zLCBleGNlcHQgYXQgdGhlIGJlZ2lubmluZyBvZiBsaW5lcyB3aGljaCBtYXkgbmVlZCB0aGVtLlwiXG4gICAgfSxcbiAgICBzaW5nbGVRdW90ZTogY29tbW9uT3B0aW9ucy5zaW5nbGVRdW90ZSxcbiAgICBqc3hTaW5nbGVRdW90ZToge1xuICAgICAgc2luY2U6IFwiMS4xNS4wXCIsXG4gICAgICBjYXRlZ29yeTogQ0FURUdPUllfSkFWQVNDUklQVCxcbiAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICBkZXNjcmlwdGlvbjogXCJVc2Ugc2luZ2xlIHF1b3RlcyBpbiBKU1guXCJcbiAgICB9LFxuICAgIHF1b3RlUHJvcHM6IHtcbiAgICAgIHNpbmNlOiBcIjEuMTcuMFwiLFxuICAgICAgY2F0ZWdvcnk6IENBVEVHT1JZX0pBVkFTQ1JJUFQsXG4gICAgICB0eXBlOiBcImNob2ljZVwiLFxuICAgICAgZGVmYXVsdDogXCJhcy1uZWVkZWRcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkNoYW5nZSB3aGVuIHByb3BlcnRpZXMgaW4gb2JqZWN0cyBhcmUgcXVvdGVkLlwiLFxuICAgICAgY2hvaWNlczogW3tcbiAgICAgICAgdmFsdWU6IFwiYXMtbmVlZGVkXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIk9ubHkgYWRkIHF1b3RlcyBhcm91bmQgb2JqZWN0IHByb3BlcnRpZXMgd2hlcmUgcmVxdWlyZWQuXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwiY29uc2lzdGVudFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJJZiBhdCBsZWFzdCBvbmUgcHJvcGVydHkgaW4gYW4gb2JqZWN0IHJlcXVpcmVzIHF1b3RlcywgcXVvdGUgYWxsIHByb3BlcnRpZXMuXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwicHJlc2VydmVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiUmVzcGVjdCB0aGUgaW5wdXQgdXNlIG9mIHF1b3RlcyBpbiBvYmplY3QgcHJvcGVydGllcy5cIlxuICAgICAgfV1cbiAgICB9LFxuICAgIHRyYWlsaW5nQ29tbWE6IHtcbiAgICAgIHNpbmNlOiBcIjAuMC4wXCIsXG4gICAgICBjYXRlZ29yeTogQ0FURUdPUllfSkFWQVNDUklQVCxcbiAgICAgIHR5cGU6IFwiY2hvaWNlXCIsXG4gICAgICBkZWZhdWx0OiBbe1xuICAgICAgICBzaW5jZTogXCIwLjAuMFwiLFxuICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgc2luY2U6IFwiMC4xOS4wXCIsXG4gICAgICAgIHZhbHVlOiBcIm5vbmVcIlxuICAgICAgfV0sXG4gICAgICBkZXNjcmlwdGlvbjogXCJQcmludCB0cmFpbGluZyBjb21tYXMgd2hlcmV2ZXIgcG9zc2libGUgd2hlbiBtdWx0aS1saW5lLlwiLFxuICAgICAgY2hvaWNlczogW3tcbiAgICAgICAgdmFsdWU6IFwibm9uZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJObyB0cmFpbGluZyBjb21tYXMuXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwiZXM1XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlRyYWlsaW5nIGNvbW1hcyB3aGVyZSB2YWxpZCBpbiBFUzUgKG9iamVjdHMsIGFycmF5cywgZXRjLilcIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJhbGxcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiVHJhaWxpbmcgY29tbWFzIHdoZXJldmVyIHBvc3NpYmxlIChpbmNsdWRpbmcgZnVuY3Rpb24gYXJndW1lbnRzKS5cIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogdHJ1ZSxcbiAgICAgICAgZGVwcmVjYXRlZDogXCIwLjE5LjBcIixcbiAgICAgICAgcmVkaXJlY3Q6IFwiZXM1XCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICBkZXByZWNhdGVkOiBcIjAuMTkuMFwiLFxuICAgICAgICByZWRpcmVjdDogXCJub25lXCJcbiAgICAgIH1dXG4gICAgfVxuICB9O1xuXG4gIHZhciBuYW1lJDkgPSBcIkphdmFTY3JpcHRcIjtcbiAgdmFyIHR5cGUkOCA9IFwicHJvZ3JhbW1pbmdcIjtcbiAgdmFyIHRtU2NvcGUkOCA9IFwic291cmNlLmpzXCI7XG4gIHZhciBhY2VNb2RlJDggPSBcImphdmFzY3JpcHRcIjtcbiAgdmFyIGNvZGVtaXJyb3JNb2RlJDQgPSBcImphdmFzY3JpcHRcIjtcbiAgdmFyIGNvZGVtaXJyb3JNaW1lVHlwZSQ0ID0gXCJ0ZXh0L2phdmFzY3JpcHRcIjtcbiAgdmFyIGNvbG9yJDMgPSBcIiNmMWUwNWFcIjtcbiAgdmFyIGFsaWFzZXMkMiA9IFtcbiAgXHRcImpzXCIsXG4gIFx0XCJub2RlXCJcbiAgXTtcbiAgdmFyIGV4dGVuc2lvbnMkOCA9IFtcbiAgXHRcIi5qc1wiLFxuICBcdFwiLl9qc1wiLFxuICBcdFwiLmJvbmVzXCIsXG4gIFx0XCIuZXNcIixcbiAgXHRcIi5lczZcIixcbiAgXHRcIi5mcmFnXCIsXG4gIFx0XCIuZ3NcIixcbiAgXHRcIi5qYWtlXCIsXG4gIFx0XCIuanNiXCIsXG4gIFx0XCIuanNjYWRcIixcbiAgXHRcIi5qc2ZsXCIsXG4gIFx0XCIuanNtXCIsXG4gIFx0XCIuanNzXCIsXG4gIFx0XCIubWpzXCIsXG4gIFx0XCIubmpzXCIsXG4gIFx0XCIucGFjXCIsXG4gIFx0XCIuc2pzXCIsXG4gIFx0XCIuc3Nqc1wiLFxuICBcdFwiLnhzanNcIixcbiAgXHRcIi54c2pzbGliXCJcbiAgXTtcbiAgdmFyIGZpbGVuYW1lcyA9IFtcbiAgXHRcIkpha2VmaWxlXCJcbiAgXTtcbiAgdmFyIGludGVycHJldGVycyA9IFtcbiAgXHRcImNoYWtyYVwiLFxuICBcdFwiZDhcIixcbiAgXHRcImpzXCIsXG4gIFx0XCJub2RlXCIsXG4gIFx0XCJyaGlub1wiLFxuICBcdFwidjhcIixcbiAgXHRcInY4LXNoZWxsXCJcbiAgXTtcbiAgdmFyIGxhbmd1YWdlSWQkOCA9IDE4MztcbiAgdmFyIEphdmFTY3JpcHQgPSB7XG4gIFx0bmFtZTogbmFtZSQ5LFxuICBcdHR5cGU6IHR5cGUkOCxcbiAgXHR0bVNjb3BlOiB0bVNjb3BlJDgsXG4gIFx0YWNlTW9kZTogYWNlTW9kZSQ4LFxuICBcdGNvZGVtaXJyb3JNb2RlOiBjb2RlbWlycm9yTW9kZSQ0LFxuICBcdGNvZGVtaXJyb3JNaW1lVHlwZTogY29kZW1pcnJvck1pbWVUeXBlJDQsXG4gIFx0Y29sb3I6IGNvbG9yJDMsXG4gIFx0YWxpYXNlczogYWxpYXNlcyQyLFxuICBcdGV4dGVuc2lvbnM6IGV4dGVuc2lvbnMkOCxcbiAgXHRmaWxlbmFtZXM6IGZpbGVuYW1lcyxcbiAgXHRpbnRlcnByZXRlcnM6IGludGVycHJldGVycyxcbiAgXHRsYW5ndWFnZUlkOiBsYW5ndWFnZUlkJDhcbiAgfTtcblxuICB2YXIgSmF2YVNjcmlwdCQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBuYW1lOiBuYW1lJDksXG4gICAgdHlwZTogdHlwZSQ4LFxuICAgIHRtU2NvcGU6IHRtU2NvcGUkOCxcbiAgICBhY2VNb2RlOiBhY2VNb2RlJDgsXG4gICAgY29kZW1pcnJvck1vZGU6IGNvZGVtaXJyb3JNb2RlJDQsXG4gICAgY29kZW1pcnJvck1pbWVUeXBlOiBjb2RlbWlycm9yTWltZVR5cGUkNCxcbiAgICBjb2xvcjogY29sb3IkMyxcbiAgICBhbGlhc2VzOiBhbGlhc2VzJDIsXG4gICAgZXh0ZW5zaW9uczogZXh0ZW5zaW9ucyQ4LFxuICAgIGZpbGVuYW1lczogZmlsZW5hbWVzLFxuICAgIGludGVycHJldGVyczogaW50ZXJwcmV0ZXJzLFxuICAgIGxhbmd1YWdlSWQ6IGxhbmd1YWdlSWQkOCxcbiAgICAnZGVmYXVsdCc6IEphdmFTY3JpcHRcbiAgfSk7XG5cbiAgdmFyIG5hbWUkYSA9IFwiSlNYXCI7XG4gIHZhciB0eXBlJDkgPSBcInByb2dyYW1taW5nXCI7XG4gIHZhciBncm91cCRjID0gXCJKYXZhU2NyaXB0XCI7XG4gIHZhciBleHRlbnNpb25zJDkgPSBbXG4gIFx0XCIuanN4XCJcbiAgXTtcbiAgdmFyIHRtU2NvcGUkOSA9IFwic291cmNlLmpzLmpzeFwiO1xuICB2YXIgYWNlTW9kZSQ5ID0gXCJqYXZhc2NyaXB0XCI7XG4gIHZhciBjb2RlbWlycm9yTW9kZSQ1ID0gXCJqc3hcIjtcbiAgdmFyIGNvZGVtaXJyb3JNaW1lVHlwZSQ1ID0gXCJ0ZXh0L2pzeFwiO1xuICB2YXIgbGFuZ3VhZ2VJZCQ5ID0gMTc4O1xuICB2YXIgSlNYID0ge1xuICBcdG5hbWU6IG5hbWUkYSxcbiAgXHR0eXBlOiB0eXBlJDksXG4gIFx0Z3JvdXA6IGdyb3VwJGMsXG4gIFx0ZXh0ZW5zaW9uczogZXh0ZW5zaW9ucyQ5LFxuICBcdHRtU2NvcGU6IHRtU2NvcGUkOSxcbiAgXHRhY2VNb2RlOiBhY2VNb2RlJDksXG4gIFx0Y29kZW1pcnJvck1vZGU6IGNvZGVtaXJyb3JNb2RlJDUsXG4gIFx0Y29kZW1pcnJvck1pbWVUeXBlOiBjb2RlbWlycm9yTWltZVR5cGUkNSxcbiAgXHRsYW5ndWFnZUlkOiBsYW5ndWFnZUlkJDlcbiAgfTtcblxuICB2YXIgSlNYJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIG5hbWU6IG5hbWUkYSxcbiAgICB0eXBlOiB0eXBlJDksXG4gICAgZ3JvdXA6IGdyb3VwJGMsXG4gICAgZXh0ZW5zaW9uczogZXh0ZW5zaW9ucyQ5LFxuICAgIHRtU2NvcGU6IHRtU2NvcGUkOSxcbiAgICBhY2VNb2RlOiBhY2VNb2RlJDksXG4gICAgY29kZW1pcnJvck1vZGU6IGNvZGVtaXJyb3JNb2RlJDUsXG4gICAgY29kZW1pcnJvck1pbWVUeXBlOiBjb2RlbWlycm9yTWltZVR5cGUkNSxcbiAgICBsYW5ndWFnZUlkOiBsYW5ndWFnZUlkJDksXG4gICAgJ2RlZmF1bHQnOiBKU1hcbiAgfSk7XG5cbiAgdmFyIG5hbWUkYiA9IFwiVHlwZVNjcmlwdFwiO1xuICB2YXIgdHlwZSRhID0gXCJwcm9ncmFtbWluZ1wiO1xuICB2YXIgY29sb3IkNCA9IFwiIzJiNzQ4OVwiO1xuICB2YXIgYWxpYXNlcyQzID0gW1xuICBcdFwidHNcIlxuICBdO1xuICB2YXIgaW50ZXJwcmV0ZXJzJDEgPSBbXG4gIFx0XCJkZW5vXCIsXG4gIFx0XCJ0cy1ub2RlXCJcbiAgXTtcbiAgdmFyIGV4dGVuc2lvbnMkYSA9IFtcbiAgXHRcIi50c1wiXG4gIF07XG4gIHZhciB0bVNjb3BlJGEgPSBcInNvdXJjZS50c1wiO1xuICB2YXIgYWNlTW9kZSRhID0gXCJ0eXBlc2NyaXB0XCI7XG4gIHZhciBjb2RlbWlycm9yTW9kZSQ2ID0gXCJqYXZhc2NyaXB0XCI7XG4gIHZhciBjb2RlbWlycm9yTWltZVR5cGUkNiA9IFwiYXBwbGljYXRpb24vdHlwZXNjcmlwdFwiO1xuICB2YXIgbGFuZ3VhZ2VJZCRhID0gMzc4O1xuICB2YXIgVHlwZVNjcmlwdCA9IHtcbiAgXHRuYW1lOiBuYW1lJGIsXG4gIFx0dHlwZTogdHlwZSRhLFxuICBcdGNvbG9yOiBjb2xvciQ0LFxuICBcdGFsaWFzZXM6IGFsaWFzZXMkMyxcbiAgXHRpbnRlcnByZXRlcnM6IGludGVycHJldGVycyQxLFxuICBcdGV4dGVuc2lvbnM6IGV4dGVuc2lvbnMkYSxcbiAgXHR0bVNjb3BlOiB0bVNjb3BlJGEsXG4gIFx0YWNlTW9kZTogYWNlTW9kZSRhLFxuICBcdGNvZGVtaXJyb3JNb2RlOiBjb2RlbWlycm9yTW9kZSQ2LFxuICBcdGNvZGVtaXJyb3JNaW1lVHlwZTogY29kZW1pcnJvck1pbWVUeXBlJDYsXG4gIFx0bGFuZ3VhZ2VJZDogbGFuZ3VhZ2VJZCRhXG4gIH07XG5cbiAgdmFyIFR5cGVTY3JpcHQkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgbmFtZTogbmFtZSRiLFxuICAgIHR5cGU6IHR5cGUkYSxcbiAgICBjb2xvcjogY29sb3IkNCxcbiAgICBhbGlhc2VzOiBhbGlhc2VzJDMsXG4gICAgaW50ZXJwcmV0ZXJzOiBpbnRlcnByZXRlcnMkMSxcbiAgICBleHRlbnNpb25zOiBleHRlbnNpb25zJGEsXG4gICAgdG1TY29wZTogdG1TY29wZSRhLFxuICAgIGFjZU1vZGU6IGFjZU1vZGUkYSxcbiAgICBjb2RlbWlycm9yTW9kZTogY29kZW1pcnJvck1vZGUkNixcbiAgICBjb2RlbWlycm9yTWltZVR5cGU6IGNvZGVtaXJyb3JNaW1lVHlwZSQ2LFxuICAgIGxhbmd1YWdlSWQ6IGxhbmd1YWdlSWQkYSxcbiAgICAnZGVmYXVsdCc6IFR5cGVTY3JpcHRcbiAgfSk7XG5cbiAgdmFyIG5hbWUkYyA9IFwiVFNYXCI7XG4gIHZhciB0eXBlJGIgPSBcInByb2dyYW1taW5nXCI7XG4gIHZhciBncm91cCRkID0gXCJUeXBlU2NyaXB0XCI7XG4gIHZhciBleHRlbnNpb25zJGIgPSBbXG4gIFx0XCIudHN4XCJcbiAgXTtcbiAgdmFyIHRtU2NvcGUkYiA9IFwic291cmNlLnRzeFwiO1xuICB2YXIgYWNlTW9kZSRiID0gXCJqYXZhc2NyaXB0XCI7XG4gIHZhciBjb2RlbWlycm9yTW9kZSQ3ID0gXCJqc3hcIjtcbiAgdmFyIGNvZGVtaXJyb3JNaW1lVHlwZSQ3ID0gXCJ0ZXh0L2pzeFwiO1xuICB2YXIgbGFuZ3VhZ2VJZCRiID0gOTQ5MDE5MjQ7XG4gIHZhciBUU1ggPSB7XG4gIFx0bmFtZTogbmFtZSRjLFxuICBcdHR5cGU6IHR5cGUkYixcbiAgXHRncm91cDogZ3JvdXAkZCxcbiAgXHRleHRlbnNpb25zOiBleHRlbnNpb25zJGIsXG4gIFx0dG1TY29wZTogdG1TY29wZSRiLFxuICBcdGFjZU1vZGU6IGFjZU1vZGUkYixcbiAgXHRjb2RlbWlycm9yTW9kZTogY29kZW1pcnJvck1vZGUkNyxcbiAgXHRjb2RlbWlycm9yTWltZVR5cGU6IGNvZGVtaXJyb3JNaW1lVHlwZSQ3LFxuICBcdGxhbmd1YWdlSWQ6IGxhbmd1YWdlSWQkYlxuICB9O1xuXG4gIHZhciBUU1gkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgbmFtZTogbmFtZSRjLFxuICAgIHR5cGU6IHR5cGUkYixcbiAgICBncm91cDogZ3JvdXAkZCxcbiAgICBleHRlbnNpb25zOiBleHRlbnNpb25zJGIsXG4gICAgdG1TY29wZTogdG1TY29wZSRiLFxuICAgIGFjZU1vZGU6IGFjZU1vZGUkYixcbiAgICBjb2RlbWlycm9yTW9kZTogY29kZW1pcnJvck1vZGUkNyxcbiAgICBjb2RlbWlycm9yTWltZVR5cGU6IGNvZGVtaXJyb3JNaW1lVHlwZSQ3LFxuICAgIGxhbmd1YWdlSWQ6IGxhbmd1YWdlSWQkYixcbiAgICAnZGVmYXVsdCc6IFRTWFxuICB9KTtcblxuICB2YXIgbmFtZSRkID0gXCJKU09OXCI7XG4gIHZhciB0eXBlJGMgPSBcImRhdGFcIjtcbiAgdmFyIHRtU2NvcGUkYyA9IFwic291cmNlLmpzb25cIjtcbiAgdmFyIGFjZU1vZGUkYyA9IFwianNvblwiO1xuICB2YXIgY29kZW1pcnJvck1vZGUkOCA9IFwiamF2YXNjcmlwdFwiO1xuICB2YXIgY29kZW1pcnJvck1pbWVUeXBlJDggPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcbiAgdmFyIHNlYXJjaGFibGUgPSBmYWxzZTtcbiAgdmFyIGV4dGVuc2lvbnMkYyA9IFtcbiAgXHRcIi5qc29uXCIsXG4gIFx0XCIuYXZzY1wiLFxuICBcdFwiLmdlb2pzb25cIixcbiAgXHRcIi5nbHRmXCIsXG4gIFx0XCIuaGFyXCIsXG4gIFx0XCIuaWNlXCIsXG4gIFx0XCIuSlNPTi10bUxhbmd1YWdlXCIsXG4gIFx0XCIuanNvbmxcIixcbiAgXHRcIi5tY21ldGFcIixcbiAgXHRcIi50ZnN0YXRlXCIsXG4gIFx0XCIudGZzdGF0ZS5iYWNrdXBcIixcbiAgXHRcIi50b3BvanNvblwiLFxuICBcdFwiLndlYmFwcFwiLFxuICBcdFwiLndlYm1hbmlmZXN0XCIsXG4gIFx0XCIueXlcIixcbiAgXHRcIi55eXBcIlxuICBdO1xuICB2YXIgZmlsZW5hbWVzJDEgPSBbXG4gIFx0XCIuYXJjY29uZmlnXCIsXG4gIFx0XCIuaHRtbGhpbnRyY1wiLFxuICBcdFwiLnRlcm4tY29uZmlnXCIsXG4gIFx0XCIudGVybi1wcm9qZWN0XCIsXG4gIFx0XCIud2F0Y2htYW5jb25maWdcIixcbiAgXHRcImNvbXBvc2VyLmxvY2tcIixcbiAgXHRcIm1jbW9kLmluZm9cIlxuICBdO1xuICB2YXIgbGFuZ3VhZ2VJZCRjID0gMTc0O1xuICB2YXIgX0pTT04gPSB7XG4gIFx0bmFtZTogbmFtZSRkLFxuICBcdHR5cGU6IHR5cGUkYyxcbiAgXHR0bVNjb3BlOiB0bVNjb3BlJGMsXG4gIFx0YWNlTW9kZTogYWNlTW9kZSRjLFxuICBcdGNvZGVtaXJyb3JNb2RlOiBjb2RlbWlycm9yTW9kZSQ4LFxuICBcdGNvZGVtaXJyb3JNaW1lVHlwZTogY29kZW1pcnJvck1pbWVUeXBlJDgsXG4gIFx0c2VhcmNoYWJsZTogc2VhcmNoYWJsZSxcbiAgXHRleHRlbnNpb25zOiBleHRlbnNpb25zJGMsXG4gIFx0ZmlsZW5hbWVzOiBmaWxlbmFtZXMkMSxcbiAgXHRsYW5ndWFnZUlkOiBsYW5ndWFnZUlkJGNcbiAgfTtcblxuICB2YXIgX0pTT04kMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgbmFtZTogbmFtZSRkLFxuICAgIHR5cGU6IHR5cGUkYyxcbiAgICB0bVNjb3BlOiB0bVNjb3BlJGMsXG4gICAgYWNlTW9kZTogYWNlTW9kZSRjLFxuICAgIGNvZGVtaXJyb3JNb2RlOiBjb2RlbWlycm9yTW9kZSQ4LFxuICAgIGNvZGVtaXJyb3JNaW1lVHlwZTogY29kZW1pcnJvck1pbWVUeXBlJDgsXG4gICAgc2VhcmNoYWJsZTogc2VhcmNoYWJsZSxcbiAgICBleHRlbnNpb25zOiBleHRlbnNpb25zJGMsXG4gICAgZmlsZW5hbWVzOiBmaWxlbmFtZXMkMSxcbiAgICBsYW5ndWFnZUlkOiBsYW5ndWFnZUlkJGMsXG4gICAgJ2RlZmF1bHQnOiBfSlNPTlxuICB9KTtcblxuICB2YXIgbmFtZSRlID0gXCJKU09OIHdpdGggQ29tbWVudHNcIjtcbiAgdmFyIHR5cGUkZCA9IFwiZGF0YVwiO1xuICB2YXIgZ3JvdXAkZSA9IFwiSlNPTlwiO1xuICB2YXIgdG1TY29wZSRkID0gXCJzb3VyY2UuanNcIjtcbiAgdmFyIGFjZU1vZGUkZCA9IFwiamF2YXNjcmlwdFwiO1xuICB2YXIgY29kZW1pcnJvck1vZGUkOSA9IFwiamF2YXNjcmlwdFwiO1xuICB2YXIgY29kZW1pcnJvck1pbWVUeXBlJDkgPSBcInRleHQvamF2YXNjcmlwdFwiO1xuICB2YXIgYWxpYXNlcyQ0ID0gW1xuICBcdFwianNvbmNcIlxuICBdO1xuICB2YXIgZXh0ZW5zaW9ucyRkID0gW1xuICBcdFwiLnN1YmxpbWUtYnVpbGRcIixcbiAgXHRcIi5zdWJsaW1lLWNvbW1hbmRzXCIsXG4gIFx0XCIuc3VibGltZS1jb21wbGV0aW9uc1wiLFxuICBcdFwiLnN1YmxpbWUta2V5bWFwXCIsXG4gIFx0XCIuc3VibGltZS1tYWNyb1wiLFxuICBcdFwiLnN1YmxpbWUtbWVudVwiLFxuICBcdFwiLnN1YmxpbWUtbW91c2VtYXBcIixcbiAgXHRcIi5zdWJsaW1lLXByb2plY3RcIixcbiAgXHRcIi5zdWJsaW1lLXNldHRpbmdzXCIsXG4gIFx0XCIuc3VibGltZS10aGVtZVwiLFxuICBcdFwiLnN1YmxpbWUtd29ya3NwYWNlXCIsXG4gIFx0XCIuc3VibGltZV9tZXRyaWNzXCIsXG4gIFx0XCIuc3VibGltZV9zZXNzaW9uXCJcbiAgXTtcbiAgdmFyIGZpbGVuYW1lcyQyID0gW1xuICBcdFwiLmJhYmVscmNcIixcbiAgXHRcIi5lc2xpbnRyYy5qc29uXCIsXG4gIFx0XCIuanNjc3JjXCIsXG4gIFx0XCIuanNoaW50cmNcIixcbiAgXHRcIi5qc2xpbnRyY1wiLFxuICBcdFwianNjb25maWcuanNvblwiLFxuICBcdFwibGFuZ3VhZ2UtY29uZmlndXJhdGlvbi5qc29uXCIsXG4gIFx0XCJ0c2NvbmZpZy5qc29uXCJcbiAgXTtcbiAgdmFyIGxhbmd1YWdlSWQkZCA9IDQyMztcbiAgdmFyIEpTT05fd2l0aF9Db21tZW50cyA9IHtcbiAgXHRuYW1lOiBuYW1lJGUsXG4gIFx0dHlwZTogdHlwZSRkLFxuICBcdGdyb3VwOiBncm91cCRlLFxuICBcdHRtU2NvcGU6IHRtU2NvcGUkZCxcbiAgXHRhY2VNb2RlOiBhY2VNb2RlJGQsXG4gIFx0Y29kZW1pcnJvck1vZGU6IGNvZGVtaXJyb3JNb2RlJDksXG4gIFx0Y29kZW1pcnJvck1pbWVUeXBlOiBjb2RlbWlycm9yTWltZVR5cGUkOSxcbiAgXHRhbGlhc2VzOiBhbGlhc2VzJDQsXG4gIFx0ZXh0ZW5zaW9uczogZXh0ZW5zaW9ucyRkLFxuICBcdGZpbGVuYW1lczogZmlsZW5hbWVzJDIsXG4gIFx0bGFuZ3VhZ2VJZDogbGFuZ3VhZ2VJZCRkXG4gIH07XG5cbiAgdmFyIEpTT05fd2l0aF9Db21tZW50cyQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBuYW1lOiBuYW1lJGUsXG4gICAgdHlwZTogdHlwZSRkLFxuICAgIGdyb3VwOiBncm91cCRlLFxuICAgIHRtU2NvcGU6IHRtU2NvcGUkZCxcbiAgICBhY2VNb2RlOiBhY2VNb2RlJGQsXG4gICAgY29kZW1pcnJvck1vZGU6IGNvZGVtaXJyb3JNb2RlJDksXG4gICAgY29kZW1pcnJvck1pbWVUeXBlOiBjb2RlbWlycm9yTWltZVR5cGUkOSxcbiAgICBhbGlhc2VzOiBhbGlhc2VzJDQsXG4gICAgZXh0ZW5zaW9uczogZXh0ZW5zaW9ucyRkLFxuICAgIGZpbGVuYW1lczogZmlsZW5hbWVzJDIsXG4gICAgbGFuZ3VhZ2VJZDogbGFuZ3VhZ2VJZCRkLFxuICAgICdkZWZhdWx0JzogSlNPTl93aXRoX0NvbW1lbnRzXG4gIH0pO1xuXG4gIHZhciBuYW1lJGYgPSBcIkpTT041XCI7XG4gIHZhciB0eXBlJGUgPSBcImRhdGFcIjtcbiAgdmFyIGV4dGVuc2lvbnMkZSA9IFtcbiAgXHRcIi5qc29uNVwiXG4gIF07XG4gIHZhciB0bVNjb3BlJGUgPSBcInNvdXJjZS5qc1wiO1xuICB2YXIgYWNlTW9kZSRlID0gXCJqYXZhc2NyaXB0XCI7XG4gIHZhciBjb2RlbWlycm9yTW9kZSRhID0gXCJqYXZhc2NyaXB0XCI7XG4gIHZhciBjb2RlbWlycm9yTWltZVR5cGUkYSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuICB2YXIgbGFuZ3VhZ2VJZCRlID0gMTc1O1xuICB2YXIgSlNPTjUgPSB7XG4gIFx0bmFtZTogbmFtZSRmLFxuICBcdHR5cGU6IHR5cGUkZSxcbiAgXHRleHRlbnNpb25zOiBleHRlbnNpb25zJGUsXG4gIFx0dG1TY29wZTogdG1TY29wZSRlLFxuICBcdGFjZU1vZGU6IGFjZU1vZGUkZSxcbiAgXHRjb2RlbWlycm9yTW9kZTogY29kZW1pcnJvck1vZGUkYSxcbiAgXHRjb2RlbWlycm9yTWltZVR5cGU6IGNvZGVtaXJyb3JNaW1lVHlwZSRhLFxuICBcdGxhbmd1YWdlSWQ6IGxhbmd1YWdlSWQkZVxuICB9O1xuXG4gIHZhciBKU09ONSQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBuYW1lOiBuYW1lJGYsXG4gICAgdHlwZTogdHlwZSRlLFxuICAgIGV4dGVuc2lvbnM6IGV4dGVuc2lvbnMkZSxcbiAgICB0bVNjb3BlOiB0bVNjb3BlJGUsXG4gICAgYWNlTW9kZTogYWNlTW9kZSRlLFxuICAgIGNvZGVtaXJyb3JNb2RlOiBjb2RlbWlycm9yTW9kZSRhLFxuICAgIGNvZGVtaXJyb3JNaW1lVHlwZTogY29kZW1pcnJvck1pbWVUeXBlJGEsXG4gICAgbGFuZ3VhZ2VJZDogbGFuZ3VhZ2VJZCRlLFxuICAgICdkZWZhdWx0JzogSlNPTjVcbiAgfSk7XG5cbiAgdmFyIHJlcXVpcmUkJDAkNiA9IGdldENqc0V4cG9ydEZyb21OYW1lc3BhY2UoSmF2YVNjcmlwdCQxKTtcblxuICB2YXIgcmVxdWlyZSQkMSQyID0gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZShKU1gkMSk7XG5cbiAgdmFyIHJlcXVpcmUkJDIkMSA9IGdldENqc0V4cG9ydEZyb21OYW1lc3BhY2UoVHlwZVNjcmlwdCQxKTtcblxuICB2YXIgcmVxdWlyZSQkMyQxID0gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZShUU1gkMSk7XG5cbiAgdmFyIHJlcXVpcmUkJDQgPSBnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlKF9KU09OJDEpO1xuXG4gIHZhciByZXF1aXJlJCQ1ID0gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZShKU09OX3dpdGhfQ29tbWVudHMkMSk7XG5cbiAgdmFyIHJlcXVpcmUkJDYgPSBnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlKEpTT041JDEpO1xuXG4gIHZhciBsYW5ndWFnZXMkNCA9IFtjcmVhdGVMYW5ndWFnZShyZXF1aXJlJCQwJDYsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZGF0YSwge1xuICAgICAgc2luY2U6IFwiMC4wLjBcIixcbiAgICAgIHBhcnNlcnM6IFtcImJhYmVsXCIsIFwiZmxvd1wiXSxcbiAgICAgIHZzY29kZUxhbmd1YWdlSWRzOiBbXCJqYXZhc2NyaXB0XCIsIFwibW9uZ29cIl0sXG4gICAgICBpbnRlcnByZXRlcnM6IGRhdGEuaW50ZXJwcmV0ZXJzLmNvbmNhdChbXCJub2RlanNcIl0pXG4gICAgfSk7XG4gIH0pLCBjcmVhdGVMYW5ndWFnZShyZXF1aXJlJCQwJDYsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZGF0YSwge1xuICAgICAgbmFtZTogXCJGbG93XCIsXG4gICAgICBzaW5jZTogXCIwLjAuMFwiLFxuICAgICAgcGFyc2VyczogW1wiYmFiZWxcIiwgXCJmbG93XCJdLFxuICAgICAgdnNjb2RlTGFuZ3VhZ2VJZHM6IFtcImphdmFzY3JpcHRcIl0sXG4gICAgICBhbGlhc2VzOiBbXSxcbiAgICAgIGZpbGVuYW1lczogW10sXG4gICAgICBleHRlbnNpb25zOiBbXCIuanMuZmxvd1wiXVxuICAgIH0pO1xuICB9KSwgY3JlYXRlTGFuZ3VhZ2UocmVxdWlyZSQkMSQyLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGRhdGEsIHtcbiAgICAgIHNpbmNlOiBcIjAuMC4wXCIsXG4gICAgICBwYXJzZXJzOiBbXCJiYWJlbFwiLCBcImZsb3dcIl0sXG4gICAgICB2c2NvZGVMYW5ndWFnZUlkczogW1wiamF2YXNjcmlwdHJlYWN0XCJdXG4gICAgfSk7XG4gIH0pLCBjcmVhdGVMYW5ndWFnZShyZXF1aXJlJCQyJDEsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZGF0YSwge1xuICAgICAgc2luY2U6IFwiMS40LjBcIixcbiAgICAgIHBhcnNlcnM6IFtcInR5cGVzY3JpcHRcIl0sXG4gICAgICB2c2NvZGVMYW5ndWFnZUlkczogW1widHlwZXNjcmlwdFwiXVxuICAgIH0pO1xuICB9KSwgY3JlYXRlTGFuZ3VhZ2UocmVxdWlyZSQkMyQxLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGRhdGEsIHtcbiAgICAgIHNpbmNlOiBcIjEuNC4wXCIsXG4gICAgICBwYXJzZXJzOiBbXCJ0eXBlc2NyaXB0XCJdLFxuICAgICAgdnNjb2RlTGFuZ3VhZ2VJZHM6IFtcInR5cGVzY3JpcHRyZWFjdFwiXVxuICAgIH0pO1xuICB9KSwgY3JlYXRlTGFuZ3VhZ2UocmVxdWlyZSQkNCwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkYXRhLCB7XG4gICAgICBuYW1lOiBcIkpTT04uc3RyaW5naWZ5XCIsXG4gICAgICBzaW5jZTogXCIxLjEzLjBcIixcbiAgICAgIHBhcnNlcnM6IFtcImpzb24tc3RyaW5naWZ5XCJdLFxuICAgICAgdnNjb2RlTGFuZ3VhZ2VJZHM6IFtcImpzb25cIl0sXG4gICAgICBleHRlbnNpb25zOiBbXSxcbiAgICAgIC8vIC5qc29uIGZpbGUgZGVmYXVsdHMgdG8ganNvbiBpbnN0ZWFkIG9mIGpzb24tc3RyaW5naWZ5XG4gICAgICBmaWxlbmFtZXM6IFtcInBhY2thZ2UuanNvblwiLCBcInBhY2thZ2UtbG9jay5qc29uXCIsIFwiY29tcG9zZXIuanNvblwiXVxuICAgIH0pO1xuICB9KSwgY3JlYXRlTGFuZ3VhZ2UocmVxdWlyZSQkNCwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkYXRhLCB7XG4gICAgICBzaW5jZTogXCIxLjUuMFwiLFxuICAgICAgcGFyc2VyczogW1wianNvblwiXSxcbiAgICAgIHZzY29kZUxhbmd1YWdlSWRzOiBbXCJqc29uXCJdLFxuICAgICAgZmlsZW5hbWVzOiBkYXRhLmZpbGVuYW1lcy5jb25jYXQoW1wiLnByZXR0aWVycmNcIl0pXG4gICAgfSk7XG4gIH0pLCBjcmVhdGVMYW5ndWFnZShyZXF1aXJlJCQ1LCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGRhdGEsIHtcbiAgICAgIHNpbmNlOiBcIjEuNS4wXCIsXG4gICAgICBwYXJzZXJzOiBbXCJqc29uXCJdLFxuICAgICAgdnNjb2RlTGFuZ3VhZ2VJZHM6IFtcImpzb25jXCJdLFxuICAgICAgZmlsZW5hbWVzOiBkYXRhLmZpbGVuYW1lcy5jb25jYXQoW1wiLmVzbGludHJjXCJdKVxuICAgIH0pO1xuICB9KSwgY3JlYXRlTGFuZ3VhZ2UocmVxdWlyZSQkNiwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkYXRhLCB7XG4gICAgICBzaW5jZTogXCIxLjEzLjBcIixcbiAgICAgIHBhcnNlcnM6IFtcImpzb241XCJdLFxuICAgICAgdnNjb2RlTGFuZ3VhZ2VJZHM6IFtcImpzb241XCJdXG4gICAgfSk7XG4gIH0pXTtcbiAgdmFyIHByaW50ZXJzJDQgPSB7XG4gICAgZXN0cmVlOiBwcmludGVyRXN0cmVlLFxuICAgIFwiZXN0cmVlLWpzb25cIjogcHJpbnRlckVzdHJlZUpzb25cbiAgfTtcbiAgdmFyIGxhbmd1YWdlSnMgPSB7XG4gICAgbGFuZ3VhZ2VzOiBsYW5ndWFnZXMkNCxcbiAgICBvcHRpb25zOiBvcHRpb25zJDUsXG4gICAgcHJpbnRlcnM6IHByaW50ZXJzJDRcbiAgfTtcblxuICB2YXIganNvbiQxID0ge1xuICAgIFwiY2prUGF0dGVyblwiOiBcIltcXFxcdTAyZWEtXFxcXHUwMmViXFxcXHUxMTAwLVxcXFx1MTFmZlxcXFx1MmU4MC1cXFxcdTJlOTlcXFxcdTJlOWItXFxcXHUyZWYzXFxcXHUyZjAwLVxcXFx1MmZkNVxcXFx1MzAwMC1cXFxcdTMwM2ZcXFxcdTMwNDEtXFxcXHUzMDk2XFxcXHUzMDk5LVxcXFx1MzA5ZlxcXFx1MzBhMS1cXFxcdTMwZmFcXFxcdTMwZmMtXFxcXHUzMGZmXFxcXHUzMTA1LVxcXFx1MzEyZlxcXFx1MzEzMS1cXFxcdTMxOGVcXFxcdTMxOTAtXFxcXHUzMTkxXFxcXHUzMTk2LVxcXFx1MzFiYVxcXFx1MzFjMC1cXFxcdTMxZTNcXFxcdTMxZjAtXFxcXHUzMjFlXFxcXHUzMjJhLVxcXFx1MzI0N1xcXFx1MzI2MC1cXFxcdTMyN2VcXFxcdTMyOGEtXFxcXHUzMmIwXFxcXHUzMmMwLVxcXFx1MzJjYlxcXFx1MzJkMC1cXFxcdTMzNzBcXFxcdTMzN2ItXFxcXHUzMzdmXFxcXHUzM2UwLVxcXFx1MzNmZVxcXFx1MzQwMC1cXFxcdTRkYjVcXFxcdTRlMDAtXFxcXHU5ZmVmXFxcXHVhOTYwLVxcXFx1YTk3Y1xcXFx1YWMwMC1cXFxcdWQ3YTNcXFxcdWQ3YjAtXFxcXHVkN2M2XFxcXHVkN2NiLVxcXFx1ZDdmYlxcXFx1ZjkwMC1cXFxcdWZhNmRcXFxcdWZhNzAtXFxcXHVmYWQ5XFxcXHVmZTEwLVxcXFx1ZmUxZlxcXFx1ZmUzMC1cXFxcdWZlNmZcXFxcdWZmMDAtXFxcXHVmZmVmXXxbXFxcXHVkODQwLVxcXFx1ZDg2OFxcXFx1ZDg2YS1cXFxcdWQ4NmNcXFxcdWQ4NmYtXFxcXHVkODcyXFxcXHVkODc0LVxcXFx1ZDg3OV1bXFxcXHVkYzAwLVxcXFx1ZGZmZl18XFxcXHVkODJjW1xcXFx1ZGMwMC1cXFxcdWRkMWVcXFxcdWRkNTAtXFxcXHVkZDUyXFxcXHVkZDY0LVxcXFx1ZGQ2N118XFxcXHVkODNjW1xcXFx1ZGUwMFxcXFx1ZGU1MC1cXFxcdWRlNTFdfFxcXFx1ZDg2OVtcXFxcdWRjMDAtXFxcXHVkZWQ2XFxcXHVkZjAwLVxcXFx1ZGZmZl18XFxcXHVkODZkW1xcXFx1ZGMwMC1cXFxcdWRmMzRcXFxcdWRmNDAtXFxcXHVkZmZmXXxcXFxcdWQ4NmVbXFxcXHVkYzAwLVxcXFx1ZGMxZFxcXFx1ZGMyMC1cXFxcdWRmZmZdfFxcXFx1ZDg3M1tcXFxcdWRjMDAtXFxcXHVkZWExXFxcXHVkZWIwLVxcXFx1ZGZmZl18XFxcXHVkODdhW1xcXFx1ZGMwMC1cXFxcdWRmZTBdfFxcXFx1ZDg3ZVtcXFxcdWRjMDAtXFxcXHVkZTFkXVwiLFxuICAgIFwia1BhdHRlcm5cIjogXCJbXFxcXHUxMTAwLVxcXFx1MTFmZlxcXFx1MzAwMS1cXFxcdTMwMDNcXFxcdTMwMDgtXFxcXHUzMDExXFxcXHUzMDEzLVxcXFx1MzAxZlxcXFx1MzAyZS1cXFxcdTMwMzBcXFxcdTMwMzdcXFxcdTMwZmJcXFxcdTMxMzEtXFxcXHUzMThlXFxcXHUzMjAwLVxcXFx1MzIxZVxcXFx1MzI2MC1cXFxcdTMyN2VcXFxcdWE5NjAtXFxcXHVhOTdjXFxcXHVhYzAwLVxcXFx1ZDdhM1xcXFx1ZDdiMC1cXFxcdWQ3YzZcXFxcdWQ3Y2ItXFxcXHVkN2ZiXFxcXHVmZTQ1LVxcXFx1ZmU0NlxcXFx1ZmY2MS1cXFxcdWZmNjVcXFxcdWZmYTAtXFxcXHVmZmJlXFxcXHVmZmMyLVxcXFx1ZmZjN1xcXFx1ZmZjYS1cXFxcdWZmY2ZcXFxcdWZmZDItXFxcXHVmZmQ3XFxcXHVmZmRhLVxcXFx1ZmZkY11cIixcbiAgICBcInB1bmN0dWF0aW9uUGF0dGVyblwiOiBcIltcXFxcdTAwMjEtXFxcXHUwMDJmXFxcXHUwMDNhLVxcXFx1MDA0MFxcXFx1MDA1Yi1cXFxcdTAwNjBcXFxcdTAwN2ItXFxcXHUwMDdlXFxcXHUwMGExXFxcXHUwMGE3XFxcXHUwMGFiXFxcXHUwMGI2LVxcXFx1MDBiN1xcXFx1MDBiYlxcXFx1MDBiZlxcXFx1MDM3ZVxcXFx1MDM4N1xcXFx1MDU1YS1cXFxcdTA1NWZcXFxcdTA1ODktXFxcXHUwNThhXFxcXHUwNWJlXFxcXHUwNWMwXFxcXHUwNWMzXFxcXHUwNWM2XFxcXHUwNWYzLVxcXFx1MDVmNFxcXFx1MDYwOS1cXFxcdTA2MGFcXFxcdTA2MGMtXFxcXHUwNjBkXFxcXHUwNjFiXFxcXHUwNjFlLVxcXFx1MDYxZlxcXFx1MDY2YS1cXFxcdTA2NmRcXFxcdTA2ZDRcXFxcdTA3MDAtXFxcXHUwNzBkXFxcXHUwN2Y3LVxcXFx1MDdmOVxcXFx1MDgzMC1cXFxcdTA4M2VcXFxcdTA4NWVcXFxcdTA5NjQtXFxcXHUwOTY1XFxcXHUwOTcwXFxcXHUwOWZkXFxcXHUwYTc2XFxcXHUwYWYwXFxcXHUwYzc3XFxcXHUwYzg0XFxcXHUwZGY0XFxcXHUwZTRmXFxcXHUwZTVhLVxcXFx1MGU1YlxcXFx1MGYwNC1cXFxcdTBmMTJcXFxcdTBmMTRcXFxcdTBmM2EtXFxcXHUwZjNkXFxcXHUwZjg1XFxcXHUwZmQwLVxcXFx1MGZkNFxcXFx1MGZkOS1cXFxcdTBmZGFcXFxcdTEwNGEtXFxcXHUxMDRmXFxcXHUxMGZiXFxcXHUxMzYwLVxcXFx1MTM2OFxcXFx1MTQwMFxcXFx1MTY2ZVxcXFx1MTY5Yi1cXFxcdTE2OWNcXFxcdTE2ZWItXFxcXHUxNmVkXFxcXHUxNzM1LVxcXFx1MTczNlxcXFx1MTdkNC1cXFxcdTE3ZDZcXFxcdTE3ZDgtXFxcXHUxN2RhXFxcXHUxODAwLVxcXFx1MTgwYVxcXFx1MTk0NC1cXFxcdTE5NDVcXFxcdTFhMWUtXFxcXHUxYTFmXFxcXHUxYWEwLVxcXFx1MWFhNlxcXFx1MWFhOC1cXFxcdTFhYWRcXFxcdTFiNWEtXFxcXHUxYjYwXFxcXHUxYmZjLVxcXFx1MWJmZlxcXFx1MWMzYi1cXFxcdTFjM2ZcXFxcdTFjN2UtXFxcXHUxYzdmXFxcXHUxY2MwLVxcXFx1MWNjN1xcXFx1MWNkM1xcXFx1MjAxMC1cXFxcdTIwMjdcXFxcdTIwMzAtXFxcXHUyMDQzXFxcXHUyMDQ1LVxcXFx1MjA1MVxcXFx1MjA1My1cXFxcdTIwNWVcXFxcdTIwN2QtXFxcXHUyMDdlXFxcXHUyMDhkLVxcXFx1MjA4ZVxcXFx1MjMwOC1cXFxcdTIzMGJcXFxcdTIzMjktXFxcXHUyMzJhXFxcXHUyNzY4LVxcXFx1Mjc3NVxcXFx1MjdjNS1cXFxcdTI3YzZcXFxcdTI3ZTYtXFxcXHUyN2VmXFxcXHUyOTgzLVxcXFx1Mjk5OFxcXFx1MjlkOC1cXFxcdTI5ZGJcXFxcdTI5ZmMtXFxcXHUyOWZkXFxcXHUyY2Y5LVxcXFx1MmNmY1xcXFx1MmNmZS1cXFxcdTJjZmZcXFxcdTJkNzBcXFxcdTJlMDAtXFxcXHUyZTJlXFxcXHUyZTMwLVxcXFx1MmU0ZlxcXFx1MzAwMS1cXFxcdTMwMDNcXFxcdTMwMDgtXFxcXHUzMDExXFxcXHUzMDE0LVxcXFx1MzAxZlxcXFx1MzAzMFxcXFx1MzAzZFxcXFx1MzBhMFxcXFx1MzBmYlxcXFx1YTRmZS1cXFxcdWE0ZmZcXFxcdWE2MGQtXFxcXHVhNjBmXFxcXHVhNjczXFxcXHVhNjdlXFxcXHVhNmYyLVxcXFx1YTZmN1xcXFx1YTg3NC1cXFxcdWE4NzdcXFxcdWE4Y2UtXFxcXHVhOGNmXFxcXHVhOGY4LVxcXFx1YThmYVxcXFx1YThmY1xcXFx1YTkyZS1cXFxcdWE5MmZcXFxcdWE5NWZcXFxcdWE5YzEtXFxcXHVhOWNkXFxcXHVhOWRlLVxcXFx1YTlkZlxcXFx1YWE1Yy1cXFxcdWFhNWZcXFxcdWFhZGUtXFxcXHVhYWRmXFxcXHVhYWYwLVxcXFx1YWFmMVxcXFx1YWJlYlxcXFx1ZmQzZS1cXFxcdWZkM2ZcXFxcdWZlMTAtXFxcXHVmZTE5XFxcXHVmZTMwLVxcXFx1ZmU1MlxcXFx1ZmU1NC1cXFxcdWZlNjFcXFxcdWZlNjNcXFxcdWZlNjhcXFxcdWZlNmEtXFxcXHVmZTZiXFxcXHVmZjAxLVxcXFx1ZmYwM1xcXFx1ZmYwNS1cXFxcdWZmMGFcXFxcdWZmMGMtXFxcXHVmZjBmXFxcXHVmZjFhLVxcXFx1ZmYxYlxcXFx1ZmYxZi1cXFxcdWZmMjBcXFxcdWZmM2ItXFxcXHVmZjNkXFxcXHVmZjNmXFxcXHVmZjViXFxcXHVmZjVkXFxcXHVmZjVmLVxcXFx1ZmY2NV18XFxcXHVkODAwW1xcXFx1ZGQwMC1cXFxcdWRkMDJcXFxcdWRmOWZcXFxcdWRmZDBdfFxcXFx1ZDgwMVtcXFxcdWRkNmZdfFxcXFx1ZDgwMltcXFxcdWRjNTdcXFxcdWRkMWZcXFxcdWRkM2ZcXFxcdWRlNTAtXFxcXHVkZTU4XFxcXHVkZTdmXFxcXHVkZWYwLVxcXFx1ZGVmNlxcXFx1ZGYzOS1cXFxcdWRmM2ZcXFxcdWRmOTktXFxcXHVkZjljXXxcXFxcdWQ4MDNbXFxcXHVkZjU1LVxcXFx1ZGY1OV18XFxcXHVkODA0W1xcXFx1ZGM0Ny1cXFxcdWRjNGRcXFxcdWRjYmItXFxcXHVkY2JjXFxcXHVkY2JlLVxcXFx1ZGNjMVxcXFx1ZGQ0MC1cXFxcdWRkNDNcXFxcdWRkNzQtXFxcXHVkZDc1XFxcXHVkZGM1LVxcXFx1ZGRjOFxcXFx1ZGRjZFxcXFx1ZGRkYlxcXFx1ZGRkZC1cXFxcdWRkZGZcXFxcdWRlMzgtXFxcXHVkZTNkXFxcXHVkZWE5XXxcXFxcdWQ4MDVbXFxcXHVkYzRiLVxcXFx1ZGM0ZlxcXFx1ZGM1YlxcXFx1ZGM1ZFxcXFx1ZGNjNlxcXFx1ZGRjMS1cXFxcdWRkZDdcXFxcdWRlNDEtXFxcXHVkZTQzXFxcXHVkZTYwLVxcXFx1ZGU2Y1xcXFx1ZGYzYy1cXFxcdWRmM2VdfFxcXFx1ZDgwNltcXFxcdWRjM2JcXFxcdWRkZTJcXFxcdWRlM2YtXFxcXHVkZTQ2XFxcXHVkZTlhLVxcXFx1ZGU5Y1xcXFx1ZGU5ZS1cXFxcdWRlYTJdfFxcXFx1ZDgwN1tcXFxcdWRjNDEtXFxcXHVkYzQ1XFxcXHVkYzcwLVxcXFx1ZGM3MVxcXFx1ZGVmNy1cXFxcdWRlZjhcXFxcdWRmZmZdfFxcXFx1ZDgwOVtcXFxcdWRjNzAtXFxcXHVkYzc0XXxcXFxcdWQ4MWFbXFxcXHVkZTZlLVxcXFx1ZGU2ZlxcXFx1ZGVmNVxcXFx1ZGYzNy1cXFxcdWRmM2JcXFxcdWRmNDRdfFxcXFx1ZDgxYltcXFxcdWRlOTctXFxcXHVkZTlhXFxcXHVkZmUyXXxcXFxcdWQ4MmZbXFxcXHVkYzlmXXxcXFxcdWQ4MzZbXFxcXHVkZTg3LVxcXFx1ZGU4Yl18XFxcXHVkODNhW1xcXFx1ZGQ1ZS1cXFxcdWRkNWZdXCJcbiAgfTtcblxuICB2YXIgY2prUGF0dGVybiA9IGpzb24kMS5jamtQYXR0ZXJuLFxuICAgICAga1BhdHRlcm4gPSBqc29uJDEua1BhdHRlcm4sXG4gICAgICBwdW5jdHVhdGlvblBhdHRlcm4gPSBqc29uJDEucHVuY3R1YXRpb25QYXR0ZXJuO1xuICB2YXIgZ2V0TGFzdCQzID0gdXRpbC5nZXRMYXN0O1xuICB2YXIgSU5MSU5FX05PREVfVFlQRVMgPSBbXCJsaXF1aWROb2RlXCIsIFwiaW5saW5lQ29kZVwiLCBcImVtcGhhc2lzXCIsIFwic3Ryb25nXCIsIFwiZGVsZXRlXCIsIFwibGlua1wiLCBcImxpbmtSZWZlcmVuY2VcIiwgXCJpbWFnZVwiLCBcImltYWdlUmVmZXJlbmNlXCIsIFwiZm9vdG5vdGVcIiwgXCJmb290bm90ZVJlZmVyZW5jZVwiLCBcInNlbnRlbmNlXCIsIFwid2hpdGVzcGFjZVwiLCBcIndvcmRcIiwgXCJicmVha1wiLCBcImlubGluZU1hdGhcIl07XG4gIHZhciBJTkxJTkVfTk9ERV9XUkFQUEVSX1RZUEVTID0gSU5MSU5FX05PREVfVFlQRVMuY29uY2F0KFtcInRhYmxlQ2VsbFwiLCBcInBhcmFncmFwaFwiLCBcImhlYWRpbmdcIl0pO1xuICB2YXIga1JlZ2V4ID0gbmV3IFJlZ0V4cChrUGF0dGVybik7XG4gIHZhciBwdW5jdHVhdGlvblJlZ2V4ID0gbmV3IFJlZ0V4cChwdW5jdHVhdGlvblBhdHRlcm4pO1xuICAvKipcbiAgICogc3BsaXQgdGV4dCBpbnRvIHdoaXRlc3BhY2VzIGFuZCB3b3Jkc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKiBAcmV0dXJuIHtBcnJheTx7IHR5cGU6IFwid2hpdGVzcGFjZVwiLCB2YWx1ZTogXCIgXCIgfCBcIlxcblwiIHwgXCJcIiB9IHwgeyB0eXBlOiBcIndvcmRcIiwgdmFsdWU6IHN0cmluZyB9Pn1cbiAgICovXG5cbiAgZnVuY3Rpb24gc3BsaXRUZXh0KHRleHQsIG9wdGlvbnMpIHtcbiAgICB2YXIgS0lORF9OT05fQ0pLID0gXCJub24tY2prXCI7XG4gICAgdmFyIEtJTkRfQ0pfTEVUVEVSID0gXCJjai1sZXR0ZXJcIjtcbiAgICB2YXIgS0lORF9LX0xFVFRFUiA9IFwiay1sZXR0ZXJcIjtcbiAgICB2YXIgS0lORF9DSktfUFVOQ1RVQVRJT04gPSBcImNqay1wdW5jdHVhdGlvblwiO1xuICAgIHZhciBub2RlcyA9IFtdO1xuICAgIChvcHRpb25zLnByb3NlV3JhcCA9PT0gXCJwcmVzZXJ2ZVwiID8gdGV4dCA6IHRleHQucmVwbGFjZShuZXcgUmVnRXhwKFwiKFwiLmNvbmNhdChjamtQYXR0ZXJuLCBcIilcXG4oXCIpLmNvbmNhdChjamtQYXR0ZXJuLCBcIilcIiksIFwiZ1wiKSwgXCIkMSQyXCIpKS5zcGxpdCgvKFsgXFx0XFxuXSspLykuZm9yRWFjaChmdW5jdGlvbiAodG9rZW4sIGluZGV4LCB0b2tlbnMpIHtcbiAgICAgIC8vIHdoaXRlc3BhY2VcbiAgICAgIGlmIChpbmRleCAlIDIgPT09IDEpIHtcbiAgICAgICAgbm9kZXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJ3aGl0ZXNwYWNlXCIsXG4gICAgICAgICAgdmFsdWU6IC9cXG4vLnRlc3QodG9rZW4pID8gXCJcXG5cIiA6IFwiIFwiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIHdvcmQgc2VwYXJhdGVkIGJ5IHdoaXRlc3BhY2VcblxuXG4gICAgICBpZiAoKGluZGV4ID09PSAwIHx8IGluZGV4ID09PSB0b2tlbnMubGVuZ3RoIC0gMSkgJiYgdG9rZW4gPT09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0b2tlbi5zcGxpdChuZXcgUmVnRXhwKFwiKFwiLmNvbmNhdChjamtQYXR0ZXJuLCBcIilcIikpKS5mb3JFYWNoKGZ1bmN0aW9uIChpbm5lclRva2VuLCBpbm5lckluZGV4LCBpbm5lclRva2Vucykge1xuICAgICAgICBpZiAoKGlubmVySW5kZXggPT09IDAgfHwgaW5uZXJJbmRleCA9PT0gaW5uZXJUb2tlbnMubGVuZ3RoIC0gMSkgJiYgaW5uZXJUb2tlbiA9PT0gXCJcIikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBub24tQ0pLIHdvcmRcblxuXG4gICAgICAgIGlmIChpbm5lckluZGV4ICUgMiA9PT0gMCkge1xuICAgICAgICAgIGlmIChpbm5lclRva2VuICE9PSBcIlwiKSB7XG4gICAgICAgICAgICBhcHBlbmROb2RlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ3b3JkXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBpbm5lclRva2VuLFxuICAgICAgICAgICAgICBraW5kOiBLSU5EX05PTl9DSkssXG4gICAgICAgICAgICAgIGhhc0xlYWRpbmdQdW5jdHVhdGlvbjogcHVuY3R1YXRpb25SZWdleC50ZXN0KGlubmVyVG9rZW5bMF0pLFxuICAgICAgICAgICAgICBoYXNUcmFpbGluZ1B1bmN0dWF0aW9uOiBwdW5jdHVhdGlvblJlZ2V4LnRlc3QoZ2V0TGFzdCQzKGlubmVyVG9rZW4pKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIENKSyBjaGFyYWN0ZXJcblxuXG4gICAgICAgIGFwcGVuZE5vZGUocHVuY3R1YXRpb25SZWdleC50ZXN0KGlubmVyVG9rZW4pID8ge1xuICAgICAgICAgIHR5cGU6IFwid29yZFwiLFxuICAgICAgICAgIHZhbHVlOiBpbm5lclRva2VuLFxuICAgICAgICAgIGtpbmQ6IEtJTkRfQ0pLX1BVTkNUVUFUSU9OLFxuICAgICAgICAgIGhhc0xlYWRpbmdQdW5jdHVhdGlvbjogdHJ1ZSxcbiAgICAgICAgICBoYXNUcmFpbGluZ1B1bmN0dWF0aW9uOiB0cnVlXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgdHlwZTogXCJ3b3JkXCIsXG4gICAgICAgICAgdmFsdWU6IGlubmVyVG9rZW4sXG4gICAgICAgICAga2luZDoga1JlZ2V4LnRlc3QoaW5uZXJUb2tlbikgPyBLSU5EX0tfTEVUVEVSIDogS0lORF9DSl9MRVRURVIsXG4gICAgICAgICAgaGFzTGVhZGluZ1B1bmN0dWF0aW9uOiBmYWxzZSxcbiAgICAgICAgICBoYXNUcmFpbGluZ1B1bmN0dWF0aW9uOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBub2RlcztcblxuICAgIGZ1bmN0aW9uIGFwcGVuZE5vZGUobm9kZSkge1xuICAgICAgdmFyIGxhc3ROb2RlID0gZ2V0TGFzdCQzKG5vZGVzKTtcblxuICAgICAgaWYgKGxhc3ROb2RlICYmIGxhc3ROb2RlLnR5cGUgPT09IFwid29yZFwiKSB7XG4gICAgICAgIGlmIChsYXN0Tm9kZS5raW5kID09PSBLSU5EX05PTl9DSksgJiYgbm9kZS5raW5kID09PSBLSU5EX0NKX0xFVFRFUiAmJiAhbGFzdE5vZGUuaGFzVHJhaWxpbmdQdW5jdHVhdGlvbiB8fCBsYXN0Tm9kZS5raW5kID09PSBLSU5EX0NKX0xFVFRFUiAmJiBub2RlLmtpbmQgPT09IEtJTkRfTk9OX0NKSyAmJiAhbm9kZS5oYXNMZWFkaW5nUHVuY3R1YXRpb24pIHtcbiAgICAgICAgICBub2Rlcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwid2hpdGVzcGFjZVwiLFxuICAgICAgICAgICAgdmFsdWU6IFwiIFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzQmV0d2VlbihLSU5EX05PTl9DSkssIEtJTkRfQ0pLX1BVTkNUVUFUSU9OKSAmJiAvLyBkaXNhbGxvdyBsZWFkaW5nL3RyYWlsaW5nIGZ1bGwtd2lkdGggd2hpdGVzcGFjZVxuICAgICAgICAhW2xhc3ROb2RlLnZhbHVlLCBub2RlLnZhbHVlXS5zb21lKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiAvXFx1MzAwMC8udGVzdCh2YWx1ZSk7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgbm9kZXMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcIndoaXRlc3BhY2VcIixcbiAgICAgICAgICAgIHZhbHVlOiBcIlwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbm9kZXMucHVzaChub2RlKTtcblxuICAgICAgZnVuY3Rpb24gaXNCZXR3ZWVuKGtpbmQxLCBraW5kMikge1xuICAgICAgICByZXR1cm4gbGFzdE5vZGUua2luZCA9PT0ga2luZDEgJiYgbm9kZS5raW5kID09PSBraW5kMiB8fCBsYXN0Tm9kZS5raW5kID09PSBraW5kMiAmJiBub2RlLmtpbmQgPT09IGtpbmQxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE9yZGVyZWRMaXN0SXRlbUluZm8ob3JkZXJMaXN0SXRlbSwgb3JpZ2luYWxUZXh0KSB7XG4gICAgdmFyIF9vcmlnaW5hbFRleHQkc2xpY2UkbSA9IG9yaWdpbmFsVGV4dC5zbGljZShvcmRlckxpc3RJdGVtLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldCwgb3JkZXJMaXN0SXRlbS5wb3NpdGlvbi5lbmQub2Zmc2V0KS5tYXRjaCgvXlxccyooXFxkKykoXFwufFxcKSkoXFxzKikvKSxcbiAgICAgICAgX29yaWdpbmFsVGV4dCRzbGljZSRtMiA9IF9zbGljZWRUb0FycmF5KF9vcmlnaW5hbFRleHQkc2xpY2UkbSwgNCksXG4gICAgICAgIG51bWJlclRleHQgPSBfb3JpZ2luYWxUZXh0JHNsaWNlJG0yWzFdLFxuICAgICAgICBtYXJrZXIgPSBfb3JpZ2luYWxUZXh0JHNsaWNlJG0yWzJdLFxuICAgICAgICBsZWFkaW5nU3BhY2VzID0gX29yaWdpbmFsVGV4dCRzbGljZSRtMlszXTtcblxuICAgIHJldHVybiB7XG4gICAgICBudW1iZXJUZXh0OiBudW1iZXJUZXh0LFxuICAgICAgbWFya2VyOiBtYXJrZXIsXG4gICAgICBsZWFkaW5nU3BhY2VzOiBsZWFkaW5nU3BhY2VzXG4gICAgfTtcbiAgfSAvLyB3b3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vcmVtYXJranMvcmVtYXJrL2lzc3Vlcy8zNTFcbiAgLy8gbGVhZGluZyBhbmQgdHJhaWxpbmcgbmV3bGluZXMgYXJlIHN0cmlwcGVkIGJ5IHJlbWFya1xuXG5cbiAgZnVuY3Rpb24gZ2V0RmVuY2VkQ29kZUJsb2NrVmFsdWUobm9kZSwgb3JpZ2luYWxUZXh0KSB7XG4gICAgdmFyIHRleHQgPSBvcmlnaW5hbFRleHQuc2xpY2Uobm9kZS5wb3NpdGlvbi5zdGFydC5vZmZzZXQsIG5vZGUucG9zaXRpb24uZW5kLm9mZnNldCk7XG4gICAgdmFyIGxlYWRpbmdTcGFjZUNvdW50ID0gdGV4dC5tYXRjaCgvXlxccyovKVswXS5sZW5ndGg7XG4gICAgdmFyIHJlcGxhY2VSZWdleCA9IG5ldyBSZWdFeHAoXCJeXFxcXHN7MCxcIi5jb25jYXQobGVhZGluZ1NwYWNlQ291bnQsIFwifVwiKSk7XG4gICAgdmFyIGxpbmVDb250ZW50cyA9IHRleHQuc3BsaXQoXCJcXG5cIik7XG4gICAgdmFyIG1hcmtlclN0eWxlID0gdGV4dFtsZWFkaW5nU3BhY2VDb3VudF07IC8vIGAgb3IgflxuXG4gICAgdmFyIG1hcmtlciA9IHRleHQuc2xpY2UobGVhZGluZ1NwYWNlQ291bnQpLm1hdGNoKG5ldyBSZWdFeHAoXCJeW1wiLmNvbmNhdChtYXJrZXJTdHlsZSwgXCJdK1wiKSkpWzBdOyAvLyBodHRwczovL3NwZWMuY29tbW9ubWFyay5vcmcvMC4yOC8jZXhhbXBsZS0xMDQ6IENsb3NpbmcgZmVuY2VzIG1heSBiZSBpbmRlbnRlZCBieSAwLTMgc3BhY2VzXG4gICAgLy8gaHR0cHM6Ly9zcGVjLmNvbW1vbm1hcmsub3JnLzAuMjgvI2V4YW1wbGUtOTM6IFRoZSBjbG9zaW5nIGNvZGUgZmVuY2UgbXVzdCBiZSBhdCBsZWFzdCBhcyBsb25nIGFzIHRoZSBvcGVuaW5nIGZlbmNlXG5cbiAgICB2YXIgaGFzRW5kTWFya2VyID0gbmV3IFJlZ0V4cChcIl5cXFxcc3swLDN9XCIuY29uY2F0KG1hcmtlcikpLnRlc3QobGluZUNvbnRlbnRzW2xpbmVDb250ZW50cy5sZW5ndGggLSAxXS5zbGljZShnZXRJbmRlbnQobGluZUNvbnRlbnRzLmxlbmd0aCAtIDEpKSk7XG4gICAgcmV0dXJuIGxpbmVDb250ZW50cy5zbGljZSgxLCBoYXNFbmRNYXJrZXIgPyAtMSA6IHVuZGVmaW5lZCkubWFwKGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICByZXR1cm4geC5zbGljZShnZXRJbmRlbnQoaSArIDEpKS5yZXBsYWNlKHJlcGxhY2VSZWdleCwgXCJcIik7XG4gICAgfSkuam9pbihcIlxcblwiKTtcblxuICAgIGZ1bmN0aW9uIGdldEluZGVudChsaW5lSW5kZXgpIHtcbiAgICAgIHJldHVybiBub2RlLnBvc2l0aW9uLmluZGVudFtsaW5lSW5kZXggLSAxXSAtIDE7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFwQXN0KGFzdCwgaGFuZGxlcikge1xuICAgIHJldHVybiBmdW5jdGlvbiBwcmVvcmRlcihub2RlLCBpbmRleCwgcGFyZW50U3RhY2spIHtcbiAgICAgIHBhcmVudFN0YWNrID0gcGFyZW50U3RhY2sgfHwgW107XG4gICAgICB2YXIgbmV3Tm9kZSA9IGhhbmRsZXIobm9kZSwgaW5kZXgsIHBhcmVudFN0YWNrKTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobmV3Tm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgICB9XG5cbiAgICAgIG5ld05vZGUgPSBPYmplY3QuYXNzaWduKHt9LCBuZXdOb2RlKTtcblxuICAgICAgaWYgKG5ld05vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgbmV3Tm9kZS5jaGlsZHJlbiA9IG5ld05vZGUuY2hpbGRyZW4ucmVkdWNlKGZ1bmN0aW9uIChub2RlcywgY2hpbGQsIGluZGV4KSB7XG4gICAgICAgICAgdmFyIG5ld05vZGVzID0gcHJlb3JkZXIoY2hpbGQsIGluZGV4LCBbbmV3Tm9kZV0uY29uY2F0KHBhcmVudFN0YWNrKSk7XG5cbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobmV3Tm9kZXMpKSB7XG4gICAgICAgICAgICBuZXdOb2RlcyA9IFtuZXdOb2Rlc107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbm9kZXMucHVzaC5hcHBseShub2RlcywgbmV3Tm9kZXMpO1xuICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgfSwgW10pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3Tm9kZTtcbiAgICB9KGFzdCwgbnVsbCwgbnVsbCk7XG4gIH1cblxuICB2YXIgdXRpbHMkNSA9IHtcbiAgICBtYXBBc3Q6IG1hcEFzdCxcbiAgICBzcGxpdFRleHQ6IHNwbGl0VGV4dCxcbiAgICBwdW5jdHVhdGlvblBhdHRlcm46IHB1bmN0dWF0aW9uUGF0dGVybixcbiAgICBnZXRGZW5jZWRDb2RlQmxvY2tWYWx1ZTogZ2V0RmVuY2VkQ29kZUJsb2NrVmFsdWUsXG4gICAgZ2V0T3JkZXJlZExpc3RJdGVtSW5mbzogZ2V0T3JkZXJlZExpc3RJdGVtSW5mbyxcbiAgICBJTkxJTkVfTk9ERV9UWVBFUzogSU5MSU5FX05PREVfVFlQRVMsXG4gICAgSU5MSU5FX05PREVfV1JBUFBFUl9UWVBFUzogSU5MSU5FX05PREVfV1JBUFBFUl9UWVBFU1xuICB9O1xuXG4gIHZhciBfcmVxdWlyZSQkMCRidWlsZGVycyQ4ID0gZG9jLmJ1aWxkZXJzLFxuICAgICAgaGFyZGxpbmUkYiA9IF9yZXF1aXJlJCQwJGJ1aWxkZXJzJDguaGFyZGxpbmUsXG4gICAgICBsaXRlcmFsbGluZSQ1ID0gX3JlcXVpcmUkJDAkYnVpbGRlcnMkOC5saXRlcmFsbGluZSxcbiAgICAgIGNvbmNhdCRmID0gX3JlcXVpcmUkJDAkYnVpbGRlcnMkOC5jb25jYXQsXG4gICAgICBtYXJrQXNSb290JDMgPSBfcmVxdWlyZSQkMCRidWlsZGVycyQ4Lm1hcmtBc1Jvb3QsXG4gICAgICBtYXBEb2MkNiA9IGRvYy51dGlscy5tYXBEb2M7XG4gIHZhciBnZXRGZW5jZWRDb2RlQmxvY2tWYWx1ZSQxID0gdXRpbHMkNS5nZXRGZW5jZWRDb2RlQmxvY2tWYWx1ZTtcblxuICBmdW5jdGlvbiBlbWJlZCQ0KHBhdGgsIHByaW50LCB0ZXh0VG9Eb2MsIG9wdGlvbnMpIHtcbiAgICB2YXIgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcblxuICAgIGlmIChub2RlLnR5cGUgPT09IFwiY29kZVwiICYmIG5vZGUubGFuZyAhPT0gbnVsbCkge1xuICAgICAgLy8gb25seSBsb29rIGZvciB0aGUgZmlyc3Qgc3RyaW5nIHNvIGFzIHRvIHN1cHBvcnQgW21hcmtkb3duLXByZXZpZXctZW5oYW5jZWRdKGh0dHBzOi8vc2hkMTAxd3l5LmdpdGh1Yi5pby9tYXJrZG93bi1wcmV2aWV3LWVuaGFuY2VkLyMvY29kZS1jaHVuaylcbiAgICAgIHZhciBsYW5nTWF0Y2ggPSBub2RlLmxhbmcubWF0Y2goL15bQS1aYS16MC05Xy1dKy8pO1xuICAgICAgdmFyIGxhbmcgPSBsYW5nTWF0Y2ggPyBsYW5nTWF0Y2hbMF0gOiBcIlwiO1xuICAgICAgdmFyIHBhcnNlciA9IGdldFBhcnNlck5hbWUobGFuZyk7XG5cbiAgICAgIGlmIChwYXJzZXIpIHtcbiAgICAgICAgdmFyIHN0eWxlVW5pdCA9IG9wdGlvbnMuX19pbkpzVGVtcGxhdGUgPyBcIn5cIiA6IFwiYFwiO1xuICAgICAgICB2YXIgc3R5bGUgPSBzdHlsZVVuaXQucmVwZWF0KE1hdGgubWF4KDMsIHV0aWwuZ2V0TWF4Q29udGludW91c0NvdW50KG5vZGUudmFsdWUsIHN0eWxlVW5pdCkgKyAxKSk7XG4gICAgICAgIHZhciBkb2MgPSB0ZXh0VG9Eb2MoZ2V0RmVuY2VkQ29kZUJsb2NrVmFsdWUkMShub2RlLCBvcHRpb25zLm9yaWdpbmFsVGV4dCksIHtcbiAgICAgICAgICBwYXJzZXI6IHBhcnNlclxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1hcmtBc1Jvb3QkMyhjb25jYXQkZihbc3R5bGUsIG5vZGUubGFuZywgaGFyZGxpbmUkYiwgcmVwbGFjZU5ld2xpbmVzV2l0aExpdGVyYWxsaW5lcyhkb2MpLCBzdHlsZV0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9kZS50eXBlID09PSBcInlhbWxcIikge1xuICAgICAgcmV0dXJuIG1hcmtBc1Jvb3QkMyhjb25jYXQkZihbXCItLS1cIiwgaGFyZGxpbmUkYiwgbm9kZS52YWx1ZSAmJiBub2RlLnZhbHVlLnRyaW0oKSA/IHJlcGxhY2VOZXdsaW5lc1dpdGhMaXRlcmFsbGluZXModGV4dFRvRG9jKG5vZGUudmFsdWUsIHtcbiAgICAgICAgcGFyc2VyOiBcInlhbWxcIlxuICAgICAgfSkpIDogXCJcIiwgXCItLS1cIl0pKTtcbiAgICB9IC8vIE1EWFxuXG5cbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcImltcG9ydEV4cG9ydFwiOlxuICAgICAgICByZXR1cm4gdGV4dFRvRG9jKG5vZGUudmFsdWUsIHtcbiAgICAgICAgICBwYXJzZXI6IFwiYmFiZWxcIlxuICAgICAgICB9KTtcblxuICAgICAgY2FzZSBcImpzeFwiOlxuICAgICAgICByZXR1cm4gdGV4dFRvRG9jKG5vZGUudmFsdWUsIHtcbiAgICAgICAgICBwYXJzZXI6IFwiX19qc19leHByZXNzaW9uXCJcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzZXJOYW1lKGxhbmcpIHtcbiAgICAgIHZhciBzdXBwb3J0SW5mbyA9IHN1cHBvcnQuZ2V0U3VwcG9ydEluZm8obnVsbCwge1xuICAgICAgICBwbHVnaW5zOiBvcHRpb25zLnBsdWdpbnNcbiAgICAgIH0pO1xuICAgICAgdmFyIGxhbmd1YWdlID0gc3VwcG9ydEluZm8ubGFuZ3VhZ2VzLmZpbmQoZnVuY3Rpb24gKGxhbmd1YWdlKSB7XG4gICAgICAgIHJldHVybiBsYW5ndWFnZS5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IGxhbmcgfHwgbGFuZ3VhZ2UuYWxpYXNlcyAmJiBsYW5ndWFnZS5hbGlhc2VzLmluZGV4T2YobGFuZykgIT09IC0xIHx8IGxhbmd1YWdlLmV4dGVuc2lvbnMgJiYgbGFuZ3VhZ2UuZXh0ZW5zaW9ucy5maW5kKGZ1bmN0aW9uIChleHQpIHtcbiAgICAgICAgICByZXR1cm4gZXh0LnN1YnN0cmluZygxKSA9PT0gbGFuZztcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGxhbmd1YWdlKSB7XG4gICAgICAgIHJldHVybiBsYW5ndWFnZS5wYXJzZXJzWzBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlTmV3bGluZXNXaXRoTGl0ZXJhbGxpbmVzKGRvYykge1xuICAgICAgcmV0dXJuIG1hcERvYyQ2KGRvYywgZnVuY3Rpb24gKGN1cnJlbnREb2MpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjdXJyZW50RG9jID09PSBcInN0cmluZ1wiICYmIGN1cnJlbnREb2MuaW5jbHVkZXMoXCJcXG5cIikgPyBjb25jYXQkZihjdXJyZW50RG9jLnNwbGl0KC8oXFxuKS9nKS5tYXAoZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgICAgICByZXR1cm4gaSAlIDIgPT09IDAgPyB2IDogbGl0ZXJhbGxpbmUkNTtcbiAgICAgICAgfSkpIDogY3VycmVudERvYztcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbWJlZF8xJDIgPSBlbWJlZCQ0O1xuXG4gIHZhciBwcmFnbWFzID0gW1wiZm9ybWF0XCIsIFwicHJldHRpZXJcIl07XG5cbiAgZnVuY3Rpb24gc3RhcnRXaXRoUHJhZ21hKHRleHQpIHtcbiAgICB2YXIgcHJhZ21hID0gXCJAKFwiLmNvbmNhdChwcmFnbWFzLmpvaW4oXCJ8XCIpLCBcIilcIik7XG4gICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cChbXCI8IS0tXFxcXHMqXCIuY29uY2F0KHByYWdtYSwgXCJcXFxccyotLT5cIiksIFwiPCEtLS4qXFxyP1xcbltcXFxcc1xcXFxTXSooXnxcXG4pW15cXFxcU1xcbl0qXCIuY29uY2F0KHByYWdtYSwgXCJbXlxcXFxTXFxuXSooJHxcXG4pW1xcXFxzXFxcXFNdKlxcbi4qLS0+XCIpXS5qb2luKFwifFwiKSwgXCJtXCIpO1xuICAgIHZhciBtYXRjaGVkID0gdGV4dC5tYXRjaChyZWdleCk7XG4gICAgcmV0dXJuIG1hdGNoZWQgJiYgbWF0Y2hlZC5pbmRleCA9PT0gMDtcbiAgfVxuXG4gIHZhciBwcmFnbWEkNCA9IHtcbiAgICBzdGFydFdpdGhQcmFnbWE6IHN0YXJ0V2l0aFByYWdtYSxcbiAgICBoYXNQcmFnbWE6IGZ1bmN0aW9uIGhhc1ByYWdtYSh0ZXh0KSB7XG4gICAgICByZXR1cm4gc3RhcnRXaXRoUHJhZ21hKGZyb250TWF0dGVyKHRleHQpLmNvbnRlbnQudHJpbUxlZnQoKSk7XG4gICAgfSxcbiAgICBpbnNlcnRQcmFnbWE6IGZ1bmN0aW9uIGluc2VydFByYWdtYSh0ZXh0KSB7XG4gICAgICB2YXIgZXh0cmFjdGVkID0gZnJvbnRNYXR0ZXIodGV4dCk7XG4gICAgICB2YXIgcHJhZ21hID0gXCI8IS0tIEBcIi5jb25jYXQocHJhZ21hc1swXSwgXCIgLS0+XCIpO1xuICAgICAgcmV0dXJuIGV4dHJhY3RlZC5mcm9udE1hdHRlciA/IFwiXCIuY29uY2F0KGV4dHJhY3RlZC5mcm9udE1hdHRlci5yYXcsIFwiXFxuXFxuXCIpLmNvbmNhdChwcmFnbWEsIFwiXFxuXFxuXCIpLmNvbmNhdChleHRyYWN0ZWQuY29udGVudCkgOiBcIlwiLmNvbmNhdChwcmFnbWEsIFwiXFxuXFxuXCIpLmNvbmNhdChleHRyYWN0ZWQuY29udGVudCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRPcmRlcmVkTGlzdEl0ZW1JbmZvJDEgPSB1dGlscyQ1LmdldE9yZGVyZWRMaXN0SXRlbUluZm8sXG4gICAgICBtYXBBc3QkMSA9IHV0aWxzJDUubWFwQXN0LFxuICAgICAgc3BsaXRUZXh0JDEgPSB1dGlscyQ1LnNwbGl0VGV4dDsgLy8gMHgwIH4gMHgxMGZmZmZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcblxuICB2YXIgaXNTaW5nbGVDaGFyUmVnZXggPSAvXihbXFx1MDAwMC1cXHVmZmZmXXxbXFx1ZDgwMC1cXHVkYmZmXVtcXHVkYzAwLVxcdWRmZmZdKSQvO1xuXG4gIGZ1bmN0aW9uIHByZXByb2Nlc3MkMihhc3QsIG9wdGlvbnMpIHtcbiAgICBhc3QgPSByZXN0b3JlVW5lc2NhcGVkQ2hhcmFjdGVyKGFzdCwgb3B0aW9ucyk7XG4gICAgYXN0ID0gbWVyZ2VDb250aW51b3VzVGV4dHMoYXN0KTtcbiAgICBhc3QgPSB0cmFuc2Zvcm1JbmxpbmVDb2RlKGFzdCk7XG4gICAgYXN0ID0gdHJhbnNmb3JtSW5kZW50ZWRDb2RlYmxvY2tBbmRNYXJrSXRzUGFyZW50TGlzdChhc3QsIG9wdGlvbnMpO1xuICAgIGFzdCA9IG1hcmtBbGlnbmVkTGlzdChhc3QsIG9wdGlvbnMpO1xuICAgIGFzdCA9IHNwbGl0VGV4dEludG9TZW50ZW5jZXMoYXN0LCBvcHRpb25zKTtcbiAgICBhc3QgPSB0cmFuc2Zvcm1JbXBvcnRFeHBvcnQoYXN0KTtcbiAgICBhc3QgPSBtZXJnZUNvbnRpbnVvdXNJbXBvcnRFeHBvcnQoYXN0KTtcbiAgICByZXR1cm4gYXN0O1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNmb3JtSW1wb3J0RXhwb3J0KGFzdCkge1xuICAgIHJldHVybiBtYXBBc3QkMShhc3QsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBpZiAobm9kZS50eXBlICE9PSBcImltcG9ydFwiICYmIG5vZGUudHlwZSAhPT0gXCJleHBvcnRcIikge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG5vZGUsIHtcbiAgICAgICAgdHlwZTogXCJpbXBvcnRFeHBvcnRcIlxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2Zvcm1JbmxpbmVDb2RlKGFzdCkge1xuICAgIHJldHVybiBtYXBBc3QkMShhc3QsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBpZiAobm9kZS50eXBlICE9PSBcImlubGluZUNvZGVcIikge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG5vZGUsIHtcbiAgICAgICAgdmFsdWU6IG5vZGUudmFsdWUucmVwbGFjZSgvXFxzKy9nLCBcIiBcIilcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzdG9yZVVuZXNjYXBlZENoYXJhY3Rlcihhc3QsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbWFwQXN0JDEoYXN0LCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUudHlwZSAhPT0gXCJ0ZXh0XCIgPyBub2RlIDogT2JqZWN0LmFzc2lnbih7fSwgbm9kZSwge1xuICAgICAgICB2YWx1ZTogbm9kZS52YWx1ZSAhPT0gXCIqXCIgJiYgbm9kZS52YWx1ZSAhPT0gXCJfXCIgJiYgbm9kZS52YWx1ZSAhPT0gXCIkXCIgJiYgLy8gaGFuZGxlIHRoZXNlIGNhc2VzIGluIHByaW50ZXJcbiAgICAgICAgaXNTaW5nbGVDaGFyUmVnZXgudGVzdChub2RlLnZhbHVlKSAmJiBub2RlLnBvc2l0aW9uLmVuZC5vZmZzZXQgLSBub2RlLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldCAhPT0gbm9kZS52YWx1ZS5sZW5ndGggPyBvcHRpb25zLm9yaWdpbmFsVGV4dC5zbGljZShub2RlLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldCwgbm9kZS5wb3NpdGlvbi5lbmQub2Zmc2V0KSA6IG5vZGUudmFsdWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VDb250aW51b3VzSW1wb3J0RXhwb3J0KGFzdCkge1xuICAgIHJldHVybiBtZXJnZUNoaWxkcmVuKGFzdCwgZnVuY3Rpb24gKHByZXZOb2RlLCBub2RlKSB7XG4gICAgICByZXR1cm4gcHJldk5vZGUudHlwZSA9PT0gXCJpbXBvcnRFeHBvcnRcIiAmJiBub2RlLnR5cGUgPT09IFwiaW1wb3J0RXhwb3J0XCI7XG4gICAgfSwgZnVuY3Rpb24gKHByZXZOb2RlLCBub2RlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImltcG9ydEV4cG9ydFwiLFxuICAgICAgICB2YWx1ZTogcHJldk5vZGUudmFsdWUgKyBcIlxcblxcblwiICsgbm9kZS52YWx1ZSxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICBzdGFydDogcHJldk5vZGUucG9zaXRpb24uc3RhcnQsXG4gICAgICAgICAgZW5kOiBub2RlLnBvc2l0aW9uLmVuZFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VDaGlsZHJlbihhc3QsIHNob3VsZE1lcmdlLCBtZXJnZU5vZGUpIHtcbiAgICByZXR1cm4gbWFwQXN0JDEoYXN0LCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKCFub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLnJlZHVjZShmdW5jdGlvbiAoY3VycmVudCwgY2hpbGQpIHtcbiAgICAgICAgdmFyIGxhc3RDaGlsZCA9IGN1cnJlbnRbY3VycmVudC5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAobGFzdENoaWxkICYmIHNob3VsZE1lcmdlKGxhc3RDaGlsZCwgY2hpbGQpKSB7XG4gICAgICAgICAgY3VycmVudC5zcGxpY2UoLTEsIDEsIG1lcmdlTm9kZShsYXN0Q2hpbGQsIGNoaWxkKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudC5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfSwgW10pO1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG5vZGUsIHtcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlQ29udGludW91c1RleHRzKGFzdCkge1xuICAgIHJldHVybiBtZXJnZUNoaWxkcmVuKGFzdCwgZnVuY3Rpb24gKHByZXZOb2RlLCBub2RlKSB7XG4gICAgICByZXR1cm4gcHJldk5vZGUudHlwZSA9PT0gXCJ0ZXh0XCIgJiYgbm9kZS50eXBlID09PSBcInRleHRcIjtcbiAgICB9LCBmdW5jdGlvbiAocHJldk5vZGUsIG5vZGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICB2YWx1ZTogcHJldk5vZGUudmFsdWUgKyBub2RlLnZhbHVlLFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIHN0YXJ0OiBwcmV2Tm9kZS5wb3NpdGlvbi5zdGFydCxcbiAgICAgICAgICBlbmQ6IG5vZGUucG9zaXRpb24uZW5kXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBzcGxpdFRleHRJbnRvU2VudGVuY2VzKGFzdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBtYXBBc3QkMShhc3QsIGZ1bmN0aW9uIChub2RlLCBpbmRleCwgX3JlZikge1xuICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMSksXG4gICAgICAgICAgcGFyZW50Tm9kZSA9IF9yZWYyWzBdO1xuXG4gICAgICBpZiAobm9kZS50eXBlICE9PSBcInRleHRcIikge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gbm9kZS52YWx1ZTtcblxuICAgICAgaWYgKHBhcmVudE5vZGUudHlwZSA9PT0gXCJwYXJhZ3JhcGhcIikge1xuICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRyaW1MZWZ0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggPT09IHBhcmVudE5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUudHJpbVJpZ2h0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzZW50ZW5jZVwiLFxuICAgICAgICBwb3NpdGlvbjogbm9kZS5wb3NpdGlvbixcbiAgICAgICAgY2hpbGRyZW46IHNwbGl0VGV4dCQxKHZhbHVlLCBvcHRpb25zKVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybUluZGVudGVkQ29kZWJsb2NrQW5kTWFya0l0c1BhcmVudExpc3QoYXN0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG1hcEFzdCQxKGFzdCwgZnVuY3Rpb24gKG5vZGUsIGluZGV4LCBwYXJlbnRTdGFjaykge1xuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJjb2RlXCIpIHtcbiAgICAgICAgLy8gdGhlIGZpcnN0IGNoYXIgbWF5IHBvaW50IHRvIGBcXG5gLCBlLmcuIGBcXG5cXHRcXHRiYXJgLCBqdXN0IGlnbm9yZSBpdFxuICAgICAgICB2YXIgaXNJbmRlbnRlZCA9IC9eXFxuPyggezQsfXxcXHQpLy50ZXN0KG9wdGlvbnMub3JpZ2luYWxUZXh0LnNsaWNlKG5vZGUucG9zaXRpb24uc3RhcnQub2Zmc2V0LCBub2RlLnBvc2l0aW9uLmVuZC5vZmZzZXQpKTtcbiAgICAgICAgbm9kZS5pc0luZGVudGVkID0gaXNJbmRlbnRlZDtcblxuICAgICAgICBpZiAoaXNJbmRlbnRlZCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50U3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRTdGFja1tpXTsgLy8gbm8gbmVlZCB0byBjaGVjayBjaGVja2VkIGl0ZW1zXG5cbiAgICAgICAgICAgIGlmIChwYXJlbnQuaGFzSW5kZW50ZWRDb2RlYmxvY2spIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gXCJsaXN0XCIpIHtcbiAgICAgICAgICAgICAgcGFyZW50Lmhhc0luZGVudGVkQ29kZWJsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrQWxpZ25lZExpc3QoYXN0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG1hcEFzdCQxKGFzdCwgZnVuY3Rpb24gKG5vZGUsIGluZGV4LCBwYXJlbnRTdGFjaykge1xuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJsaXN0XCIgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggIT09IDApIHtcbiAgICAgICAgLy8gaWYgb25lIG9mIGl0cyBwYXJlbnRzIGlzIG5vdCBhbGlnbmVkLCBpdCdzIG5vdCBwb3NzaWJsZSB0byBiZSBhbGlnbmVkIGluIHN1Yi1saXN0c1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudFN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHBhcmVudCA9IHBhcmVudFN0YWNrW2ldO1xuXG4gICAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSBcImxpc3RcIiAmJiAhcGFyZW50LmlzQWxpZ25lZCkge1xuICAgICAgICAgICAgbm9kZS5pc0FsaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUuaXNBbGlnbmVkID0gaXNBbGlnbmVkKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGdldExpc3RJdGVtU3RhcnQobGlzdEl0ZW0pIHtcbiAgICAgIHJldHVybiBsaXN0SXRlbS5jaGlsZHJlbi5sZW5ndGggPT09IDAgPyAtMSA6IGxpc3RJdGVtLmNoaWxkcmVuWzBdLnBvc2l0aW9uLnN0YXJ0LmNvbHVtbiAtIDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBbGlnbmVkKGxpc3QpIHtcbiAgICAgIGlmICghbGlzdC5vcmRlcmVkKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAtIDEyM1xuICAgICAgICAgKiAtIDEyM1xuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBfbGlzdCRjaGlsZHJlbiA9IF9zbGljZWRUb0FycmF5KGxpc3QuY2hpbGRyZW4sIDIpLFxuICAgICAgICAgIGZpcnN0SXRlbSA9IF9saXN0JGNoaWxkcmVuWzBdLFxuICAgICAgICAgIHNlY29uZEl0ZW0gPSBfbGlzdCRjaGlsZHJlblsxXTtcblxuICAgICAgdmFyIGZpcnN0SW5mbyA9IGdldE9yZGVyZWRMaXN0SXRlbUluZm8kMShmaXJzdEl0ZW0sIG9wdGlvbnMub3JpZ2luYWxUZXh0KTtcblxuICAgICAgaWYgKGZpcnN0SW5mby5sZWFkaW5nU3BhY2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDEuICAgMTIzXG4gICAgICAgICAqXG4gICAgICAgICAqIDEuICAgMTIzXG4gICAgICAgICAqIDEuIDEyM1xuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBmaXJzdFN0YXJ0ID0gZ2V0TGlzdEl0ZW1TdGFydChmaXJzdEl0ZW0pO1xuXG4gICAgICBpZiAoZmlyc3RTdGFydCA9PT0gLTEpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDEuXG4gICAgICAgICAqXG4gICAgICAgICAqIDEuXG4gICAgICAgICAqIDEuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChsaXN0LmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogYWxpZ25lZDpcbiAgICAgICAgICpcbiAgICAgICAgICogMTEuIDEyM1xuICAgICAgICAgKlxuICAgICAgICAgKiBub3QgYWxpZ25lZDpcbiAgICAgICAgICpcbiAgICAgICAgICogMS4gMTIzXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gZmlyc3RTdGFydCAlIG9wdGlvbnMudGFiV2lkdGggPT09IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWNvbmRTdGFydCA9IGdldExpc3RJdGVtU3RhcnQoc2Vjb25kSXRlbSk7XG5cbiAgICAgIGlmIChmaXJzdFN0YXJ0ICE9PSBzZWNvbmRTdGFydCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogMTEuIDEyM1xuICAgICAgICAgKiAxLiAxMjNcbiAgICAgICAgICpcbiAgICAgICAgICogMS4gMTIzXG4gICAgICAgICAqIDExLiAxMjNcbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpcnN0U3RhcnQgJSBvcHRpb25zLnRhYldpZHRoID09PSAwKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAxMS4gMTIzXG4gICAgICAgICAqIDEyLiAxMjNcbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBhbGlnbmVkOlxuICAgICAgICpcbiAgICAgICAqIDExLiAxMjNcbiAgICAgICAqIDEuICAxMjNcbiAgICAgICAqXG4gICAgICAgKiBub3QgYWxpZ25lZDpcbiAgICAgICAqXG4gICAgICAgKiAxLiAxMjNcbiAgICAgICAqIDIuIDEyM1xuICAgICAgICovXG5cblxuICAgICAgdmFyIHNlY29uZEluZm8gPSBnZXRPcmRlcmVkTGlzdEl0ZW1JbmZvJDEoc2Vjb25kSXRlbSwgb3B0aW9ucy5vcmlnaW5hbFRleHQpO1xuICAgICAgcmV0dXJuIHNlY29uZEluZm8ubGVhZGluZ1NwYWNlcy5sZW5ndGggPiAxO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcmVwcm9jZXNzXzEkMiA9IHByZXByb2Nlc3MkMjtcblxuICB2YXIgX3JlcXVpcmUkJDAkYnVpbGRlcnMkOSA9IGRvYy5idWlsZGVycyxcbiAgICAgIGJyZWFrUGFyZW50JDQgPSBfcmVxdWlyZSQkMCRidWlsZGVycyQ5LmJyZWFrUGFyZW50LFxuICAgICAgY29uY2F0JGcgPSBfcmVxdWlyZSQkMCRidWlsZGVycyQ5LmNvbmNhdCxcbiAgICAgIGpvaW4kYiA9IF9yZXF1aXJlJCQwJGJ1aWxkZXJzJDkuam9pbixcbiAgICAgIGxpbmUkOCA9IF9yZXF1aXJlJCQwJGJ1aWxkZXJzJDkubGluZSxcbiAgICAgIGxpdGVyYWxsaW5lJDYgPSBfcmVxdWlyZSQkMCRidWlsZGVycyQ5LmxpdGVyYWxsaW5lLFxuICAgICAgbWFya0FzUm9vdCQ0ID0gX3JlcXVpcmUkJDAkYnVpbGRlcnMkOS5tYXJrQXNSb290LFxuICAgICAgaGFyZGxpbmUkYyA9IF9yZXF1aXJlJCQwJGJ1aWxkZXJzJDkuaGFyZGxpbmUsXG4gICAgICBzb2Z0bGluZSQ3ID0gX3JlcXVpcmUkJDAkYnVpbGRlcnMkOS5zb2Z0bGluZSxcbiAgICAgIGlmQnJlYWskNyA9IF9yZXF1aXJlJCQwJGJ1aWxkZXJzJDkuaWZCcmVhayxcbiAgICAgIGZpbGwkNSA9IF9yZXF1aXJlJCQwJGJ1aWxkZXJzJDkuZmlsbCxcbiAgICAgIGFsaWduJDIgPSBfcmVxdWlyZSQkMCRidWlsZGVycyQ5LmFsaWduLFxuICAgICAgaW5kZW50JDkgPSBfcmVxdWlyZSQkMCRidWlsZGVycyQ5LmluZGVudCxcbiAgICAgIGdyb3VwJGYgPSBfcmVxdWlyZSQkMCRidWlsZGVycyQ5Lmdyb3VwLFxuICAgICAgbWFwRG9jJDcgPSBkb2MudXRpbHMubWFwRG9jLFxuICAgICAgcHJpbnREb2NUb1N0cmluZyQyID0gZG9jLnByaW50ZXIucHJpbnREb2NUb1N0cmluZztcbiAgdmFyIGdldEZlbmNlZENvZGVCbG9ja1ZhbHVlJDIgPSB1dGlscyQ1LmdldEZlbmNlZENvZGVCbG9ja1ZhbHVlLFxuICAgICAgZ2V0T3JkZXJlZExpc3RJdGVtSW5mbyQyID0gdXRpbHMkNS5nZXRPcmRlcmVkTGlzdEl0ZW1JbmZvLFxuICAgICAgc3BsaXRUZXh0JDIgPSB1dGlscyQ1LnNwbGl0VGV4dCxcbiAgICAgIHB1bmN0dWF0aW9uUGF0dGVybiQxID0gdXRpbHMkNS5wdW5jdHVhdGlvblBhdHRlcm4sXG4gICAgICBJTkxJTkVfTk9ERV9UWVBFUyQxID0gdXRpbHMkNS5JTkxJTkVfTk9ERV9UWVBFUyxcbiAgICAgIElOTElORV9OT0RFX1dSQVBQRVJfVFlQRVMkMSA9IHV0aWxzJDUuSU5MSU5FX05PREVfV1JBUFBFUl9UWVBFUztcbiAgdmFyIHJlcGxhY2VFbmRPZkxpbmVXaXRoJDIgPSB1dGlsLnJlcGxhY2VFbmRPZkxpbmVXaXRoO1xuICB2YXIgVFJBSUxJTkdfSEFSRExJTkVfTk9ERVMgPSBbXCJpbXBvcnRFeHBvcnRcIl07XG4gIHZhciBTSU5HTEVfTElORV9OT0RFX1RZUEVTID0gW1wiaGVhZGluZ1wiLCBcInRhYmxlQ2VsbFwiLCBcImxpbmtcIl07XG4gIHZhciBTSUJMSU5HX05PREVfVFlQRVMgPSBbXCJsaXN0SXRlbVwiLCBcImRlZmluaXRpb25cIiwgXCJmb290bm90ZURlZmluaXRpb25cIiwgXCJqc3hcIl07XG5cbiAgZnVuY3Rpb24gZ2VuZXJpY1ByaW50JDUocGF0aCwgb3B0aW9ucywgcHJpbnQpIHtcbiAgICB2YXIgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcblxuICAgIGlmIChzaG91bGRSZW1haW5UaGVTYW1lQ29udGVudChwYXRoKSkge1xuICAgICAgcmV0dXJuIGNvbmNhdCRnKHNwbGl0VGV4dCQyKG9wdGlvbnMub3JpZ2luYWxUZXh0LnNsaWNlKG5vZGUucG9zaXRpb24uc3RhcnQub2Zmc2V0LCBub2RlLnBvc2l0aW9uLmVuZC5vZmZzZXQpLCBvcHRpb25zKS5tYXAoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJ3b3JkXCIgPyBub2RlLnZhbHVlIDogbm9kZS52YWx1ZSA9PT0gXCJcIiA/IFwiXCIgOiBwcmludExpbmUocGF0aCwgbm9kZS52YWx1ZSwgb3B0aW9ucyk7XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJyb290XCI6XG4gICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmNhdCRnKFtub3JtYWxpemVEb2MocHJpbnRSb290KHBhdGgsIG9wdGlvbnMsIHByaW50KSksIFRSQUlMSU5HX0hBUkRMSU5FX05PREVTLmluZGV4T2YoZ2V0TGFzdERlc2NlbmRhbnROb2RlKG5vZGUpLnR5cGUpID09PSAtMSA/IGhhcmRsaW5lJGMgOiBcIlwiXSk7XG5cbiAgICAgIGNhc2UgXCJwYXJhZ3JhcGhcIjpcbiAgICAgICAgcmV0dXJuIHByaW50Q2hpbGRyZW4kMihwYXRoLCBvcHRpb25zLCBwcmludCwge1xuICAgICAgICAgIHBvc3Rwcm9jZXNzb3I6IGZpbGwkNVxuICAgICAgICB9KTtcblxuICAgICAgY2FzZSBcInNlbnRlbmNlXCI6XG4gICAgICAgIHJldHVybiBwcmludENoaWxkcmVuJDIocGF0aCwgb3B0aW9ucywgcHJpbnQpO1xuXG4gICAgICBjYXNlIFwid29yZFwiOlxuICAgICAgICByZXR1cm4gbm9kZS52YWx1ZS5yZXBsYWNlKC9bKiRdL2csIFwiXFxcXCQmXCIpIC8vIGVzY2FwZSBhbGwgYCpgIGFuZCBgJGAgKG1hdGgpXG4gICAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoW1wiKF58XCIuY29uY2F0KHB1bmN0dWF0aW9uUGF0dGVybiQxLCBcIikoXyspXCIpLCBcIihfKykoXCIuY29uY2F0KHB1bmN0dWF0aW9uUGF0dGVybiQxLCBcInwkKVwiKV0uam9pbihcInxcIiksIFwiZ1wiKSwgZnVuY3Rpb24gKF8sIHRleHQxLCB1bmRlcnNjb3JlMSwgdW5kZXJzY29yZTIsIHRleHQyKSB7XG4gICAgICAgICAgcmV0dXJuICh1bmRlcnNjb3JlMSA/IFwiXCIuY29uY2F0KHRleHQxKS5jb25jYXQodW5kZXJzY29yZTEpIDogXCJcIi5jb25jYXQodW5kZXJzY29yZTIpLmNvbmNhdCh0ZXh0MikpLnJlcGxhY2UoL18vZywgXCJcXFxcX1wiKTtcbiAgICAgICAgfSk7XG4gICAgICAvLyBlc2NhcGUgYWxsIGBfYCBleGNlcHQgY29uY2F0aW5nIHdpdGggbm9uLXB1bmN0dWF0aW9uLCBlLmcuIGAxXzJfM2AgaXMgbm90IGNvbnNpZGVyZWQgZW1waGFzaXNcblxuICAgICAgY2FzZSBcIndoaXRlc3BhY2VcIjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG4gICAgICAgICAgdmFyIGluZGV4ID0gcGFyZW50Tm9kZS5jaGlsZHJlbi5pbmRleE9mKG5vZGUpO1xuICAgICAgICAgIHZhciBuZXh0Tm9kZSA9IHBhcmVudE5vZGUuY2hpbGRyZW5baW5kZXggKyAxXTtcbiAgICAgICAgICB2YXIgcHJvc2VXcmFwID0gLy8gbGVhZGluZyBjaGFyIHRoYXQgbWF5IGNhdXNlIGRpZmZlcmVudCBzeW50YXhcbiAgICAgICAgICBuZXh0Tm9kZSAmJiAvXj58XihbLSsqXXwjezEsNn18WzAtOV0rWy4pXSkkLy50ZXN0KG5leHROb2RlLnZhbHVlKSA/IFwibmV2ZXJcIiA6IG9wdGlvbnMucHJvc2VXcmFwO1xuICAgICAgICAgIHJldHVybiBwcmludExpbmUocGF0aCwgbm9kZS52YWx1ZSwge1xuICAgICAgICAgICAgcHJvc2VXcmFwOiBwcm9zZVdyYXBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiZW1waGFzaXNcIjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfcGFyZW50Tm9kZSA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpO1xuXG4gICAgICAgICAgdmFyIF9pbmRleCA9IF9wYXJlbnROb2RlLmNoaWxkcmVuLmluZGV4T2Yobm9kZSk7XG5cbiAgICAgICAgICB2YXIgcHJldk5vZGUgPSBfcGFyZW50Tm9kZS5jaGlsZHJlbltfaW5kZXggLSAxXTtcbiAgICAgICAgICB2YXIgX25leHROb2RlID0gX3BhcmVudE5vZGUuY2hpbGRyZW5bX2luZGV4ICsgMV07XG4gICAgICAgICAgdmFyIGhhc1ByZXZPck5leHRXb3JkID0gLy8gYDEqMiozYCBpcyBjb25zaWRlcmVkIGVtcGhhc2lzIGJ1dCBgMV8yXzNgIGlzIG5vdFxuICAgICAgICAgIHByZXZOb2RlICYmIHByZXZOb2RlLnR5cGUgPT09IFwic2VudGVuY2VcIiAmJiBwcmV2Tm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwICYmIHV0aWwuZ2V0TGFzdChwcmV2Tm9kZS5jaGlsZHJlbikudHlwZSA9PT0gXCJ3b3JkXCIgJiYgIXV0aWwuZ2V0TGFzdChwcmV2Tm9kZS5jaGlsZHJlbikuaGFzVHJhaWxpbmdQdW5jdHVhdGlvbiB8fCBfbmV4dE5vZGUgJiYgX25leHROb2RlLnR5cGUgPT09IFwic2VudGVuY2VcIiAmJiBfbmV4dE5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCAmJiBfbmV4dE5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gXCJ3b3JkXCIgJiYgIV9uZXh0Tm9kZS5jaGlsZHJlblswXS5oYXNMZWFkaW5nUHVuY3R1YXRpb247XG4gICAgICAgICAgdmFyIHN0eWxlID0gaGFzUHJldk9yTmV4dFdvcmQgfHwgZ2V0QW5jZXN0b3JOb2RlJDIocGF0aCwgXCJlbXBoYXNpc1wiKSA/IFwiKlwiIDogXCJfXCI7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRnKFtzdHlsZSwgcHJpbnRDaGlsZHJlbiQyKHBhdGgsIG9wdGlvbnMsIHByaW50KSwgc3R5bGVdKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwic3Ryb25nXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZyhbXCIqKlwiLCBwcmludENoaWxkcmVuJDIocGF0aCwgb3B0aW9ucywgcHJpbnQpLCBcIioqXCJdKTtcblxuICAgICAgY2FzZSBcImRlbGV0ZVwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGcoW1wifn5cIiwgcHJpbnRDaGlsZHJlbiQyKHBhdGgsIG9wdGlvbnMsIHByaW50KSwgXCJ+flwiXSk7XG5cbiAgICAgIGNhc2UgXCJpbmxpbmVDb2RlXCI6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgYmFja3RpY2tDb3VudCA9IHV0aWwuZ2V0TWluTm90UHJlc2VudENvbnRpbnVvdXNDb3VudChub2RlLnZhbHVlLCBcImBcIik7XG5cbiAgICAgICAgICB2YXIgX3N0eWxlID0gXCJgXCIucmVwZWF0KGJhY2t0aWNrQ291bnQgfHwgMSk7XG5cbiAgICAgICAgICB2YXIgZ2FwID0gYmFja3RpY2tDb3VudCA/IFwiIFwiIDogXCJcIjtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JGcoW19zdHlsZSwgZ2FwLCBub2RlLnZhbHVlLCBnYXAsIF9zdHlsZV0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJsaW5rXCI6XG4gICAgICAgIHN3aXRjaCAob3B0aW9ucy5vcmlnaW5hbFRleHRbbm9kZS5wb3NpdGlvbi5zdGFydC5vZmZzZXRdKSB7XG4gICAgICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIG1haWx0byA9IFwibWFpbHRvOlwiO1xuICAgICAgICAgICAgICB2YXIgdXJsID0gLy8gPGhlbGxvQGV4YW1wbGUuY29tPiBpcyBwYXJzZWQgYXMgeyB1cmw6IFwibWFpbHRvOmhlbGxvQGV4YW1wbGUuY29tXCIgfVxuICAgICAgICAgICAgICBub2RlLnVybC5zdGFydHNXaXRoKG1haWx0bykgJiYgb3B0aW9ucy5vcmlnaW5hbFRleHQuc2xpY2Uobm9kZS5wb3NpdGlvbi5zdGFydC5vZmZzZXQgKyAxLCBub2RlLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldCArIDEgKyBtYWlsdG8ubGVuZ3RoKSAhPT0gbWFpbHRvID8gbm9kZS51cmwuc2xpY2UobWFpbHRvLmxlbmd0aCkgOiBub2RlLnVybDtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCRnKFtcIjxcIiwgdXJsLCBcIj5cIl0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBcIltcIjpcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQkZyhbXCJbXCIsIHByaW50Q2hpbGRyZW4kMihwYXRoLCBvcHRpb25zLCBwcmludCksIFwiXShcIiwgcHJpbnRVcmwobm9kZS51cmwsIFwiKVwiKSwgcHJpbnRUaXRsZShub2RlLnRpdGxlLCBvcHRpb25zKSwgXCIpXCJdKTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5vcmlnaW5hbFRleHQuc2xpY2Uobm9kZS5wb3NpdGlvbi5zdGFydC5vZmZzZXQsIG5vZGUucG9zaXRpb24uZW5kLm9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcImltYWdlXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZyhbXCIhW1wiLCBub2RlLmFsdCB8fCBcIlwiLCBcIl0oXCIsIHByaW50VXJsKG5vZGUudXJsLCBcIilcIiksIHByaW50VGl0bGUobm9kZS50aXRsZSwgb3B0aW9ucyksIFwiKVwiXSk7XG5cbiAgICAgIGNhc2UgXCJibG9ja3F1b3RlXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZyhbXCI+IFwiLCBhbGlnbiQyKFwiPiBcIiwgcHJpbnRDaGlsZHJlbiQyKHBhdGgsIG9wdGlvbnMsIHByaW50KSldKTtcblxuICAgICAgY2FzZSBcImhlYWRpbmdcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRnKFtcIiNcIi5yZXBlYXQobm9kZS5kZXB0aCkgKyBcIiBcIiwgcHJpbnRDaGlsZHJlbiQyKHBhdGgsIG9wdGlvbnMsIHByaW50KV0pO1xuXG4gICAgICBjYXNlIFwiY29kZVwiOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKG5vZGUuaXNJbmRlbnRlZCkge1xuICAgICAgICAgICAgLy8gaW5kZW50ZWQgY29kZSBibG9ja1xuICAgICAgICAgICAgdmFyIGFsaWdubWVudCA9IFwiIFwiLnJlcGVhdCg0KTtcbiAgICAgICAgICAgIHJldHVybiBhbGlnbiQyKGFsaWdubWVudCwgY29uY2F0JGcoW2FsaWdubWVudCwgY29uY2F0JGcocmVwbGFjZUVuZE9mTGluZVdpdGgkMihub2RlLnZhbHVlLCBoYXJkbGluZSRjKSldKSk7XG4gICAgICAgICAgfSAvLyBmZW5jZWQgY29kZSBibG9ja1xuXG5cbiAgICAgICAgICB2YXIgc3R5bGVVbml0ID0gb3B0aW9ucy5fX2luSnNUZW1wbGF0ZSA/IFwiflwiIDogXCJgXCI7XG5cbiAgICAgICAgICB2YXIgX3N0eWxlMiA9IHN0eWxlVW5pdC5yZXBlYXQoTWF0aC5tYXgoMywgdXRpbC5nZXRNYXhDb250aW51b3VzQ291bnQobm9kZS52YWx1ZSwgc3R5bGVVbml0KSArIDEpKTtcblxuICAgICAgICAgIHJldHVybiBjb25jYXQkZyhbX3N0eWxlMiwgbm9kZS5sYW5nIHx8IFwiXCIsIGhhcmRsaW5lJGMsIGNvbmNhdCRnKHJlcGxhY2VFbmRPZkxpbmVXaXRoJDIoZ2V0RmVuY2VkQ29kZUJsb2NrVmFsdWUkMihub2RlLCBvcHRpb25zLm9yaWdpbmFsVGV4dCksIGhhcmRsaW5lJGMpKSwgaGFyZGxpbmUkYywgX3N0eWxlMl0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJ5YW1sXCI6XG4gICAgICBjYXNlIFwidG9tbFwiOlxuICAgICAgICByZXR1cm4gb3B0aW9ucy5vcmlnaW5hbFRleHQuc2xpY2Uobm9kZS5wb3NpdGlvbi5zdGFydC5vZmZzZXQsIG5vZGUucG9zaXRpb24uZW5kLm9mZnNldCk7XG5cbiAgICAgIGNhc2UgXCJodG1sXCI6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3BhcmVudE5vZGUyID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG5cbiAgICAgICAgICB2YXIgdmFsdWUgPSBfcGFyZW50Tm9kZTIudHlwZSA9PT0gXCJyb290XCIgJiYgdXRpbC5nZXRMYXN0KF9wYXJlbnROb2RlMi5jaGlsZHJlbikgPT09IG5vZGUgPyBub2RlLnZhbHVlLnRyaW1SaWdodCgpIDogbm9kZS52YWx1ZTtcbiAgICAgICAgICB2YXIgaXNIdG1sQ29tbWVudCA9IC9ePCEtLVtcXHNcXFNdKi0tPiQvLnRlc3QodmFsdWUpO1xuICAgICAgICAgIHJldHVybiBjb25jYXQkZyhyZXBsYWNlRW5kT2ZMaW5lV2l0aCQyKHZhbHVlLCBpc0h0bWxDb21tZW50ID8gaGFyZGxpbmUkYyA6IG1hcmtBc1Jvb3QkNChsaXRlcmFsbGluZSQ2KSkpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJsaXN0XCI6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbnRoU2libGluZ0luZGV4ID0gZ2V0TnRoTGlzdFNpYmxpbmdJbmRleChub2RlLCBwYXRoLmdldFBhcmVudE5vZGUoKSk7XG4gICAgICAgICAgdmFyIGlzR2l0RGlmZkZyaWVuZGx5T3JkZXJlZExpc3QgPSBub2RlLm9yZGVyZWQgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPiAxICYmICtnZXRPcmRlcmVkTGlzdEl0ZW1JbmZvJDIobm9kZS5jaGlsZHJlblsxXSwgb3B0aW9ucy5vcmlnaW5hbFRleHQpLm51bWJlclRleHQgPT09IDE7XG4gICAgICAgICAgcmV0dXJuIHByaW50Q2hpbGRyZW4kMihwYXRoLCBvcHRpb25zLCBwcmludCwge1xuICAgICAgICAgICAgcHJvY2Vzc29yOiBmdW5jdGlvbiBwcm9jZXNzb3IoY2hpbGRQYXRoLCBpbmRleCkge1xuICAgICAgICAgICAgICB2YXIgcHJlZml4ID0gZ2V0UHJlZml4KCk7XG4gICAgICAgICAgICAgIHJldHVybiBjb25jYXQkZyhbcHJlZml4LCBhbGlnbiQyKFwiIFwiLnJlcGVhdChwcmVmaXgubGVuZ3RoKSwgcHJpbnRMaXN0SXRlbShjaGlsZFBhdGgsIG9wdGlvbnMsIHByaW50LCBwcmVmaXgpKV0pO1xuXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIGdldFByZWZpeCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmF3UHJlZml4ID0gbm9kZS5vcmRlcmVkID8gKGluZGV4ID09PSAwID8gbm9kZS5zdGFydCA6IGlzR2l0RGlmZkZyaWVuZGx5T3JkZXJlZExpc3QgPyAxIDogbm9kZS5zdGFydCArIGluZGV4KSArIChudGhTaWJsaW5nSW5kZXggJSAyID09PSAwID8gXCIuIFwiIDogXCIpIFwiKSA6IG50aFNpYmxpbmdJbmRleCAlIDIgPT09IDAgPyBcIi0gXCIgOiBcIiogXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuaXNBbGlnbmVkIHx8XG4gICAgICAgICAgICAgICAgLyogd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL3JlbWFya2pzL3JlbWFyay9pc3N1ZXMvMzE1ICovXG4gICAgICAgICAgICAgICAgbm9kZS5oYXNJbmRlbnRlZENvZGVibG9jayA/IGFsaWduTGlzdFByZWZpeChyYXdQcmVmaXgsIG9wdGlvbnMpIDogcmF3UHJlZml4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInRoZW1hdGljQnJlYWtcIjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBjb3VudGVyID0gZ2V0QW5jZXN0b3JDb3VudGVyJDEocGF0aCwgXCJsaXN0XCIpO1xuXG4gICAgICAgICAgaWYgKGNvdW50ZXIgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gXCItLS1cIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX250aFNpYmxpbmdJbmRleCA9IGdldE50aExpc3RTaWJsaW5nSW5kZXgocGF0aC5nZXRQYXJlbnROb2RlKGNvdW50ZXIpLCBwYXRoLmdldFBhcmVudE5vZGUoY291bnRlciArIDEpKTtcblxuICAgICAgICAgIHJldHVybiBfbnRoU2libGluZ0luZGV4ICUgMiA9PT0gMCA/IFwiKioqXCIgOiBcIi0tLVwiO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJsaW5rUmVmZXJlbmNlXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZyhbXCJbXCIsIHByaW50Q2hpbGRyZW4kMihwYXRoLCBvcHRpb25zLCBwcmludCksIFwiXVwiLCBub2RlLnJlZmVyZW5jZVR5cGUgPT09IFwiZnVsbFwiID8gY29uY2F0JGcoW1wiW1wiLCBub2RlLmlkZW50aWZpZXIsIFwiXVwiXSkgOiBub2RlLnJlZmVyZW5jZVR5cGUgPT09IFwiY29sbGFwc2VkXCIgPyBcIltdXCIgOiBcIlwiXSk7XG5cbiAgICAgIGNhc2UgXCJpbWFnZVJlZmVyZW5jZVwiOlxuICAgICAgICBzd2l0Y2ggKG5vZGUucmVmZXJlbmNlVHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJmdWxsXCI6XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0JGcoW1wiIVtcIiwgbm9kZS5hbHQgfHwgXCJcIiwgXCJdW1wiLCBub2RlLmlkZW50aWZpZXIsIFwiXVwiXSk7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCRnKFtcIiFbXCIsIG5vZGUuYWx0LCBcIl1cIiwgbm9kZS5yZWZlcmVuY2VUeXBlID09PSBcImNvbGxhcHNlZFwiID8gXCJbXVwiIDogXCJcIl0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJkZWZpbml0aW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGluZU9yU3BhY2UgPSBvcHRpb25zLnByb3NlV3JhcCA9PT0gXCJhbHdheXNcIiA/IGxpbmUkOCA6IFwiIFwiO1xuICAgICAgICAgIHJldHVybiBncm91cCRmKGNvbmNhdCRnKFtjb25jYXQkZyhbXCJbXCIsIG5vZGUuaWRlbnRpZmllciwgXCJdOlwiXSksIGluZGVudCQ5KGNvbmNhdCRnKFtsaW5lT3JTcGFjZSwgcHJpbnRVcmwobm9kZS51cmwpLCBub2RlLnRpdGxlID09PSBudWxsID8gXCJcIiA6IGNvbmNhdCRnKFtsaW5lT3JTcGFjZSwgcHJpbnRUaXRsZShub2RlLnRpdGxlLCBvcHRpb25zLCBmYWxzZSldKV0pKV0pKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiZm9vdG5vdGVcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRnKFtcIlteXCIsIHByaW50Q2hpbGRyZW4kMihwYXRoLCBvcHRpb25zLCBwcmludCksIFwiXVwiXSk7XG5cbiAgICAgIGNhc2UgXCJmb290bm90ZVJlZmVyZW5jZVwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGcoW1wiW15cIiwgbm9kZS5pZGVudGlmaWVyLCBcIl1cIl0pO1xuXG4gICAgICBjYXNlIFwiZm9vdG5vdGVEZWZpbml0aW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX25leHROb2RlMiA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpLmNoaWxkcmVuW3BhdGguZ2V0TmFtZSgpICsgMV07XG4gICAgICAgICAgdmFyIHNob3VsZElubGluZUZvb3Rub3RlID0gbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSBcInBhcmFncmFwaFwiICYmIChvcHRpb25zLnByb3NlV3JhcCA9PT0gXCJuZXZlclwiIHx8IG9wdGlvbnMucHJvc2VXcmFwID09PSBcInByZXNlcnZlXCIgJiYgbm9kZS5jaGlsZHJlblswXS5wb3NpdGlvbi5zdGFydC5saW5lID09PSBub2RlLmNoaWxkcmVuWzBdLnBvc2l0aW9uLmVuZC5saW5lKTtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JGcoW1wiW15cIiwgbm9kZS5pZGVudGlmaWVyLCBcIl06IFwiLCBzaG91bGRJbmxpbmVGb290bm90ZSA/IHByaW50Q2hpbGRyZW4kMihwYXRoLCBvcHRpb25zLCBwcmludCkgOiBncm91cCRmKGNvbmNhdCRnKFthbGlnbiQyKFwiIFwiLnJlcGVhdChvcHRpb25zLnRhYldpZHRoKSwgcHJpbnRDaGlsZHJlbiQyKHBhdGgsIG9wdGlvbnMsIHByaW50LCB7XG4gICAgICAgICAgICBwcm9jZXNzb3I6IGZ1bmN0aW9uIHByb2Nlc3NvcihjaGlsZFBhdGgsIGluZGV4KSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbmRleCA9PT0gMCA/IGdyb3VwJGYoY29uY2F0JGcoW3NvZnRsaW5lJDcsIHNvZnRsaW5lJDcsIGNoaWxkUGF0aC5jYWxsKHByaW50KV0pKSA6IGNoaWxkUGF0aC5jYWxsKHByaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSksIF9uZXh0Tm9kZTIgJiYgX25leHROb2RlMi50eXBlID09PSBcImZvb3Rub3RlRGVmaW5pdGlvblwiID8gc29mdGxpbmUkNyA6IFwiXCJdKSldKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwidGFibGVcIjpcbiAgICAgICAgcmV0dXJuIHByaW50VGFibGUocGF0aCwgb3B0aW9ucywgcHJpbnQpO1xuXG4gICAgICBjYXNlIFwidGFibGVDZWxsXCI6XG4gICAgICAgIHJldHVybiBwcmludENoaWxkcmVuJDIocGF0aCwgb3B0aW9ucywgcHJpbnQpO1xuXG4gICAgICBjYXNlIFwiYnJlYWtcIjpcbiAgICAgICAgcmV0dXJuIC9cXHMvLnRlc3Qob3B0aW9ucy5vcmlnaW5hbFRleHRbbm9kZS5wb3NpdGlvbi5zdGFydC5vZmZzZXRdKSA/IGNvbmNhdCRnKFtcIiAgXCIsIG1hcmtBc1Jvb3QkNChsaXRlcmFsbGluZSQ2KV0pIDogY29uY2F0JGcoW1wiXFxcXFwiLCBoYXJkbGluZSRjXSk7XG5cbiAgICAgIGNhc2UgXCJsaXF1aWROb2RlXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZyhyZXBsYWNlRW5kT2ZMaW5lV2l0aCQyKG5vZGUudmFsdWUsIGhhcmRsaW5lJGMpKTtcbiAgICAgIC8vIE1EWFxuXG4gICAgICBjYXNlIFwiaW1wb3J0RXhwb3J0XCI6XG4gICAgICBjYXNlIFwianN4XCI6XG4gICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgICAgLy8gZmFsbGJhY2sgdG8gdGhlIG9yaWdpbmFsIHRleHQgaWYgbXVsdGlwYXJzZXIgZmFpbGVkXG5cbiAgICAgIGNhc2UgXCJtYXRoXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZyhbXCIkJFwiLCBoYXJkbGluZSRjLCBub2RlLnZhbHVlID8gY29uY2F0JGcoW2NvbmNhdCRnKHJlcGxhY2VFbmRPZkxpbmVXaXRoJDIobm9kZS52YWx1ZSwgaGFyZGxpbmUkYykpLCBoYXJkbGluZSRjXSkgOiBcIlwiLCBcIiQkXCJdKTtcblxuICAgICAgY2FzZSBcImlubGluZU1hdGhcIjpcbiAgICAgICAge1xuICAgICAgICAgIC8vIHJlbWFyay1tYXRoIHRyaW1zIGNvbnRlbnQgYnV0IHdlIGRvbid0IHdhbnQgdG8gcmVtb3ZlIHdoaXRlc3BhY2VzXG4gICAgICAgICAgLy8gc2luY2UgaXQncyB2ZXJ5IHBvc3NpYmxlIHRoYXQgaXQncyByZWNvZ25pemVkIGFzIG1hdGggYWNjaWRlbnRhbGx5XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnMub3JpZ2luYWxUZXh0LnNsaWNlKG9wdGlvbnMubG9jU3RhcnQobm9kZSksIG9wdGlvbnMubG9jRW5kKG5vZGUpKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwidGFibGVSb3dcIjogLy8gaGFuZGxlZCBpbiBcInRhYmxlXCJcblxuICAgICAgY2FzZSBcImxpc3RJdGVtXCI6IC8vIGhhbmRsZWQgaW4gXCJsaXN0XCJcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBtYXJrZG93biB0eXBlIFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShub2RlLnR5cGUpKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRMaXN0SXRlbShwYXRoLCBvcHRpb25zLCBwcmludCwgbGlzdFByZWZpeCkge1xuICAgIHZhciBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIHZhciBwcmVmaXggPSBub2RlLmNoZWNrZWQgPT09IG51bGwgPyBcIlwiIDogbm9kZS5jaGVja2VkID8gXCJbeF0gXCIgOiBcIlsgXSBcIjtcbiAgICByZXR1cm4gY29uY2F0JGcoW3ByZWZpeCwgcHJpbnRDaGlsZHJlbiQyKHBhdGgsIG9wdGlvbnMsIHByaW50LCB7XG4gICAgICBwcm9jZXNzb3I6IGZ1bmN0aW9uIHByb2Nlc3NvcihjaGlsZFBhdGgsIGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gMCAmJiBjaGlsZFBhdGguZ2V0VmFsdWUoKS50eXBlICE9PSBcImxpc3RcIikge1xuICAgICAgICAgIHJldHVybiBhbGlnbiQyKFwiIFwiLnJlcGVhdChwcmVmaXgubGVuZ3RoKSwgY2hpbGRQYXRoLmNhbGwocHJpbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhbGlnbm1lbnQgPSBcIiBcIi5yZXBlYXQoY2xhbXAob3B0aW9ucy50YWJXaWR0aCAtIGxpc3RQcmVmaXgubGVuZ3RoLCAwLCAzKSAvLyA0KyB3aWxsIGNhdXNlIGluZGVudGVkIGNvZGUgYmxvY2tcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRnKFthbGlnbm1lbnQsIGFsaWduJDIoYWxpZ25tZW50LCBjaGlsZFBhdGguY2FsbChwcmludCkpXSk7XG4gICAgICB9XG4gICAgfSldKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFsaWduTGlzdFByZWZpeChwcmVmaXgsIG9wdGlvbnMpIHtcbiAgICB2YXIgYWRkaXRpb25hbFNwYWNlcyA9IGdldEFkZGl0aW9uYWxTcGFjZXMoKTtcbiAgICByZXR1cm4gcHJlZml4ICsgXCIgXCIucmVwZWF0KGFkZGl0aW9uYWxTcGFjZXMgPj0gNCA/IDAgOiBhZGRpdGlvbmFsU3BhY2VzIC8vIDQrIHdpbGwgY2F1c2UgaW5kZW50ZWQgY29kZSBibG9ja1xuICAgICk7XG5cbiAgICBmdW5jdGlvbiBnZXRBZGRpdGlvbmFsU3BhY2VzKCkge1xuICAgICAgdmFyIHJlc3RTcGFjZXMgPSBwcmVmaXgubGVuZ3RoICUgb3B0aW9ucy50YWJXaWR0aDtcbiAgICAgIHJldHVybiByZXN0U3BhY2VzID09PSAwID8gMCA6IG9wdGlvbnMudGFiV2lkdGggLSByZXN0U3BhY2VzO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE50aExpc3RTaWJsaW5nSW5kZXgobm9kZSwgcGFyZW50Tm9kZSkge1xuICAgIHJldHVybiBnZXROdGhTaWJsaW5nSW5kZXgobm9kZSwgcGFyZW50Tm9kZSwgZnVuY3Rpb24gKHNpYmxpbmdOb2RlKSB7XG4gICAgICByZXR1cm4gc2libGluZ05vZGUub3JkZXJlZCA9PT0gbm9kZS5vcmRlcmVkO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TnRoU2libGluZ0luZGV4KG5vZGUsIHBhcmVudE5vZGUsIGNvbmRpdGlvbikge1xuICAgIGNvbmRpdGlvbiA9IGNvbmRpdGlvbiB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIGluZGV4ID0gLTE7XG4gICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBwYXJlbnROb2RlLmNoaWxkcmVuW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICB2YXIgY2hpbGROb2RlID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgaWYgKGNoaWxkTm9kZS50eXBlID09PSBub2RlLnR5cGUgJiYgY29uZGl0aW9uKGNoaWxkTm9kZSkpIHtcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hpbGROb2RlID09PSBub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRBbmNlc3RvckNvdW50ZXIkMShwYXRoLCB0eXBlT3JUeXBlcykge1xuICAgIHZhciB0eXBlcyA9IFtdLmNvbmNhdCh0eXBlT3JUeXBlcyk7XG4gICAgdmFyIGNvdW50ZXIgPSAtMTtcbiAgICB2YXIgYW5jZXN0b3JOb2RlO1xuXG4gICAgd2hpbGUgKGFuY2VzdG9yTm9kZSA9IHBhdGguZ2V0UGFyZW50Tm9kZSgrK2NvdW50ZXIpKSB7XG4gICAgICBpZiAodHlwZXMuaW5kZXhPZihhbmNlc3Rvck5vZGUudHlwZSkgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBjb3VudGVyO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEFuY2VzdG9yTm9kZSQyKHBhdGgsIHR5cGVPclR5cGVzKSB7XG4gICAgdmFyIGNvdW50ZXIgPSBnZXRBbmNlc3RvckNvdW50ZXIkMShwYXRoLCB0eXBlT3JUeXBlcyk7XG4gICAgcmV0dXJuIGNvdW50ZXIgPT09IC0xID8gbnVsbCA6IHBhdGguZ2V0UGFyZW50Tm9kZShjb3VudGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50TGluZShwYXRoLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnByb3NlV3JhcCA9PT0gXCJwcmVzZXJ2ZVwiICYmIHZhbHVlID09PSBcIlxcblwiKSB7XG4gICAgICByZXR1cm4gaGFyZGxpbmUkYztcbiAgICB9XG5cbiAgICB2YXIgaXNCcmVha2FibGUgPSBvcHRpb25zLnByb3NlV3JhcCA9PT0gXCJhbHdheXNcIiAmJiAhZ2V0QW5jZXN0b3JOb2RlJDIocGF0aCwgU0lOR0xFX0xJTkVfTk9ERV9UWVBFUyk7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBcIlwiID8gaXNCcmVha2FibGUgPyBsaW5lJDggOiBcIiBcIiA6IGlzQnJlYWthYmxlID8gc29mdGxpbmUkNyA6IFwiXCI7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludFRhYmxlKHBhdGgsIG9wdGlvbnMsIHByaW50KSB7XG4gICAgdmFyIGhhcmRsaW5lV2l0aG91dEJyZWFrUGFyZW50ID0gaGFyZGxpbmUkYy5wYXJ0c1swXTtcbiAgICB2YXIgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICB2YXIgY29udGVudHMgPSBbXTsgLy8geyBbcm93SW5kZXg6IG51bWJlcl06IHsgW2NvbHVtbkluZGV4OiBudW1iZXJdOiBzdHJpbmcgfSB9XG5cbiAgICBwYXRoLm1hcChmdW5jdGlvbiAocm93UGF0aCkge1xuICAgICAgdmFyIHJvd0NvbnRlbnRzID0gW107XG4gICAgICByb3dQYXRoLm1hcChmdW5jdGlvbiAoY2VsbFBhdGgpIHtcbiAgICAgICAgcm93Q29udGVudHMucHVzaChwcmludERvY1RvU3RyaW5nJDIoY2VsbFBhdGguY2FsbChwcmludCksIG9wdGlvbnMpLmZvcm1hdHRlZCk7XG4gICAgICB9LCBcImNoaWxkcmVuXCIpO1xuICAgICAgY29udGVudHMucHVzaChyb3dDb250ZW50cyk7XG4gICAgfSwgXCJjaGlsZHJlblwiKTsgLy8gR2V0IHRoZSB3aWR0aCBvZiBlYWNoIGNvbHVtblxuXG4gICAgdmFyIGNvbHVtbk1heFdpZHRocyA9IGNvbnRlbnRzLnJlZHVjZShmdW5jdGlvbiAoY3VycmVudFdpZHRocywgcm93Q29udGVudHMpIHtcbiAgICAgIHJldHVybiBjdXJyZW50V2lkdGhzLm1hcChmdW5jdGlvbiAod2lkdGgsIGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh3aWR0aCwgdXRpbC5nZXRTdHJpbmdXaWR0aChyb3dDb250ZW50c1tjb2x1bW5JbmRleF0pKTtcbiAgICAgIH0pO1xuICAgIH0sIGNvbnRlbnRzWzBdLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gMztcbiAgICB9KSAvLyBtaW5pbXVtIHdpZHRoID0gMyAoLS0tLCA6LS0sIDotOiwgLS06KVxuICAgICk7XG4gICAgdmFyIGFsaWduZWRUYWJsZSA9IGpvaW4kYihoYXJkbGluZVdpdGhvdXRCcmVha1BhcmVudCwgW3ByaW50Um93KGNvbnRlbnRzWzBdKSwgcHJpbnRTZXBhcmF0b3IoKSwgam9pbiRiKGhhcmRsaW5lV2l0aG91dEJyZWFrUGFyZW50LCBjb250ZW50cy5zbGljZSgxKS5tYXAoZnVuY3Rpb24gKHJvd0NvbnRlbnRzKSB7XG4gICAgICByZXR1cm4gcHJpbnRSb3cocm93Q29udGVudHMpO1xuICAgIH0pKV0pO1xuXG4gICAgaWYgKG9wdGlvbnMucHJvc2VXcmFwICE9PSBcIm5ldmVyXCIpIHtcbiAgICAgIHJldHVybiBjb25jYXQkZyhbYnJlYWtQYXJlbnQkNCwgYWxpZ25lZFRhYmxlXSk7XG4gICAgfSAvLyBPbmx5IGlmIHRoZSAtLXByb3NlLXdyYXAgbmV2ZXIgaXMgc2V0IGFuZCBpdCBleGNlZWRzIHRoZSBwcmludCB3aWR0aC5cblxuXG4gICAgdmFyIGNvbXBhY3RUYWJsZSA9IGpvaW4kYihoYXJkbGluZVdpdGhvdXRCcmVha1BhcmVudCwgW3ByaW50Um93KGNvbnRlbnRzWzBdLFxuICAgIC8qIGlzQ29tcGFjdCAqL1xuICAgIHRydWUpLCBwcmludFNlcGFyYXRvcihcbiAgICAvKiBpc0NvbXBhY3QgKi9cbiAgICB0cnVlKSwgam9pbiRiKGhhcmRsaW5lV2l0aG91dEJyZWFrUGFyZW50LCBjb250ZW50cy5zbGljZSgxKS5tYXAoZnVuY3Rpb24gKHJvd0NvbnRlbnRzKSB7XG4gICAgICByZXR1cm4gcHJpbnRSb3cocm93Q29udGVudHMsXG4gICAgICAvKiBpc0NvbXBhY3QgKi9cbiAgICAgIHRydWUpO1xuICAgIH0pKV0pO1xuICAgIHJldHVybiBjb25jYXQkZyhbYnJlYWtQYXJlbnQkNCwgZ3JvdXAkZihpZkJyZWFrJDcoY29tcGFjdFRhYmxlLCBhbGlnbmVkVGFibGUpKV0pO1xuXG4gICAgZnVuY3Rpb24gcHJpbnRTZXBhcmF0b3IoaXNDb21wYWN0KSB7XG4gICAgICByZXR1cm4gY29uY2F0JGcoW1wifCBcIiwgam9pbiRiKFwiIHwgXCIsIGNvbHVtbk1heFdpZHRocy5tYXAoZnVuY3Rpb24gKHdpZHRoLCBpbmRleCkge1xuICAgICAgICB2YXIgc3BhY2VzID0gaXNDb21wYWN0ID8gMyA6IHdpZHRoO1xuXG4gICAgICAgIHN3aXRjaCAobm9kZS5hbGlnbltpbmRleF0pIHtcbiAgICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiOlwiICsgXCItXCIucmVwZWF0KHNwYWNlcyAtIDEpO1xuXG4gICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgICByZXR1cm4gXCItXCIucmVwZWF0KHNwYWNlcyAtIDEpICsgXCI6XCI7XG5cbiAgICAgICAgICBjYXNlIFwiY2VudGVyXCI6XG4gICAgICAgICAgICByZXR1cm4gXCI6XCIgKyBcIi1cIi5yZXBlYXQoc3BhY2VzIC0gMikgKyBcIjpcIjtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gXCItXCIucmVwZWF0KHNwYWNlcyk7XG4gICAgICAgIH1cbiAgICAgIH0pKSwgXCIgfFwiXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJpbnRSb3cocm93Q29udGVudHMsIGlzQ29tcGFjdCkge1xuICAgICAgcmV0dXJuIGNvbmNhdCRnKFtcInwgXCIsIGpvaW4kYihcIiB8IFwiLCBpc0NvbXBhY3QgPyByb3dDb250ZW50cyA6IHJvd0NvbnRlbnRzLm1hcChmdW5jdGlvbiAocm93Q29udGVudCwgY29sdW1uSW5kZXgpIHtcbiAgICAgICAgc3dpdGNoIChub2RlLmFsaWduW2NvbHVtbkluZGV4XSkge1xuICAgICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgICAgcmV0dXJuIGFsaWduUmlnaHQocm93Q29udGVudCwgY29sdW1uTWF4V2lkdGhzW2NvbHVtbkluZGV4XSk7XG5cbiAgICAgICAgICBjYXNlIFwiY2VudGVyXCI6XG4gICAgICAgICAgICByZXR1cm4gYWxpZ25DZW50ZXIocm93Q29udGVudCwgY29sdW1uTWF4V2lkdGhzW2NvbHVtbkluZGV4XSk7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGFsaWduTGVmdChyb3dDb250ZW50LCBjb2x1bW5NYXhXaWR0aHNbY29sdW1uSW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgfSkpLCBcIiB8XCJdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhbGlnbkxlZnQodGV4dCwgd2lkdGgpIHtcbiAgICAgIHZhciBzcGFjZXMgPSB3aWR0aCAtIHV0aWwuZ2V0U3RyaW5nV2lkdGgodGV4dCk7XG4gICAgICByZXR1cm4gY29uY2F0JGcoW3RleHQsIFwiIFwiLnJlcGVhdChzcGFjZXMpXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWxpZ25SaWdodCh0ZXh0LCB3aWR0aCkge1xuICAgICAgdmFyIHNwYWNlcyA9IHdpZHRoIC0gdXRpbC5nZXRTdHJpbmdXaWR0aCh0ZXh0KTtcbiAgICAgIHJldHVybiBjb25jYXQkZyhbXCIgXCIucmVwZWF0KHNwYWNlcyksIHRleHRdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhbGlnbkNlbnRlcih0ZXh0LCB3aWR0aCkge1xuICAgICAgdmFyIHNwYWNlcyA9IHdpZHRoIC0gdXRpbC5nZXRTdHJpbmdXaWR0aCh0ZXh0KTtcbiAgICAgIHZhciBsZWZ0ID0gTWF0aC5mbG9vcihzcGFjZXMgLyAyKTtcbiAgICAgIHZhciByaWdodCA9IHNwYWNlcyAtIGxlZnQ7XG4gICAgICByZXR1cm4gY29uY2F0JGcoW1wiIFwiLnJlcGVhdChsZWZ0KSwgdGV4dCwgXCIgXCIucmVwZWF0KHJpZ2h0KV0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50Um9vdChwYXRoLCBvcHRpb25zLCBwcmludCkge1xuICAgIC8qKiBAdHlwZWRlZiB7eyBpbmRleDogbnVtYmVyLCBvZmZzZXQ6IG51bWJlciB9fSBJZ25vcmVQb3NpdGlvbiAqL1xuXG4gICAgLyoqIEB0eXBlIHtBcnJheTx7c3RhcnQ6IElnbm9yZVBvc2l0aW9uLCBlbmQ6IElnbm9yZVBvc2l0aW9ufT59ICovXG4gICAgdmFyIGlnbm9yZVJhbmdlcyA9IFtdO1xuICAgIC8qKiBAdHlwZSB7SWdub3JlUG9zaXRpb24gfCBudWxsfSAqL1xuXG4gICAgdmFyIGlnbm9yZVN0YXJ0ID0gbnVsbDtcbiAgICB2YXIgY2hpbGRyZW4gPSBwYXRoLmdldFZhbHVlKCkuY2hpbGRyZW47XG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGROb2RlLCBpbmRleCkge1xuICAgICAgc3dpdGNoIChpc1ByZXR0aWVySWdub3JlJDEoY2hpbGROb2RlKSkge1xuICAgICAgICBjYXNlIFwic3RhcnRcIjpcbiAgICAgICAgICBpZiAoaWdub3JlU3RhcnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlnbm9yZVN0YXJ0ID0ge1xuICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgIG9mZnNldDogY2hpbGROb2RlLnBvc2l0aW9uLmVuZC5vZmZzZXRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgIGlmIChpZ25vcmVTdGFydCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWdub3JlUmFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICBzdGFydDogaWdub3JlU3RhcnQsXG4gICAgICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IGNoaWxkTm9kZS5wb3NpdGlvbi5zdGFydC5vZmZzZXRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZ25vcmVTdGFydCA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHByaW50Q2hpbGRyZW4kMihwYXRoLCBvcHRpb25zLCBwcmludCwge1xuICAgICAgcHJvY2Vzc29yOiBmdW5jdGlvbiBwcm9jZXNzb3IoY2hpbGRQYXRoLCBpbmRleCkge1xuICAgICAgICBpZiAoaWdub3JlUmFuZ2VzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHZhciBpZ25vcmVSYW5nZSA9IGlnbm9yZVJhbmdlc1swXTtcblxuICAgICAgICAgIGlmIChpbmRleCA9PT0gaWdub3JlUmFuZ2Uuc3RhcnQuaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQkZyhbY2hpbGRyZW5baWdub3JlUmFuZ2Uuc3RhcnQuaW5kZXhdLnZhbHVlLCBvcHRpb25zLm9yaWdpbmFsVGV4dC5zbGljZShpZ25vcmVSYW5nZS5zdGFydC5vZmZzZXQsIGlnbm9yZVJhbmdlLmVuZC5vZmZzZXQpLCBjaGlsZHJlbltpZ25vcmVSYW5nZS5lbmQuaW5kZXhdLnZhbHVlXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlnbm9yZVJhbmdlLnN0YXJ0LmluZGV4IDwgaW5kZXggJiYgaW5kZXggPCBpZ25vcmVSYW5nZS5lbmQuaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaW5kZXggPT09IGlnbm9yZVJhbmdlLmVuZC5pbmRleCkge1xuICAgICAgICAgICAgaWdub3JlUmFuZ2VzLnNoaWZ0KCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkUGF0aC5jYWxsKHByaW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50Q2hpbGRyZW4kMihwYXRoLCBvcHRpb25zLCBwcmludCwgZXZlbnRzKSB7XG4gICAgZXZlbnRzID0gZXZlbnRzIHx8IHt9O1xuICAgIHZhciBwb3N0cHJvY2Vzc29yID0gZXZlbnRzLnBvc3Rwcm9jZXNzb3IgfHwgY29uY2F0JGc7XG5cbiAgICB2YXIgcHJvY2Vzc29yID0gZXZlbnRzLnByb2Nlc3NvciB8fCBmdW5jdGlvbiAoY2hpbGRQYXRoKSB7XG4gICAgICByZXR1cm4gY2hpbGRQYXRoLmNhbGwocHJpbnQpO1xuICAgIH07XG5cbiAgICB2YXIgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICB2YXIgbGFzdENoaWxkTm9kZTtcbiAgICBwYXRoLm1hcChmdW5jdGlvbiAoY2hpbGRQYXRoLCBpbmRleCkge1xuICAgICAgdmFyIGNoaWxkTm9kZSA9IGNoaWxkUGF0aC5nZXRWYWx1ZSgpO1xuICAgICAgdmFyIHJlc3VsdCA9IHByb2Nlc3NvcihjaGlsZFBhdGgsIGluZGV4KTtcblxuICAgICAgaWYgKHJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgcGFydHM6IHBhcnRzLFxuICAgICAgICAgIHByZXZOb2RlOiBsYXN0Q2hpbGROb2RlLFxuICAgICAgICAgIHBhcmVudE5vZGU6IG5vZGUsXG4gICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghc2hvdWxkTm90UHJlUHJpbnRIYXJkbGluZShjaGlsZE5vZGUsIGRhdGEpKSB7XG4gICAgICAgICAgcGFydHMucHVzaChoYXJkbGluZSRjKTtcblxuICAgICAgICAgIGlmIChsYXN0Q2hpbGROb2RlICYmIFRSQUlMSU5HX0hBUkRMSU5FX05PREVTLmluZGV4T2YobGFzdENoaWxkTm9kZS50eXBlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChzaG91bGRQcmVQcmludFRyaXBsZUhhcmRsaW5lKGNoaWxkTm9kZSwgZGF0YSkpIHtcbiAgICAgICAgICAgICAgcGFydHMucHVzaChoYXJkbGluZSRjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNob3VsZFByZVByaW50RG91YmxlSGFyZGxpbmUoY2hpbGROb2RlLCBkYXRhKSB8fCBzaG91bGRQcmVQcmludFRyaXBsZUhhcmRsaW5lKGNoaWxkTm9kZSwgZGF0YSkpIHtcbiAgICAgICAgICAgICAgcGFydHMucHVzaChoYXJkbGluZSRjKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNob3VsZFByZVByaW50VHJpcGxlSGFyZGxpbmUoY2hpbGROb2RlLCBkYXRhKSkge1xuICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGhhcmRsaW5lJGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgbGFzdENoaWxkTm9kZSA9IGNoaWxkTm9kZTtcbiAgICAgIH1cbiAgICB9LCBcImNoaWxkcmVuXCIpO1xuICAgIHJldHVybiBwb3N0cHJvY2Vzc29yKHBhcnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExhc3REZXNjZW5kYW50Tm9kZShub2RlKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBub2RlO1xuXG4gICAgd2hpbGUgKGN1cnJlbnQuY2hpbGRyZW4gJiYgY3VycmVudC5jaGlsZHJlbi5sZW5ndGggIT09IDApIHtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmNoaWxkcmVuW2N1cnJlbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cbiAgLyoqIEByZXR1cm4ge2ZhbHNlIHwgJ25leHQnIHwgJ3N0YXJ0JyB8ICdlbmQnfSAqL1xuXG5cbiAgZnVuY3Rpb24gaXNQcmV0dGllcklnbm9yZSQxKG5vZGUpIHtcbiAgICBpZiAobm9kZS50eXBlICE9PSBcImh0bWxcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBtYXRjaCA9IG5vZGUudmFsdWUubWF0Y2goL148IS0tXFxzKnByZXR0aWVyLWlnbm9yZSg/Oi0oc3RhcnR8ZW5kKSk/XFxzKi0tPiQvKTtcbiAgICByZXR1cm4gbWF0Y2ggPT09IG51bGwgPyBmYWxzZSA6IG1hdGNoWzFdID8gbWF0Y2hbMV0gOiBcIm5leHRcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSW5saW5lTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgSU5MSU5FX05PREVfVFlQRVMkMS5pbmRleE9mKG5vZGUudHlwZSkgIT09IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNFbmRzV2l0aEhhcmRMaW5lKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAmJiAvXFxuKyQvLnRlc3Qobm9kZS52YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBsYXN0KG5vZGVzKSB7XG4gICAgcmV0dXJuIG5vZGVzICYmIG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkTm90UHJlUHJpbnRIYXJkbGluZShub2RlLCBfcmVmKSB7XG4gICAgdmFyIHBhcmVudE5vZGUgPSBfcmVmLnBhcmVudE5vZGUsXG4gICAgICAgIHBhcnRzID0gX3JlZi5wYXJ0cyxcbiAgICAgICAgcHJldk5vZGUgPSBfcmVmLnByZXZOb2RlO1xuICAgIHZhciBpc0ZpcnN0Tm9kZSA9IHBhcnRzLmxlbmd0aCA9PT0gMDtcbiAgICB2YXIgaXNJbmxpbmVIVE1MID0gbm9kZS50eXBlID09PSBcImh0bWxcIiAmJiBJTkxJTkVfTk9ERV9XUkFQUEVSX1RZUEVTJDEuaW5kZXhPZihwYXJlbnROb2RlLnR5cGUpICE9PSAtMTtcbiAgICB2YXIgaXNBZnRlckhhcmRsaW5lTm9kZSA9IHByZXZOb2RlICYmIChpc0VuZHNXaXRoSGFyZExpbmUocHJldk5vZGUpIHx8IGlzRW5kc1dpdGhIYXJkTGluZShsYXN0KHByZXZOb2RlLmNoaWxkcmVuKSkpO1xuICAgIHJldHVybiBpc0ZpcnN0Tm9kZSB8fCBpc0lubGluZU5vZGUobm9kZSkgfHwgaXNJbmxpbmVIVE1MIHx8IGlzQWZ0ZXJIYXJkbGluZU5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRQcmVQcmludERvdWJsZUhhcmRsaW5lKG5vZGUsIF9yZWYyKSB7XG4gICAgdmFyIHBhcmVudE5vZGUgPSBfcmVmMi5wYXJlbnROb2RlLFxuICAgICAgICBwcmV2Tm9kZSA9IF9yZWYyLnByZXZOb2RlO1xuICAgIHZhciBwcmV2Tm9kZVR5cGUgPSBwcmV2Tm9kZSAmJiBwcmV2Tm9kZS50eXBlO1xuICAgIHZhciBub2RlVHlwZSA9IG5vZGUudHlwZTtcbiAgICB2YXIgaXNTZXF1ZW5jZSA9IHByZXZOb2RlVHlwZSA9PT0gbm9kZVR5cGU7XG4gICAgdmFyIGlzU2libGluZ05vZGUgPSBpc1NlcXVlbmNlICYmIFNJQkxJTkdfTk9ERV9UWVBFUy5pbmRleE9mKG5vZGVUeXBlKSAhPT0gLTE7XG4gICAgdmFyIGlzSW5UaWdodExpc3RJdGVtID0gcGFyZW50Tm9kZS50eXBlID09PSBcImxpc3RJdGVtXCIgJiYgIXBhcmVudE5vZGUubG9vc2U7XG4gICAgdmFyIGlzUHJldk5vZGVMb29zZUxpc3RJdGVtID0gcHJldk5vZGVUeXBlID09PSBcImxpc3RJdGVtXCIgJiYgcHJldk5vZGUubG9vc2U7XG4gICAgdmFyIGlzUHJldk5vZGVQcmV0dGllcklnbm9yZSA9IGlzUHJldHRpZXJJZ25vcmUkMShwcmV2Tm9kZSkgPT09IFwibmV4dFwiO1xuICAgIHZhciBpc0Jsb2NrSHRtbFdpdGhvdXRCbGFua0xpbmVCZXR3ZWVuUHJldkh0bWwgPSBub2RlVHlwZSA9PT0gXCJodG1sXCIgJiYgcHJldk5vZGVUeXBlID09PSBcImh0bWxcIiAmJiBwcmV2Tm9kZS5wb3NpdGlvbi5lbmQubGluZSArIDEgPT09IG5vZGUucG9zaXRpb24uc3RhcnQubGluZTtcbiAgICB2YXIgaXNKc3hJbmxpbmVTaWJsaW5nID0gcHJldk5vZGVUeXBlID09PSBcImpzeFwiICYmIGlzSW5saW5lTm9kZShub2RlKSB8fCBub2RlVHlwZSA9PT0gXCJqc3hcIiAmJiBpc0lubGluZU5vZGUocHJldk5vZGUpO1xuICAgIHJldHVybiBpc1ByZXZOb2RlTG9vc2VMaXN0SXRlbSB8fCAhKGlzU2libGluZ05vZGUgfHwgaXNJblRpZ2h0TGlzdEl0ZW0gfHwgaXNQcmV2Tm9kZVByZXR0aWVySWdub3JlIHx8IGlzQmxvY2tIdG1sV2l0aG91dEJsYW5rTGluZUJldHdlZW5QcmV2SHRtbCB8fCBpc0pzeElubGluZVNpYmxpbmcpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkUHJlUHJpbnRUcmlwbGVIYXJkbGluZShub2RlLCBkYXRhKSB7XG4gICAgdmFyIGlzUHJldk5vZGVMaXN0ID0gZGF0YS5wcmV2Tm9kZSAmJiBkYXRhLnByZXZOb2RlLnR5cGUgPT09IFwibGlzdFwiO1xuICAgIHZhciBpc0luZGVudGVkQ29kZSA9IG5vZGUudHlwZSA9PT0gXCJjb2RlXCIgJiYgbm9kZS5pc0luZGVudGVkO1xuICAgIHJldHVybiBpc1ByZXZOb2RlTGlzdCAmJiBpc0luZGVudGVkQ29kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZFJlbWFpblRoZVNhbWVDb250ZW50KHBhdGgpIHtcbiAgICB2YXIgYW5jZXN0b3JOb2RlID0gZ2V0QW5jZXN0b3JOb2RlJDIocGF0aCwgW1wibGlua1JlZmVyZW5jZVwiLCBcImltYWdlUmVmZXJlbmNlXCJdKTtcbiAgICByZXR1cm4gYW5jZXN0b3JOb2RlICYmIChhbmNlc3Rvck5vZGUudHlwZSAhPT0gXCJsaW5rUmVmZXJlbmNlXCIgfHwgYW5jZXN0b3JOb2RlLnJlZmVyZW5jZVR5cGUgIT09IFwiZnVsbFwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZURvYyhkb2MpIHtcbiAgICByZXR1cm4gbWFwRG9jJDcoZG9jLCBmdW5jdGlvbiAoY3VycmVudERvYykge1xuICAgICAgaWYgKCFjdXJyZW50RG9jLnBhcnRzKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50RG9jO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudERvYy50eXBlID09PSBcImNvbmNhdFwiICYmIGN1cnJlbnREb2MucGFydHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50RG9jLnBhcnRzWzBdO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFydHMgPSBbXTtcbiAgICAgIGN1cnJlbnREb2MucGFydHMuZm9yRWFjaChmdW5jdGlvbiAocGFydCkge1xuICAgICAgICBpZiAocGFydC50eXBlID09PSBcImNvbmNhdFwiKSB7XG4gICAgICAgICAgcGFydHMucHVzaC5hcHBseShwYXJ0cywgcGFydC5wYXJ0cyk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFydCAhPT0gXCJcIikge1xuICAgICAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGN1cnJlbnREb2MsIHtcbiAgICAgICAgcGFydHM6IG5vcm1hbGl6ZVBhcnRzJDIocGFydHMpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50VXJsKHVybCwgZGFuZ2Vyb3VzQ2hhck9yQ2hhcnMpIHtcbiAgICB2YXIgZGFuZ2Vyb3VzQ2hhcnMgPSBbXCIgXCJdLmNvbmNhdChkYW5nZXJvdXNDaGFyT3JDaGFycyB8fCBbXSk7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoZGFuZ2Vyb3VzQ2hhcnMubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gXCJcXFxcXCIuY29uY2F0KHgpO1xuICAgIH0pLmpvaW4oXCJ8XCIpKS50ZXN0KHVybCkgPyBcIjxcIi5jb25jYXQodXJsLCBcIj5cIikgOiB1cmw7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludFRpdGxlKHRpdGxlLCBvcHRpb25zLCBwcmludFNwYWNlKSB7XG4gICAgaWYgKHByaW50U3BhY2UgPT0gbnVsbCkge1xuICAgICAgcHJpbnRTcGFjZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCF0aXRsZSkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgaWYgKHByaW50U3BhY2UpIHtcbiAgICAgIHJldHVybiBcIiBcIiArIHByaW50VGl0bGUodGl0bGUsIG9wdGlvbnMsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAodGl0bGUuaW5jbHVkZXMoJ1wiJykgJiYgdGl0bGUuaW5jbHVkZXMoXCInXCIpICYmICF0aXRsZS5pbmNsdWRlcyhcIilcIikpIHtcbiAgICAgIHJldHVybiBcIihcIi5jb25jYXQodGl0bGUsIFwiKVwiKTsgLy8gYXZvaWQgZXNjYXBlZCBxdW90ZXNcbiAgICB9IC8vIGZhc3RlciB0aGFuIHVzaW5nIFJlZ0V4cHM6IGh0dHBzOi8vanNwZXJmLmNvbS9wZXJmb3JtYW5jZS1vZi1tYXRjaC12cy1zcGxpdFxuXG5cbiAgICB2YXIgc2luZ2xlQ291bnQgPSB0aXRsZS5zcGxpdChcIidcIikubGVuZ3RoIC0gMTtcbiAgICB2YXIgZG91YmxlQ291bnQgPSB0aXRsZS5zcGxpdCgnXCInKS5sZW5ndGggLSAxO1xuICAgIHZhciBxdW90ZSA9IHNpbmdsZUNvdW50ID4gZG91YmxlQ291bnQgPyAnXCInIDogZG91YmxlQ291bnQgPiBzaW5nbGVDb3VudCA/IFwiJ1wiIDogb3B0aW9ucy5zaW5nbGVRdW90ZSA/IFwiJ1wiIDogJ1wiJztcbiAgICB0aXRsZSA9IHRpdGxlLnJlcGxhY2UobmV3IFJlZ0V4cChcIihcIi5jb25jYXQocXVvdGUsIFwiKVwiKSwgXCJnXCIpLCBcIlxcXFwkMVwiKTtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQocXVvdGUpLmNvbmNhdCh0aXRsZSkuY29uY2F0KHF1b3RlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVBhcnRzJDIocGFydHMpIHtcbiAgICByZXR1cm4gcGFydHMucmVkdWNlKGZ1bmN0aW9uIChjdXJyZW50LCBwYXJ0KSB7XG4gICAgICB2YXIgbGFzdFBhcnQgPSB1dGlsLmdldExhc3QoY3VycmVudCk7XG5cbiAgICAgIGlmICh0eXBlb2YgbGFzdFBhcnQgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHBhcnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY3VycmVudC5zcGxpY2UoLTEsIDEsIGxhc3RQYXJ0ICsgcGFydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50LnB1c2gocGFydCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH0sIFtdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4sIG1heCkge1xuICAgIHJldHVybiB2YWx1ZSA8IG1pbiA/IG1pbiA6IHZhbHVlID4gbWF4ID8gbWF4IDogdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbiQ2KGFzdCwgbmV3T2JqLCBwYXJlbnQpIHtcbiAgICBkZWxldGUgbmV3T2JqLnBvc2l0aW9uO1xuICAgIGRlbGV0ZSBuZXdPYmoucmF3OyAvLyBmcm9udC1tYXR0ZXJcbiAgICAvLyBmb3IgY29kZWJsb2NrXG5cbiAgICBpZiAoYXN0LnR5cGUgPT09IFwiY29kZVwiIHx8IGFzdC50eXBlID09PSBcInlhbWxcIiB8fCBhc3QudHlwZSA9PT0gXCJpbXBvcnRcIiB8fCBhc3QudHlwZSA9PT0gXCJleHBvcnRcIiB8fCBhc3QudHlwZSA9PT0gXCJqc3hcIikge1xuICAgICAgZGVsZXRlIG5ld09iai52YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoYXN0LnR5cGUgPT09IFwibGlzdFwiKSB7XG4gICAgICBkZWxldGUgbmV3T2JqLmlzQWxpZ25lZDtcbiAgICB9IC8vIHRleHRzIGNhbiBiZSBzcGxpdHRlZCBvciBtZXJnZWRcblxuXG4gICAgaWYgKGFzdC50eXBlID09PSBcInRleHRcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGFzdC50eXBlID09PSBcImlubGluZUNvZGVcIikge1xuICAgICAgbmV3T2JqLnZhbHVlID0gYXN0LnZhbHVlLnJlcGxhY2UoL1sgXFx0XFxuXSsvZywgXCIgXCIpO1xuICAgIH0gLy8gZm9yIGluc2VydCBwcmFnbWFcblxuXG4gICAgaWYgKHBhcmVudCAmJiBwYXJlbnQudHlwZSA9PT0gXCJyb290XCIgJiYgcGFyZW50LmNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgKHBhcmVudC5jaGlsZHJlblswXSA9PT0gYXN0IHx8IChwYXJlbnQuY2hpbGRyZW5bMF0udHlwZSA9PT0gXCJ5YW1sXCIgfHwgcGFyZW50LmNoaWxkcmVuWzBdLnR5cGUgPT09IFwidG9tbFwiKSAmJiBwYXJlbnQuY2hpbGRyZW5bMV0gPT09IGFzdCkgJiYgYXN0LnR5cGUgPT09IFwiaHRtbFwiICYmIHByYWdtYSQ0LnN0YXJ0V2l0aFByYWdtYShhc3QudmFsdWUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYXNQcmV0dGllcklnbm9yZSQ0KHBhdGgpIHtcbiAgICB2YXIgaW5kZXggPSArcGF0aC5nZXROYW1lKCk7XG5cbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcHJldk5vZGUgPSBwYXRoLmdldFBhcmVudE5vZGUoKS5jaGlsZHJlbltpbmRleCAtIDFdO1xuICAgIHJldHVybiBpc1ByZXR0aWVySWdub3JlJDEocHJldk5vZGUpID09PSBcIm5leHRcIjtcbiAgfVxuXG4gIHZhciBwcmludGVyTWFya2Rvd24gPSB7XG4gICAgcHJlcHJvY2VzczogcHJlcHJvY2Vzc18xJDIsXG4gICAgcHJpbnQ6IGdlbmVyaWNQcmludCQ1LFxuICAgIGVtYmVkOiBlbWJlZF8xJDIsXG4gICAgbWFzc2FnZUFzdE5vZGU6IGNsZWFuJDYsXG4gICAgaGFzUHJldHRpZXJJZ25vcmU6IGhhc1ByZXR0aWVySWdub3JlJDQsXG4gICAgaW5zZXJ0UHJhZ21hOiBwcmFnbWEkNC5pbnNlcnRQcmFnbWFcbiAgfTtcblxuICB2YXIgb3B0aW9ucyQ2ID0ge1xuICAgIHByb3NlV3JhcDogY29tbW9uT3B0aW9ucy5wcm9zZVdyYXAsXG4gICAgc2luZ2xlUXVvdGU6IGNvbW1vbk9wdGlvbnMuc2luZ2xlUXVvdGVcbiAgfTtcblxuICB2YXIgbmFtZSRnID0gXCJNYXJrZG93blwiO1xuICB2YXIgdHlwZSRmID0gXCJwcm9zZVwiO1xuICB2YXIgYWxpYXNlcyQ1ID0gW1xuICBcdFwicGFuZG9jXCJcbiAgXTtcbiAgdmFyIGFjZU1vZGUkZiA9IFwibWFya2Rvd25cIjtcbiAgdmFyIGNvZGVtaXJyb3JNb2RlJGIgPSBcImdmbVwiO1xuICB2YXIgY29kZW1pcnJvck1pbWVUeXBlJGIgPSBcInRleHQveC1nZm1cIjtcbiAgdmFyIHdyYXAgPSB0cnVlO1xuICB2YXIgZXh0ZW5zaW9ucyRmID0gW1xuICBcdFwiLm1kXCIsXG4gIFx0XCIubWFya2Rvd25cIixcbiAgXHRcIi5tZG93blwiLFxuICBcdFwiLm1kd25cIixcbiAgXHRcIi5tZHhcIixcbiAgXHRcIi5ta2RcIixcbiAgXHRcIi5ta2RuXCIsXG4gIFx0XCIubWtkb3duXCIsXG4gIFx0XCIucm9ublwiLFxuICBcdFwiLndvcmtib29rXCJcbiAgXTtcbiAgdmFyIGZpbGVuYW1lcyQzID0gW1xuICBcdFwiY29udGVudHMubHJcIlxuICBdO1xuICB2YXIgdG1TY29wZSRmID0gXCJzb3VyY2UuZ2ZtXCI7XG4gIHZhciBsYW5ndWFnZUlkJGYgPSAyMjI7XG4gIHZhciBNYXJrZG93biA9IHtcbiAgXHRuYW1lOiBuYW1lJGcsXG4gIFx0dHlwZTogdHlwZSRmLFxuICBcdGFsaWFzZXM6IGFsaWFzZXMkNSxcbiAgXHRhY2VNb2RlOiBhY2VNb2RlJGYsXG4gIFx0Y29kZW1pcnJvck1vZGU6IGNvZGVtaXJyb3JNb2RlJGIsXG4gIFx0Y29kZW1pcnJvck1pbWVUeXBlOiBjb2RlbWlycm9yTWltZVR5cGUkYixcbiAgXHR3cmFwOiB3cmFwLFxuICBcdGV4dGVuc2lvbnM6IGV4dGVuc2lvbnMkZixcbiAgXHRmaWxlbmFtZXM6IGZpbGVuYW1lcyQzLFxuICBcdHRtU2NvcGU6IHRtU2NvcGUkZixcbiAgXHRsYW5ndWFnZUlkOiBsYW5ndWFnZUlkJGZcbiAgfTtcblxuICB2YXIgTWFya2Rvd24kMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgbmFtZTogbmFtZSRnLFxuICAgIHR5cGU6IHR5cGUkZixcbiAgICBhbGlhc2VzOiBhbGlhc2VzJDUsXG4gICAgYWNlTW9kZTogYWNlTW9kZSRmLFxuICAgIGNvZGVtaXJyb3JNb2RlOiBjb2RlbWlycm9yTW9kZSRiLFxuICAgIGNvZGVtaXJyb3JNaW1lVHlwZTogY29kZW1pcnJvck1pbWVUeXBlJGIsXG4gICAgd3JhcDogd3JhcCxcbiAgICBleHRlbnNpb25zOiBleHRlbnNpb25zJGYsXG4gICAgZmlsZW5hbWVzOiBmaWxlbmFtZXMkMyxcbiAgICB0bVNjb3BlOiB0bVNjb3BlJGYsXG4gICAgbGFuZ3VhZ2VJZDogbGFuZ3VhZ2VJZCRmLFxuICAgICdkZWZhdWx0JzogTWFya2Rvd25cbiAgfSk7XG5cbiAgdmFyIHJlcXVpcmUkJDAkNyA9IGdldENqc0V4cG9ydEZyb21OYW1lc3BhY2UoTWFya2Rvd24kMSk7XG5cbiAgdmFyIGxhbmd1YWdlcyQ1ID0gW2NyZWF0ZUxhbmd1YWdlKHJlcXVpcmUkJDAkNywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkYXRhLCB7XG4gICAgICBzaW5jZTogXCIxLjguMFwiLFxuICAgICAgcGFyc2VyczogW1wicmVtYXJrXCJdLFxuICAgICAgdnNjb2RlTGFuZ3VhZ2VJZHM6IFtcIm1hcmtkb3duXCJdLFxuICAgICAgZmlsZW5hbWVzOiBkYXRhLmZpbGVuYW1lcy5jb25jYXQoW1wiUkVBRE1FXCJdKSxcbiAgICAgIGV4dGVuc2lvbnM6IGRhdGEuZXh0ZW5zaW9ucy5maWx0ZXIoZnVuY3Rpb24gKGV4dGVuc2lvbikge1xuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uICE9PSBcIi5tZHhcIjtcbiAgICAgIH0pXG4gICAgfSk7XG4gIH0pLCBjcmVhdGVMYW5ndWFnZShyZXF1aXJlJCQwJDcsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZGF0YSwge1xuICAgICAgbmFtZTogXCJNRFhcIixcbiAgICAgIHNpbmNlOiBcIjEuMTUuMFwiLFxuICAgICAgcGFyc2VyczogW1wibWR4XCJdLFxuICAgICAgdnNjb2RlTGFuZ3VhZ2VJZHM6IFtcIm1keFwiXSxcbiAgICAgIGZpbGVuYW1lczogW10sXG4gICAgICBleHRlbnNpb25zOiBbXCIubWR4XCJdXG4gICAgfSk7XG4gIH0pXTtcbiAgdmFyIHByaW50ZXJzJDUgPSB7XG4gICAgbWRhc3Q6IHByaW50ZXJNYXJrZG93blxuICB9O1xuICB2YXIgbGFuZ3VhZ2VNYXJrZG93biA9IHtcbiAgICBsYW5ndWFnZXM6IGxhbmd1YWdlcyQ1LFxuICAgIG9wdGlvbnM6IG9wdGlvbnMkNixcbiAgICBwcmludGVyczogcHJpbnRlcnMkNVxuICB9O1xuXG4gIGZ1bmN0aW9uIGlzUHJhZ21hKHRleHQpIHtcbiAgICByZXR1cm4gL15cXHMqQChwcmV0dGllcnxmb3JtYXQpXFxzKiQvLnRlc3QodGV4dCk7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNQcmFnbWEkNCh0ZXh0KSB7XG4gICAgcmV0dXJuIC9eXFxzKiNbXlxcblxcU10qQChwcmV0dGllcnxmb3JtYXQpXFxzKj8oXFxufCQpLy50ZXN0KHRleHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0UHJhZ21hJDgodGV4dCkge1xuICAgIHJldHVybiBcIiMgQGZvcm1hdFxcblxcblwiLmNvbmNhdCh0ZXh0KTtcbiAgfVxuXG4gIHZhciBwcmFnbWEkNSA9IHtcbiAgICBpc1ByYWdtYTogaXNQcmFnbWEsXG4gICAgaGFzUHJhZ21hOiBoYXNQcmFnbWEkNCxcbiAgICBpbnNlcnRQcmFnbWE6IGluc2VydFByYWdtYSQ4XG4gIH07XG5cbiAgdmFyIGdldExhc3QkNCA9IHV0aWwuZ2V0TGFzdDtcblxuICBmdW5jdGlvbiBnZXRBbmNlc3RvckNvdW50KHBhdGgsIGZpbHRlcikge1xuICAgIHZhciBjb3VudGVyID0gMDtcbiAgICB2YXIgcGF0aFN0YWNrTGVuZ3RoID0gcGF0aC5zdGFjay5sZW5ndGggLSAxO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoU3RhY2tMZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gcGF0aC5zdGFja1tpXTtcblxuICAgICAgaWYgKGlzTm9kZSh2YWx1ZSkgJiYgZmlsdGVyKHZhbHVlKSkge1xuICAgICAgICBjb3VudGVyKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICAgKiBAcGFyYW0ge3N0cmluZ1tdPX0gdHlwZXNcbiAgICovXG5cblxuICBmdW5jdGlvbiBpc05vZGUodmFsdWUsIHR5cGVzKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50eXBlID09PSBcInN0cmluZ1wiICYmICghdHlwZXMgfHwgdHlwZXMuaW5kZXhPZih2YWx1ZS50eXBlKSAhPT0gLTEpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwTm9kZShub2RlLCBjYWxsYmFjaywgcGFyZW50KSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKFwiY2hpbGRyZW5cIiBpbiBub2RlID8gT2JqZWN0LmFzc2lnbih7fSwgbm9kZSwge1xuICAgICAgY2hpbGRyZW46IG5vZGUuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG1hcE5vZGUoY2hpbGROb2RlLCBjYWxsYmFjaywgbm9kZSk7XG4gICAgICB9KVxuICAgIH0pIDogbm9kZSwgcGFyZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmluZVNob3J0Y3V0KHgsIGtleSwgZ2V0dGVyKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHgsIGtleSwge1xuICAgICAgZ2V0OiBnZXR0ZXIsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOZXh0TGluZUVtcHR5JDUobm9kZSwgdGV4dCkge1xuICAgIHZhciBuZXdsaW5lQ291bnQgPSAwO1xuICAgIHZhciB0ZXh0TGVuZ3RoID0gdGV4dC5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gbm9kZS5wb3NpdGlvbi5lbmQub2Zmc2V0IC0gMTsgaSA8IHRleHRMZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoYXIgPSB0ZXh0W2ldO1xuXG4gICAgICBpZiAoY2hhciA9PT0gXCJcXG5cIikge1xuICAgICAgICBuZXdsaW5lQ291bnQrKztcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld2xpbmVDb3VudCA9PT0gMSAmJiAvXFxTLy50ZXN0KGNoYXIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld2xpbmVDb3VudCA9PT0gMikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBpc0xhc3REZXNjZW5kYW50Tm9kZShwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSBwYXRoLmdldFZhbHVlKCk7XG5cbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcInRhZ1wiOlxuICAgICAgY2FzZSBcImFuY2hvclwiOlxuICAgICAgY2FzZSBcImNvbW1lbnRcIjpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBwYXRoU3RhY2tMZW5ndGggPSBwYXRoLnN0YWNrLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcGF0aFN0YWNrTGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gcGF0aC5zdGFja1tpXTtcbiAgICAgIHZhciBwYXJlbnRJdGVtID0gcGF0aC5zdGFja1tpIC0gMV07XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmVudEl0ZW0pICYmIHR5cGVvZiBpdGVtID09PSBcIm51bWJlclwiICYmIGl0ZW0gIT09IHBhcmVudEl0ZW0ubGVuZ3RoIC0gMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRMYXN0RGVzY2VuZGFudE5vZGUkMShub2RlKSB7XG4gICAgcmV0dXJuIFwiY2hpbGRyZW5cIiBpbiBub2RlICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoICE9PSAwID8gZ2V0TGFzdERlc2NlbmRhbnROb2RlJDEoZ2V0TGFzdCQ0KG5vZGUuY2hpbGRyZW4pKSA6IG5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBpc1ByZXR0aWVySWdub3JlJDIoY29tbWVudCkge1xuICAgIHJldHVybiBjb21tZW50LnZhbHVlLnRyaW0oKSA9PT0gXCJwcmV0dGllci1pZ25vcmVcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc1ByZXR0aWVySWdub3JlJDUocGF0aCkge1xuICAgIHZhciBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJkb2N1bWVudEJvZHlcIikge1xuICAgICAgdmFyIGRvY3VtZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG4gICAgICByZXR1cm4gaGFzRW5kQ29tbWVudHMoZG9jdW1lbnQuaGVhZCkgJiYgaXNQcmV0dGllcklnbm9yZSQyKGdldExhc3QkNChkb2N1bWVudC5oZWFkLmVuZENvbW1lbnRzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhc0xlYWRpbmdDb21tZW50cyhub2RlKSAmJiBpc1ByZXR0aWVySWdub3JlJDIoZ2V0TGFzdCQ0KG5vZGUubGVhZGluZ0NvbW1lbnRzKSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0VtcHR5Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuICghbm9kZS5jaGlsZHJlbiB8fCBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgJiYgIWhhc0NvbW1lbnRzKG5vZGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzQ29tbWVudHMobm9kZSkge1xuICAgIHJldHVybiBoYXNMZWFkaW5nQ29tbWVudHMobm9kZSkgfHwgaGFzTWlkZGxlQ29tbWVudHMobm9kZSkgfHwgaGFzSW5kaWNhdG9yQ29tbWVudChub2RlKSB8fCBoYXNUcmFpbGluZ0NvbW1lbnQkMihub2RlKSB8fCBoYXNFbmRDb21tZW50cyhub2RlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0xlYWRpbmdDb21tZW50cyhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5sZWFkaW5nQ29tbWVudHMgJiYgbm9kZS5sZWFkaW5nQ29tbWVudHMubGVuZ3RoICE9PSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzTWlkZGxlQ29tbWVudHMobm9kZSkge1xuICAgIHJldHVybiBub2RlICYmIG5vZGUubWlkZGxlQ29tbWVudHMgJiYgbm9kZS5taWRkbGVDb21tZW50cy5sZW5ndGggIT09IDA7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNJbmRpY2F0b3JDb21tZW50KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAmJiBub2RlLmluZGljYXRvckNvbW1lbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNUcmFpbGluZ0NvbW1lbnQkMihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS50cmFpbGluZ0NvbW1lbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNFbmRDb21tZW50cyhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5lbmRDb21tZW50cyAmJiBub2RlLmVuZENvbW1lbnRzLmxlbmd0aCAhPT0gMDtcbiAgfVxuICAvKipcbiAgICogXCIgYSAgIGIgYyAgIGQgZSAgIGYgXCIgLT4gW1wiIGEgICBiXCIsIFwiYyAgIGRcIiwgXCJlICAgZiBcIl1cbiAgICovXG5cblxuICBmdW5jdGlvbiBzcGxpdFdpdGhTaW5nbGVTcGFjZSh0ZXh0KSB7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgdmFyIGxhc3RQYXJ0ID0gdW5kZWZpbmVkO1xuICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdGV4dC5zcGxpdCgvKCArKS9nKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgdmFyIHBhcnQgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICBpZiAocGFydCAhPT0gXCIgXCIpIHtcbiAgICAgICAgICBpZiAobGFzdFBhcnQgPT09IFwiIFwiKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKChwYXJ0cy5wb3AoKSB8fCBcIlwiKSArIHBhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChsYXN0UGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcGFydHMudW5zaGlmdChcIlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RQYXJ0ID0gcGFydDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsYXN0UGFydCA9PT0gXCIgXCIpIHtcbiAgICAgIHBhcnRzLnB1c2goKHBhcnRzLnBvcCgpIHx8IFwiXCIpICsgXCIgXCIpO1xuICAgIH1cblxuICAgIGlmIChwYXJ0c1swXSA9PT0gXCJcIikge1xuICAgICAgcGFydHMuc2hpZnQoKTtcbiAgICAgIHBhcnRzLnVuc2hpZnQoXCIgXCIgKyAocGFydHMuc2hpZnQoKSB8fCBcIlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnRzO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Rmxvd1NjYWxhckxpbmVDb250ZW50cyhub2RlVHlwZSwgY29udGVudCwgb3B0aW9ucykge1xuICAgIHZhciByYXdMaW5lQ29udGVudHMgPSBjb250ZW50LnNwbGl0KFwiXFxuXCIpLm1hcChmdW5jdGlvbiAobGluZUNvbnRlbnQsIGluZGV4LCBsaW5lQ29udGVudHMpIHtcbiAgICAgIHJldHVybiBpbmRleCA9PT0gMCAmJiBpbmRleCA9PT0gbGluZUNvbnRlbnRzLmxlbmd0aCAtIDEgPyBsaW5lQ29udGVudCA6IGluZGV4ICE9PSAwICYmIGluZGV4ICE9PSBsaW5lQ29udGVudHMubGVuZ3RoIC0gMSA/IGxpbmVDb250ZW50LnRyaW0oKSA6IGluZGV4ID09PSAwID8gbGluZUNvbnRlbnQudHJpbVJpZ2h0KCkgOiBsaW5lQ29udGVudC50cmltTGVmdCgpO1xuICAgIH0pO1xuXG4gICAgaWYgKG9wdGlvbnMucHJvc2VXcmFwID09PSBcInByZXNlcnZlXCIpIHtcbiAgICAgIHJldHVybiByYXdMaW5lQ29udGVudHMubWFwKGZ1bmN0aW9uIChsaW5lQ29udGVudCkge1xuICAgICAgICByZXR1cm4gbGluZUNvbnRlbnQubGVuZ3RoID09PSAwID8gW10gOiBbbGluZUNvbnRlbnRdO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhd0xpbmVDb250ZW50cy5tYXAoZnVuY3Rpb24gKGxpbmVDb250ZW50KSB7XG4gICAgICByZXR1cm4gbGluZUNvbnRlbnQubGVuZ3RoID09PSAwID8gW10gOiBzcGxpdFdpdGhTaW5nbGVTcGFjZShsaW5lQ29udGVudCk7XG4gICAgfSkucmVkdWNlKGZ1bmN0aW9uIChyZWR1Y2VkLCBsaW5lQ29udGVudFdvcmRzLCBpbmRleCkge1xuICAgICAgcmV0dXJuIGluZGV4ICE9PSAwICYmIHJhd0xpbmVDb250ZW50c1tpbmRleCAtIDFdLmxlbmd0aCAhPT0gMCAmJiBsaW5lQ29udGVudFdvcmRzLmxlbmd0aCAhPT0gMCAmJiAhKCAvLyB0cmFpbGluZyBiYWNrc2xhc2ggaW4gcXVvdGVEb3VibGUgc2hvdWxkIGJlIHByZXNlcnZlZFxuICAgICAgbm9kZVR5cGUgPT09IFwicXVvdGVEb3VibGVcIiAmJiBnZXRMYXN0JDQoZ2V0TGFzdCQ0KHJlZHVjZWQpKS5lbmRzV2l0aChcIlxcXFxcIikpID8gcmVkdWNlZC5jb25jYXQoW3JlZHVjZWQucG9wKCkuY29uY2F0KGxpbmVDb250ZW50V29yZHMpXSkgOiByZWR1Y2VkLmNvbmNhdChbbGluZUNvbnRlbnRXb3Jkc10pO1xuICAgIH0sIFtdKS5tYXAoZnVuY3Rpb24gKGxpbmVDb250ZW50V29yZHMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLnByb3NlV3JhcCA9PT0gXCJuZXZlclwiID8gW2xpbmVDb250ZW50V29yZHMuam9pbihcIiBcIildIDogbGluZUNvbnRlbnRXb3JkcztcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEJsb2NrVmFsdWVMaW5lQ29udGVudHMobm9kZSwgX3JlZikge1xuICAgIHZhciBwYXJlbnRJbmRlbnQgPSBfcmVmLnBhcmVudEluZGVudCxcbiAgICAgICAgaXNMYXN0RGVzY2VuZGFudCA9IF9yZWYuaXNMYXN0RGVzY2VuZGFudCxcbiAgICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgICB2YXIgY29udGVudCA9IG5vZGUucG9zaXRpb24uc3RhcnQubGluZSA9PT0gbm9kZS5wb3NpdGlvbi5lbmQubGluZSA/IFwiXCIgOiBvcHRpb25zLm9yaWdpbmFsVGV4dC5zbGljZShub2RlLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldCwgbm9kZS5wb3NpdGlvbi5lbmQub2Zmc2V0KSAvLyBleGNsdWRlIG9wZW4gbGluZSBgPmAgb3IgYHxgXG4gICAgLm1hdGNoKC9eW15cXG5dKj9cXG4oW1xcc1xcU10qKSQvKVsxXTtcbiAgICB2YXIgbGVhZGluZ1NwYWNlQ291bnQgPSBub2RlLmluZGVudCA9PT0gbnVsbCA/IGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0ubGVuZ3RoIDogSW5maW5pdHk7XG4gICAgfShjb250ZW50Lm1hdGNoKC9eKCAqKVxcUy9tKSkgOiBub2RlLmluZGVudCAtIDEgKyBwYXJlbnRJbmRlbnQ7XG4gICAgdmFyIHJhd0xpbmVDb250ZW50cyA9IGNvbnRlbnQuc3BsaXQoXCJcXG5cIikubWFwKGZ1bmN0aW9uIChsaW5lQ29udGVudCkge1xuICAgICAgcmV0dXJuIGxpbmVDb250ZW50LnNsaWNlKGxlYWRpbmdTcGFjZUNvdW50KTtcbiAgICB9KTtcblxuICAgIGlmIChvcHRpb25zLnByb3NlV3JhcCA9PT0gXCJwcmVzZXJ2ZVwiIHx8IG5vZGUudHlwZSA9PT0gXCJibG9ja0xpdGVyYWxcIikge1xuICAgICAgcmV0dXJuIHJlbW92ZVVubmVjZXNzYXJ5VHJhaWxpbmdOZXdsaW5lcyhyYXdMaW5lQ29udGVudHMubWFwKGZ1bmN0aW9uIChsaW5lQ29udGVudCkge1xuICAgICAgICByZXR1cm4gbGluZUNvbnRlbnQubGVuZ3RoID09PSAwID8gW10gOiBbbGluZUNvbnRlbnRdO1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiByZW1vdmVVbm5lY2Vzc2FyeVRyYWlsaW5nTmV3bGluZXMocmF3TGluZUNvbnRlbnRzLm1hcChmdW5jdGlvbiAobGluZUNvbnRlbnQpIHtcbiAgICAgIHJldHVybiBsaW5lQ29udGVudC5sZW5ndGggPT09IDAgPyBbXSA6IHNwbGl0V2l0aFNpbmdsZVNwYWNlKGxpbmVDb250ZW50KTtcbiAgICB9KS5yZWR1Y2UoZnVuY3Rpb24gKHJlZHVjZWQsIGxpbmVDb250ZW50V29yZHMsIGluZGV4KSB7XG4gICAgICByZXR1cm4gaW5kZXggIT09IDAgJiYgcmF3TGluZUNvbnRlbnRzW2luZGV4IC0gMV0ubGVuZ3RoICE9PSAwICYmIGxpbmVDb250ZW50V29yZHMubGVuZ3RoICE9PSAwICYmICEvXlxccy8udGVzdChsaW5lQ29udGVudFdvcmRzWzBdKSAmJiAhL15cXHN8XFxzJC8udGVzdChnZXRMYXN0JDQocmVkdWNlZCkpID8gcmVkdWNlZC5jb25jYXQoW3JlZHVjZWQucG9wKCkuY29uY2F0KGxpbmVDb250ZW50V29yZHMpXSkgOiByZWR1Y2VkLmNvbmNhdChbbGluZUNvbnRlbnRXb3Jkc10pO1xuICAgIH0sIFtdKS5tYXAoZnVuY3Rpb24gKGxpbmVDb250ZW50V29yZHMpIHtcbiAgICAgIHJldHVybiBsaW5lQ29udGVudFdvcmRzLnJlZHVjZShmdW5jdGlvbiAocmVkdWNlZCwgd29yZCkge1xuICAgICAgICByZXR1cm4gKC8vIGRpc2FsbG93IHRyYWlsaW5nIHNwYWNlc1xuICAgICAgICAgIHJlZHVjZWQubGVuZ3RoICE9PSAwICYmIC9cXHMkLy50ZXN0KGdldExhc3QkNChyZWR1Y2VkKSkgPyByZWR1Y2VkLmNvbmNhdChyZWR1Y2VkLnBvcCgpICsgXCIgXCIgKyB3b3JkKSA6IHJlZHVjZWQuY29uY2F0KHdvcmQpXG4gICAgICAgICk7XG4gICAgICB9LCBbXSk7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChsaW5lQ29udGVudFdvcmRzKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5wcm9zZVdyYXAgPT09IFwibmV2ZXJcIiA/IFtsaW5lQ29udGVudFdvcmRzLmpvaW4oXCIgXCIpXSA6IGxpbmVDb250ZW50V29yZHM7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gcmVtb3ZlVW5uZWNlc3NhcnlUcmFpbGluZ05ld2xpbmVzKGxpbmVDb250ZW50cykge1xuICAgICAgaWYgKG5vZGUuY2hvbXBpbmcgPT09IFwia2VlcFwiKSB7XG4gICAgICAgIHJldHVybiBnZXRMYXN0JDQobGluZUNvbnRlbnRzKS5sZW5ndGggPT09IDAgPyBsaW5lQ29udGVudHMuc2xpY2UoMCwgLTEpIDogbGluZUNvbnRlbnRzO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHJhaWxpbmdOZXdsaW5lQ291bnQgPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gbGluZUNvbnRlbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChsaW5lQ29udGVudHNbaV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdHJhaWxpbmdOZXdsaW5lQ291bnQrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJhaWxpbmdOZXdsaW5lQ291bnQgPT09IDAgPyBsaW5lQ29udGVudHMgOiB0cmFpbGluZ05ld2xpbmVDb3VudCA+PSAyICYmICFpc0xhc3REZXNjZW5kYW50ID8gLy8gbmV4dCBlbXB0eSBsaW5lXG4gICAgICBsaW5lQ29udGVudHMuc2xpY2UoMCwgLSh0cmFpbGluZ05ld2xpbmVDb3VudCAtIDEpKSA6IGxpbmVDb250ZW50cy5zbGljZSgwLCAtdHJhaWxpbmdOZXdsaW5lQ291bnQpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1dGlscyQ2ID0ge1xuICAgIGdldExhc3Q6IGdldExhc3QkNCxcbiAgICBnZXRBbmNlc3RvckNvdW50OiBnZXRBbmNlc3RvckNvdW50LFxuICAgIGlzTm9kZTogaXNOb2RlLFxuICAgIGlzRW1wdHlOb2RlOiBpc0VtcHR5Tm9kZSxcbiAgICBtYXBOb2RlOiBtYXBOb2RlLFxuICAgIGRlZmluZVNob3J0Y3V0OiBkZWZpbmVTaG9ydGN1dCxcbiAgICBpc05leHRMaW5lRW1wdHk6IGlzTmV4dExpbmVFbXB0eSQ1LFxuICAgIGlzTGFzdERlc2NlbmRhbnROb2RlOiBpc0xhc3REZXNjZW5kYW50Tm9kZSxcbiAgICBnZXRCbG9ja1ZhbHVlTGluZUNvbnRlbnRzOiBnZXRCbG9ja1ZhbHVlTGluZUNvbnRlbnRzLFxuICAgIGdldEZsb3dTY2FsYXJMaW5lQ29udGVudHM6IGdldEZsb3dTY2FsYXJMaW5lQ29udGVudHMsXG4gICAgZ2V0TGFzdERlc2NlbmRhbnROb2RlOiBnZXRMYXN0RGVzY2VuZGFudE5vZGUkMSxcbiAgICBoYXNQcmV0dGllcklnbm9yZTogaGFzUHJldHRpZXJJZ25vcmUkNSxcbiAgICBoYXNMZWFkaW5nQ29tbWVudHM6IGhhc0xlYWRpbmdDb21tZW50cyxcbiAgICBoYXNNaWRkbGVDb21tZW50czogaGFzTWlkZGxlQ29tbWVudHMsXG4gICAgaGFzSW5kaWNhdG9yQ29tbWVudDogaGFzSW5kaWNhdG9yQ29tbWVudCxcbiAgICBoYXNUcmFpbGluZ0NvbW1lbnQ6IGhhc1RyYWlsaW5nQ29tbWVudCQyLFxuICAgIGhhc0VuZENvbW1lbnRzOiBoYXNFbmRDb21tZW50c1xuICB9O1xuXG4gIHZhciBpbnNlcnRQcmFnbWEkOSA9IHByYWdtYSQ1Lmluc2VydFByYWdtYSxcbiAgICAgIGlzUHJhZ21hJDEgPSBwcmFnbWEkNS5pc1ByYWdtYTtcbiAgdmFyIGdldEFuY2VzdG9yQ291bnQkMSA9IHV0aWxzJDYuZ2V0QW5jZXN0b3JDb3VudCxcbiAgICAgIGdldEJsb2NrVmFsdWVMaW5lQ29udGVudHMkMSA9IHV0aWxzJDYuZ2V0QmxvY2tWYWx1ZUxpbmVDb250ZW50cyxcbiAgICAgIGdldEZsb3dTY2FsYXJMaW5lQ29udGVudHMkMSA9IHV0aWxzJDYuZ2V0Rmxvd1NjYWxhckxpbmVDb250ZW50cyxcbiAgICAgIGdldExhc3QkNSA9IHV0aWxzJDYuZ2V0TGFzdCxcbiAgICAgIGdldExhc3REZXNjZW5kYW50Tm9kZSQyID0gdXRpbHMkNi5nZXRMYXN0RGVzY2VuZGFudE5vZGUsXG4gICAgICBoYXNMZWFkaW5nQ29tbWVudHMkMSA9IHV0aWxzJDYuaGFzTGVhZGluZ0NvbW1lbnRzLFxuICAgICAgaGFzTWlkZGxlQ29tbWVudHMkMSA9IHV0aWxzJDYuaGFzTWlkZGxlQ29tbWVudHMsXG4gICAgICBoYXNJbmRpY2F0b3JDb21tZW50JDEgPSB1dGlscyQ2Lmhhc0luZGljYXRvckNvbW1lbnQsXG4gICAgICBoYXNUcmFpbGluZ0NvbW1lbnQkMyA9IHV0aWxzJDYuaGFzVHJhaWxpbmdDb21tZW50LFxuICAgICAgaGFzRW5kQ29tbWVudHMkMSA9IHV0aWxzJDYuaGFzRW5kQ29tbWVudHMsXG4gICAgICBoYXNQcmV0dGllcklnbm9yZSQ2ID0gdXRpbHMkNi5oYXNQcmV0dGllcklnbm9yZSxcbiAgICAgIGlzTGFzdERlc2NlbmRhbnROb2RlJDEgPSB1dGlscyQ2LmlzTGFzdERlc2NlbmRhbnROb2RlLFxuICAgICAgaXNOZXh0TGluZUVtcHR5JDYgPSB1dGlscyQ2LmlzTmV4dExpbmVFbXB0eSxcbiAgICAgIGlzTm9kZSQxID0gdXRpbHMkNi5pc05vZGUsXG4gICAgICBpc0VtcHR5Tm9kZSQxID0gdXRpbHMkNi5pc0VtcHR5Tm9kZSxcbiAgICAgIGRlZmluZVNob3J0Y3V0JDEgPSB1dGlscyQ2LmRlZmluZVNob3J0Y3V0LFxuICAgICAgbWFwTm9kZSQxID0gdXRpbHMkNi5tYXBOb2RlO1xuICB2YXIgZG9jQnVpbGRlcnMkMiA9IGRvYy5idWlsZGVycztcbiAgdmFyIGNvbmRpdGlvbmFsR3JvdXAkMiA9IGRvY0J1aWxkZXJzJDIuY29uZGl0aW9uYWxHcm91cCxcbiAgICAgIGJyZWFrUGFyZW50JDUgPSBkb2NCdWlsZGVycyQyLmJyZWFrUGFyZW50LFxuICAgICAgY29uY2F0JGggPSBkb2NCdWlsZGVycyQyLmNvbmNhdCxcbiAgICAgIGRlZGVudCQzID0gZG9jQnVpbGRlcnMkMi5kZWRlbnQsXG4gICAgICBkZWRlbnRUb1Jvb3QkMyA9IGRvY0J1aWxkZXJzJDIuZGVkZW50VG9Sb290LFxuICAgICAgZmlsbCQ2ID0gZG9jQnVpbGRlcnMkMi5maWxsLFxuICAgICAgZ3JvdXAkZyA9IGRvY0J1aWxkZXJzJDIuZ3JvdXAsXG4gICAgICBoYXJkbGluZSRkID0gZG9jQnVpbGRlcnMkMi5oYXJkbGluZSxcbiAgICAgIGlmQnJlYWskOCA9IGRvY0J1aWxkZXJzJDIuaWZCcmVhayxcbiAgICAgIGpvaW4kYyA9IGRvY0J1aWxkZXJzJDIuam9pbixcbiAgICAgIGxpbmUkOSA9IGRvY0J1aWxkZXJzJDIubGluZSxcbiAgICAgIGxpbmVTdWZmaXgkMiA9IGRvY0J1aWxkZXJzJDIubGluZVN1ZmZpeCxcbiAgICAgIGxpdGVyYWxsaW5lJDcgPSBkb2NCdWlsZGVycyQyLmxpdGVyYWxsaW5lLFxuICAgICAgbWFya0FzUm9vdCQ1ID0gZG9jQnVpbGRlcnMkMi5tYXJrQXNSb290LFxuICAgICAgc29mdGxpbmUkOCA9IGRvY0J1aWxkZXJzJDIuc29mdGxpbmU7XG4gIHZhciByZXBsYWNlRW5kT2ZMaW5lV2l0aCQzID0gdXRpbC5yZXBsYWNlRW5kT2ZMaW5lV2l0aDtcblxuICBmdW5jdGlvbiBwcmVwcm9jZXNzJDMoYXN0KSB7XG4gICAgcmV0dXJuIG1hcE5vZGUkMShhc3QsIGRlZmluZVNob3J0Y3V0cyk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWZpbmVTaG9ydGN1dHMobm9kZSkge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiZG9jdW1lbnRcIjpcbiAgICAgICAgZGVmaW5lU2hvcnRjdXQkMShub2RlLCBcImhlYWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuWzBdO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmaW5lU2hvcnRjdXQkMShub2RlLCBcImJvZHlcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuWzFdO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJkb2N1bWVudEJvZHlcIjpcbiAgICAgIGNhc2UgXCJzZXF1ZW5jZUl0ZW1cIjpcbiAgICAgIGNhc2UgXCJmbG93U2VxdWVuY2VJdGVtXCI6XG4gICAgICBjYXNlIFwibWFwcGluZ0tleVwiOlxuICAgICAgY2FzZSBcIm1hcHBpbmdWYWx1ZVwiOlxuICAgICAgICBkZWZpbmVTaG9ydGN1dCQxKG5vZGUsIFwiY29udGVudFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW5bMF07XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIm1hcHBpbmdJdGVtXCI6XG4gICAgICBjYXNlIFwiZmxvd01hcHBpbmdJdGVtXCI6XG4gICAgICAgIGRlZmluZVNob3J0Y3V0JDEobm9kZSwgXCJrZXlcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuWzBdO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmaW5lU2hvcnRjdXQkMShub2RlLCBcInZhbHVlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS5jaGlsZHJlblsxXTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJpY1ByaW50JDYocGF0aCwgb3B0aW9ucywgcHJpbnQpIHtcbiAgICB2YXIgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpO1xuICAgIHZhciB0YWcgPSAhbm9kZS50YWcgPyBcIlwiIDogcGF0aC5jYWxsKHByaW50LCBcInRhZ1wiKTtcbiAgICB2YXIgYW5jaG9yID0gIW5vZGUuYW5jaG9yID8gXCJcIiA6IHBhdGguY2FsbChwcmludCwgXCJhbmNob3JcIik7XG4gICAgdmFyIG5leHRFbXB0eUxpbmUgPSBpc05vZGUkMShub2RlLCBbXCJtYXBwaW5nXCIsIFwic2VxdWVuY2VcIiwgXCJjb21tZW50XCIsIFwiZGlyZWN0aXZlXCIsIFwibWFwcGluZ0l0ZW1cIiwgXCJzZXF1ZW5jZUl0ZW1cIl0pICYmICFpc0xhc3REZXNjZW5kYW50Tm9kZSQxKHBhdGgpID8gcHJpbnROZXh0RW1wdHlMaW5lKHBhdGgsIG9wdGlvbnMub3JpZ2luYWxUZXh0KSA6IFwiXCI7XG4gICAgcmV0dXJuIGNvbmNhdCRoKFtub2RlLnR5cGUgIT09IFwibWFwcGluZ1ZhbHVlXCIgJiYgaGFzTGVhZGluZ0NvbW1lbnRzJDEobm9kZSkgPyBjb25jYXQkaChbam9pbiRjKGhhcmRsaW5lJGQsIHBhdGgubWFwKHByaW50LCBcImxlYWRpbmdDb21tZW50c1wiKSksIGhhcmRsaW5lJGRdKSA6IFwiXCIsIHRhZywgdGFnICYmIGFuY2hvciA/IFwiIFwiIDogXCJcIiwgYW5jaG9yLCB0YWcgfHwgYW5jaG9yID8gaXNOb2RlJDEobm9kZSwgW1wic2VxdWVuY2VcIiwgXCJtYXBwaW5nXCJdKSAmJiAhaGFzTWlkZGxlQ29tbWVudHMkMShub2RlKSA/IGhhcmRsaW5lJGQgOiBcIiBcIiA6IFwiXCIsIGhhc01pZGRsZUNvbW1lbnRzJDEobm9kZSkgPyBjb25jYXQkaChbbm9kZS5taWRkbGVDb21tZW50cy5sZW5ndGggPT09IDEgPyBcIlwiIDogaGFyZGxpbmUkZCwgam9pbiRjKGhhcmRsaW5lJGQsIHBhdGgubWFwKHByaW50LCBcIm1pZGRsZUNvbW1lbnRzXCIpKSwgaGFyZGxpbmUkZF0pIDogXCJcIiwgaGFzUHJldHRpZXJJZ25vcmUkNihwYXRoKSA/IGNvbmNhdCRoKHJlcGxhY2VFbmRPZkxpbmVXaXRoJDMob3B0aW9ucy5vcmlnaW5hbFRleHQuc2xpY2Uobm9kZS5wb3NpdGlvbi5zdGFydC5vZmZzZXQsIG5vZGUucG9zaXRpb24uZW5kLm9mZnNldCksIGxpdGVyYWxsaW5lJDcpKSA6IGdyb3VwJGcoX3ByaW50KG5vZGUsIHBhcmVudE5vZGUsIHBhdGgsIG9wdGlvbnMsIHByaW50KSksIGhhc1RyYWlsaW5nQ29tbWVudCQzKG5vZGUpICYmICFpc05vZGUkMShub2RlLCBbXCJkb2N1bWVudFwiLCBcImRvY3VtZW50SGVhZFwiXSkgPyBsaW5lU3VmZml4JDIoY29uY2F0JGgoW25vZGUudHlwZSA9PT0gXCJtYXBwaW5nVmFsdWVcIiAmJiAhbm9kZS5jb250ZW50ID8gXCJcIiA6IFwiIFwiLCBwYXJlbnROb2RlLnR5cGUgPT09IFwibWFwcGluZ0tleVwiICYmIHBhdGguZ2V0UGFyZW50Tm9kZSgyKS50eXBlID09PSBcIm1hcHBpbmdcIiAmJiBpc0lubGluZU5vZGUkMShub2RlKSA/IFwiXCIgOiBicmVha1BhcmVudCQ1LCBwYXRoLmNhbGwocHJpbnQsIFwidHJhaWxpbmdDb21tZW50XCIpXSkpIDogXCJcIiwgbmV4dEVtcHR5TGluZSwgaGFzRW5kQ29tbWVudHMkMShub2RlKSAmJiAhaXNOb2RlJDEobm9kZSwgW1wiZG9jdW1lbnRIZWFkXCIsIFwiZG9jdW1lbnRCb2R5XCJdKSA/IGFsaWduJDMobm9kZS50eXBlID09PSBcInNlcXVlbmNlSXRlbVwiID8gMiA6IDAsIGNvbmNhdCRoKFtoYXJkbGluZSRkLCBqb2luJGMoaGFyZGxpbmUkZCwgcGF0aC5tYXAocHJpbnQsIFwiZW5kQ29tbWVudHNcIikpXSkpIDogXCJcIl0pO1xuICB9XG5cbiAgZnVuY3Rpb24gX3ByaW50KG5vZGUsIHBhcmVudE5vZGUsIHBhdGgsIG9wdGlvbnMsIHByaW50KSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJyb290XCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkaChbam9pbiRjKGhhcmRsaW5lJGQsIHBhdGgubWFwKGZ1bmN0aW9uIChjaGlsZFBhdGgsIGluZGV4KSB7XG4gICAgICAgICAgdmFyIGRvY3VtZW50ID0gbm9kZS5jaGlsZHJlbltpbmRleF07XG4gICAgICAgICAgdmFyIG5leHREb2N1bWVudCA9IG5vZGUuY2hpbGRyZW5baW5kZXggKyAxXTtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JGgoW3ByaW50KGNoaWxkUGF0aCksIHNob3VsZFByaW50RG9jdW1lbnRFbmRNYXJrZXIoZG9jdW1lbnQsIG5leHREb2N1bWVudCkgPyBjb25jYXQkaChbaGFyZGxpbmUkZCwgXCIuLi5cIiwgaGFzVHJhaWxpbmdDb21tZW50JDMoZG9jdW1lbnQpID8gY29uY2F0JGgoW1wiIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwidHJhaWxpbmdDb21tZW50XCIpXSkgOiBcIlwiXSkgOiAhbmV4dERvY3VtZW50IHx8IGhhc1RyYWlsaW5nQ29tbWVudCQzKG5leHREb2N1bWVudC5oZWFkKSA/IFwiXCIgOiBjb25jYXQkaChbaGFyZGxpbmUkZCwgXCItLS1cIl0pXSk7XG4gICAgICAgIH0sIFwiY2hpbGRyZW5cIikpLCBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCBmdW5jdGlvbiAobGFzdERlc2NlbmRhbnROb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGlzTm9kZSQxKGxhc3REZXNjZW5kYW50Tm9kZSwgW1wiYmxvY2tMaXRlcmFsXCIsIFwiYmxvY2tGb2xkZWRcIl0pICYmIGxhc3REZXNjZW5kYW50Tm9kZS5jaG9tcGluZyA9PT0gXCJrZWVwXCI7XG4gICAgICAgIH0oZ2V0TGFzdERlc2NlbmRhbnROb2RlJDIobm9kZSkpID8gXCJcIiA6IGhhcmRsaW5lJGRdKTtcblxuICAgICAgY2FzZSBcImRvY3VtZW50XCI6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbmV4dERvY3VtZW50ID0gcGFyZW50Tm9kZS5jaGlsZHJlbltwYXRoLmdldE5hbWUoKSArIDFdO1xuICAgICAgICAgIHJldHVybiBqb2luJGMoaGFyZGxpbmUkZCwgW3Nob3VsZFByaW50RG9jdW1lbnRIZWFkRW5kTWFya2VyKG5vZGUsIG5leHREb2N1bWVudCwgcGFyZW50Tm9kZSwgb3B0aW9ucykgPT09IFwiaGVhZFwiID8gam9pbiRjKGhhcmRsaW5lJGQsIFtub2RlLmhlYWQuY2hpbGRyZW4ubGVuZ3RoID09PSAwICYmIG5vZGUuaGVhZC5lbmRDb21tZW50cy5sZW5ndGggPT09IDAgPyBcIlwiIDogcGF0aC5jYWxsKHByaW50LCBcImhlYWRcIiksIGNvbmNhdCRoKFtcIi0tLVwiLCBoYXNUcmFpbGluZ0NvbW1lbnQkMyhub2RlLmhlYWQpID8gY29uY2F0JGgoW1wiIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiaGVhZFwiLCBcInRyYWlsaW5nQ29tbWVudFwiKV0pIDogXCJcIl0pXS5maWx0ZXIoQm9vbGVhbikpIDogXCJcIiwgc2hvdWxkUHJpbnREb2N1bWVudEJvZHkobm9kZSkgPyBwYXRoLmNhbGwocHJpbnQsIFwiYm9keVwiKSA6IFwiXCJdLmZpbHRlcihCb29sZWFuKSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcImRvY3VtZW50SGVhZFwiOlxuICAgICAgICByZXR1cm4gam9pbiRjKGhhcmRsaW5lJGQsIFtdLmNvbmNhdChwYXRoLm1hcChwcmludCwgXCJjaGlsZHJlblwiKSwgcGF0aC5tYXAocHJpbnQsIFwiZW5kQ29tbWVudHNcIikpKTtcblxuICAgICAgY2FzZSBcImRvY3VtZW50Qm9keVwiOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gam9pbiRjKGhhcmRsaW5lJGQsIHBhdGgubWFwKHByaW50LCBcImNoaWxkcmVuXCIpKS5wYXJ0cztcbiAgICAgICAgICB2YXIgZW5kQ29tbWVudHMgPSBqb2luJGMoaGFyZGxpbmUkZCwgcGF0aC5tYXAocHJpbnQsIFwiZW5kQ29tbWVudHNcIikpLnBhcnRzO1xuICAgICAgICAgIHZhciBzZXBhcmF0b3IgPSBjaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgZW5kQ29tbWVudHMubGVuZ3RoID09PSAwID8gXCJcIiA6IGZ1bmN0aW9uIChsYXN0RGVzY2VuZGFudE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBpc05vZGUkMShsYXN0RGVzY2VuZGFudE5vZGUsIFtcImJsb2NrRm9sZGVkXCIsIFwiYmxvY2tMaXRlcmFsXCJdKSA/IGxhc3REZXNjZW5kYW50Tm9kZS5jaG9tcGluZyA9PT0gXCJrZWVwXCIgPyAvLyB0aGVyZSdzIGFscmVhZHkgYSBuZXdsaW5lIHByaW50ZWQgYXQgdGhlIGVuZCBvZiBibG9ja1ZhbHVlIChjaG9tcGluZz1rZWVwLCBsYXN0RGVzY2VuZGFudD10cnVlKVxuICAgICAgICAgICAgXCJcIiA6IC8vIGFuIGV4dHJhIG5ld2xpbmUgZm9yIGJldHRlciByZWFkYWJpbGl0eVxuICAgICAgICAgICAgY29uY2F0JGgoW2hhcmRsaW5lJGQsIGhhcmRsaW5lJGRdKSA6IGhhcmRsaW5lJGQ7XG4gICAgICAgICAgfShnZXRMYXN0RGVzY2VuZGFudE5vZGUkMihub2RlKSk7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRoKFtdLmNvbmNhdChjaGlsZHJlbiwgc2VwYXJhdG9yLCBlbmRDb21tZW50cykpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJkaXJlY3RpdmVcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRoKFtcIiVcIiwgam9pbiRjKFwiIFwiLCBbbm9kZS5uYW1lXS5jb25jYXQobm9kZS5wYXJhbWV0ZXJzKSldKTtcblxuICAgICAgY2FzZSBcImNvbW1lbnRcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRoKFtcIiNcIiwgbm9kZS52YWx1ZV0pO1xuXG4gICAgICBjYXNlIFwiYWxpYXNcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRoKFtcIipcIiwgbm9kZS52YWx1ZV0pO1xuXG4gICAgICBjYXNlIFwidGFnXCI6XG4gICAgICAgIHJldHVybiBvcHRpb25zLm9yaWdpbmFsVGV4dC5zbGljZShub2RlLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldCwgbm9kZS5wb3NpdGlvbi5lbmQub2Zmc2V0KTtcblxuICAgICAgY2FzZSBcImFuY2hvclwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGgoW1wiJlwiLCBub2RlLnZhbHVlXSk7XG5cbiAgICAgIGNhc2UgXCJwbGFpblwiOlxuICAgICAgICByZXR1cm4gcHJpbnRGbG93U2NhbGFyQ29udGVudChub2RlLnR5cGUsIG9wdGlvbnMub3JpZ2luYWxUZXh0LnNsaWNlKG5vZGUucG9zaXRpb24uc3RhcnQub2Zmc2V0LCBub2RlLnBvc2l0aW9uLmVuZC5vZmZzZXQpLCBvcHRpb25zKTtcblxuICAgICAgY2FzZSBcInF1b3RlRG91YmxlXCI6XG4gICAgICBjYXNlIFwicXVvdGVTaW5nbGVcIjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBzaW5nbGVRdW90ZSA9IFwiJ1wiO1xuICAgICAgICAgIHZhciBkb3VibGVRdW90ZSA9ICdcIic7XG4gICAgICAgICAgdmFyIHJhdyA9IG9wdGlvbnMub3JpZ2luYWxUZXh0LnNsaWNlKG5vZGUucG9zaXRpb24uc3RhcnQub2Zmc2V0ICsgMSwgbm9kZS5wb3NpdGlvbi5lbmQub2Zmc2V0IC0gMSk7XG5cbiAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBcInF1b3RlU2luZ2xlXCIgJiYgcmF3LmluY2x1ZGVzKFwiXFxcXFwiKSB8fCBub2RlLnR5cGUgPT09IFwicXVvdGVEb3VibGVcIiAmJiAvXFxcXFteXCJdLy50ZXN0KHJhdykpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgcXVvdGVEb3VibGUgY2FuIHVzZSBlc2NhcGUgY2hhcnNcbiAgICAgICAgICAgIC8vIGFuZCBxdW90ZVNpbmdsZSBkbyBub3QgbmVlZCB0byBlc2NhcGUgYmFja3NsYXNoZXNcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbFF1b3RlID0gbm9kZS50eXBlID09PSBcInF1b3RlRG91YmxlXCIgPyBkb3VibGVRdW90ZSA6IHNpbmdsZVF1b3RlO1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCRoKFtvcmlnaW5hbFF1b3RlLCBwcmludEZsb3dTY2FsYXJDb250ZW50KG5vZGUudHlwZSwgcmF3LCBvcHRpb25zKSwgb3JpZ2luYWxRdW90ZV0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmF3LmluY2x1ZGVzKGRvdWJsZVF1b3RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCRoKFtzaW5nbGVRdW90ZSwgcHJpbnRGbG93U2NhbGFyQ29udGVudChub2RlLnR5cGUsIG5vZGUudHlwZSA9PT0gXCJxdW90ZURvdWJsZVwiID8gcmF3IC8vIGRvdWJsZSBxdW90ZSBuZWVkcyB0byBiZSBlc2NhcGVkIGJ5IGJhY2tzbGFzaCBpbiBxdW90ZURvdWJsZVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCBkb3VibGVRdW90ZSkucmVwbGFjZSgvJy9nLCBzaW5nbGVRdW90ZS5yZXBlYXQoMikpIDogcmF3LCBvcHRpb25zKSwgc2luZ2xlUXVvdGVdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmF3LmluY2x1ZGVzKHNpbmdsZVF1b3RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCRoKFtkb3VibGVRdW90ZSwgcHJpbnRGbG93U2NhbGFyQ29udGVudChub2RlLnR5cGUsIG5vZGUudHlwZSA9PT0gXCJxdW90ZVNpbmdsZVwiID8gLy8gc2luZ2xlIHF1b3RlIG5lZWRzIHRvIGJlIGVzY2FwZWQgYnkgMiBzaW5nbGUgcXVvdGVzIGluIHF1b3RlU2luZ2xlXG4gICAgICAgICAgICByYXcucmVwbGFjZSgvJycvZywgc2luZ2xlUXVvdGUpIDogcmF3LCBvcHRpb25zKSwgZG91YmxlUXVvdGVdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcXVvdGUgPSBvcHRpb25zLnNpbmdsZVF1b3RlID8gc2luZ2xlUXVvdGUgOiBkb3VibGVRdW90ZTtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JGgoW3F1b3RlLCBwcmludEZsb3dTY2FsYXJDb250ZW50KG5vZGUudHlwZSwgcmF3LCBvcHRpb25zKSwgcXVvdGVdKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiYmxvY2tGb2xkZWRcIjpcbiAgICAgIGNhc2UgXCJibG9ja0xpdGVyYWxcIjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBwYXJlbnRJbmRlbnQgPSBnZXRBbmNlc3RvckNvdW50JDEocGF0aCwgZnVuY3Rpb24gKGFuY2VzdG9yTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzTm9kZSQxKGFuY2VzdG9yTm9kZSwgW1wic2VxdWVuY2VcIiwgXCJtYXBwaW5nXCJdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgaXNMYXN0RGVzY2VuZGFudCA9IGlzTGFzdERlc2NlbmRhbnROb2RlJDEocGF0aCk7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRoKFtub2RlLnR5cGUgPT09IFwiYmxvY2tGb2xkZWRcIiA/IFwiPlwiIDogXCJ8XCIsIG5vZGUuaW5kZW50ID09PSBudWxsID8gXCJcIiA6IG5vZGUuaW5kZW50LnRvU3RyaW5nKCksIG5vZGUuY2hvbXBpbmcgPT09IFwiY2xpcFwiID8gXCJcIiA6IG5vZGUuY2hvbXBpbmcgPT09IFwia2VlcFwiID8gXCIrXCIgOiBcIi1cIiwgaGFzSW5kaWNhdG9yQ29tbWVudCQxKG5vZGUpID8gY29uY2F0JGgoW1wiIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiaW5kaWNhdG9yQ29tbWVudFwiKV0pIDogXCJcIiwgKG5vZGUuaW5kZW50ID09PSBudWxsID8gZGVkZW50JDMgOiBkZWRlbnRUb1Jvb3QkMykoYWxpZ24kMyhub2RlLmluZGVudCA9PT0gbnVsbCA/IG9wdGlvbnMudGFiV2lkdGggOiBub2RlLmluZGVudCAtIDEgKyBwYXJlbnRJbmRlbnQsIGNvbmNhdCRoKGdldEJsb2NrVmFsdWVMaW5lQ29udGVudHMkMShub2RlLCB7XG4gICAgICAgICAgICBwYXJlbnRJbmRlbnQ6IHBhcmVudEluZGVudCxcbiAgICAgICAgICAgIGlzTGFzdERlc2NlbmRhbnQ6IGlzTGFzdERlc2NlbmRhbnQsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgICAgfSkucmVkdWNlKGZ1bmN0aW9uIChyZWR1Y2VkLCBsaW5lV29yZHMsIGluZGV4LCBsaW5lQ29udGVudHMpIHtcbiAgICAgICAgICAgIHJldHVybiByZWR1Y2VkLmNvbmNhdChpbmRleCA9PT0gMCA/IGhhcmRsaW5lJGQgOiBcIlwiLCBmaWxsJDYoam9pbiRjKGxpbmUkOSwgbGluZVdvcmRzKS5wYXJ0cyksIGluZGV4ICE9PSBsaW5lQ29udGVudHMubGVuZ3RoIC0gMSA/IGxpbmVXb3Jkcy5sZW5ndGggPT09IDAgPyBoYXJkbGluZSRkIDogbWFya0FzUm9vdCQ1KGxpdGVyYWxsaW5lJDcpIDogbm9kZS5jaG9tcGluZyA9PT0gXCJrZWVwXCIgJiYgaXNMYXN0RGVzY2VuZGFudCA/IGxpbmVXb3Jkcy5sZW5ndGggPT09IDAgPyBkZWRlbnRUb1Jvb3QkMyhoYXJkbGluZSRkKSA6IGRlZGVudFRvUm9vdCQzKGxpdGVyYWxsaW5lJDcpIDogXCJcIik7XG4gICAgICAgICAgfSwgW10pKSkpXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInNlcXVlbmNlXCI6XG4gICAgICAgIHJldHVybiBqb2luJGMoaGFyZGxpbmUkZCwgcGF0aC5tYXAocHJpbnQsIFwiY2hpbGRyZW5cIikpO1xuXG4gICAgICBjYXNlIFwic2VxdWVuY2VJdGVtXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkaChbXCItIFwiLCBhbGlnbiQzKDIsICFub2RlLmNvbnRlbnQgPyBcIlwiIDogcGF0aC5jYWxsKHByaW50LCBcImNvbnRlbnRcIikpXSk7XG5cbiAgICAgIGNhc2UgXCJtYXBwaW5nS2V5XCI6XG4gICAgICAgIHJldHVybiAhbm9kZS5jb250ZW50ID8gXCJcIiA6IHBhdGguY2FsbChwcmludCwgXCJjb250ZW50XCIpO1xuXG4gICAgICBjYXNlIFwibWFwcGluZ1ZhbHVlXCI6XG4gICAgICAgIHJldHVybiAhbm9kZS5jb250ZW50ID8gXCJcIiA6IHBhdGguY2FsbChwcmludCwgXCJjb250ZW50XCIpO1xuXG4gICAgICBjYXNlIFwibWFwcGluZ1wiOlxuICAgICAgICByZXR1cm4gam9pbiRjKGhhcmRsaW5lJGQsIHBhdGgubWFwKHByaW50LCBcImNoaWxkcmVuXCIpKTtcblxuICAgICAgY2FzZSBcIm1hcHBpbmdJdGVtXCI6XG4gICAgICBjYXNlIFwiZmxvd01hcHBpbmdJdGVtXCI6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgaXNFbXB0eU1hcHBpbmdLZXkgPSBpc0VtcHR5Tm9kZSQxKG5vZGUua2V5KTtcbiAgICAgICAgICB2YXIgaXNFbXB0eU1hcHBpbmdWYWx1ZSA9IGlzRW1wdHlOb2RlJDEobm9kZS52YWx1ZSk7XG5cbiAgICAgICAgICBpZiAoaXNFbXB0eU1hcHBpbmdLZXkgJiYgaXNFbXB0eU1hcHBpbmdWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCRoKFtcIjogXCJdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIga2V5ID0gcGF0aC5jYWxsKHByaW50LCBcImtleVwiKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBwYXRoLmNhbGwocHJpbnQsIFwidmFsdWVcIik7XG5cbiAgICAgICAgICBpZiAoaXNFbXB0eU1hcHBpbmdWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJmbG93TWFwcGluZ0l0ZW1cIiAmJiBwYXJlbnROb2RlLnR5cGUgPT09IFwiZmxvd01hcHBpbmdcIiA/IGtleSA6IG5vZGUudHlwZSA9PT0gXCJtYXBwaW5nSXRlbVwiICYmIGlzQWJzb2x1dGVseVByaW50ZWRBc1NpbmdsZUxpbmVOb2RlKG5vZGUua2V5LmNvbnRlbnQsIG9wdGlvbnMpICYmICFoYXNUcmFpbGluZ0NvbW1lbnQkMyhub2RlLmtleS5jb250ZW50KSAmJiAoIXBhcmVudE5vZGUudGFnIHx8IHBhcmVudE5vZGUudGFnLnZhbHVlICE9PSBcInRhZzp5YW1sLm9yZywyMDAyOnNldFwiKSA/IGNvbmNhdCRoKFtrZXksIG5lZWRzU3BhY2VJbkZyb250T2ZNYXBwaW5nVmFsdWUobm9kZSkgPyBcIiBcIiA6IFwiXCIsIFwiOlwiXSkgOiBjb25jYXQkaChbXCI/IFwiLCBhbGlnbiQzKDIsIGtleSldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNFbXB0eU1hcHBpbmdLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQkaChbXCI6IFwiLCBhbGlnbiQzKDIsIHZhbHVlKV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBncm91cElkID0gU3ltYm9sKFwibWFwcGluZ0tleVwiKTtcbiAgICAgICAgICB2YXIgZm9yY2VFeHBsaWNpdEtleSA9IGhhc0xlYWRpbmdDb21tZW50cyQxKG5vZGUudmFsdWUpIHx8ICFpc0lubGluZU5vZGUkMShub2RlLmtleS5jb250ZW50KTtcbiAgICAgICAgICByZXR1cm4gZm9yY2VFeHBsaWNpdEtleSA/IGNvbmNhdCRoKFtcIj8gXCIsIGFsaWduJDMoMiwga2V5KSwgaGFyZGxpbmUkZCwgam9pbiRjKFwiXCIsIHBhdGgubWFwKHByaW50LCBcInZhbHVlXCIsIFwibGVhZGluZ0NvbW1lbnRzXCIpLm1hcChmdW5jdGlvbiAoY29tbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCRoKFtjb21tZW50LCBoYXJkbGluZSRkXSk7XG4gICAgICAgICAgfSkpLCBcIjogXCIsIGFsaWduJDMoMiwgdmFsdWUpXSkgOiAvLyBmb3JjZSBzaW5nbGVsaW5lXG4gICAgICAgICAgaXNTaW5nbGVMaW5lTm9kZShub2RlLmtleS5jb250ZW50KSAmJiAhaGFzTGVhZGluZ0NvbW1lbnRzJDEobm9kZS5rZXkuY29udGVudCkgJiYgIWhhc01pZGRsZUNvbW1lbnRzJDEobm9kZS5rZXkuY29udGVudCkgJiYgIWhhc1RyYWlsaW5nQ29tbWVudCQzKG5vZGUua2V5LmNvbnRlbnQpICYmICFoYXNFbmRDb21tZW50cyQxKG5vZGUua2V5KSAmJiAhaGFzTGVhZGluZ0NvbW1lbnRzJDEobm9kZS52YWx1ZS5jb250ZW50KSAmJiAhaGFzTWlkZGxlQ29tbWVudHMkMShub2RlLnZhbHVlLmNvbnRlbnQpICYmICFoYXNFbmRDb21tZW50cyQxKG5vZGUudmFsdWUpICYmIGlzQWJzb2x1dGVseVByaW50ZWRBc1NpbmdsZUxpbmVOb2RlKG5vZGUudmFsdWUuY29udGVudCwgb3B0aW9ucykgPyBjb25jYXQkaChba2V5LCBuZWVkc1NwYWNlSW5Gcm9udE9mTWFwcGluZ1ZhbHVlKG5vZGUpID8gXCIgXCIgOiBcIlwiLCBcIjogXCIsIHZhbHVlXSkgOiBjb25kaXRpb25hbEdyb3VwJDIoW2NvbmNhdCRoKFtncm91cCRnKGNvbmNhdCRoKFtpZkJyZWFrJDgoXCI/IFwiKSwgZ3JvdXAkZyhhbGlnbiQzKDIsIGtleSksIHtcbiAgICAgICAgICAgIGlkOiBncm91cElkXG4gICAgICAgICAgfSldKSksIGlmQnJlYWskOChjb25jYXQkaChbaGFyZGxpbmUkZCwgXCI6IFwiLCBhbGlnbiQzKDIsIHZhbHVlKV0pLCBpbmRlbnQoY29uY2F0JGgoW25lZWRzU3BhY2VJbkZyb250T2ZNYXBwaW5nVmFsdWUobm9kZSkgPyBcIiBcIiA6IFwiXCIsIFwiOlwiLCBoYXNMZWFkaW5nQ29tbWVudHMkMShub2RlLnZhbHVlLmNvbnRlbnQpIHx8IGhhc0VuZENvbW1lbnRzJDEobm9kZS52YWx1ZSkgJiYgbm9kZS52YWx1ZS5jb250ZW50ICYmICFpc05vZGUkMShub2RlLnZhbHVlLmNvbnRlbnQsIFtcIm1hcHBpbmdcIiwgXCJzZXF1ZW5jZVwiXSkgfHwgcGFyZW50Tm9kZS50eXBlID09PSBcIm1hcHBpbmdcIiAmJiBoYXNUcmFpbGluZ0NvbW1lbnQkMyhub2RlLmtleS5jb250ZW50KSAmJiBpc0lubGluZU5vZGUkMShub2RlLnZhbHVlLmNvbnRlbnQpIHx8IGlzTm9kZSQxKG5vZGUudmFsdWUuY29udGVudCwgW1wibWFwcGluZ1wiLCBcInNlcXVlbmNlXCJdKSAmJiBub2RlLnZhbHVlLmNvbnRlbnQudGFnID09PSBudWxsICYmIG5vZGUudmFsdWUuY29udGVudC5hbmNob3IgPT09IG51bGwgPyBoYXJkbGluZSRkIDogIW5vZGUudmFsdWUuY29udGVudCA/IFwiXCIgOiBsaW5lJDksIHZhbHVlXSkpLCB7XG4gICAgICAgICAgICBncm91cElkOiBncm91cElkXG4gICAgICAgICAgfSldKV0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJmbG93TWFwcGluZ1wiOlxuICAgICAgY2FzZSBcImZsb3dTZXF1ZW5jZVwiOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIG9wZW5NYXJrZXIgPSBub2RlLnR5cGUgPT09IFwiZmxvd01hcHBpbmdcIiA/IFwie1wiIDogXCJbXCI7XG4gICAgICAgICAgdmFyIGNsb3NlTWFya2VyID0gbm9kZS50eXBlID09PSBcImZsb3dNYXBwaW5nXCIgPyBcIn1cIiA6IFwiXVwiO1xuICAgICAgICAgIHZhciBicmFja2V0U3BhY2luZyA9IG5vZGUudHlwZSA9PT0gXCJmbG93TWFwcGluZ1wiICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoICE9PSAwICYmIG9wdGlvbnMuYnJhY2tldFNwYWNpbmcgPyBsaW5lJDkgOiBzb2Z0bGluZSQ4O1xuXG4gICAgICAgICAgdmFyIGlzTGFzdEl0ZW1FbXB0eU1hcHBpbmdJdGVtID0gbm9kZS5jaGlsZHJlbi5sZW5ndGggIT09IDAgJiYgZnVuY3Rpb24gKGxhc3RJdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFzdEl0ZW0udHlwZSA9PT0gXCJmbG93TWFwcGluZ0l0ZW1cIiAmJiBpc0VtcHR5Tm9kZSQxKGxhc3RJdGVtLmtleSkgJiYgaXNFbXB0eU5vZGUkMShsYXN0SXRlbS52YWx1ZSk7XG4gICAgICAgICAgfShnZXRMYXN0JDUobm9kZS5jaGlsZHJlbikpO1xuXG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRoKFtvcGVuTWFya2VyLCBpbmRlbnQoY29uY2F0JGgoW2JyYWNrZXRTcGFjaW5nLCBjb25jYXQkaChwYXRoLm1hcChmdW5jdGlvbiAoY2hpbGRQYXRoLCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCRoKFtwcmludChjaGlsZFBhdGgpLCBpbmRleCA9PT0gbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxID8gXCJcIiA6IGNvbmNhdCRoKFtcIixcIiwgbGluZSQ5LCBub2RlLmNoaWxkcmVuW2luZGV4XS5wb3NpdGlvbi5zdGFydC5saW5lICE9PSBub2RlLmNoaWxkcmVuW2luZGV4ICsgMV0ucG9zaXRpb24uc3RhcnQubGluZSA/IHByaW50TmV4dEVtcHR5TGluZShjaGlsZFBhdGgsIG9wdGlvbnMub3JpZ2luYWxUZXh0KSA6IFwiXCJdKV0pO1xuICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIikpLCBpZkJyZWFrJDgoXCIsXCIsIFwiXCIpXSkpLCBpc0xhc3RJdGVtRW1wdHlNYXBwaW5nSXRlbSA/IFwiXCIgOiBicmFja2V0U3BhY2luZywgY2xvc2VNYXJrZXJdKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiZmxvd1NlcXVlbmNlSXRlbVwiOlxuICAgICAgICByZXR1cm4gcGF0aC5jYWxsKHByaW50LCBcImNvbnRlbnRcIik7XG4gICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG5vZGUgdHlwZSBcIi5jb25jYXQobm9kZS50eXBlKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5kZW50KGRvYykge1xuICAgICAgcmV0dXJuIGRvY0J1aWxkZXJzJDIuYWxpZ24oXCIgXCIucmVwZWF0KG9wdGlvbnMudGFiV2lkdGgpLCBkb2MpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFsaWduJDMobiwgZG9jKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBuID09PSBcIm51bWJlclwiICYmIG4gPiAwID8gZG9jQnVpbGRlcnMkMi5hbGlnbihcIiBcIi5yZXBlYXQobiksIGRvYykgOiBkb2NCdWlsZGVycyQyLmFsaWduKG4sIGRvYyk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0lubGluZU5vZGUkMShub2RlKSB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcInBsYWluXCI6XG4gICAgICBjYXNlIFwicXVvdGVEb3VibGVcIjpcbiAgICAgIGNhc2UgXCJxdW90ZVNpbmdsZVwiOlxuICAgICAgY2FzZSBcImFsaWFzXCI6XG4gICAgICBjYXNlIFwiZmxvd01hcHBpbmdcIjpcbiAgICAgIGNhc2UgXCJmbG93U2VxdWVuY2VcIjpcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1NpbmdsZUxpbmVOb2RlKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwicGxhaW5cIjpcbiAgICAgIGNhc2UgXCJxdW90ZURvdWJsZVwiOlxuICAgICAgY2FzZSBcInF1b3RlU2luZ2xlXCI6XG4gICAgICAgIHJldHVybiBub2RlLnBvc2l0aW9uLnN0YXJ0LmxpbmUgPT09IG5vZGUucG9zaXRpb24uZW5kLmxpbmU7XG5cbiAgICAgIGNhc2UgXCJhbGlhc1wiOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZFByaW50RG9jdW1lbnRCb2R5KGRvY3VtZW50KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHkuY2hpbGRyZW4ubGVuZ3RoICE9PSAwIHx8IGhhc0VuZENvbW1lbnRzJDEoZG9jdW1lbnQuYm9keSk7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRQcmludERvY3VtZW50RW5kTWFya2VyKGRvY3VtZW50LCBuZXh0RG9jdW1lbnQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgLyoqXG4gICAgICAgKi4uLiAjIHRyYWlsaW5nQ29tbWVudFxuICAgICAgICovXG4gICAgICBoYXNUcmFpbGluZ0NvbW1lbnQkMyhkb2N1bWVudCkgfHwgbmV4dERvY3VtZW50ICYmIChcbiAgICAgIC8qKlxuICAgICAgICogLi4uXG4gICAgICAgKiAlRElSRUNUSVZFXG4gICAgICAgKiAtLS1cbiAgICAgICAqL1xuICAgICAgbmV4dERvY3VtZW50LmhlYWQuY2hpbGRyZW4ubGVuZ3RoICE9PSAwIHx8XG4gICAgICAvKipcbiAgICAgICAqIC4uLlxuICAgICAgICogIyBlbmRDb21tZW50XG4gICAgICAgKiAtLS1cbiAgICAgICAqL1xuICAgICAgaGFzRW5kQ29tbWVudHMkMShuZXh0RG9jdW1lbnQuaGVhZCkpXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZFByaW50RG9jdW1lbnRIZWFkRW5kTWFya2VyKGRvY3VtZW50LCBuZXh0RG9jdW1lbnQsIHJvb3QsIG9wdGlvbnMpIHtcbiAgICBpZiAoXG4gICAgLyoqXG4gICAgICogLS0tXG4gICAgICogcHJlc2VydmUgdGhlIGZpcnN0IGRvY3VtZW50IGhlYWQgZW5kIG1hcmtlclxuICAgICAqL1xuICAgIHJvb3QuY2hpbGRyZW5bMF0gPT09IGRvY3VtZW50ICYmIC8tLS0oXFxzfCQpLy50ZXN0KG9wdGlvbnMub3JpZ2luYWxUZXh0LnNsaWNlKG9wdGlvbnMubG9jU3RhcnQoZG9jdW1lbnQpLCBvcHRpb25zLmxvY1N0YXJ0KGRvY3VtZW50KSArIDQpKSB8fFxuICAgIC8qKlxuICAgICAqICVESVJFQ1RJVkVcbiAgICAgKiAtLS1cbiAgICAgKi9cbiAgICBkb2N1bWVudC5oZWFkLmNoaWxkcmVuLmxlbmd0aCAhPT0gMCB8fFxuICAgIC8qKlxuICAgICAqICMgZW5kIGNvbW1lbnRcbiAgICAgKiAtLS1cbiAgICAgKi9cbiAgICBoYXNFbmRDb21tZW50cyQxKGRvY3VtZW50LmhlYWQpIHx8XG4gICAgLyoqXG4gICAgICogLS0tICMgdHJhaWxpbmcgY29tbWVudFxuICAgICAqL1xuICAgIGhhc1RyYWlsaW5nQ29tbWVudCQzKGRvY3VtZW50LmhlYWQpKSB7XG4gICAgICByZXR1cm4gXCJoZWFkXCI7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFByaW50RG9jdW1lbnRFbmRNYXJrZXIoZG9jdW1lbnQsIG5leHREb2N1bWVudCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dERvY3VtZW50ID8gXCJyb290XCIgOiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQWJzb2x1dGVseVByaW50ZWRBc1NpbmdsZUxpbmVOb2RlKG5vZGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwicGxhaW5cIjpcbiAgICAgIGNhc2UgXCJxdW90ZVNpbmdsZVwiOlxuICAgICAgY2FzZSBcInF1b3RlRG91YmxlXCI6XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiYWxpYXNcIjpcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wcm9zZVdyYXAgPT09IFwicHJlc2VydmVcIikge1xuICAgICAgcmV0dXJuIG5vZGUucG9zaXRpb24uc3RhcnQubGluZSA9PT0gbm9kZS5wb3NpdGlvbi5lbmQubGluZTtcbiAgICB9XG5cbiAgICBpZiAoIC8vIGJhY2tzbGFzaC1uZXdsaW5lXG4gICAgL1xcXFwkL20udGVzdChvcHRpb25zLm9yaWdpbmFsVGV4dC5zbGljZShub2RlLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldCwgbm9kZS5wb3NpdGlvbi5lbmQub2Zmc2V0KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKG9wdGlvbnMucHJvc2VXcmFwKSB7XG4gICAgICBjYXNlIFwibmV2ZXJcIjpcbiAgICAgICAgcmV0dXJuIG5vZGUudmFsdWUuaW5kZXhPZihcIlxcblwiKSA9PT0gLTE7XG5cbiAgICAgIGNhc2UgXCJhbHdheXNcIjpcbiAgICAgICAgcmV0dXJuICEvW1xcbiBdLy50ZXN0KG5vZGUudmFsdWUpO1xuICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5lZWRzU3BhY2VJbkZyb250T2ZNYXBwaW5nVmFsdWUobm9kZSkge1xuICAgIHJldHVybiBub2RlLmtleS5jb250ZW50ICYmIG5vZGUua2V5LmNvbnRlbnQudHlwZSA9PT0gXCJhbGlhc1wiO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnROZXh0RW1wdHlMaW5lKHBhdGgsIG9yaWdpbmFsVGV4dCkge1xuICAgIHZhciBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIHZhciByb290ID0gcGF0aC5zdGFja1swXTtcbiAgICByb290LmlzTmV4dEVtcHR5TGluZVByaW50ZWRDaGVja2xpc3QgPSByb290LmlzTmV4dEVtcHR5TGluZVByaW50ZWRDaGVja2xpc3QgfHwgW107XG5cbiAgICBpZiAoIXJvb3QuaXNOZXh0RW1wdHlMaW5lUHJpbnRlZENoZWNrbGlzdFtub2RlLnBvc2l0aW9uLmVuZC5saW5lXSkge1xuICAgICAgaWYgKGlzTmV4dExpbmVFbXB0eSQ2KG5vZGUsIG9yaWdpbmFsVGV4dCkpIHtcbiAgICAgICAgcm9vdC5pc05leHRFbXB0eUxpbmVQcmludGVkQ2hlY2tsaXN0W25vZGUucG9zaXRpb24uZW5kLmxpbmVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHNvZnRsaW5lJDg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludEZsb3dTY2FsYXJDb250ZW50KG5vZGVUeXBlLCBjb250ZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIGxpbmVDb250ZW50cyA9IGdldEZsb3dTY2FsYXJMaW5lQ29udGVudHMkMShub2RlVHlwZSwgY29udGVudCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGpvaW4kYyhoYXJkbGluZSRkLCBsaW5lQ29udGVudHMubWFwKGZ1bmN0aW9uIChsaW5lQ29udGVudFdvcmRzKSB7XG4gICAgICByZXR1cm4gZmlsbCQ2KGpvaW4kYyhsaW5lJDksIGxpbmVDb250ZW50V29yZHMpLnBhcnRzKTtcbiAgICB9KSk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbiQ3KG5vZGUsIG5ld05vZGVcbiAgLyosIHBhcmVudCAqL1xuICApIHtcbiAgICBpZiAoaXNOb2RlJDEobmV3Tm9kZSkpIHtcbiAgICAgIGRlbGV0ZSBuZXdOb2RlLnBvc2l0aW9uO1xuXG4gICAgICBzd2l0Y2ggKG5ld05vZGUudHlwZSkge1xuICAgICAgICBjYXNlIFwiY29tbWVudFwiOlxuICAgICAgICAgIC8vIGluc2VydCBwcmFnbWFcbiAgICAgICAgICBpZiAoaXNQcmFnbWEkMShuZXdOb2RlLnZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcInF1b3RlRG91YmxlXCI6XG4gICAgICAgIGNhc2UgXCJxdW90ZVNpbmdsZVwiOlxuICAgICAgICAgIG5ld05vZGUudHlwZSA9IFwicXVvdGVcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgcHJpbnRlcllhbWwgPSB7XG4gICAgcHJlcHJvY2VzczogcHJlcHJvY2VzcyQzLFxuICAgIHByaW50OiBnZW5lcmljUHJpbnQkNixcbiAgICBtYXNzYWdlQXN0Tm9kZTogY2xlYW4kNyxcbiAgICBpbnNlcnRQcmFnbWE6IGluc2VydFByYWdtYSQ5XG4gIH07XG5cbiAgdmFyIG9wdGlvbnMkNyA9IHtcbiAgICBicmFja2V0U3BhY2luZzogY29tbW9uT3B0aW9ucy5icmFja2V0U3BhY2luZyxcbiAgICBzaW5nbGVRdW90ZTogY29tbW9uT3B0aW9ucy5zaW5nbGVRdW90ZSxcbiAgICBwcm9zZVdyYXA6IGNvbW1vbk9wdGlvbnMucHJvc2VXcmFwXG4gIH07XG5cbiAgdmFyIG5hbWUkaCA9IFwiWUFNTFwiO1xuICB2YXIgdHlwZSRnID0gXCJkYXRhXCI7XG4gIHZhciB0bVNjb3BlJGcgPSBcInNvdXJjZS55YW1sXCI7XG4gIHZhciBhbGlhc2VzJDYgPSBbXG4gIFx0XCJ5bWxcIlxuICBdO1xuICB2YXIgZXh0ZW5zaW9ucyRnID0gW1xuICBcdFwiLnltbFwiLFxuICBcdFwiLm1pclwiLFxuICBcdFwiLnJlZWtcIixcbiAgXHRcIi5ydml6XCIsXG4gIFx0XCIuc3VibGltZS1zeW50YXhcIixcbiAgXHRcIi5zeW50YXhcIixcbiAgXHRcIi55YW1sXCIsXG4gIFx0XCIueWFtbC10bWxhbmd1YWdlXCIsXG4gIFx0XCIueW1sLm15c3FsXCJcbiAgXTtcbiAgdmFyIGZpbGVuYW1lcyQ0ID0gW1xuICBcdFwiLmNsYW5nLWZvcm1hdFwiLFxuICBcdFwiLmNsYW5nLXRpZHlcIixcbiAgXHRcIi5nZW1yY1wiLFxuICBcdFwiZ2xpZGUubG9ja1wiXG4gIF07XG4gIHZhciBhY2VNb2RlJGcgPSBcInlhbWxcIjtcbiAgdmFyIGNvZGVtaXJyb3JNb2RlJGMgPSBcInlhbWxcIjtcbiAgdmFyIGNvZGVtaXJyb3JNaW1lVHlwZSRjID0gXCJ0ZXh0L3gteWFtbFwiO1xuICB2YXIgbGFuZ3VhZ2VJZCRnID0gNDA3O1xuICB2YXIgWUFNTCA9IHtcbiAgXHRuYW1lOiBuYW1lJGgsXG4gIFx0dHlwZTogdHlwZSRnLFxuICBcdHRtU2NvcGU6IHRtU2NvcGUkZyxcbiAgXHRhbGlhc2VzOiBhbGlhc2VzJDYsXG4gIFx0ZXh0ZW5zaW9uczogZXh0ZW5zaW9ucyRnLFxuICBcdGZpbGVuYW1lczogZmlsZW5hbWVzJDQsXG4gIFx0YWNlTW9kZTogYWNlTW9kZSRnLFxuICBcdGNvZGVtaXJyb3JNb2RlOiBjb2RlbWlycm9yTW9kZSRjLFxuICBcdGNvZGVtaXJyb3JNaW1lVHlwZTogY29kZW1pcnJvck1pbWVUeXBlJGMsXG4gIFx0bGFuZ3VhZ2VJZDogbGFuZ3VhZ2VJZCRnXG4gIH07XG5cbiAgdmFyIFlBTUwkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgbmFtZTogbmFtZSRoLFxuICAgIHR5cGU6IHR5cGUkZyxcbiAgICB0bVNjb3BlOiB0bVNjb3BlJGcsXG4gICAgYWxpYXNlczogYWxpYXNlcyQ2LFxuICAgIGV4dGVuc2lvbnM6IGV4dGVuc2lvbnMkZyxcbiAgICBmaWxlbmFtZXM6IGZpbGVuYW1lcyQ0LFxuICAgIGFjZU1vZGU6IGFjZU1vZGUkZyxcbiAgICBjb2RlbWlycm9yTW9kZTogY29kZW1pcnJvck1vZGUkYyxcbiAgICBjb2RlbWlycm9yTWltZVR5cGU6IGNvZGVtaXJyb3JNaW1lVHlwZSRjLFxuICAgIGxhbmd1YWdlSWQ6IGxhbmd1YWdlSWQkZyxcbiAgICAnZGVmYXVsdCc6IFlBTUxcbiAgfSk7XG5cbiAgdmFyIHJlcXVpcmUkJDAkOCA9IGdldENqc0V4cG9ydEZyb21OYW1lc3BhY2UoWUFNTCQxKTtcblxuICB2YXIgbGFuZ3VhZ2VzJDYgPSBbY3JlYXRlTGFuZ3VhZ2UocmVxdWlyZSQkMCQ4LCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGRhdGEsIHtcbiAgICAgIHNpbmNlOiBcIjEuMTQuMFwiLFxuICAgICAgcGFyc2VyczogW1wieWFtbFwiXSxcbiAgICAgIHZzY29kZUxhbmd1YWdlSWRzOiBbXCJ5YW1sXCJdXG4gICAgfSk7XG4gIH0pXTtcbiAgdmFyIGxhbmd1YWdlWWFtbCA9IHtcbiAgICBsYW5ndWFnZXM6IGxhbmd1YWdlcyQ2LFxuICAgIHByaW50ZXJzOiB7XG4gICAgICB5YW1sOiBwcmludGVyWWFtbFxuICAgIH0sXG4gICAgb3B0aW9uczogb3B0aW9ucyQ3XG4gIH07XG5cbiAgdmFyIHZlcnNpb24kMiA9IHJlcXVpcmUkJDAudmVyc2lvbjtcbiAgdmFyIGdldFN1cHBvcnRJbmZvJDIgPSBzdXBwb3J0LmdldFN1cHBvcnRJbmZvO1xuICB2YXIgaW50ZXJuYWxQbHVnaW5zID0gW2xhbmd1YWdlQ3NzLCBsYW5ndWFnZUdyYXBocWwsIGxhbmd1YWdlSGFuZGxlYmFycywgbGFuZ3VhZ2VIdG1sLCBsYW5ndWFnZUpzLCBsYW5ndWFnZU1hcmtkb3duLCBsYW5ndWFnZVlhbWxdO1xuXG4gIHZhciBpc0FycmF5JDEgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgfTsgLy8gTHVja2lseSBgb3B0c2AgaXMgYWx3YXlzIHRoZSAybmQgYXJndW1lbnRcblxuXG4gIGZ1bmN0aW9uIHdpdGhQbHVnaW5zKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gQXJyYXkuZnJvbShhcmd1bWVudHMpO1xuICAgICAgdmFyIHBsdWdpbnMgPSBhcmdzWzFdICYmIGFyZ3NbMV0ucGx1Z2lucyB8fCBbXTtcblxuICAgICAgaWYgKCFpc0FycmF5JDEocGx1Z2lucykpIHtcbiAgICAgICAgcGx1Z2lucyA9IE9iamVjdC52YWx1ZXMocGx1Z2lucyk7XG4gICAgICB9XG5cbiAgICAgIGFyZ3NbMV0gPSBPYmplY3QuYXNzaWduKHt9LCBhcmdzWzFdLCB7XG4gICAgICAgIHBsdWdpbnM6IGludGVybmFsUGx1Z2lucy5jb25jYXQocGx1Z2lucylcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH07XG4gIH1cblxuICB2YXIgZm9ybWF0V2l0aEN1cnNvciA9IHdpdGhQbHVnaW5zKGNvcmUuZm9ybWF0V2l0aEN1cnNvcik7XG4gIHZhciBzdGFuZGFsb25lID0ge1xuICAgIGZvcm1hdFdpdGhDdXJzb3I6IGZvcm1hdFdpdGhDdXJzb3IsXG4gICAgZm9ybWF0OiBmdW5jdGlvbiBmb3JtYXQodGV4dCwgb3B0cykge1xuICAgICAgcmV0dXJuIGZvcm1hdFdpdGhDdXJzb3IodGV4dCwgb3B0cykuZm9ybWF0dGVkO1xuICAgIH0sXG4gICAgY2hlY2s6IGZ1bmN0aW9uIGNoZWNrKHRleHQsIG9wdHMpIHtcbiAgICAgIHZhciBmb3JtYXR0ZWQgPSBmb3JtYXRXaXRoQ3Vyc29yKHRleHQsIG9wdHMpLmZvcm1hdHRlZDtcbiAgICAgIHJldHVybiBmb3JtYXR0ZWQgPT09IHRleHQ7XG4gICAgfSxcbiAgICBkb2M6IGRvYyxcbiAgICBnZXRTdXBwb3J0SW5mbzogd2l0aFBsdWdpbnMoZ2V0U3VwcG9ydEluZm8kMiksXG4gICAgdmVyc2lvbjogdmVyc2lvbiQyLFxuICAgIHV0aWw6IHV0aWxTaGFyZWQsXG4gICAgX19kZWJ1Zzoge1xuICAgICAgcGFyc2U6IHdpdGhQbHVnaW5zKGNvcmUucGFyc2UpLFxuICAgICAgZm9ybWF0QVNUOiB3aXRoUGx1Z2lucyhjb3JlLmZvcm1hdEFTVCksXG4gICAgICBmb3JtYXREb2M6IHdpdGhQbHVnaW5zKGNvcmUuZm9ybWF0RG9jKSxcbiAgICAgIHByaW50VG9Eb2M6IHdpdGhQbHVnaW5zKGNvcmUucHJpbnRUb0RvYyksXG4gICAgICBwcmludERvY1RvU3RyaW5nOiB3aXRoUGx1Z2lucyhjb3JlLnByaW50RG9jVG9TdHJpbmcpXG4gICAgfVxuICB9O1xuXG4gIHZhciBzdGFuZGFsb25lJDEgPSBzdGFuZGFsb25lO1xuXG4gIHJldHVybiBzdGFuZGFsb25lJDE7XG5cbn0pKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/prettier/standalone.js\n"));

/***/ })

}]);